(function () {

'use strict';

angular.module('OpenSlidesApp.agenda', ['OpenSlidesApp.users'])

.factory('Speaker', [
    'DS',
    function(DS) {
        return DS.defineResource({
            name: 'agenda/speaker',
            relations: {
                belongsTo: {
                    'users/user': {
                        localField: 'user',
                        localKey: 'user_id',
                    }
                }
            }
        });
    }
])

.factory('Agenda', [
    '$http',
    'DS',
    'Speaker',
    'jsDataModel',
    'Projector',
    'ProjectHelper',
    'gettextCatalog',
    'gettext',
    'CamelCase',
    'EditForm',
    function($http, DS, Speaker, jsDataModel, Projector, ProjectHelper, gettextCatalog,
        gettext, CamelCase, EditForm) {
        var name = 'agenda/item';
        return DS.defineResource({
            name: name,
            useClass: jsDataModel,
            verboseName: gettext('Agenda'),
            computed: {
                is_public: function () {
                    return !this.is_internal && !this.is_hidden;
                },
            },
            methods: {
                getResourceName: function () {
                    return name;
                },
                getContentObject: function () {
                    return DS.get(this.content_object.collection, this.content_object.id);
                },
                getContentObjectDetailState: function () {
                    return CamelCase(this.content_object.collection).replace('/', '.') +
                        '.detail({id: ' + this.content_object.id + '})';
                },
                getContentObjectForm: function () {
                    return EditForm.fromCollectionString(this.content_object.collection);
                },
                getContentResource: function () {
                    return DS.definitions[this.content_object.collection];
                },
                getTitle: function () {
                    var title;
                    try {
                        title =  this.getContentObject().getAgendaTitle();
                    } catch (e) {
                        // when the content object is not in the DS store.
                        title = this.title;
                    }
                    if (this.item_number) {
                        title = this.item_number + ' · ' + title;
                    }
                    return title;
                },
                getListOfSpeakersTitle: function () {
                    var title;
                    try {
                        title =  this.getContentObject().getListOfSpeakersTitle();
                        if (this.item_number) {
                            title = this.item_number + ' · ' + title;
                        }
                    } catch (e) {
                        title = this.getTitle();
                    }
                    return title;
                },
                getAgendaTitle: function () {
                    return this.title;
                },
                getCSVExportText: function () {
                    var text;
                    try {
                        text =  this.getContentObject().getCSVExportText();
                    } catch (e) {
                        // when the content object is not in the DS store
                        // or 'getCSVExportText' is not defined return nothing.
                    }
                    return text;
                },
                // link name which is shown in search result
                getSearchResultName: function () {
                    return this.getAgendaTitle();
                },
                // return true if a specific relation matches for given searchquery
                // (here: speakers)
                hasSearchResult: function (results) {
                    var item = this;
                    // search for speakers (check if any user.id from already found users matches)
                    return _.some(results, function(result) {
                        if (result.getResourceName() === "users/user") {
                            if (_.some(item.speakers, {'user_id': result.id})) {
                                return true;
                            }
                        }
                    });
                },
                getProjectorTitle: function () {
                    try {
                        return this.getContentObject().getAgendaListViewTitle();
                    } catch (e) {
                        // when the content object is not in the DS store
                        return this.list_view_title;
                    }
                },
                getListViewTitle: function () {
                    var title = this.getProjectorTitle();
                    if (this.item_number) {
                        title = this.item_number + ' · ' + title;
                    }
                    return title;
                },
                getItemNumberWithAncestors: function (agendaId) {
                    if (!agendaId) {
                        agendaId = this.id;
                    }
                    var agendaItem = DS.get(name, agendaId);
                    if (!agendaItem) {
                        return '';
                    } else if (agendaItem.item_number) {
                        return agendaItem.item_number;
                    } else if (agendaItem.parent_id) {
                        return this.getItemNumberWithAncestors(agendaItem.parent_id);
                    } else {
                        return '';
                    }
                },
                // override project function of jsDataModel factory
                project: function (projectorId, tree) {
                    if (tree) {
                        var isProjectedIds = this.isProjected(tree);
                        var requestData = {
                            clear_ids: isProjectedIds,
                        };
                        // Activate, if the projector_id is a new projector.
                        if (_.indexOf(isProjectedIds, projectorId) == -1) {
                            requestData.prune = {
                                id: projectorId,
                                element: {
                                    name: 'agenda/item-list',
                                    tree: true,
                                    id: this.id,
                                },
                            };
                        }
                        return ProjectHelper.project(requestData);
                    } else {  // Project the content object
                        var contentObject = DS.get(this.content_object.collection, this.content_object.id);
                        return contentObject.project(projectorId);
                    }
                },
                // override isProjected function of jsDataModel factory
                isProjected: function (tree) {
                    // Returns all ids of all projectors with an agenda-item element. Otherwise an empty list.
                    if (typeof tree === 'undefined') {
                        tree = false;
                    }
                    var self = this;
                    var predicate = function (element) {
                        var value;
                        if (tree) {
                            // Item tree slide for sub tree
                            value = element.name == 'agenda/item-list' &&
                                typeof element.id !== 'undefined' &&
                                element.id == self.id;
                        } else {
                            // Releated item detail slide
                            value = element.name == self.content_object.collection &&
                                typeof element.id !== 'undefined' &&
                                element.id == self.content_object.id;
                        }
                        return value;
                    };
                    var isProjectedIds = [];
                    Projector.getAll().forEach(function (projector) {
                        if (typeof _.findKey(projector.elements, predicate) === 'string') {
                            isProjectedIds.push(projector.id);
                        }
                    });
                    return isProjectedIds;
                },
                isRelatedProjected: function () {
                    // related objects for agenda items: list of speakers slide.
                    return this.isListOfSpeakersProjected();
                },
                // project list of speakers
                projectListOfSpeakers: function(projectorId) {
                    var isProjectedIds = this.isListOfSpeakersProjected();
                    var requestData = {
                        clear_ids: isProjectedIds,
                    };
                    if (_.indexOf(isProjectedIds, projectorId) == -1) {
                        requestData.prune = {
                            id: projectorId,
                            element: {
                                name: 'agenda/list-of-speakers',
                                id: this.id,
                            },
                        };
                    }
                    return ProjectHelper.project(requestData);
                },
                // check if list of speakers is projected
                isListOfSpeakersProjected: function () {
                    // Returns all ids of all projectors with an element with the
                    // name 'agenda/list-of-speakers' and the same id. Else returns an empty list.
                    var self = this;
                    var predicate = function (element) {
                        return element.name == 'agenda/list-of-speakers' &&
                               typeof element.id !== 'undefined' &&
                               element.id == self.id;
                    };
                    var isProjecteds = [];
                    Projector.getAll().forEach(function (projector) {
                        if (typeof _.findKey(projector.elements, predicate) === 'string') {
                            isProjecteds.push(projector.id);
                        }
                    });
                    return isProjecteds;
                },
                hasSubitems: function(items) {
                    var self = this;
                    var hasChild = false;
                    // Returns true if the item has at least one child item.
                    _.each(items, function (item) {
                        if (item.parent_id == self.id) {
                            hasChild = true;
                        }
                    });
                    return hasChild;
                }
            },
            relations: {
                hasMany: {
                    'core/tag': {
                        localField: 'tags',
                        localKeys: 'tags_id',
                    },
                    'agenda/speaker': {
                        localField: 'speakers',
                        foreignKey: 'item_id',
                    }
                }
            },
            beforeInject: function (resource, instance) {
                Speaker.ejectAll({where: {item_id: {'==': instance.id}}});
            }
        });
    }
])

.factory('AgendaTree', [
    function () {
        return {
            getTree: function (items) {
                // Sort items after there weight
                items.sort(function(itemA, itemB) {
                    return itemA.weight - itemB.weight;
                });

                // Build a dict with all children (dict-value) to a specific
                // item id (dict-key).
                var itemChildren = {};

                _.each(items, function (item) {
                    if (item.parent_id) {
                        // Add item to his parent. If it is the first child, then
                        // create a new list.
                        try {
                            itemChildren[item.parent_id].push(item);
                        } catch (error) {
                            itemChildren[item.parent_id] = [item];
                        }
                    }

                });

                // Recursive function that generates a nested list with all
                // items with there children
                function getChildren(items) {
                    var returnItems = [];
                    _.each(items, function (item) {
                        returnItems.push({
                            item: item,
                            children: getChildren(itemChildren[item.id]),
                            id: item.id,
                        });
                    });
                    return returnItems;
                }

                // Generates the list of root items (with no parents)
                var parentItems = items.filter(function (item) {
                    return !item.parent_id;
                });
                return getChildren(parentItems);
            },

            // Returns a list of all items as a flat tree
            getFlatTree: function(items) {
                var tree = this.getTree(items);
                var flatItems = [];

                function generateFlatTree(tree, parentCount) {
                    _.each(tree, function (item) {
                        item.item.childrenCount = item.children.length;
                        item.item.parentCount = parentCount;
                        flatItems.push(item.item);
                        generateFlatTree(item.children, parentCount + 1);
                    });
                }
                generateFlatTree(tree, 0);
                return flatItems;
            }
        };
    }
])

.factory('CurrentListOfSpeakersItem', [
    'Projector',
    'Agenda',
    function (Projector, Agenda) {
        return {
            getItem: function (projectorId) {
                var projector = Projector.get(projectorId), item;
                if (projector) {
                    _.forEach(projector.elements, function(element) {
                        if (element.agenda_item_id) {
                            item = Agenda.get(element.agenda_item_id);
                        }
                    });
                }
                return item;
            }
        };
    }
])

.factory('CurrentListOfSpeakersSlide', [
    '$http',
    'Projector',
    function($http, Projector) {
        var name = 'agenda/current-list-of-speakers';
        return {
            project: function (projectorId, overlay) {
                var isProjected = this.isProjectedWithOverlayStatus();
                _.forEach(isProjected, function (mapping) {
                    $http.post('/rest/core/projector/' + mapping.projectorId + '/deactivate_elements/',
                        [mapping.uuid]
                    );
                });

                // The slide was projected, if the id matches. If the overlay is given, also
                // the overlay is checked
                var wasProjectedBefore = _.some(isProjected, function (mapping) {
                    var value = (mapping.projectorId === projectorId);
                    if (overlay !== undefined) {
                        value = value && (mapping.overlay === overlay);
                    }
                    return value;
                });
                overlay = overlay || false; // set overlay if it wasn't defined

                if (!wasProjectedBefore) {
                    var activate = function () {
                        return $http.post(
                            '/rest/core/projector/' + projectorId + '/activate_elements/',
                             [{name: name,
                               stable: overlay, // if this is an overlay, it should not be
                                                // removed by changing the main content
                               overlay: overlay}]
                        );
                    };
                    if (!overlay) {
                        // clear all elements on this projector, because we are _not_ using the overlay.
                        $http.post('/rest/core/projector/' + projectorId + '/clear_elements/').then(activate);
                    } else {
                        activate();
                    }
                }
            },
            isProjected: function () {
                // Returns the ids of all projectors with an agenda-item element. Else return an empty list.
                var predicate = function (element) {
                    return element.name === name;
                };
                var isProjectedIds = [];
                Projector.getAll().forEach(function (projector) {
                    if (typeof _.findKey(projector.elements, predicate) === 'string') {
                        isProjectedIds.push(projector.id);
                    }
                });
                return isProjectedIds;
            },
            // Returns a list of mappings between pojector id, overlay and uuid.
            isProjectedWithOverlayStatus: function () {
                var mapping = [];
                _.forEach(Projector.getAll(), function (projector) {
                    _.forEach(projector.elements, function (element, uuid) {
                        if (element.name === name) {
                            mapping.push({
                                projectorId: projector.id,
                                uuid: uuid,
                                overlay: element.overlay || false,
                            });
                        }
                    });
                });
                return mapping;
            },
        };
    }
])



// Make sure that the Agenda resource is loaded.
.run(['Agenda', function(Agenda) {}]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.agenda.csv', [])

.factory('AgendaCsvExport', [
    'HumanTimeConverter',
    'gettextCatalog',
    'CsvDownload',
    function (HumanTimeConverter, gettextCatalog, CsvDownload) {
        var makeHeaderline = function () {
            var headerline = ['Title', 'Text', 'Duration', 'Comment', 'Internal item'];
            return _.map(headerline, function (entry) {
                return gettextCatalog.getString(entry);
            });
        };
        return {
            export: function (agenda) {
                var csvRows = [
                    makeHeaderline()
                ];
                _.forEach(agenda, function (item) {
                    var row = [];
                    var duration = item.duration ? HumanTimeConverter.secondsToHumanTime(item.duration*60,
                            { seconds: 'disabled',
                                hours: 'enabled' }) : '';
                    row.push('"' + (item.title || '') + '"');
                    row.push('"' + (item.getCSVExportText() || '') + '"');
                    row.push('"' + duration + '"');
                    row.push('"' + (item.comment || '') + '"');
                    row.push('"' + (item.is_hidden ? '1' : '')  + '"');
                    csvRows.push(row);
                });
                CsvDownload(csvRows, gettextCatalog.getString('Agenda') + '.csv');
            },
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.agenda.docx', ['OpenSlidesApp.core.docx'])

.factory('AgendaDocxExport', [
    '$http',
    'gettextCatalog',
    'FileSaver',
    'Agenda',
    'AgendaTree',
    'Config',
    function ($http, gettextCatalog, FileSaver, Agenda, AgendaTree, Config) {

        var getData = function (items) {
            // Item structure: The top layer has subitems, that are flat.
            // The first layer is bold and all sublayers not. The docx
            // templater cannot render items recursively, so the second
            // layer are all subitems flated out. Spacing is done with tabs.
            var tree = AgendaTree.getTree(items);
            var subitems = []; // This will be used as a temporary variable.
            var flatSubitems = function (children, parentCount) {
                _.forEach(children, function (child) {
                    var taps = _.repeat('\t', parentCount - 1);
                    subitems.push({
                        item_number: taps + child.item.item_number,
                        item_title: child.item.list_view_title,
                    });
                    flatSubitems(child.children, parentCount + 1);
                });
            };
            var twoLayerTree = _.map(tree, function (mainItem) {
                subitems = [];
                flatSubitems(mainItem.children, 1);
                return {
                    item_number: mainItem.item.item_number,
                    item_title: mainItem.item.list_view_title,
                    subitems: subitems,
                };
            });

            // header
            var headerline1 = [
                Config.translate(Config.get('general_event_name').value),
                Config.translate(Config.get('general_event_description').value)
            ].filter(Boolean).join(' – ');
            var headerline2 = [
                Config.get('general_event_location').value,
                Config.get('general_event_date').value
            ].filter(Boolean).join(', ');

            // Data structure for the docx templater.
            return {
                header: [headerline1, headerline2].join('\n'),
                agenda_translation: gettextCatalog.getString('Agenda'),
                top_list: twoLayerTree,
            };
        };

        return {
            export: function (items) {
                // TODO: use filtered items.
                var filename = gettextCatalog.getString('Agenda') + '.docx';
                $http.get('/agenda/docxtemplate/').then(function (success) {
                    var content = window.atob(success.data);
                    var doc = new Docxgen(content);

                    var data = getData(items);
                    doc.setData(data);
                    doc.render();

                    var zip = doc.getZip();
                    //zip = converter.updateZipFile(zip);

                    var out = zip.generate({type: 'blob'});
                    FileSaver.saveAs(out, filename);
                });
            },
        };
    }
]);

})();

(function () {

'use strict';

angular.module('OpenSlidesApp.agenda.pdf', ['OpenSlidesApp.core.pdf'])

.factory('AgendaContentProvider', [
    'gettextCatalog',
    'PDFLayout',
    function(gettextCatalog, PDFLayout) {

    var createInstance = function(items) {

        // page title
        var title = PDFLayout.createTitle(gettextCatalog.getString("Agenda"));

        // generate the item list with all subitems
        var createItemList = function() {
            var agenda_items = [];
            _.forEach(items, function (item) {
                if (item.is_public) {
                    var itemIndent = item.parentCount * 15;

                    var itemStyle;
                    if (item.parentCount === 0) {
                        itemStyle = 'listParent';
                    } else {
                        itemStyle = 'listChild';
                    }

                    var agendaJsonString = {
                        style: itemStyle,
                        columns: [
                            {
                                width: itemIndent,
                                text: ''
                            },
                            {
                                width: 60,
                                text: item.item_number
                            },
                            {
                                text: item.title
                            }
                        ]
                    };

                    agenda_items.push(agendaJsonString);
                }
            });
            return agenda_items;
        };

        var getContent = function() {
            return [
                title,
                createItemList()
            ];
        };

        return {
            getContent: getContent
        };
    };

    return {
        createInstance: createInstance
    };

}])

.factory('AgendaPdfExport', [
    'gettextCatalog',
    'AgendaContentProvider',
    'PdfMakeDocumentProvider',
    'PdfCreate',
    'Messaging',
    function (gettextCatalog, AgendaContentProvider, PdfMakeDocumentProvider, PdfCreate, Messaging) {
        return {
            export: function (items) {
                var filename = gettextCatalog.getString('Agenda') + '.pdf';
                var agendaContentProvider = AgendaContentProvider.createInstance(items);
                PdfMakeDocumentProvider.createInstance(agendaContentProvider).then(function (documentProvider) {
                    PdfCreate.download(documentProvider, filename);
                }, function (error) {
                    Messaging.addMessage(error.msg, 'error');
                });
            },
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.agenda.projector', ['OpenSlidesApp.agenda'])

.config([
    'slidesProvider',
    function(slidesProvider) {
        slidesProvider.registerSlide('agenda/list-of-speakers', {
            template: 'static/templates/agenda/slide-list-of-speakers.html',
        });
        slidesProvider.registerSlide('agenda/item-list', {
            template: 'static/templates/agenda/slide-item-list.html',
        });
        slidesProvider.registerSlide('agenda/current-list-of-speakers', {
            template: 'static/templates/agenda/slide-current-list-of-speakers.html',
        });
    }
])

.controller('SlideCurrentListOfSpeakersCtrl', [
    '$scope',
    'Agenda',
    'CurrentListOfSpeakersItem',
    'Config',
    'Projector',
    function ($scope, Agenda, CurrentListOfSpeakersItem, Config, Projector) {
        $scope.overlay = $scope.element.overlay;
        // Watch for changes in the current list of speakers reference
        $scope.$watch(function () {
            return Config.lastModified('projector_currentListOfSpeakers_reference');
        }, function () {
            $scope.currentListOfSpeakersReference = $scope.config('projector_currentListOfSpeakers_reference');
            $scope.updateCurrentListOfSpeakers();
        });
        // Watch for changes in the referenced projector
        $scope.$watch(function () {
            return Projector.lastModified($scope.currentListOfSpeakersReference);
        }, function () {
            $scope.updateCurrentListOfSpeakers();
        });
        // Watch for changes in the current item.
        $scope.$watch(function () {
            return Agenda.lastModified();
        }, function () {
            $scope.updateCurrentListOfSpeakers();
        });
        $scope.updateCurrentListOfSpeakers = function () {
            $scope.agendaItem = CurrentListOfSpeakersItem.getItem($scope.currentListOfSpeakersReference);
        };
    }
])

.controller('SlideListOfSpeakersCtrl', [
    '$scope',
    'Agenda',
    'User',
    function ($scope, Agenda, User) {
        // Attention! Each object that is used here has to be dealt on server side.
        // Add it to the coresponding get_requirements method of the ProjectorElement
        // class.
        var id = $scope.element.id;
        Agenda.bindOne(id, $scope, 'item');
    }
])

.controller('SlideItemListCtrl', [
    '$scope',
    '$http',
    '$filter',
    'Agenda',
    'AgendaTree',
    'Config',
    function ($scope, $http, $filter, Agenda, AgendaTree, Config) {
        // Attention! Each object that is used here has to be dealt on server side.
        // Add it to the coresponding get_requirements method of the ProjectorElement
        // class.

        // Bind agenda tree to the scope
        var items;
        $scope.$watch(function () {
            return Agenda.lastModified() +
                Config.lastModified('agenda_hide_internal_items_on_projector');
        }, function () {
            if ($scope.element.id) {
                // remove hidden items
                items = _.filter(Agenda.getAll(), function (item) {
                    return !item.is_hidden;
                });
                if (Config.get('agenda_hide_internal_items_on_projector').value) {
                    items = _.filter(items, function (item) {
                        return item.is_public;
                    });
                }
                var tree = AgendaTree.getTree(items);

                var getRootNode = function (node) {
                    if (node.id == $scope.element.id) {
                        return node;
                    }
                    for (var i = 0; i < node.children.length; i++) {
                        var result = getRootNode(node.children[i]);
                        if (result) {
                            return result;
                        }
                    }
                    return false;
                };
                _.forEach(tree, function (node) {
                    var result = getRootNode(node);
                    if (result) {
                        $scope.rootItem = result.item;
                        $scope.tree = result.children;
                        return false;
                    }
                });
            } else if ($scope.element.tree) {
                items = _.filter(Agenda.getAll(), function (item) {
                    return item.is_public;
                });
                $scope.tree = AgendaTree.getTree(items);
            } else {
                items = Agenda.filter({
                    where: { parent_id: null },
                    orderBy: 'weight'
                });
                items = _.filter(items, function (item) {
                    return item.is_public;
                });
                $scope.tree = AgendaTree.getTree(items);
            }
        });
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.agenda.site', [
    'OpenSlidesApp.agenda',
    'OpenSlidesApp.core.pdf',
    'OpenSlidesApp.agenda.pdf',
    'OpenSlidesApp.agenda.csv',
    'OpenSlidesApp.agenda.docx',
])

.config([
    'mainMenuProvider',
    'gettext',
    function (mainMenuProvider, gettext) {
        mainMenuProvider.register({
            'ui_sref': 'agenda.item.list',
            'img_class': 'calendar-o',
            'title': gettext('Agenda'),
            'weight': 200,
            'perm': 'agenda.can_see',
        });
    }
])

.config([
    'SearchProvider',
    'gettext',
    function (SearchProvider, gettext) {
        SearchProvider.register({
            'verboseName': gettext('Agenda'),
            'collectionName': 'agenda/item',
            'urlDetailState': 'agenda.item.detail',
            'weight': 200,
        });
    }
])

.config([
    '$stateProvider',
    'gettext',
    function ($stateProvider, gettext) {
        $stateProvider
            .state('agenda', {
                url: '/agenda',
                abstract: true,
                template: "<ui-view/>",
                data: {
                    title: gettext('Agenda'),
                    basePerm: 'agenda.can_see',
                },
            })
            .state('agenda.item', {
                abstract: true,
                template: "<ui-view/>",
            })
            .state('agenda.item.list', {})
            .state('agenda.item.detail', {
                resolve: {
                    itemId: ['$stateParams', function($stateParams) {
                        return $stateParams.id;
                    }],
                }
            })
            .state('agenda.item.sort', {
                url: '/sort',
                controller: 'AgendaSortCtrl',
            })
            .state('agenda.current-list-of-speakers', {
                url: '/speakers',
                controller: 'CurrentListOfSpeakersViewCtrl',
                data: {
                    title: gettext('Current list of speakers'),
                },
            });
    }
])

// Set the sensitivity of moving nodes horizontal for the ui-tree.
.config([
    'treeConfig',
    function (treeConfig) {
        treeConfig.dragMoveSensitivity = 20;
    }
])

.factory('ShowAsAgendaItemField', [
    'operator',
    'gettext',
    'gettextCatalog',
    function (operator, gettext, gettextCatalog) {
        return function (managePermission) {
            return {
                key: 'agenda_type',
                type: 'select-single',
                templateOptions: {
                    label: gettextCatalog.getString('Agenda visibility'),
                    options: [
                        {type: 1, displayName: gettext('Public item')},
                        {type: 2, displayName: gettext('Internal item')},
                        {type: 3, displayName: gettext('Hidden item')}
                    ],
                    ngOptions: 'type.type as (type.displayName | translate) for type in to.options',
                },
                hide: !(operator.hasPerms(managePermission) && operator.hasPerms('agenda.can_manage'))
            };
        };
    }
])

.controller('ItemListCtrl', [
    '$scope',
    '$filter',
    '$http',
    '$state',
    'DS',
    'operator',
    'ngDialog',
    'Agenda',
    'TopicForm', // TODO: Remove this dependency. Use template hook for "New" and "Import" buttons.
    'AgendaTree',
    'Projector',
    'ProjectionDefault',
    'gettextCatalog',
    'gettext',
    'osTableFilter',
    'osTablePagination',
    'AgendaCsvExport',
    'AgendaPdfExport',
    'AgendaDocxExport',
    'ErrorMessage',
    function($scope, $filter, $http, $state, DS, operator, ngDialog, Agenda, TopicForm,
        AgendaTree, Projector, ProjectionDefault, gettextCatalog, gettext, osTableFilter,
        osTablePagination, AgendaCsvExport, AgendaPdfExport, AgendaDocxExport, ErrorMessage) {

        $scope.AGENDA_ITEM = 1;
        $scope.INTERNAL_ITEM = 2;
        $scope.HIDDEN_ITEM = 3;

        // Bind agenda tree to the scope
        $scope.$watch(function () {
            return Agenda.lastModified();
        }, function () {
            // Filter out items that doesn't have the list_item_title. This happens, if the
            // item is a hidden item but provides the list of speakers, but should not be
            // visible in the list view.
            var allowedItems = _.filter(Agenda.getAll(), function (item) {
                return item.list_view_title;
            });
            $scope.items = AgendaTree.getFlatTree(allowedItems);
            $scope.agendaHasSubitems = $filter('filter')($scope.items, {'parent_id': ''}).length;
        });
        Projector.bindAll({}, $scope, 'projectors');
        $scope.mainListTree = true;
        $scope.$watch(function () {
            return Projector.lastModified();
        }, function () {
            var projectiondefault =  ProjectionDefault.filter({name: 'agenda_all_items'})[0];
            if (projectiondefault) {
                $scope.defaultProjectorId_all_items = projectiondefault.projector_id;
            }
            $scope.projectionDefaults = ProjectionDefault.getAll();
        });
        $scope.alert = {};


        // Filtering
        $scope.filter = osTableFilter.createInstance('AgendaTableFilter');

        if (!$scope.filter.existsStorageEntry()) {
            $scope.filter.booleanFilters = {
                closed: {
                    value: undefined,
                    defaultValue: undefined,
                    displayName: gettext('Closed items'),
                    choiceYes: gettext('Closed items'),
                    choiceNo: gettext('Open items'),
                },
                // The next filters are just on-off, so no undefined there
                is_public: {
                    value: true,
                    defaultValue: true,
                    choiceYes: gettext('Public items'),
                    choiceNo: gettext('No public items'),
                },
                is_internal: {
                    value: true,
                    defaultValue: true,
                    choiceYes: gettext('Internal items'),
                    choiceNo: gettext('No internal items'),
                    permission: 'agenda.can_see_internal_items',
                },
                is_hidden: {
                    value: false,
                    defaultValue: false,
                    choiceYes: gettext('Hidden items'),
                    choiceNo: gettext('No hidden items'),
                    permission: 'agenda.can_manage',
                },
            };
        }
        $scope.filter.propertyList = ['item_number', 'title', 'title_list_view', 'comment', 'duration'];
        $scope.filter.propertyFunctionList = [
            function (item) {return item.getListViewTitle();},
        ];
        $scope.areFiltersSet = function () {
            return ($scope.areVisibilityFiltersSet() ||
                $scope.filter.booleanFilters.closed.value !== $scope.filter.booleanFilters.closed.defaultValue);
        };
        $scope.areVisibilityFiltersSet = function () {
            return ($scope.filter.booleanFilters.is_public.value !== $scope.filter.booleanFilters.is_public.defaultValue ||
                $scope.filter.booleanFilters.is_internal.value !== $scope.filter.booleanFilters.is_internal.defaultValue ||
                $scope.filter.booleanFilters.is_hidden.value !== $scope.filter.booleanFilters.is_hidden.defaultValue);

        };
        $scope.resetFilters = function (isSelectMode) {
            if (!isSelectMode) {
                _.forEach($scope.filter.booleanFilters, function (filter) {
                    filter.value = filter.defaultValue;
                });
                $scope.filter.save();
            }
        };

        // Expand all items during searching.
        $scope.filter.changed = function () {
            $scope.collapseState = true;
            $scope.toggleCollapseState();
        };

        // pagination
        $scope.pagination = osTablePagination.createInstance('AgendaTablePagination', 50);

        // parse duration for inline editing
        $scope.generateDurationText = function (item) {
            //convert data from model format (m) to view format (hh:mm)
            if (item.duration) {
                var time = "",
                    totalminutes = item.duration;
                if (totalminutes < 0) {
                    time = "-";
                    totalminutes = -totalminutes;
                }
                var hh = Math.floor(totalminutes / 60);
                var mm = Math.floor(totalminutes % 60);
                // Add leading "0" for double digit values
                mm = ("0"+mm).slice(-2);
                time += hh + ":" + mm;
                item.durationText = time;
            } else {
                item.durationText = "";
            }
        };
        $scope.setDurationText = function (item) {
            //convert data from view format (hh:mm) to model format (m)
            var time = item.durationText.replace('h', '').split(':');
            var data;
            if (time.length > 1 && !isNaN(time[0]) && !isNaN(time[1])) {
                data = (+time[0]) * 60 + (+time[1]);
                if (data < 0) {
                    data = "-"+data;
                }
                item.duration = parseInt(data);
            } else if (time.length == 1 && !isNaN(time[0])) {
                data = (+time[0]);
                item.duration = parseInt(data);
            } else {
                item.duration = 0;
            }
            $scope.save(item);
        };

        /** Duration calculations **/
        $scope.sumDurations = function () {
            var totalDuration = 0;
            $scope.items.forEach(function (item) {
                if (item.duration) {
                    totalDuration += item.duration;
                }
            });
            return totalDuration;
        };
        $scope.calculateEndTime = function () {
            var totalDuration = $scope.sumDurations();
            var startTimestamp = $scope.config('agenda_start_event_date_time');
            if (startTimestamp) {
                var endTimestamp = startTimestamp + totalDuration * 60 * 1000;
                var endDate = new Date(endTimestamp);
                var mm = ("0" + endDate.getMinutes()).slice(-2);
                var dateStr = endDate.getHours() + ':' + mm;
                return dateStr;
            } else {
                return '';
            }
        };

        // Agenda collapse function
        $scope.toggleCollapseState = function () {
            $scope.collapseState = !$scope.collapseState;
            _.forEach($scope.items, function (item) {
                item.hideChildren = $scope.collapseState;
            });
        };

        // Check, if an item has childs in all filtered items
        $scope.hasChildren = function (item) {
            return _.some($scope.itemsFiltered, function (_item) {
                return _item.parent_id == item.id;
            });
        };

        // returns true, if the agenda has at least two layers
        $scope.agendaHasMultipleLayers = function () {
            return _.some($scope.items, function (item) {
                return item.parent_id;
            });
        };

        /** Agenda item functions **/
        // open dialog for new topics // TODO Remove this. Don't forget import button in template.
        $scope.newDialog = function () {
            ngDialog.open(TopicForm.getDialog());
        };
        // save changed item
        $scope.save = function (item) {
            Agenda.save(item).then(
                function (success) {
                    $scope.alert.show = false;
                },
                function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                });
        };
        // delete related item
        $scope.deleteRelatedItem = function (item) {
            DS.destroy(item.content_object.collection, item.content_object.id);
        };
        // auto numbering of agenda items
        $scope.autoNumbering = function() {
            $http.post('/rest/agenda/item/numbering/', {});
        };
        // check open permission
        // TODO: Use generic solution here.
        $scope.isAllowedToSeeOpenLink = function (item) {
            var collection = item.content_object.collection;
            switch (collection) {
                case 'topics/topic':
                    return operator.hasPerms('agenda.can_see');
                case 'motions/motion':
                    return operator.hasPerms('motions.can_see');
                case 'motions/motion-block':
                    return operator.hasPerms('motions.can_see');
                case 'assignments/assignment':
                    return operator.hasPerms('assignments.can_see');
                default:
                    return false;
            }
        };
        $scope.edit = function (item) {
            ngDialog.open(item.getContentObjectForm().getDialog({id: item.content_object.id}));
        };

        // export
        $scope.pdfExport = function () {
            AgendaPdfExport.export($scope.itemsFiltered);
        };
        $scope.csvExport = function () {
            AgendaCsvExport.export($scope.itemsFiltered);
        };
        $scope.docxExport = function () {
            AgendaDocxExport.export($scope.itemsFiltered);
        };

        /** select mode functions **/
        $scope.isSelectMode = false;
        // check all checkboxes
        $scope.checkAll = function () {
            $scope.selectedAll = !$scope.selectedAll;
            angular.forEach($scope.items, function (item) {
                item.selected = $scope.selectedAll;
            });
        };
        // uncheck all checkboxes if isDeleteMode is closed
        $scope.uncheckAll = function () {
            if (!$scope.isSelectMode) {
                $scope.selectedAll = false;
                angular.forEach($scope.items, function (item) {
                    item.selected = false;
                });
            }
        };
        // set type for selected items
        $scope.setTypeMultiple = function (type) {
            _.forEach($scope.items, function (item) {
                if (item.selected) {
                    item.type = type;
                    $scope.save(item);
                }
            });
            $scope.isSelectMode = false;
            $scope.uncheckAll();
        };
        // set closed for selected items
        $scope.setStateMultiple = function (closed) {
            _.forEach($scope.items, function (item) {
                if (item.selected) {
                    item.closed = closed;
                    $scope.save(item);
                }
            });
            $scope.isSelectMode = false;
            $scope.uncheckAll();
        };
        // delete selected items
        $scope.deleteMultiple = function () {
            _.forEach($scope.items, function (item) {
                if (item.selected) {
                    DS.destroy(item.content_object.collection, item.content_object.id);
                }
            });
            $scope.isSelectMode = false;
            $scope.uncheckAll();
        };

        /** Project functions **/
        // get ProjectionDefault for item
        $scope.getProjectionDefault = function (item) {
            if (item.tree) {
                return $scope.defaultProjectorId_all_items;
            } else {
                var app_name = item.content_object.collection.split('/')[0];
                var id = 1;
                $scope.projectionDefaults.forEach(function (projectionDefault) {
                    if (projectionDefault.name == app_name) {
                        id = projectionDefault.projector_id;
                    }
                });
                return id;
            }
        };
        // project agenda
        $scope.projectAgenda = function (projectorId, tree, id) {
            var isAgendaProjectedIds = $scope.isAgendaProjected($scope.mainListTree);
            _.forEach(isAgendaProjectedIds, function (id) {
                $http.post('/rest/core/projector/' + id + '/clear_elements/');
            });
            if (_.indexOf(isAgendaProjectedIds, projectorId) == -1) {
                $http.post('/rest/core/projector/' + projectorId + '/prune_elements/',
                    [{name: 'agenda/item-list', tree: tree, id: id}]);
            }
        };
        // change whether all items or only main items should be projected
        $scope.changeMainListTree = function () {
            var isAgendaProjectedId = $scope.isAgendaProjected($scope.mainListTree);
            $scope.mainListTree = !$scope.mainListTree;
            if (isAgendaProjectedId > 0) {
                $scope.projectAgenda(isAgendaProjectedId, $scope.mainListTree);
            }
        };
        // change whether one item or all subitems should be projected
        $scope.changeItemTree = function (item) {
            var tree = item.tree;
            item.tree = !item.tree;
            var isProjected = item.isProjected(tree);
            _.forEach(isProjected, function (projectorId) {
                // Deactivate and reactivate
                item.project(projectorId, tree).then(function (s) {
                    item.project(projectorId, !tree);
                });
            });
        };
        // check if agenda is projected
        $scope.isAgendaProjected = function (tree) {
            // Returns the ids of all projectors with an element with
            // the name 'agenda/item-list'. Else returns an empty list.
            var predicate = function (element) {
                var value;
                if (tree) {
                    // tree with all agenda items
                    value = element.name == 'agenda/item-list' &&
                        typeof element.id === 'undefined' &&
                        element.tree;
                } else {
                    // only main agenda items
                    value = element.name == 'agenda/item-list' &&
                        typeof element.id === 'undefined' &&
                        !element.tree;
                }
                return value;
            };
            var projectorIds = [];
            $scope.projectors.forEach(function (projector) {
                if (typeof _.findKey(projector.elements, predicate) === 'string') {
                    projectorIds.push(projector.id);
                }
            });
            return projectorIds;
        };
    }
])

// Filter for the item type that filters the selected items by type. filters
// are the boolean filters from the ui.
.filter('itemTypeFilter', [
    function () {
        return function (items, filters) {
            return _.filter(items, function (item) {
                return (item.is_public && filters.is_public.value) ||
                    (item.is_internal && filters.is_internal.value) ||
                    (item.is_hidden && filters.is_hidden.value);
            });
        };
    }
])

// filter to hide collapsed items. Items has to be a flat tree.
.filter('collapsedItemFilter', [
    function () {
        return function (items) {
            return _.filter(items, function (item) {
                var index = _.findIndex(items, item);
                var parentId = item.parent_id;
                // Search for parents, if one has the hideChildren attribute set. All parents
                // have a higher index as this item, because items is a flat tree.
                // If a parent has this attribute, we should remove this item. Else if we hit
                // the top or an item on the first layer, the item is not collapsed.
                for (--index; index >= 0 && parentId !== null; index--) {
                    var p = items[index];
                    if (p.id === parentId) {
                        if (p.hideChildren) {
                            return false;
                        } else {
                            parentId = p.parent_id;
                        }
                    }
                }
                return true;
            });
        };
    }
])

.controller('ItemDetailCtrl', [
    '$scope',
    '$filter',
    'Agenda',
    'itemId',
    'Projector',
    'ProjectionDefault',
    'gettextCatalog',
    'WebpageTitle',
    'ErrorMessage',
    function ($scope, $filter, Agenda, itemId, Projector, ProjectionDefault, gettextCatalog, WebpageTitle,
        ErrorMessage) {
        $scope.alert = {};

        $scope.$watch(function () {
            return Agenda.lastModified(itemId);
        }, function () {
            $scope.item = Agenda.get(itemId);
            WebpageTitle.updateTitle(gettextCatalog.getString('List of speakers') + ' ' +
                gettextCatalog.getString('of') + ' ' + $scope.item.getTitle());
            // all speakers
            $scope.speakers = $filter('orderBy')($scope.item.speakers, 'weight');
            // next speakers
            $scope.nextSpeakers = $filter('filter')($scope.speakers, {'begin_time': null});
            // current speaker
            $scope.currentSpeaker = $filter('filter')($scope.speakers, {'begin_time': '!!', 'end_time': null});
            // last speakers
            $scope.lastSpeakers = $filter('filter')($scope.speakers, {'end_time': '!!'});
            $scope.lastSpeakers = $filter('orderBy')($scope.lastSpeakers, 'begin_time');
        });
        $scope.$watch(function () {
            return Projector.lastModified();
        }, function () {
            var item_app_name = $scope.item.content_object.collection.split('/')[0];
            var projectiondefaultItem = ProjectionDefault.filter({name: item_app_name})[0];
            if (projectiondefaultItem) {
                $scope.defaultProjectorItemId = projectiondefaultItem.projector_id;
            }
            var projectiondefaultListOfSpeakers = ProjectionDefault.filter({name: 'agenda_list_of_speakers'})[0];
            if (projectiondefaultListOfSpeakers) {
                $scope.defaultProjectorListOfSpeakersId = projectiondefaultListOfSpeakers.projector_id;
            }
        });
    }
])

/* This is the controller for the list of speakers partial management template.
 * The parent controller needs to provide a $scope.item, $scope.speakers, $scope.nextSpeakers,
 * $scope.currentSpeakers, $scope.lastSpeakers. See (as example) ItemDetailCtrl. */
.controller('ListOfSpeakersManagementCtrl', [
    '$scope',
    '$http',
    '$filter',
    'Agenda',
    'User',
    'operator',
    'ErrorMessage',
    function ($scope, $http, $filter, Agenda, User, operator, ErrorMessage) {
        User.bindAll({}, $scope, 'users');
        $scope.speakerSelectBox = {};

        // close/open list of speakers of current item
        $scope.closeList = function (listClosed) {
            $scope.item.speaker_list_closed = listClosed;
            Agenda.save($scope.item);
        };

        // add user to list of speakers
        $scope.addSpeaker = function (userId) {
            $http.post('/rest/agenda/item/' + $scope.item.id + '/manage_speaker/', {'user': userId}).then(
                function (success) {
                    $scope.alert.show = false;
                    $scope.speakerSelectBox = {};
                }, function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                    $scope.speakerSelectBox = {};
                }
            );
        };

        // delete speaker(!) from list of speakers
        $scope.removeSpeaker = function (speakerId) {
            $http.delete(
                '/rest/agenda/item/' + $scope.item.id + '/manage_speaker/',
                {headers: {'Content-Type': 'application/json'},
                 data: JSON.stringify({speaker: speakerId})}
            )
            .then(function (success) {
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };

        //delete all speakers from list of speakers
        $scope.removeAllSpeakers = function () {
            var speakersOnList = [];
            angular.forEach($scope.item.speakers, function (speaker) {
                speakersOnList.push(speaker.id);
            });
            $http.delete(
                '/rest/agenda/item/' + $scope.item.id + '/manage_speaker/',
                {headers: {'Content-Type': 'application/json'},
                 data: JSON.stringify({speaker: speakersOnList})}
            )
            .then(function (success) {
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };

        // Return true if the requested user is allowed to do a specific action
        // and see the corresponding button (e.g. 'add me' or 'remove me').
        $scope.isAllowed = function (action) {
            var nextUsers = [];
            angular.forEach($scope.nextSpeakers, function (speaker) {
                nextUsers.push(speaker.user_id);
            });
            switch (action) {
                case 'add':
                    return (operator.hasPerms('agenda.can_be_speaker') &&
                            !$scope.item.speaker_list_closed &&
                            $.inArray(operator.user.id, nextUsers) == -1);
                case 'remove':
                    if (operator.user) {
                        return ($.inArray(operator.user.id, nextUsers) != -1);
                    }
                    return false;
                case 'removeAll':
                    return (operator.hasPerms('agenda.can_manage_list_of_speakers') &&
                            $scope.speakers.length > 0);
                case 'showLastSpeakers':
                    return $scope.lastSpeakers.length > 0;
            }
        };

        // begin speech of selected/next speaker
        $scope.beginSpeech = function (speakerId) {
            $http.put('/rest/agenda/item/' + $scope.item.id + '/speak/', {'speaker': speakerId})
            .then(function (success) {
                $scope.alert.show = false;
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };

        // end speech of current speaker
        $scope.endSpeech = function () {
            $http.delete(
                '/rest/agenda/item/' + $scope.item.id + '/speak/',
                {headers: {'Content-Type': 'application/json'}, data: {}}
            ).then(
                function (success) {},
                function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
        // gets speech duration of selected speaker in seconds
        $scope.getDuration = function (speaker) {
            var beginTimestamp = new Date(speaker.begin_time).getTime();
            var endTimestamp = new Date(speaker.end_time).getTime();
            // calculate duration in seconds
            return Math.floor((endTimestamp - beginTimestamp) / 1000);

        };
        // save reordered list of speakers
        $scope.treeOptions = {
            dropped: function (event) {
                var sortedSpeakers = _.map($scope.nextSpeakers, function (speaker) {
                    return speaker.id;
                });
                $http.post('/rest/agenda/item/' + $scope.item.id + '/sort_speakers/',
                    {speakers: sortedSpeakers}
                );
            }
        };

        // Marking a speaker
        $scope.toggleMarked = function (speaker) {
            $http.patch('/rest/agenda/item/' + $scope.item.id + '/manage_speaker/', {
                user: speaker.user.id,
                marked: !speaker.marked,
            }).then(function (success) {
                $scope.alert.show = false;
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };
    }
])

.controller('AgendaSortCtrl', [
    '$scope',
    '$http',
    'Agenda',
    'AgendaTree',
    'ErrorMessage',
    function($scope, $http, Agenda, AgendaTree, ErrorMessage) {
        // Bind agenda tree to the scope
        $scope.$watch(function () {
            return Agenda.lastModified();
        }, function () {
            $scope.items = AgendaTree.getTree(Agenda.getAll());
        });
        $scope.showInternalItems = true;
        $scope.alert = {};

        // save parent and weight of moved agenda item (and all items on same level)
        $scope.treeOptions = {
            dropped: function(event) {
                var parentID = null;
                var droppedItemID = event.source.nodeScope.$modelValue.id;
                if (event.dest.nodesScope.item) {
                    parentID = event.dest.nodesScope.item.id;
                }
                $http.post('/rest/agenda/item/sort/', {
                    nodes: event.dest.nodesScope.$modelValue,
                    parent_id: parentID}
                ).then(
                    function(success) {},
                    function(error){
                        $scope.alert = ErrorMessage.forAlert(error);
                    }
                );
            }
        };
    }
])

.controller('CurrentListOfSpeakersViewCtrl', [
    '$scope',
    '$http',
    '$filter',
    'Projector',
    'ProjectionDefault',
    'Agenda',
    'Config',
    'CurrentListOfSpeakersItem',
    'CurrentListOfSpeakersSlide',
    'gettextCatalog',
    'WebpageTitle',
    function($scope, $http, $filter, Projector, ProjectionDefault, Agenda, Config,
        CurrentListOfSpeakersItem, CurrentListOfSpeakersSlide, gettextCatalog, WebpageTitle) {
        $scope.alert = {};
        $scope.currentListOfSpeakers = CurrentListOfSpeakersSlide;

        // Watch for changes in the current list of speakers reference
        $scope.$watch(function () {
            return Config.lastModified('projector_currentListOfSpeakers_reference');
        }, function () {
            $scope.currentListOfSpeakersReference = $scope.config('projector_currentListOfSpeakers_reference');
            $scope.updateCurrentListOfSpeakersItem();
        });
        $scope.$watch(function () {
            return Projector.lastModified();
        }, function() {
            $scope.projectors = Projector.getAll();
            // If there is just one projector we provide just the overlay.
            if ($scope.projectors.length === 1) {
                $scope.currentListOfSpeakersAsOverlay = true;
            }
            $scope.updateCurrentListOfSpeakersItem();

            $scope.listOfSpeakersDefaultProjectorId = ProjectionDefault.filter({name: 'agenda_current_list_of_speakers'})[0].projector_id;
        });

        $scope.$watch(function () {
            return $scope.item ? Agenda.lastModified($scope.item.id) : void 0;
        }, function () {
            $scope.updateCurrentListOfSpeakersItem();
        });

        $scope.updateCurrentListOfSpeakersItem = function () {
            $scope.item = CurrentListOfSpeakersItem.getItem($scope.currentListOfSpeakersReference);
            if ($scope.item) {
                // all speakers
                $scope.speakers = $filter('orderBy')($scope.item.speakers, 'weight');
                // next speakers
                $scope.nextSpeakers = $filter('filter')($scope.speakers, {'begin_time': null});
                // current speaker
                $scope.currentSpeaker = $filter('filter')($scope.speakers, {'begin_time': '!!', 'end_time': null});
                // last speakers
                $scope.lastSpeakers = $filter('filter')($scope.speakers, {'end_time': '!!'});
                $scope.lastSpeakers = $filter('orderBy')($scope.lastSpeakers, 'begin_time');
            } else {
                $scope.speakers = void 0;
                $scope.nextSpeakers = void 0;
                $scope.currentSpeaker = void 0;
                $scope.lastSpeakers = void 0;
            }
            if ($scope.item) {
                WebpageTitle.updateTitle(gettextCatalog.getString('Current list of speakers') + ' ' +
                    gettextCatalog.getString('of') + ' ' + $scope.item.getTitle());
            } else {
                WebpageTitle.updateTitle(gettextCatalog.getString('Current list of speakers'));
            }
        };

        // Set the current overlay status
        if ($scope.currentListOfSpeakers.isProjected().length) {
            var isProjected = $scope.currentListOfSpeakers.isProjectedWithOverlayStatus();
            $scope.currentListOfSpeakersAsOverlay = isProjected[0].overlay;
        } else {
            $scope.currentListOfSpeakersAsOverlay = false;
        }
        $scope.setOverlay = function (overlay) {
            $scope.currentListOfSpeakersAsOverlay = overlay;
            var isProjected = $scope.currentListOfSpeakers.isProjectedWithOverlayStatus();
            if (isProjected.length) {
                _.forEach(isProjected, function (mapping) {
                    if (mapping.overlay != overlay) { // change the overlay if it is different
                        $scope.currentListOfSpeakers.project(mapping.projectorId, overlay);
                    }
                });
            }
        };
    }
])

//mark all agenda config strings for translation with Javascript
.config([
    'gettext',
    function (gettext) {
        gettext('Enable numbering for agenda items');
        gettext('Numbering prefix for agenda items');
        gettext('This prefix will be set if you run the automatic agenda numbering.');
        gettext('Agenda');
        gettext('Invalid input.');
        gettext('Numeral system for agenda items');
        gettext('Arabic');
        gettext('Roman');
        gettext('Begin of event');
        gettext('Input format: DD.MM.YYYY HH:MM');
        gettext('Hide internal items when projecting subitems');
        gettext('Number of last speakers to be shown on the projector');
        gettext('List of speakers');
        gettext('Show orange countdown in the last x seconds of speaking time');
        gettext('Enter duration in seconds. Choose 0 to disable warning color.');
        gettext('Couple countdown with the list of speakers');
        gettext('[Begin speech] starts the countdown, [End speech] stops the ' +
                'countdown.');
        gettext('Agenda visibility');
        gettext('Default visibility for new agenda items (except topics)');
    }
 ]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.assignments', [])

.factory('AssignmentPollOption', [
    'DS',
    'jsDataModel',
    'gettextCatalog',
    'Config',
    'MajorityMethods',
    function (DS, jsDataModel, gettextCatalog, Config, MajorityMethods) {
        return DS.defineResource({
            name: 'assignments/polloption',
            useClass: jsDataModel,
            // Change the stringified numbers to floats.
            beforeInject: function (resource, instance) {
                _.forEach(instance.votes, function (vote) {
                    vote.weight = parseFloat(vote.weight);
                });
            },
            methods: {
                getVotes: function () {
                    if (!this.poll.has_votes) {
                        // Return undefined if this poll has no votes.
                        return;
                    }

                    // Initial values for the option
                    var votes = [],
                        config = Config.get('assignments_poll_100_percent_base').value;

                    var base = this.poll.getPercentBase(config);
                    if (typeof base === 'object' && base !== null) {
                        // this.poll.pollmethod === 'yna'
                        base = base[this.id];
                    }

                    _.forEach(this.votes, function (vote) {
                        // Initial values for the vote
                        var order = '',
                            value = '',
                            percentStr = '',
                            percentNumber;

                        // Check for special value
                        switch (vote.weight) {
                            case -1:
                                value = gettextCatalog.getString('majority');
                                break;
                            case -2:
                                value = gettextCatalog.getString('undocumented');
                                break;
                            default:
                                if (vote.weight >= 0) {
                                    value = vote.weight;
                                } else {
                                    value = 0;  // Vote was not defined. Set value to 0.
                                }
                        }
                        switch (vote.value) {
                            case "Yes":
                                order = 1;
                                break;
                            case "No":
                                order = 2;
                                break;
                            case "Abstain":
                                order = 3;
                                break;
                            default:
                                order = 0;
                        }

                        // Special case where to skip percents
                        var skipPercents = config === 'YES_NO' && vote.value === 'Abstain';

                        if (base && !skipPercents) {
                            percentNumber = Math.round(vote.weight * 100 / base * 100) / 100;
                            if (percentNumber >= 0) {
                                percentStr = '(' + percentNumber + ' %)';
                            }
                        }
                        votes.push({
                            'order': order,
                            'label': gettextCatalog.getString(vote.value),
                            'value': value,
                            'percentStr': percentStr,
                            'percentNumber': percentNumber
                        });
                    });
                    return _.sortBy(votes, 'order');
                },

                // Returns 0 or positive integer if quorum is reached or surpassed.
                // Returns negativ integer if quorum is not reached.
                // Returns undefined if we can not calculate the quorum.
                isReached: function (method) {
                    if (!this.poll.has_votes) {
                        // Return undefined if this poll has no votes.
                        return;
                    }
                    var isReached;
                    var config = Config.get('assignments_poll_100_percent_base').value;
                    var base = this.poll.getPercentBase(config);
                    if (typeof base === 'object' && base !== null) {
                        // this.poll.pollmethod === 'yna'
                        base = base[this.id];
                    }
                    if (base) {
                        // Provide result only if base is not undefined and not 0.
                        isReached = MajorityMethods[method](this.getVoteYes(), base);
                    }
                    return isReached;
                },

                // Returns the weight for the vote or the vote 'yes' in case of YNA poll method.
                getVoteYes: function () {
                    var voteYes = 0;
                    if (this.poll.pollmethod === 'yna') {
                        var voteObj = _.find(this.votes, function (vote) {
                            return vote.value === 'Yes';
                        });
                        if (voteObj) {
                            voteYes = voteObj.weight;
                        }
                    } else {
                        // pollmethod === 'votes'
                        voteYes = this.votes[0].weight;
                    }
                    return voteYes;
                }
            },
            relations: {
                belongsTo: {
                    'assignments/poll': {
                        localField: 'poll',
                        localKey: 'poll_id',
                    },
                    'users/user': {
                        localField: 'candidate',
                        localKey: 'candidate_id',
                    }
                }
            },
        });
    }
])

.factory('AssignmentPoll', [
    '$http',
    'DS',
    'jsDataModel',
    'gettextCatalog',
    'AssignmentPollOption',
    'Config',
    function ($http, DS, jsDataModel, gettextCatalog, AssignmentPollOption, Config) {
        var name = 'assignments/poll';
        return DS.defineResource({
            name: name,
            useClass: jsDataModel,
            // Change the stringified numbers to floats.
            beforeInject: function (resource, instance) {
                var attrs = ['votescast', 'votesinvalid', 'votesvalid', 'votesabstain', 'votesno'];
                _.forEach(attrs, function (attr) {
                    if (instance[attr] !== null) {
                        instance[attr] = parseFloat(instance[attr]);
                    }
                });
            },
            methods: {
                getResourceName: function () {
                    return name;
                },

                // Returns percent base. Returns undefined if calculation is not possible in general.
                getPercentBase: function (config, type) {
                    var base;
                    switch (config) {
                        case 'CAST':
                            if (this.votescast <= 0 || this.votesinvalid < 0) {
                                // It would be OK to check only this.votescast < 0 because 0
                                // is checked again later but this is a little bit faster.
                                break;
                            }
                            base = this.votescast;
                            /* falls through */
                        case 'VALID':
                            if (this.votesvalid < 0) {
                                base = void 0;
                                break;
                            }
                            if (typeof base === 'undefined' && type !== 'votescast' && type !== 'votesinvalid') {
                                base = this.votesvalid;
                            }
                            /* falls through */
                        case 'YES_NO_ABSTAIN':
                        case 'YES_NO':
                            if (this.pollmethod === 'yna') {
                                if (typeof base === 'undefined' && type !== 'votescast' && type !== 'votesinvalid' && type !== 'votesvalid') {
                                    base = {};
                                    _.forEach(this.options, function (option) {
                                        var allVotes = option.votes;
                                        if (config === 'YES_NO') {
                                            allVotes = _.filter(allVotes, function (vote) {
                                                // Extract abstain votes in case of YES_NO percent base.
                                                // Do not extract abstain vote if it is set to majority so the predicate later
                                                // fails and therefor we get an undefined base. Reason: It should not be possible
                                                // to set abstain to majority and nevertheless calculate percents of yes and no.
                                                return vote.value !== 'Abstain' || vote.weight === -1;
                                            });
                                        }
                                        var predicate = function (vote) {
                                            return vote.weight < 0;
                                        };
                                        if (_.findIndex(allVotes, predicate) === -1) {
                                            base[option.id] = _.reduce(allVotes, function (sum, vote) {
                                                return sum + vote.weight;
                                            }, 0);
                                        }
                                    });
                                }
                            } else {
                                // this.pollmethod === 'votes'
                                var predicate = function (option) {
                                    return option.votes[0].weight < 0;
                                };
                                if (_.findIndex(this.options, predicate) !== -1) {
                                    base = void 0;
                                } else {
                                    if (typeof base === 'undefined' && type !== 'votesabstain' &&
                                        type !== 'votesno' && type !== 'votescast' &&
                                        type !== 'votesinvalid' && type !== 'votesvalid') {
                                        base = _.reduce(this.options, function (sum, option) {
                                            return sum + option.votes[0].weight;
                                        }, 0);
                                    }
                                }
                            }
                    }
                    return base;
                },

                // Returns object with value and percent for this poll (for votes valid/invalid/cast only).
                getVote: function (type) {
                    if (!this.has_votes) {
                        // Return undefined if this poll has no votes.
                        return;
                    }

                    // Initial values
                    var value = '',
                        percentStr = '',
                        percentNumber,
                        vote,
                        config = Config.get('assignments_poll_100_percent_base').value;

                    switch (type) {
                        case 'votesabstain':
                            vote = this.votesabstain;
                            break;
                        case 'votesno':
                            vote = this.votesno;
                            break;
                        case 'votesinvalid':
                            vote = this.votesinvalid;
                            break;
                        case 'votesvalid':
                            vote = this.votesvalid;
                            break;
                        case 'votescast':
                            vote = this.votescast;
                            break;
                    }

                    // Check special values
                    switch (vote) {
                        case -1:
                            value = gettextCatalog.getString('majority');
                            break;
                        case -2:
                            value = gettextCatalog.getString('undocumented');
                            break;
                        default:
                            if (vote >= 0) {
                                value = vote;
                            } else {
                                value = 0; // value was not defined
                            }
                    }

                    // Calculate percent value
                    var base = this.getPercentBase(config, type);
                    if (base) {
                        percentNumber = Math.round(vote * 100 / (base) * 10) / 10;
                        percentStr = '(' + percentNumber + ' %)';
                    }
                    return {
                        'value': value,
                        'percentStr': percentStr,
                        'percentNumber': percentNumber,
                        'display': value + ' ' + percentStr
                    };
                }
            },
            relations: {
                belongsTo: {
                    'assignments/assignment': {
                        localField: 'assignment',
                        localKey: 'assignment_id',
                    }
                },
                hasMany: {
                    'assignments/polloption': {
                        localField: 'options',
                        foreignKey: 'poll_id',
                    }
                }
            },
        });
    }
])

.provider('AssignmentPollDecimalPlaces', [
    function () {
        this.$get = ['$q', function ($q) {
            return {
                getPlaces: function (poll, find) {
                    if (find) {
                        return $q(function (resolve) {
                            resolve(0);
                        });
                    } else {
                        return 0;
                    }
                },
            };
        }];
    }
])

.factory('AssignmentRelatedUser', [
    'DS',
    function (DS) {
        return DS.defineResource({
            name: 'assignments/relateduser',
            relations: {
                belongsTo: {
                    'users/user': {
                        localField: 'user',
                        localKey: 'user_id',
                    }
                }
            }
        });
    }
])

.factory('Assignment', [
    '$http',
    'DS',
    'Projector',
    'ProjectHelper',
    'AssignmentRelatedUser',
    'AssignmentPoll',
    'jsDataModel',
    'gettext',
    function ($http, DS, Projector, ProjectHelper, AssignmentRelatedUser, AssignmentPoll,
        jsDataModel, gettext) {
        var name = 'assignments/assignment';
        return DS.defineResource({
            name: name,
            useClass: jsDataModel,
            verboseName: gettext('Election'),
            verboseNamePlural: gettext('Elections'),
            methods: {
                getResourceName: function () {
                    return name;
                },
                getTitle: function () {
                    return this.title;
                },
                getAgendaTitle: function () {
                    return this.getTitle();
                },
                // link name which is shown in search result
                getSearchResultName: function () {
                    return this.getAgendaTitle();
                },
                // return true if a specific relation matches for given searchquery
                // (here: related_users/candidates)
                hasSearchResult: function (results) {
                    var assignment = this;
                    // search for related users (check if any user.id from already found users matches)
                    return _.some(results, function(result) {
                        if (result.getResourceName() === "users/user") {
                            if (_.some(assignment.assignment_related_users, {'user_id': result.id})) {
                                return true;
                            }
                        }
                    });
                },
                // override project function of jsDataModel factory
                project: function (projectorId, pollId) {
                    var isProjectedIds = this.isProjected(pollId);
                    var requestData = {
                        clear_ids: isProjectedIds,
                    };
                    if (_.indexOf(isProjectedIds, projectorId) == -1) {
                        requestData.prune = {
                            id: projectorId,
                            element: {
                                name: 'assignments/assignment',
                                id: this.id,
                                poll: pollId
                            },
                        };
                    }
                    return ProjectHelper.project(requestData);
                },
                // override isProjected function of jsDataModel factory
                isProjected: function (poll_id, anyPoll) {
                    // Returns the ids of all projectors with an element
                    // with the name 'assignments/assignment'. Else returns an empty list.
                    // Provide a poll_id to query a specific poll or set anyPoll to true, to
                    // query whether any poll (but not the assignment itself) is projected.
                    var self = this;
                    var predicate = function (element) {
                        var value;
                        if (typeof poll_id === 'undefined') {
                            // Assignment detail slide without poll
                            value = element.name == 'assignments/assignment' &&
                                typeof element.id !== 'undefined' &&
                                element.id == self.id &&
                                typeof element.poll === 'undefined';
                        } else if (anyPoll) {
                            // Assignment detail slide with any poll
                            value = element.name == 'assignments/assignment' &&
                                typeof element.id !== 'undefined' &&
                                element.id == self.id &&
                                typeof element.poll !== 'undefined';
                        } else {
                            // Assignment detail slide with specific poll
                            value = element.name == 'assignments/assignment' &&
                                typeof element.id !== 'undefined' &&
                                element.id == self.id &&
                                typeof element.poll !== 'undefined' &&
                                element.poll == poll_id;
                        }
                        return value;
                    };
                    var isProjectedIds = [];
                    Projector.getAll().forEach(function (projector) {
                        if (typeof _.findKey(projector.elements, predicate) === 'string') {
                            isProjectedIds.push(projector.id);
                        }
                    });
                    return isProjectedIds;
                },
                isRelatedProjected: function () {
                    var listOfSpeakers = [];
                    if (this.agenda_item) {
                        listOfSpeakers = this.agenda_item.isListOfSpeakersProjected();
                    }
                    return listOfSpeakers.concat(this.isProjected(null, true));
                },
            },
            relations: {
                belongsTo: {
                    'agenda/item': {
                        localKey: 'agenda_item_id',
                        localField: 'agenda_item',
                    }
                },
                hasMany: {
                    'core/tag': {
                        localField: 'tags',
                        localKeys: 'tags_id',
                    },
                    'assignments/relateduser': {
                        localField: 'assignment_related_users',
                        foreignKey: 'assignment_id',
                    },
                    'assignments/poll': {
                        localField: 'polls',
                        foreignKey: 'assignment_id',
                    }
                }
            },
            beforeInject: function (resource, instance) {
                AssignmentRelatedUser.ejectAll({where: {assignment_id: {'==': instance.id}}});
            }
        });
    }
])

.run(['Assignment', function(Assignment) {}]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.assignments.pdf', ['OpenSlidesApp.core.pdf'])

.factory('AssignmentContentProvider', [
    '$filter',
    'HTMLValidizer',
    'gettextCatalog',
    'PDFLayout',
    'AssignmentPollDecimalPlaces',
    function($filter, HTMLValidizer, gettextCatalog, PDFLayout, AssignmentPollDecimalPlaces) {

        var createInstance = function(assignment) {

            // page title
            var title = PDFLayout.createTitle(assignment.title);
            var isElectedSemaphore = false;

            // open posts
            var createPreamble = function() {
                var preambleText = gettextCatalog.getString("Number of persons to be elected") + ": ";
                var memberNumber = ""+assignment.open_posts;
                var preamble = {
                    text: [
                        {
                            text: preambleText,
                            bold: true,
                            style: 'textItem'
                        },
                        {
                            text: memberNumber,
                            style: 'textItem'
                        }
                    ]
                };
                return preamble;
            };

            // description
            var createDescription = function() {
                if (assignment.description) {
                    var html = HTMLValidizer.validize(assignment.description);
                    var descriptionText = gettextCatalog.getString("Description") + ":";
                    var description = [
                        {
                            text: descriptionText,
                            bold: true,
                            style: 'textItem'
                        },
                        {
                            text: $(html).text(),
                            style: 'textItem',
                            margin: [10, 0, 0, 0]
                        }
                    ];
                    return description;
                } else {
                    return "";
                }
            };

            // show candidate list (if assignment phase is not 'finished')
            var createCandidateList = function() {
                if (assignment.phase != 2) {
                    var candidates = $filter('orderBy')(assignment.assignment_related_users, 'weight');
                    var candidatesText = gettextCatalog.getString("Candidates") + ": ";
                    var userList = [];

                    _.forEach(candidates, function(assignmentsRelatedUser) {
                        userList.push({
                                text: assignmentsRelatedUser.user.get_full_name(),
                                margin: [0, 0, 0, 10],
                            }
                        );
                    });

                    var cadidateList = {
                        columns: [
                            {
                                text: candidatesText,
                                bold: true,
                                width: "25%",
                                style: 'textItem'
                            },
                            {
                                ul: userList,
                                style: 'textItem'
                            }
                        ]
                    };
                    return cadidateList;
                } else {
                    return "";
                }
            };

            // handles the case if a candidate is elected or not
            var electedCandidateLine = function(candidateName, pollOption, pollTableBody) {
                if (pollOption.is_elected) {
                    isElectedSemaphore = true;
                    return {
                        text: candidateName + "*",
                        bold: true,
                        style: PDFLayout.flipTableRowStyle(pollTableBody.length)
                    };
                } else {
                    return {
                        text: candidateName,
                        style: PDFLayout.flipTableRowStyle(pollTableBody.length)
                    };
                }
            };

            //creates the voting string for the result table and differentiates between special values
            var parseVoteValue = function(voteObject, printLabel, precision) {
                var voteVal = '';
                if (voteObject) {
                    if (printLabel) {
                        voteVal += voteObject.label + ': ';
                    }
                    voteVal += $filter('number')(voteObject.value, precision);

                    if (voteObject.percentStr) {
                        voteVal += ' ' + voteObject.percentStr;
                    }
                }
                voteVal += '\n';
                return voteVal;
            };

            // creates the election result table
            var createPollResultTable = function() {
                var resultBody = [];
                _.forEach(assignment.polls, function(poll, pollIndex) {
                    if (poll.published) {
                        var pollTableBody = [];
                        var precision = AssignmentPollDecimalPlaces.getPlaces(poll);

                        resultBody.push({
                            text: gettextCatalog.getString('Ballot') + ' ' + (pollIndex+1),
                            bold: true,
                            style: 'textItem',
                            margin: [0, 15, 0, 0]
                        });

                        pollTableBody.push([
                            {
                                text: gettextCatalog.getString('Candidates'),
                                style: 'tableHeader',
                            },
                            {
                                text: gettextCatalog.getString('Votes'),
                                style: 'tableHeader',
                            }
                        ]);

                        _.forEach(poll.options, function(pollOption, optionIndex) {
                            var candidateName = pollOption.candidate.get_full_name();
                            var votes = pollOption.getVotes(); // 0 = yes, 1 = no, 2 = abstain
                            var tableLine = [];

                            tableLine.push(electedCandidateLine(candidateName, pollOption, pollTableBody));
                            if (poll.pollmethod == 'votes') {
                                tableLine.push(
                                    {
                                        text: parseVoteValue(votes[0], false, precision),
                                        style: PDFLayout.flipTableRowStyle(pollTableBody.length)
                                    }
                                );
                            } else {
                                var resultBlock = [];
                                _.forEach(votes, function(vote) {
                                    resultBlock.push(parseVoteValue(vote, true, precision));
                                });
                                tableLine.push({
                                        text: resultBlock,
                                        style: PDFLayout.flipTableRowStyle(pollTableBody.length)
                                    }
                                );
                            }
                            pollTableBody.push(tableLine);
                        });

                        var pushConcludeRow = function (title, fieldName) {
                            if (poll[fieldName]) {
                                pollTableBody.push([
                                    {
                                        text: gettextCatalog.getString(title),
                                        style: 'tableConclude'
                                    },
                                    {
                                        text: parseVoteValue(poll.getVote(fieldName), false, precision),
                                        style: 'tableConclude'
                                    },
                                ]);
                            }
                        };

                        pushConcludeRow('Abstain', 'votesabstain');
                        pushConcludeRow('No', 'votesno');
                        pushConcludeRow('Valid ballots', 'votesvalid');
                        pushConcludeRow('Invalid ballots', 'votesinvalid');
                        pushConcludeRow('Casted ballots', 'votescast');

                        var resultTableJsonSting = {
                            table: {
                                widths: ['64%','33%'],
                                headerRows: 1,
                                body: pollTableBody,
                            },
                            layout: 'headerLineOnly',
                        };

                        resultBody.push(resultTableJsonSting);
                    }
                });

                // add the legend to the result body
                if (assignment.polls.length > 0 && isElectedSemaphore) {
                    resultBody.push({
                        text: '* = ' + gettextCatalog.getString('is elected'),
                        margin: [0, 5, 0, 0],
                    });
                }

                return resultBody;
            };

            var getContent = function() {
                return [
                    title,
                    createPreamble(),
                    createDescription(),
                    createCandidateList(),
                    createPollResultTable()
                ];
            };

            return {
                getContent: getContent,
                title: assignment.title
            };
        };

        return {
            createInstance: createInstance
        };
    }
])

.factory('BallotContentProvider', [
    '$q',
    '$filter',
    'gettextCatalog',
    'PDFLayout',
    'Config',
    'User',
    'ImageConverter',
    function($q, $filter, gettextCatalog, PDFLayout, Config, User, ImageConverter) {
        var createInstance = function(assignment, poll, pollNumber) {

            var logoBallotPaperUrl = Config.get('logo_pdf_ballot_paper').value.path;
            var imageMap = {};

            // PDF header
            var header = function() {
                var columns = [];

                // logo
                if (logoBallotPaperUrl) {
                    columns.push({
                        image: logoBallotPaperUrl,
                        fit: [90,20],
                        width: '20%'
                    });
                }
                var text = Config.get('general_event_name').value;
                columns.push({
                    text: text,
                    fontSize: 8,
                    alignment: 'right',
                });

                return {
                    color: '#555',
                    margin: [30, 10, 10, -10], // [left, top, right, bottom]
                    columns: columns,
                    columnGap: 10
                };
            };

            // page title
            var createTitle = function() {
                return {
                    text: assignment.title,
                    style: 'title',
                };
            };

            // poll description
            var createPollHint = function() {
                var description = poll.description ? ': ' + poll.description : '';
                return {
                    text: gettextCatalog.getString("Ballot") + " " + pollNumber + description,
                    style: 'description',
                };
            };

            // election entries
            var createYNBallotEntry = function(decision) {
                var YNColumn = [
                    {
                        width: "auto",
                        stack: [
                            PDFLayout.createBallotEntry(gettextCatalog.getString("Yes"))
                        ]
                    },
                    {
                        width: "auto",
                        stack: [
                            PDFLayout.createBallotEntry(gettextCatalog.getString("No"))
                        ]
                    },
                ];

                if (poll.pollmethod == 'yna') {
                    YNColumn.push({
                        width: "auto",
                        stack: [
                            PDFLayout.createBallotEntry(gettextCatalog.getString("Abstain"))
                        ]
                    });
                }

                return [
                    {
                        text: decision,
                        margin: [40, 10, 0, 0],
                    },
                    {
                        columns: YNColumn
                    }
                ];
            };

            var createSelectionField = function() {
                var candidates = $filter('orderBy')(poll.options, 'weight');
                var candidateBallotList = [];

                if (poll.pollmethod == 'votes') {
                    _.forEach(candidates, function(option) {
                        var candidate = option.candidate.get_full_name();
                        candidateBallotList.push(PDFLayout.createBallotEntry(candidate));
                    });
                    // Add 'no' option
                    var no = gettextCatalog.getString('No');
                    var ballotEntry = PDFLayout.createBallotEntry(no);
                    ballotEntry.margin[1] = 25; // top margin
                    candidateBallotList.push(ballotEntry);
                } else {
                    _.forEach(candidates, function(option) {
                        var candidate;
                        if (option.candidate) {
                            candidate = option.candidate.get_full_name();
                        }
                        candidateBallotList.push(createYNBallotEntry(candidate));
                    });
                }
                return candidateBallotList;
            };

            var createSection = function(marginTop) {

                // since it is not possible to give a column a fixed height, we draw an "empty" column
                // with a one px width and a fixed top-margin
                return {
                    columns: [
                        {
                            width: 1,
                            margin: [0, marginTop],
                            text: '',
                        },
                        {
                            width: '*',
                            stack: [
                                header(),
                                createTitle(),
                                createPollHint(),
                                createSelectionField(),
                            ],
                        },
                    ]
                };
            };

            var createTableBody = function(numberOfRows, sheetend, maxballots) {
                var ballotstoprint = numberOfRows * 2;
                if (Number.isInteger(maxballots) && maxballots > 0 && maxballots < ballotstoprint) {
                    ballotstoprint = maxballots;
                }
                var tableBody = [];
                while (ballotstoprint > 1){
                    tableBody.push([createSection(sheetend), createSection(sheetend)]);
                    ballotstoprint -= 2;
                }
                if (ballotstoprint == 1) {
                    tableBody.push([createSection(sheetend), '']);
                }
                return tableBody;
            };

            var createContentTable = function() {
                // first, determine how many ballots we need
                var amount;
                var amount_method = Config.get('assignments_pdf_ballot_papers_selection').value;
                switch (amount_method) {
                    case 'NUMBER_OF_ALL_PARTICIPANTS':
                        amount = User.getAll().length;
                        break;
                    case 'NUMBER_OF_DELEGATES':
                        //TODO: assumption that DELEGATES is always group id 2. This may not be true
                        var group_id = 2;
                        amount = User.filter({where: {'groups_id': {contains:group_id} }}).length;
                        break;
                    case 'CUSTOM_NUMBER':
                        amount = Config.get('assignments_pdf_ballot_papers_number').value;
                        break;
                    default:
                        // should not happen.
                        amount = 0;
                }
                var tabledContent = [];
                var rowsperpage;
                var sheetend;
                if (poll.pollmethod == 'votes') {
                    if (poll.options.length <= 4) {
                        sheetend = 105;
                        rowsperpage = 4;
                    } else if (poll.options.length <= 8) {
                        sheetend = 140;
                        rowsperpage = 3;
                    } else if (poll.options.length <= 12) {
                        sheetend = 210;
                        rowsperpage = 2;
                    }
                    else { //works untill ~30 people
                        sheetend = 418;
                        rowsperpage = 1;
                    }
                } else {
                    if (poll.options.length <= 2) {
                        sheetend = 105;
                        rowsperpage = 4;
                    } else if (poll.options.length <= 4) {
                        sheetend = 140;
                        rowsperpage = 3;
                    } else if (poll.options.length <= 6) {
                        sheetend = 210;
                        rowsperpage = 2;
                    } else {
                        sheetend = 418;
                        rowsperpage = 1;
                    }
                }
                var page_entries = rowsperpage * 2;
                var fullpages = Math.floor(amount / page_entries);
                for (var i=0; i < fullpages; i++) {
                    tabledContent.push({
                        table: {
                            headerRows: 1,
                            widths: ['50%', '50%'],
                            body: createTableBody(rowsperpage, sheetend),
                            pageBreak: 'after'
                            },
                            layout: PDFLayout.getBallotLayoutLines(),
                            rowsperpage: rowsperpage
                        });
                }
                // fill the last page only partially
                var lastpage_ballots = amount - (fullpages * page_entries);
                if (lastpage_ballots < page_entries && lastpage_ballots > 0){
                    var partialpage = createTableBody(rowsperpage, sheetend, lastpage_ballots);
                    tabledContent.push({
                        table: {
                            headerRows: 1,
                            widths: ['50%', '50%'],
                            body: partialpage
                        },
                        layout: PDFLayout.getBallotLayoutLines(),
                        rowsperpage: rowsperpage
                    });
                }
                return tabledContent;
            };

            var getContent = function() {
                return createContentTable();
            };

            var getImageMap = function () {
                return imageMap;
            };

            return $q(function (resolve, reject) {
                var imageSources = [
                    logoBallotPaperUrl,
                ];
                ImageConverter.toBase64(imageSources).then(function (_imageMap) {
                    imageMap = _imageMap;
                    resolve({
                        getContent: getContent,
                        getImageMap: getImageMap,
                    });
                }, reject);
            });
        };

        return {
            createInstance: createInstance
        };
    }
])

.factory('AssignmentCatalogContentProvider', [
    'gettextCatalog',
    'PDFLayout',
    'Config',
    function(gettextCatalog, PDFLayout, Config) {

        var createInstance = function(allAssignments) {

            var title = PDFLayout.createTitle(
                    Config.translate(Config.get('assignments_pdf_title').value)
            );

            var createPreamble = function() {
                var preambleText = Config.get('assignments_pdf_preamble').value;
                if (preambleText) {
                    return {
                        text: preambleText,
                        style: "preamble"
                    };
                } else {
                    return "";
                }
            };

            var createTOContent = function(assignmentTitles) {
                var heading = {
                    text: gettextCatalog.getString("Table of contents"),
                    style: "heading2",
                };

                var toc = [];
                _.forEach(assignmentTitles, function(title) {
                    toc.push({
                        text: title,
                        style: "tableofcontent"
                    });
                });

                return [
                    heading,
                    toc,
                    PDFLayout.addPageBreak()
                ];
            };

            var getContent = function() {
                var content = [];
                var assignmentContent = [];
                var assignmentTitles = [];

                _.forEach(allAssignments, function(assignment, key) {
                    assignmentTitles.push(assignment.title);
                    assignmentContent.push(assignment.getContent());
                    if (key < allAssignments.length - 1) {
                        assignmentContent.push(PDFLayout.addPageBreak());
                    }
                });

                content.push(title);
                content.push(createPreamble());
                content.push(createTOContent(assignmentTitles));
                content.push(assignmentContent);
                return content;
            };

            return {
                getContent: getContent
            };
        };

        return {
            createInstance: createInstance
        };
    }
])

.factory('AssignmentPdfExport', [
    'gettextCatalog',
    'AssignmentContentProvider',
    'AssignmentCatalogContentProvider',
    'PdfMakeDocumentProvider',
    'BallotContentProvider',
    'PdfMakeBallotPaperProvider',
    'PdfCreate',
    'Messaging',
    function (gettextCatalog, AssignmentContentProvider, AssignmentCatalogContentProvider,
        PdfMakeDocumentProvider, BallotContentProvider, PdfMakeBallotPaperProvider, PdfCreate,
        Messaging) {
        return {
            export: function (assignments, singleAssignment) {
                var filename = singleAssignment ?
                    gettextCatalog.getString('Election') + '_' + assignments.title :
                    gettextCatalog.getString('Elections');
                filename += '.pdf';
                if (singleAssignment) {
                    assignments = [assignments];
                }

                // Convert the assignments to content providers
                var assignmentContentProviderArray = _.map(assignments, function (assignment) {
                    return AssignmentContentProvider.createInstance(assignment);
                });

                var documentProviderPromise;
                if (singleAssignment) {
                    documentProviderPromise =
                        PdfMakeDocumentProvider.createInstance(assignmentContentProviderArray[0]);
                } else {
                    var assignmentCatalogContentProvider =
                        AssignmentCatalogContentProvider.createInstance(assignmentContentProviderArray);
                    documentProviderPromise =
                        PdfMakeDocumentProvider.createInstance(assignmentCatalogContentProvider);
                }
                documentProviderPromise.then(function (documentProvider) {
                    PdfCreate.download(documentProvider, filename);
                }, function (error) {
                    Messaging.addMessage(error.msg, 'error');
                });
            },
            createBallotPdf: function (assignment, pollId) {
                var thePoll;
                var pollNumber;
                _.forEach(assignment.polls, function(poll, pollIndex) {
                    if (poll.id == pollId) {
                        thePoll = poll;
                        pollNumber = pollIndex+1;
                    }
                });
                var filename = gettextCatalog.getString('Ballot') + '_' + pollNumber + '_' + assignment.title + '.pdf';
                BallotContentProvider.createInstance(assignment, thePoll, pollNumber).then(function (ballotContentProvider) {
                    var documentProvider = PdfMakeBallotPaperProvider.createInstance(ballotContentProvider);
                    PdfCreate.download(documentProvider, filename);
                }, function (error) {
                    Messaging.addMessage(error.msg, 'error');
                });
            },
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.assignments.projector', ['OpenSlidesApp.assignments'])

.config([
    'slidesProvider',
    function(slidesProvider) {
        slidesProvider.registerSlide('assignments/assignment', {
            template: 'static/templates/assignments/slide_assignment.html',
        });
    }
])

.controller('SlideAssignmentCtrl', [
    '$scope',
    'Assignment',
    'AssignmentPoll',
    'AssignmentPhases',
    'AssignmentPollDecimalPlaces',
    'User',
    function($scope, Assignment, AssignmentPoll, AssignmentPhases, AssignmentPollDecimalPlaces, User) {
        // Attention! Each object that is used here has to be dealt on server side.
        // Add it to the coresponding get_requirements method of the ProjectorElement
        // class.
        var id = $scope.element.id;
        $scope.showResult = $scope.element.poll;

        if ($scope.showResult) {
            var poll = AssignmentPoll.get($scope.showResult);
            $scope.votesPrecision = 0;
            if (poll) {
                AssignmentPollDecimalPlaces.getPlaces(poll, true).then(function (decimalPlaces) {
                    $scope.votesPrecision = decimalPlaces;
                });
            }
        }

        Assignment.bindOne(id, $scope, 'assignment');
        $scope.phases = AssignmentPhases;
        User.bindAll({}, $scope, 'users');
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.assignments.site', [
    'OpenSlidesApp.assignments',
    'OpenSlidesApp.core.pdf',
    'OpenSlidesApp.assignments.pdf',
    'OpenSlidesApp.poll.majority'
])

.config([
    'mainMenuProvider',
    'gettext',
    function (mainMenuProvider, gettext) {
        mainMenuProvider.register({
            'ui_sref': 'assignments.assignment.list',
            'img_class': 'pie-chart',
            'title': gettext('Elections'),
            'weight': 400,
            'perm': 'assignments.can_see'
        });
    }
])

.config([
    'SearchProvider',
    'gettext',
    function (SearchProvider, gettext) {
        SearchProvider.register({
            'verboseName': gettext('Elections'),
            'collectionName': 'assignments/assignment',
            'urlDetailState': 'assignments.assignment.detail',
            'weight': 400,
        });
    }
])

.config([
    '$stateProvider',
    'gettext',
    function($stateProvider, gettext) {
        $stateProvider
            .state('assignments', {
                url: '/assignments',
                abstract: true,
                template: "<ui-view/>",
                data: {
                    title: gettext('Elections'),
                    basePerm: 'assignments.can_see',
                },
            })
            .state('assignments.assignment', {
                abstract: true,
                template: "<ui-view/>",
            })
            .state('assignments.assignment.list', {})
            .state('assignments.assignment.detail', {
                controller: 'AssignmentDetailCtrl',
                resolve: {
                    assignmentId: ['$stateParams', function($stateParams) {
                        return $stateParams.id;
                    }],
                }
            })
            // redirects to assignment detail and opens assignment edit form dialog, uses edit url,
            // used by ui-sref links from agenda only
            // (from assignment controller use AssignmentForm factory instead to open dialog in front
            // of current view without redirect)
            .state('assignments.assignment.detail.update', {
                onEnter: ['$stateParams', '$state', 'ngDialog',
                    function($stateParams, $state, ngDialog) {
                        ngDialog.open({
                            template: 'static/templates/assignments/assignment-form.html',
                            controller: 'AssignmentUpdateCtrl',
                            className: 'ngdialog-theme-default wide-form',
                            closeByEscape: false,
                            closeByDocument: false,
                            resolve: {
                                assignmentId: function() {
                                    return $stateParams.id;
                                },
                            },
                            preCloseCallback: function() {
                                $state.go('assignments.assignment.detail', {assignment: $stateParams.id});
                                return true;
                            }
                        });
                    }
                ]
            });
    }
])

// Service for generic assignment form (create and update)
.factory('AssignmentForm', [
    'gettextCatalog',
    'operator',
    'Editor',
    'Mediafile',
    'Tag',
    'Assignment',
    'Agenda',
    'AgendaTree',
    'ShowAsAgendaItemField',
    function (gettextCatalog, operator, Editor, Mediafile, Tag, Assignment, Agenda, AgendaTree, ShowAsAgendaItemField) {
        return {
            // ngDialog for assignment form
            getDialog: function (assignment) {
                return {
                    template: 'static/templates/assignments/assignment-form.html',
                    controller: (assignment) ? 'AssignmentUpdateCtrl' : 'AssignmentCreateCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        assignmentId: function () {return assignment ? assignment.id : void 0;}
                    },
                };
            },
            // angular-formly fields for assignment form
            getFormFields: function (isCreateForm) {
                var images = Mediafile.getAllImages();
                var formFields = [
                {
                    key: 'title',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Title'),
                        required: true
                    }
                },
                {
                    key: 'description',
                    type: 'editor',
                    templateOptions: {
                        label: gettextCatalog.getString('Description')
                    },
                    data: {
                        ckeditorOptions: Editor.getOptions(images)
                    }
                },
                {
                    key: 'open_posts',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Number of persons to be elected'),
                        type: 'number',
                        min: 1,
                        required: true
                    }
                },
                {
                    key: 'poll_description_default',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Default comment on the ballot paper')
                    }
                }];

                // show as agenda item + parent item
                if (isCreateForm) {
                    formFields.push(ShowAsAgendaItemField('assignments.can_manage'));
                    formFields.push({
                        key: 'agenda_parent_id',
                        type: 'select-single',
                        templateOptions: {
                            label: gettextCatalog.getString('Parent item'),
                            options: AgendaTree.getFlatTree(Agenda.getAll()),
                            ngOptions: 'item.id as item.getListViewTitle() for item in to.options | notself : model.agenda_item_id',
                            placeholder: gettextCatalog.getString('Select a parent item ...')
                        },
                        hide: !operator.hasPerms('agenda.can_manage')
                    });
                }
                // more (with tags field)
                if (Tag.getAll().length > 0) {
                    formFields.push(
                        {
                            key: 'more',
                            type: 'checkbox',
                            templateOptions: {
                                label: gettextCatalog.getString('Show extended fields')
                            },
                            hide: !operator.hasPerms('assignments.can_manage')
                        },
                        {
                            template: '<hr class="smallhr">',
                            hideExpression: '!model.more'
                        },
                        {
                            key: 'tags_id',
                            type: 'select-multiple',
                            templateOptions: {
                                label: gettextCatalog.getString('Tags'),
                                options: Tag.getAll(),
                                ngOptions: 'option.id as option.name for option in to.options',
                                placeholder: gettextCatalog.getString('Select or search a tag ...')
                            },
                            hideExpression: '!model.more'
                        }
                    );
                }

                return formFields;
            }
        };
    }
])

// Cache for AssignmentPollDetailCtrl so that users choices are keeped during user actions (e. g. save poll form).
.value('AssignmentPollDetailCtrlCache', {})

// Child controller of AssignmentDetailCtrl for each single poll.
.controller('AssignmentPollDetailCtrl', [
    '$scope',
    'MajorityMethodChoices',
    'Config',
    'AssignmentPollDetailCtrlCache',
    'AssignmentPoll',
    'AssignmentPollDecimalPlaces',
    function ($scope, MajorityMethodChoices, Config, AssignmentPollDetailCtrlCache,
        AssignmentPoll, AssignmentPollDecimalPlaces) {
        // Define choices.
        $scope.methodChoices = MajorityMethodChoices;
        // TODO: Get $scope.baseChoices from config_variables.py without copying them.

        $scope.votesPrecision = AssignmentPollDecimalPlaces.getPlaces($scope.poll);

        // Setup empty cache with default values.
        if (typeof AssignmentPollDetailCtrlCache[$scope.poll.id] === 'undefined') {
            AssignmentPollDetailCtrlCache[$scope.poll.id] = {
                method: $scope.config('assignments_poll_default_majority_method'),
            };
        }

        // Fetch users choices from cache.
        $scope.method = AssignmentPollDetailCtrlCache[$scope.poll.id].method;

        $scope.recalculateMajorities = function (method) {
            $scope.method = method;
            _.forEach($scope.poll.options, function (option) {
                option.majorityReached = option.isReached(method);
            });
        };
        $scope.recalculateMajorities($scope.method);

        $scope.saveDescriptionChange = function (poll) {
            AssignmentPoll.save(poll);
        };

        // Save current values to cache on destroy of this controller.
        $scope.$on('$destroy', function() {
            AssignmentPollDetailCtrlCache[$scope.poll.id] = {
                method: $scope.method,
            };
        });
    }
])

.controller('AssignmentListCtrl', [
    '$scope',
    'ngDialog',
    'AssignmentForm',
    'Assignment',
    'Tag',
    'Agenda',
    'Projector',
    'ProjectionDefault',
    'gettextCatalog',
    'User',
    'osTableFilter',
    'osTableSort',
    'osTablePagination',
    'gettext',
    'AssignmentPhases',
    'AssignmentPdfExport',
    function($scope, ngDialog, AssignmentForm, Assignment, Tag, Agenda, Projector,
        ProjectionDefault, gettextCatalog, User, osTableFilter, osTableSort, osTablePagination,
        gettext, AssignmentPhases, AssignmentPdfExport) {
        $scope.$watch(function () {
            return Assignment.lastModified();
        }, function () {
            $scope.assignments = _.orderBy(Assignment.getAll(), ['title']);
        });
        Tag.bindAll({}, $scope, 'tags');
        $scope.$watch(function () {
            return Projector.lastModified();
        }, function () {
            var projectiondefault = ProjectionDefault.filter({name: 'assignments'})[0];
            if (projectiondefault) {
                $scope.defaultProjectorId = projectiondefault.projector_id;
            }
        });
        $scope.phases = AssignmentPhases;
        $scope.alert = {};

        // Filtering
        $scope.filter = osTableFilter.createInstance('AssignmentTableFilter');

        if (!$scope.filter.existsStorageEntry()) {
            $scope.filter.multiselectFilters = {
                tag: [],
                phase: [],
            };
        }
        $scope.filter.propertyList = ['title', 'description'];
        $scope.filter.propertyFunctionList = [
            function (assignment) {
                return gettextCatalog.getString($scope.phases[assignment.phase].display_name);
            },
        ];
        $scope.filter.propertyDict = {
            'assignment_related_users': function (candidate) {
                return candidate.user.get_short_name();
            },
            'tags': function (tag) {
                return tag.name;
            },
        };
        $scope.getItemId = {
            tag: function (assignment) {return assignment.tags_id;},
            phase: function (assignment) {return assignment.phase;},
        };

        // Sorting
        $scope.sort = osTableSort.createInstance('AssignmentTableSort');
        if (!$scope.sort.column) {
            $scope.sort.column = 'title';
        }
        $scope.sortOptions = [
            {name: 'agenda_item.getItemNumberWithAncestors()',
             display_name: gettext('Item')},
            {name: 'title',
             display_name: gettext('Title')},
            {name: 'phase',
             display_name: gettext('Phase')},
            {name: 'assignment_related_users.length',
             display_name: gettext('Number of candidates')},
        ];
        $scope.hasTag = function (assignment, tag) {
            return _.indexOf(assignment.tags_id, tag.id) > -1;
        };
        $scope.toggleTag = function (assignment, tag) {
            if ($scope.hasTag(assignment, tag)) {
                assignment.tags_id = _.filter(assignment.tags_id, function (tag_id){
                    return tag_id != tag.id;
                });
            } else {
                assignment.tags_id.push(tag.id);
            }
            Assignment.save(assignment);
        };

        // Pagination
        $scope.pagination = osTablePagination.createInstance('AssignmentTablePagination');

        // update phase
        $scope.updatePhase = function (assignment, phase_id) {
            assignment.phase = phase_id;
            Assignment.save(assignment);
        };
        // open new/edit dialog
        $scope.openDialog = function (assignment) {
            ngDialog.open(AssignmentForm.getDialog(assignment));
        };
        // *** select mode functions ***
        $scope.isSelectMode = false;
        // check all checkboxes
        $scope.checkAll = function () {
            $scope.selectedAll = !$scope.selectedAll;
            angular.forEach($scope.assignments, function (assignment) {
                assignment.selected = $scope.selectedAll;
            });
        };
        // uncheck all checkboxes if isSelectMode is closed
        $scope.uncheckAll = function () {
            if (!$scope.isSelectMode) {
                $scope.selectedAll = false;
                angular.forEach($scope.assignments, function (assignment) {
                    assignment.selected = false;
                });
            }
        };
        // delete all selected assignments
        $scope.deleteMultiple = function () {
            angular.forEach($scope.assignments, function (assignment) {
                if (assignment.selected)
                    Assignment.destroy(assignment.id);
            });
            $scope.isSelectMode = false;
            $scope.uncheckAll();
        };
        // delete single assignment
        $scope.delete = function (assignment) {
            Assignment.destroy(assignment.id);
        };
        // create the PDF List
        $scope.pdfExport = function () {
            AssignmentPdfExport.export($scope.assignmentsFiltered);
        };
    }
])

.controller('AssignmentDetailCtrl', [
    '$scope',
    '$http',
    '$filter',
    '$timeout',
    'filterFilter',
    'gettext',
    'ngDialog',
    'AssignmentForm',
    'operator',
    'Assignment',
    'User',
    'assignmentId',
    'Projector',
    'ProjectionDefault',
    'gettextCatalog',
    'AssignmentPhases',
    'AssignmentPdfExport',
    'WebpageTitle',
    'ErrorMessage',
    function($scope, $http, $filter, $timeout, filterFilter, gettext, ngDialog, AssignmentForm, operator,
        Assignment, User, assignmentId, Projector, ProjectionDefault, gettextCatalog, AssignmentPhases,
        AssignmentPdfExport, WebpageTitle, ErrorMessage) {
        User.bindAll({}, $scope, 'users');
        var assignment = Assignment.get(assignmentId);
        Assignment.loadRelations(assignment, 'agenda_item');
        // This flag is for setting 'activeTab' to recently added (last) ballot tab.
        // Set this flag, if ballots are added/removed. When the next autoupdate comes
        // in, the tabset will be updated.
        var updateBallotTabsFlag = true;
        $scope.$watch(function () {
            return Projector.lastModified();
        }, function () {
            var projectiondefault = ProjectionDefault.filter({name: 'assignments'})[0];
            if (projectiondefault) {
                $scope.defaultProjectorId = projectiondefault.projector_id;
            }
        });
        $scope.$watch(function () {
            return Assignment.lastModified(assignmentId);
        }, function () {
            // setup sorting of candidates
            $scope.relatedUsersSorted = $filter('orderBy')(assignment.assignment_related_users, 'weight');
            $scope.assignment = Assignment.get(assignment.id);
            if (updateBallotTabsFlag) {
                $scope.activeTab = $scope.assignment.polls.length - 1;
                updateBallotTabsFlag = false;
            }
            WebpageTitle.updateTitle(gettextCatalog.getString('Election') + ' ' + $scope.assignment.title);
        });
        $scope.candidateSelectBox = {};
        $scope.phases = AssignmentPhases;
        $scope.alert = {};

        // open edit dialog
        $scope.openDialog = function () {
            ngDialog.open(AssignmentForm.getDialog($scope.assignment));
        };
        // add (nominate) candidate
        $scope.addCandidate = function (userId) {
            $http.post('/rest/assignments/assignment/' + assignmentId + '/candidature_other/', {'user': userId})
                .then(function (success){
                    $scope.alert.show = false;
                    $scope.candidateSelectBox = {};
                }, function (error){
                    $scope.alert = ErrorMessage.forAlert(error);
                    $scope.candidateSelectBox = {};
                });
        };
        // remove candidate
        $scope.removeCandidate = function (userId) {
            $http.delete('/rest/assignments/assignment/' + assignmentId + '/candidature_other/',
                    {headers: {'Content-Type': 'application/json'},
                     data: JSON.stringify({user: userId})})
                .then(function (success) {},
                    function (error) {
                        $scope.alert = ErrorMessage.forAlert(error);
                    }
                );
        };
        // add me (nominate self as candidate)
        $scope.addMe = function () {
            $http.post('/rest/assignments/assignment/' + assignmentId + '/candidature_self/', {}).then(
                function (success) {
                    $scope.alert.show = false;
                }, function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
        // remove me (withdraw own candidature)
        $scope.removeMe = function () {
            $http.delete('/rest/assignments/assignment/' + assignmentId + '/candidature_self/').then(
                function (success) {
                    $scope.alert.show = false;
                }, function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
        // check if current user is already a candidate (elected==false)
        $scope.isCandidate = function () {
            var check = $scope.assignment.assignment_related_users.map(function(candidate) {
                if (!candidate.elected) {
                    return candidate.user_id;
                }
            }).indexOf(operator.user.id);
            if (check > -1) {
                return true;
            } else {
                return false;
            }
        };
        // Sort all candidates
        $scope.treeOptions = {
            dropped: function () {
                var sortedCandidates = [];
                _.forEach($scope.relatedUsersSorted, function (user) {
                    sortedCandidates.push(user.id);
                });
                $http.post('/rest/assignments/assignment/' + assignmentId + '/sort_related_users/',
                    {related_users: sortedCandidates}
                );
            }
        };
        // update phase
        $scope.updatePhase = function (phase_id) {
            $scope.assignment.phase = phase_id;
            Assignment.save($scope.assignment);
        };
        // create new ballot
        $scope.createBallot = function () {
            $http.post('/rest/assignments/assignment/' + assignmentId + '/create_poll/').then(
                function (success) {
                    $scope.alert.show = false;
                    if (assignment.phase === 0) {
                        $scope.updatePhase(1);
                    }
                    updateBallotTabsFlag = true;
                }, function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
        // delete ballot
        $scope.deleteBallot = function (poll) {
            poll.DSDestroy().then(
                function (success) {
                    $scope.activeTab = $scope.activeTab - 1;
                    updateBallotTabsFlag = true;
                }
            );
        };
        // edit poll dialog
        $scope.editPollDialog = function (poll, ballot) {
            ngDialog.open({
                template: 'static/templates/assignments/assignmentpoll-form.html',
                controller: 'AssignmentPollUpdateCtrl',
                className: 'ngdialog-theme-default',
                closeByEscape: false,
                closeByDocument: false,
                resolve: {
                    assignmentpollId: function () {return poll.id;},
                    ballot: function () {return ballot;},
                }
            });
        };
        // publish ballot
        $scope.togglePublishBallot = function (poll) {
            poll.DSUpdate({
                    assignment_id: assignmentId,
                    published: !poll.published,
            })
            .then(function (success) {
                $scope.alert.show = false;
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };

        // mark candidate as (not) elected
        $scope.markElected = function (user, reverse) {
            if (reverse) {
                $http.delete(
                    '/rest/assignments/assignment/' + assignmentId + '/mark_elected/', {
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        data: JSON.stringify({user: user})
                });
            } else {
                $http.post('/rest/assignments/assignment/' + assignmentId + '/mark_elected/', {'user': user});
            }

        };

        // Creates the document as pdf
        $scope.pdfExport = function() {
            AssignmentPdfExport.export($scope.assignment, true);
        };
        // Creates the ballotpaper as pdf
        $scope.ballotpaperExport = function(pollId) {
            AssignmentPdfExport.createBallotPdf($scope.assignment, pollId);
        };

        // Just mark some vote value strings for translation.
        gettext('Yes');
        gettext('No');
        gettext('Abstain');
    }
])

.controller('AssignmentCreateCtrl', [
    '$scope',
    '$state',
    'Assignment',
    'AssignmentForm',
    'Agenda',
    'Config',
    'ErrorMessage',
    function($scope, $state, Assignment, AssignmentForm, Agenda, Config, ErrorMessage) {
        $scope.model = {
            agenda_type: parseInt(Config.get('agenda_new_items_default_visibility').value),
        };
        // set default value for open posts form field
        $scope.model.open_posts = 1;
        // get all form fields
        $scope.formFields = AssignmentForm.getFormFields(true);
        // save assignment
        $scope.save = function(assignment, gotoDetailView) {
            Assignment.create(assignment).then(
                function (success) {
                    if (gotoDetailView) {
                        $state.go('assignments.assignment.detail', {id: success.id});
                    }
                    $scope.closeThisDialog();
                },
                function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('AssignmentUpdateCtrl', [
    '$scope',
    '$state',
    'Assignment',
    'AssignmentForm',
    'Agenda',
    'assignmentId',
    'ErrorMessage',
    function($scope, $state, Assignment, AssignmentForm, Agenda, assignmentId, ErrorMessage) {
        var assignment = Assignment.get(assignmentId);
        $scope.alert = {};
        // set initial values for form model by create deep copy of assignment object
        // so list/detail view is not updated while editing
        $scope.model = angular.copy(assignment);
        // get all form fields
        $scope.formFields = AssignmentForm.getFormFields();

        // save assignment
        $scope.save = function (assignment, gotoDetailView) {
            // inject the changed assignment (copy) object back into DS store
            Assignment.inject(assignment);
            // save changed assignment object on server
            Assignment.save(assignment).then(
                function(success) {
                    if (gotoDetailView) {
                        $state.go('assignments.assignment.detail', {id: success.id});
                    }
                    $scope.closeThisDialog();
                },
                function (error) {
                    // save error: revert all changes by restore
                    // (refresh) original assignment object from server
                    Assignment.refresh(assignment);
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('AssignmentPollUpdateCtrl', [
    '$scope',
    '$filter',
    'gettextCatalog',
    'AssignmentPoll',
    'assignmentpollId',
    'AssignmentPollDecimalPlaces',
    'ballot',
    'ErrorMessage',
    function($scope, $filter, gettextCatalog, AssignmentPoll, assignmentpollId,
        AssignmentPollDecimalPlaces, ballot, ErrorMessage) {
        // set initial values for form model by create deep copy of assignmentpoll object
        // so detail view is not updated while editing poll
        var assignmentpoll = angular.copy(AssignmentPoll.get(assignmentpollId));
        $scope.model = assignmentpoll;
        $scope.ballot = ballot;
        $scope.formFields = [];
        $scope.alert = {};

        // For number inputs
        var step = Math.pow(10, -AssignmentPollDecimalPlaces.getPlaces(assignmentpoll));

        // add dynamic form fields
        var options = $filter('orderBy')(assignmentpoll.options, 'weight');
        _.forEach(options, function(option) {
            var defaultValue;
            if (assignmentpoll.pollmethod == 'yna' || assignmentpoll.pollmethod == 'yn') {
                defaultValue = {};
                _.forEach(option.votes, function (vote) {
                    defaultValue[vote.value.toLowerCase()] = vote.weight;
                });

                var columnClass = (assignmentpoll.pollmethod === 'yna') ? 'col-xs-4' : 'col-xs-6';
                var columns = [
                    {
                        key: 'yes_' + option.candidate_id,
                        type: 'input',
                        className: columnClass + ' no-padding-left',
                        templateOptions: {
                            label: gettextCatalog.getString('Yes'),
                            type: 'number',
                            min: -2,
                            step: step,
                            required: true
                        },
                        defaultValue: defaultValue.yes
                    },
                    {
                        key: 'no_' + option.candidate_id,
                        type: 'input',
                        className: columnClass + ' no-padding-left' +
                            (assignmentpoll.pollmethod === 'yn' ? ' no-padding-right' : ''),
                        templateOptions: {
                            label: gettextCatalog.getString('No'),
                            type: 'number',
                            min: -2,
                            step: step,
                            required: true
                        },
                        defaultValue: defaultValue.no
                    }
                ];
                if (assignmentpoll.pollmethod == 'yna'){
                    columns.push({
                        key:'abstain_' + option.candidate_id,
                        type: 'input',
                        className: columnClass + ' no-padding-left no-padding-right',
                        templateOptions: {
                            label: gettextCatalog.getString('Abstain'),
                            type: 'number',
                            min: -2,
                            step: step,
                            required: true
                        },
                        defaultValue: defaultValue.abstain
                    });
                }
                $scope.formFields.push({
                    noFormControl: true,
                    template: '<strong>' + option.candidate.get_full_name() + '</strong>'
                },
                {
                    className: 'row',
                    fieldGroup: columns,
                });
            } else { // votes method
                if (option.votes.length) {
                    defaultValue = option.votes[0].weight;
                }
                $scope.formFields.push({
                    key: 'vote_' + option.candidate_id,
                    type: 'input',
                    templateOptions: {
                        label: option.candidate.get_full_name(),
                        type: 'number',
                        min: -2,
                        step: step,
                        required: true,
                    },
                    defaultValue: defaultValue
                });
            }
        });
        if (assignmentpoll.pollmethod == 'votes'){
            $scope.formFields.push(
                {
                    key: 'votesabstain',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Abstain'),
                        type: 'number',
                        step: step,
                        min: -2,
                    }
                },
                {
                    key: 'votesno',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('No'),
                        type: 'number',
                        step: step,
                        min: -2,
                    }
                }
            );
        }
        // add general form fields
        $scope.formFields.push(
            {
                template: '<hr class="smallhr">',
            },
            {
                key: 'votesvalid',
                type: 'input',
                templateOptions: {
                    label: gettextCatalog.getString('Valid ballots'),
                    type: 'number',
                    step: step,
                    min: -2,
                }
            },
            {
                key: 'votesinvalid',
                type: 'input',
                templateOptions: {
                    label: gettextCatalog.getString('Invalid ballots'),
                    type: 'number',
                    step: step,
                    min: -2,
                }
            },
            {
                key: 'votescast',
                type: 'input',
                templateOptions: {
                    label: gettextCatalog.getString('Casted ballots'),
                    type: 'number',
                    step: step,
                    min: -2,
                }
            }
        );

        // save assignmentpoll
        $scope.save = function (poll) {
            var votes = [];
            if (assignmentpoll.pollmethod == 'yna') {
                assignmentpoll.options.forEach(function(option) {
                    votes.push({
                        'Yes': poll['yes_' + option.candidate_id],
                        'No': poll['no_' + option.candidate_id],
                        'Abstain': poll['abstain_' + option.candidate_id]
                    });
                });
            } else if (assignmentpoll.pollmethod == 'yn') {
                    assignmentpoll.options.forEach(function(option) {
                        votes.push({
                            'Yes': poll['yes_' + option.candidate_id],
                            'No': poll['no_' + option.candidate_id]
                            });
                        });
            } else {
                assignmentpoll.options.forEach(function(option) {
                    votes.push({
                        'Votes': poll['vote_' + option.candidate_id],
                    });
                });
            }
            // save change poll object on server
            poll.DSUpdate({
                assignment_id: poll.assignment_id,
                votes: votes,
                votesabstain: poll.votesabstain,
                votesno: poll.votesno,
                votesvalid: poll.votesvalid,
                votesinvalid: poll.votesinvalid,
                votescast: poll.votescast,
            })
            .then(function(success) {
                $scope.alert.show = false;
                $scope.closeThisDialog();
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };
    }
])

//mark all assignment config strings for translation with Javascript
.config([
    'gettext',
    function (gettext) {
        gettext('Election method');
        gettext('Automatic assign of method');
        gettext('Always one option per candidate');
        gettext('Always Yes-No-Abstain per candidate');
        gettext('Always Yes/No per candidate');
        gettext('Elections');
        gettext('Ballot and ballot papers');
        gettext('The 100-%-base of an election result consists of');
        gettext('For Yes/No/Abstain per candidate and Yes/No per candidate the 100-%-base ' +
                'depends on the election method: If there is only one option per candidate, ' +
                'the sum of all votes of all candidates is 100 %. Otherwise for each ' +
                'candidate the sum of all votes is 100 %.');
        gettext('Yes/No/Abstain per candidate');
        gettext('Yes/No per candidate');
        gettext('All valid ballots');
        gettext('All casted ballots');
        gettext('Disabled (no percents)');
        gettext('Number of ballot papers (selection)');
        gettext('Number of all delegates');
        gettext('Number of all participants');
        gettext('Use the following custom number');
        gettext('Custom number of ballot papers');
        gettext('Required majority');
        gettext('Default method to check whether a candidate has reached the required majority.');
        gettext('Simple majority');
        gettext('Two-thirds majority');
        gettext('Three-quarters majority');
        gettext('Disabled');
        gettext('Put all candidates on the list of speakers');
        gettext('Title for PDF document (all elections)');
        gettext('Preamble text for PDF document (all elections)');
        //other translations
        gettext('Searching for candidates');
        gettext('Voting');
        gettext('Finished');
    }
]);

}());

(function () {

'use strict';

// The core module used for the OpenSlides site and the projector
angular.module('OpenSlidesApp.core', [
    'js-data',
    'gettext',
    'ngAnimate',
    'ngBootbox',
    'ngSanitize',  // TODO: only use this in functions that need it.
    'ngStorage',
    'ui.bootstrap',
    'ui.bootstrap.datetimepicker',
    'ui.tree',
    'pdf',
    'OpenSlidesApp-templates',
])

.config([
    'DSProvider',
    'DSHttpAdapterProvider',
    function(DSProvider, DSHttpAdapterProvider) {
        DSProvider.defaults.reapAction = 'none';
        DSProvider.defaults.basePath = '/rest';
        DSProvider.defaults.afterReap = function(model, items) {
            if (items.length > 5) {
                model.findAll({}, {bypassCache: true});
            } else {
                _.forEach(items, function (item) {
                    model.refresh(item[model.idAttribute]);
                });
            }
        };
        DSHttpAdapterProvider.defaults.forceTrailingSlash = true;
    }
])

.factory('ProjectorID', [
    function () {
        return function () {
            return /projector\/(\d+)\//.exec(location.pathname)[1];
        };
    }
])

.config([
    '$sessionStorageProvider',
    function ($sessionStorageProvider) {
        $sessionStorageProvider.setKeyPrefix('OpenSlides');
    }
])

.factory('autoupdate', [
    'DS',
    'REALM',
    'ProjectorID',
    '$q',
    '$timeout',
    'ErrorMessage',
    function (DS, REALM, ProjectorID, $q, $timeout, ErrorMessage) {
        var socket = null;
        var retryConnectCallbacks = [];

        var websocketProtocol;
        if (location.protocol == 'https:') {
            websocketProtocol = 'wss:';
        } else {
            websocketProtocol = 'ws:';
        }

        var websocketPath;
        if (REALM === 'site') {
          websocketPath = '/ws/site/';
        } else if (REALM === 'projector') {
          websocketPath = '/ws/projector/' + ProjectorID() + '/';
        } else {
          console.error('The constant REALM is not set properly.');
        }

        // Get a random retry timeout between 2000 and 5000 ms.
        var getTimeoutTime = function () {
            return Math.floor(Math.random() * 3000 + 2000);
        };

        /* The callbacks are invoked if the ws connection closed and this factory tries to
         * reconnect after 1 second. The callbacks should return a promise. If the promise
         * resolves, the retry-process is stopped, so the callback can indicate whether it
         * has managed the reconnecting different.*/
        var runRetryConnectCallbacks = function () {
            var callbackPromises = _.map(retryConnectCallbacks, function (callback) {
                return callback();
            });
            $q.all(callbackPromises).then(function (success) {
                ErrorMessage.clearConnectionError();
            }, function (error) {
                $timeout(runRetryConnectCallbacks, getTimeoutTime());
            });
        };

        var Autoupdate = {};
        Autoupdate.messageReceivers = [];
        // We use later a promise to defer the first message of the established ws connection.
        Autoupdate.firstMessageDeferred = $q.defer();
        Autoupdate.onMessage = function (receiver) {
            Autoupdate.messageReceivers.push(receiver);
        };
        Autoupdate.newConnect = function () {
            socket = new WebSocket(websocketProtocol + '//' + location.host + websocketPath);
            // Make shure the servers state hasn't changed: Send a whoami request. If no users is logged and
            // anonymous are deactivated, reboot the client in fact that the server has lost all login information.
            socket.onclose = function (event) {
                socket = null;
                if (event.code !== 1000) { // 1000 is a normal close, like the close on logout
                    ErrorMessage.setConnectionError();
                }
                $timeout(runRetryConnectCallbacks, getTimeoutTime());
            };
            socket.onmessage = function (event) {
                var dataList = [];
                try {
                    dataList = JSON.parse(event.data);
                    _.forEach(Autoupdate.messageReceivers, function (receiver) {
                        receiver(dataList);
                    });
                } catch(err) {
                    console.error(err);
                }
                // Check if the promise is not resolved yet.
                if (Autoupdate.firstMessageDeferred.promise.$$state.status === 0) {
                    Autoupdate.firstMessageDeferred.resolve();
                }
                ErrorMessage.clearConnectionError();
            };
        };
        Autoupdate.send = function (message) {
            if (socket) {
                socket.send(JSON.stringify(message));
            }
        };
        Autoupdate.closeConnection = function () {
            if (socket) {
                socket.close();
            }
            Autoupdate.firstMessageDeferred = $q.defer();
        };
        Autoupdate.registerRetryConnectCallback = function (callback) {
            retryConnectCallbacks.push(callback);
        };
        return Autoupdate;
    }
])

.factory('operator', [
    'User',
    'Group',
    function (User, Group) {
        var setUserCallbacks = [];
        var operator = {
            user: null,
            perms: [],
            isAuthenticated: function () {
                return !!this.user;
            },
            setUser: function(user_id, user_data) {
                if (user_id && user_data) {
                    operator.user = User.inject(user_data);
                } else {
                    operator.user = null;
                }
                operator.reloadPerms();
                _.forEach(setUserCallbacks, function (cb) {
                    cb(operator.user);
                });
            },
            // Returns true if the operator has at least one perm of the perms-list.
            hasPerms: function(perms) {
                if (typeof perms === 'string') {
                    perms = perms.split(' ');
                }
                return _.intersection(perms, operator.perms).length > 0;
            },
            reloadPerms: function () {
                if (operator.user) {
                    operator.perms = operator.user.getPerms();
                } else {
                    var defaultGroup = Group.get(1);
                    operator.perms = defaultGroup ? defaultGroup.permissions : [];
                }
            },
            // Returns true if the operator is a member of group.
            isInGroup: function(group) {
                var groups = operator.user.groups_id;
                if (groups.length === 0) {
                    groups = [1]; // Set the default group, if no other groups are set.
                }
                return _.indexOf(groups, group.id) > -1;
            },
            registerSetUserCallback: function (cb) {
                setUserCallbacks.push(cb);
            },
        };
        return operator;
    }
])

// gets all in OpenSlides available languages
.factory('Languages', [
    '$sessionStorage',
    '$ngBootbox',
    'gettext',
    'gettextCatalog',
    'OpenSlidesPlugins',
    function ($sessionStorage, $ngBootbox, gettext, gettextCatalog, OpenSlidesPlugins) {
        return {
            // get all available languages
            getLanguages: function () {
                var current = $sessionStorage.language;
                // Define here new languages...
                var languages = [
                    { code: 'en', name: 'English' },
                    { code: 'de', name: 'Deutsch' },
                    { code: 'fr', name: 'Français' },
                    { code: 'es', name: 'Español' },
                    { code: 'pt', name: 'Português' },
                    { code: 'cs', name: 'Čeština'},
                    { code: 'ru', name: 'русский'},
                ];
                angular.forEach(languages, function (language) {
                    if (language.code == current)
                        language.selected = true;
                });
                return languages;
            },
            // get detected browser language code
            getBrowserLanguage: function () {
                var lang = navigator.language || navigator.userLanguage;
                if (!navigator.language && !navigator.userLanguage) {
                    lang = 'en';
                } else {
                    if (lang.indexOf('-') !== -1)
                        lang = lang.split('-')[0];
                    if (lang.indexOf('_') !== -1)
                        lang = lang.split('_')[0];
                }
                return lang;
            },
            // set current language and return updated languages object array
            setCurrentLanguage: function (lang) {
                var languages = this.getLanguages();
                var plugins = OpenSlidesPlugins.getAll();
                angular.forEach(languages, function (language) {
                    language.selected = false;
                    if (language.code == lang) {
                        language.selected = true;
                        $sessionStorage.language = lang;
                        gettextCatalog.setCurrentLanguage(lang);
                        // Plugins
                        if (lang != 'en') {
                            gettextCatalog.loadRemote("static/i18n/" + lang + ".json").then(function (success) {
                                // translate ng-bootbox directives when the translations are available.
                                $ngBootbox.addLocale(lang, {
                                    OK: gettextCatalog.getString('OK'),
                                    CANCEL: gettextCatalog.getString('Cancel'),
                                    CONFIRM: gettextCatalog.getString('OK'), // Yes, 'OK' is the original string.
                                });
                                $ngBootbox.setLocale(lang);
                            });
                            // load language files from plugins
                            angular.forEach(plugins, function (plugin) {
                                if (plugin.languages.indexOf(lang) != -1) {
                                    gettextCatalog.loadRemote("static/i18n/" + plugin.name + '/' + lang + ".json");
                                }
                            });
                        }
                    }
                });
                return languages;
            }
        };
    }
])

// Hook into gettextCatalog to include custom translations by wrapping
// the getString method. The translations are stored in the config.
.decorator('gettextCatalog', [
    '$delegate',
    '$rootScope',
    function ($delegate, $rootScope) {
        var oldGetString = $delegate.getString;
        var customTranslations = {};

        $delegate.getString = function () {
            var translated = oldGetString.apply($delegate, arguments);
            if (customTranslations[translated]) {
                translated = customTranslations[translated];
            }
            return translated;
        };
        $delegate.setCustomTranslations = function (translations) {
            customTranslations = translations;
            $rootScope.$broadcast('gettextLanguageChanged');
        };

        return $delegate;
    }
])

.run([
    '$rootScope',
    'Config',
    'gettextCatalog',
    function ($rootScope, Config, gettextCatalog) {
        $rootScope.$watch(function () {
            return Config.lastModified('translations');
        }, function () {
            var translations = Config.get('translations');
            if (translations) {
                var customTranslations = {};
                _.forEach(translations.value, function (entry) {
                    customTranslations[entry.original] = entry.translation;
                });
                // Update all translate directives
                gettextCatalog.setCustomTranslations(customTranslations);
            }
        });
    }
])

// set browser language as default language for OpenSlides
.run([
    '$sessionStorage',
    'gettextCatalog',
    'Languages',
    function($sessionStorage, gettextCatalog, Languages) {
        // set detected browser language as default language (fallback: 'en')
        if ($sessionStorage.language) {
            Languages.setCurrentLanguage($sessionStorage.language);
        } else {
            Languages.setCurrentLanguage(Languages.getBrowserLanguage());
        }   
        // Set this to true for debug. Helps to find untranslated strings by
        // adding "[MISSING]:".
        gettextCatalog.debug = false;
    }
])

.factory('dsEject', [
    'DS',
    function (DS) {
        return function (collection, instance) {
            var Resource = DS.definitions[collection];
            if (Resource.relationList) {
                Resource.relationList.forEach(function (relationDef) {
                    if (relationDef.foreignKey && !relationDef.osProtectedRelation) {
                        var query = {};
                        query[relationDef.foreignKey] = instance[Resource.idAttribute];
                        Resource.getResource(relationDef.relation).ejectAll(query);
                    }
                });
            }
        };
    }
])

.run([
    'DS',
    'autoupdate',
    'dsEject',
    function (DS, autoupdate, dsEject) {
        // Handler for normal autoupdate messages.
        autoupdate.onMessage(function(dataList) {
            var dataListByCollection = _.groupBy(dataList, 'collection');
            _.forEach(dataListByCollection, function (list, key) {
                var changedElements = [];
                var deletedElements = [];
                var collectionString = key;
                _.forEach(list, function (data) {
                    // Uncomment this line for debugging to log all autoupdates:
                    // console.log("Received object: " + data.collection + ", " + data.id);

                    // Now handle autoupdate message but do not handle notify messages.
                    if (data.collection !== 'notify') {
                        // remove (=eject) object from local DS store
                        var instance = DS.get(data.collection, data.id);
                        if (instance) {
                            dsEject(data.collection, instance);
                        }
                        // check if object changed or deleted
                        if (data.action === 'changed') {
                            changedElements.push(data.data);
                        } else if (data.action === 'deleted') {
                            deletedElements.push(data.id);
                        } else {
                            console.error('Error: Undefined action for received object' +
                                '(' + data.collection + ', ' + data.id + ')');
                        }
                    }
                });
                // add (=inject) all given objects into local DS store
                if (changedElements.length > 0) {
                    DS.inject(collectionString, changedElements);
                }
                // delete (=eject) all given objects from local DS store
                // (note: js-data does not provide 'bulk eject' as for DS.inject)
                _.forEach(deletedElements, function(id) {
                    DS.eject(collectionString, id);
                });
            });
        });
    }
])

.factory('Notify', [
    'autoupdate',
    'operator',
    function (autoupdate, operator) {
        var anonymousTrackId;

        // Handler for notify messages.
        autoupdate.onMessage(function(dataList) {
            var dataListByCollection = _.groupBy(dataList, 'collection');
            _.forEach(dataListByCollection.notify, function (notifyItem) {
                // Check, if this current user (or anonymous instance) has send this notify.
                if (notifyItem.senderUserId) {
                    if (operator.user) { // User send to user
                        notifyItem.sendBySelf = (notifyItem.senderUserId === operator.user.id);
                    } else { // User send to anonymous
                        notifyItem.sendBySelf = false;
                    }
                } else {
                    if (operator.user) { // Anonymous send to user
                        notifyItem.sendBySelf = false;
                    } else { // Anonymous send to anonymous
                        notifyItem.sendBySelf = (notifyItem.anonymousTrackId === anonymousTrackId);
                    }
                }
                // notify registered receivers.
                _.forEach(callbackReceivers[notifyItem.name], function (item) {
                    item.fn(notifyItem);
                });
            });
        });

        var callbackReceivers = {};
        /* Structure of callbackReceivers:
         * event_name_one: [ {id:0, fn:fn}, {id:3, fn:fn} ],
         * event_name_two: [ {id:2, fn:fn} ],
         * */
        var idCounter = 0;
        var eventNameRegex = new RegExp('^[a-zA-Z0-9_-]+$');
        var externIdRegex = new RegExp('^[a-zA-Z0-9_-]+\/[0-9]+$');
        return {
            registerCallback: function (eventName, fn) {
                if (!eventNameRegex.test(eventName)) {
                    throw 'eventName should only consist of [a-zA-Z0-9_-]';
                } else if (typeof fn === 'function') {
                    var id = idCounter++;

                    if (!callbackReceivers[eventName]) {
                        callbackReceivers[eventName] = [];
                    }
                    callbackReceivers[eventName].push({
                        id: id,
                        fn: fn,
                    });
                    return eventName + '/' + id;
                } else {
                    throw 'fn should be a function.';
                }
            },
            deregisterCallback: function (externId) {
                if (externIdRegex.test(externId)){
                    var split = externId.split('/');
                    var eventName = split[0];
                    var id = parseInt(split[1]);
                    callbackReceivers[eventName] = _.filter(callbackReceivers[eventName], function (item) {
                        return item.id !== id;
                    });
                } else {
                    throw externId + ' is not a valid id';
                }
            },
            // variable length of parameters, just pass ids.
            deregisterCallbacks: function () {
                _.forEach(arguments, this.deregisterCallback);
            },
            notify: function(eventName, params, users, channels, projectors) {
                if (eventNameRegex.test(eventName)) {
                    if (!params || typeof params !== 'object') {
                        params = {};
                    }

                    var notifyItem = {
                        collection: 'notify',
                        name: eventName,
                        params: params,
                        users: users,
                        replyChannels: channels,
                        projectors: projectors,
                    };
                    if (!operator.user) {
                        if (!anonymousTrackId) {
                            anonymousTrackId = Math.floor(Math.random()*1000000);
                        }
                        notifyItem.anonymousTrackId = anonymousTrackId;
                    }
                    autoupdate.send([notifyItem]);
                } else {
                    throw 'eventName should only consist of [a-zA-Z0-9_-]';
                }
            },
        };
    }
])

// Save the server time to the rootscope.
.run([
    '$http',
    '$rootScope',
    function ($http, $rootScope) {
        // Loads server time and calculates server offset
        $rootScope.serverOffset = 0;
        $http.get('/core/servertime/')
        .then(function(data) {
            $rootScope.serverOffset = Math.floor(Date.now() / 1000 - data.data);
        });
    }
])

.run([
    'Config',
    '$rootScope',
    function (Config, $rootScope) {
        $rootScope.config = function (key) {
            try {
                return Config.get(key).value;
            }
            catch(err) {
                return '';
            }
        };
    }
])

// Make the indexOf available in every scope; needed for the projectorbuttons
.run([
    '$rootScope',
    function ($rootScope) {
        $rootScope.inArray = function (array, value) {
            return _.indexOf(array, value) > -1;
        };
    }
])

// Put the Math object into every scope.
.run([
    '$rootScope',
    function ($rootScope) {
        $rootScope.Math = window.Math;
    }
])

// Template hooks
// Possible uses:
// 1. { id: 'myHookId', template: '<button>click me</button>' }
// 2. { id: 'myHookId', templateUrl: '/static/templates/plugin_name/my-hook.html' }
// 3. { id: 'myHookId' }
//
// Deprecated: Give the id with 'Id'. Please use 'id'.
//
// Option 3 is for just changing the scope (see below), but not the original content. This
// is usefull to alter a JS behavior, e.g. on a ng-click. In this case, override is false
// for this template hook.
//
// It is possible to provide a scope, that is merged into the surrounding scope.
// You can override functions or values of the surrounding scope by providing them:
// { id: 'hookId', template: '<button ng-click="customOrOverwritten()">click me</button>',
//   scope: {
//     customOrOverwritten: function () { /*Do something */ },
//   },
// }
// Or you provide a function that returns an object of functions/values to overwrite to
// get access to the scope merged in:
// { id: 'hookId', template: '<button ng-click="customFn()">click me</button>',
//   scope: function (scope) {
//     return {
//       customOrOverwritten: function () {
//         scope.value = /* change it */;
//       },
//     };
//   },
// }
//
// As a default, template hooks in flavour of option 1 and 2 override the content that was
// originally there. Provide 'override: false', to prevent overriding the original content.
.factory('templateHooks', [
    function () {
        var hooks = {};
        return {
            hooks: hooks,
            registerHook: function (hook) {
                // Deprecated: Set the new style 'id', if 'Id' is given.
                if (hook.id === void 0) {
                    hook.id = hook.Id;
                }

                if (hooks[hook.id] === void 0) {
                    hooks[hook.id] = [];
                }
                // set override default
                if (hook.override === void 0) {
                    hook.override = !!(hook.template || hook.templateUrl);
                }
                hooks[hook.id].push(hook);
            }
        };
    }
])

.directive('templateHook', [
    '$compile',
    '$http',
    '$q',
    '$templateCache',
    '$timeout',
    'templateHooks',
    function ($compile, $http, $q, $templateCache, $timeout, templateHooks) {
        return {
            restrict: 'E',
            template: '',
            link: function (scope, iElement, iAttr) {
                var hooks = templateHooks.hooks[iAttr.hookName];
                if (hooks) {
                    // Populate scopes
                    _.forEach(hooks, function (hook) {
                        var _scope = hook.scope;
                        // If it is a function, get the scope from the function and provide
                        // the original scope.
                        if (typeof hook.scope === 'function') {
                            _scope = hook.scope(scope);
                        }

                        _.forEach(_scope, function (value, key) {
                            scope[key] = value;
                        });
                    });

                    // Check, if at least one hook overrides the original content.
                    var override = _.some(hooks, function (hook) {
                        return hook.override;
                    });

                    // filter hooks, that does actually have a template
                    hooks = _.filter(hooks, function (hook) {
                        return hook.template || hook.templateUrl;
                    });

                    // Get all templates
                    var templates = _.map(hooks, function (hook) {
                        // Either a template (html given as string) or a templateUrl has
                        // to be given. If a scope is provided, the schope of this templateHook
                        // is populated with the given functions/values.
                        if (hook.template) {
                            return hook.template;
                        } else {
                            return $templateCache.get(hook.templateUrl);
                        }
                    });

                    // Wait for the dom to build up, so we can retrieve the inner html of iElement.
                    $timeout(function () {
                        var html = override ? '' : iElement.html();
                        if (templates.length) {
                            html += templates.join('');
                        }

                        iElement.empty();
                        iElement.append($compile(html)(scope));
                    });
                }
            }
        };
    }
])

/*
 * This places a projector button in the document.
 *
 * Example: <projector-button model="motion" default-projector.id="defPrId"
 *           arg="2" content="{{ 'project' | translate }}"></projector-button>
 * This button references to model (in this example 'motion'). Also a defaultProjectionId
 * has to be given. In the example it's a scope variable. The next two parameters are additional:
 *   - arg: Then the model.project and model.isProjected will be called with
 *          this argument (e. g.: model.project(2))
 *   - content: A text placed behind the projector symbol.
 */
.directive('projectorButton', [
    'Projector',
    function (Projector) {
        return {
            restrict: 'E',
            templateUrl: 'static/templates/projector-button.html',
            link: function (scope, element, attributes) {
                if (!attributes.model) {
                    throw 'A model has to be given!';
                } else if (!attributes.defaultProjectorId) {
                    throw 'A default-projector-id has to be given!';
                }

                Projector.bindAll({}, scope, 'projectors');

                scope.$watch(attributes.model, function (model) {
                    scope.model = model;
                });

                scope.$watch(attributes.defaultProjectorId, function (defaultProjectorId) {
                    scope.defaultProjectorId = defaultProjectorId;
                });

                if (attributes.arg) {
                    scope.$watch(attributes.arg, function (arg) {
                        scope.arg = arg;
                    });
                }

                scope.content = '';
                if (attributes.content) {
                    attributes.$observe('content', function (content) {
                        scope.content = content;
                    });
                }
            }
        };
    }
])

.factory('jsDataModel', [
    '$http',
    'Projector',
    'ProjectHelper',
    function($http, Projector, ProjectHelper) {
        var BaseModel = function() {};
        BaseModel.prototype.project = function(projectorId) {
            // if this object is already projected on projectorId, delete this element from this projector
            var isProjectedIds = this.isProjected();
            var requestData = {
                clear_ids: isProjectedIds,
            };
            // Show the element, if it was not projected before on the given projector
            if (_.indexOf(isProjectedIds, projectorId) == -1) {
                requestData.prune = {
                    id: projectorId,
                    element: {name: this.getResourceName(), id: this.id},
                };
            }
            return ProjectHelper.project(requestData);
        };
        BaseModel.prototype.isProjected = function() {
            // Returns the ids of all projectors if there is a projector element
            // with the same name and the same id. Else returns an empty list.
            var self = this;
            var predicate = function (element) {
                return element.name == self.getResourceName() &&
                    typeof element.id !== 'undefined' &&
                    element.id == self.id;
            };
            var isProjectedIds = [];
            Projector.getAll().forEach(function (projector) {
                if (typeof _.findKey(projector.elements, predicate) === 'string') {
                    isProjectedIds.push(projector.id);
                }
            });
            return isProjectedIds;
        };
        // Override this method to get object specific behavior
        BaseModel.prototype.isRelatedProjected = function() {
            throw "needs to be implemented!";
        };
        return BaseModel;
    }
])

.factory('ErrorMessage', [
    '$timeout',
    'gettextCatalog',
    'Messaging',
    function ($timeout, gettextCatalog, Messaging) {
        return {
            forAlert: function (error) {
                var message = gettextCatalog.getString('Error') + ': ';

                if (!error.data) {
                    message += gettextCatalog.getString("The server didn't respond.");
                } else if (error.data.detail) {
                    message += error.data.detail;
                } else if (error.status > 500) { // Some kind of server error.
                    message += gettextCatalog.getString("A server error occurred (%%code%%). Please check the system logs.");
                    message = message.replace('%%code%%', error.status);
                } else {
                    for (var e in error.data) {
                        message += e + ': ' + error.data[e] + ' ';
                    }
                }
                return { type: 'danger', msg: message, show: true };
            },
            setConnectionError: function () {
                $timeout(function () {
                    Messaging.createOrEditMessage(
                        'connectionLostMessage',
                        gettextCatalog.getString('Offline mode: You can use OpenSlides but changes are not saved.'),
                        'warning',
                        {noClose: true});
                }, 1);
            },
            clearConnectionError: function () {
                $timeout(function () {
                    Messaging.deleteMessage('connectionLostMessage');
                }, 1);
            },
        };
    }
])

/* Messaging factory. The text is html-binded into the document, so you can
 * provide also html markup for the messages. There are 4 types: 'info',
 * 'success', 'warning', 'error'. The timeout is for autodeleting the message.
 * Args that could be provided:
 * - timeout: Milliseconds until autoclose the message (default: not set, no auto close)
 * - noClose: Whether to show the close button (default: false)
 */
.factory('Messaging', [
    '$timeout',
    function($timeout) {
        var callbackList = [],
            messages = {},
            idCounter = 0;

        var onChange = function () {
            _.forEach(callbackList, function (callback) {
                callback();
            });
        };

        return {
            addMessage: function (text, type, args) {
                var id = idCounter++;
                return this.createOrEditMessage(id, text, type, args);
            },
            createOrEditMessage: function (id, text, type, args) {
                if (!args) {
                    args = {};
                }
                if (messages[id] && messages[id].timeout) {
                    $timeout.cancel(messages[id].timeout);
                }
                messages[id] = {
                    text: text,
                    type: type,
                    id: id,
                    args: args,
                };
                if (typeof args.timeout === 'number' && args.timeout > 0) {
                    var self = this;
                    messages[id].timeout = $timeout(function () {
                        self.deleteMessage(id);
                    }, args.timeout);
                }
                onChange();
                return id;
            },
            deleteMessage: function (id) {
                delete messages[id];
                onChange();
            },
            getMessages: function () {
                return messages;
            },
            registerMessageChangeCallback: function (fn) {
                if (typeof fn === 'function') {
                    callbackList.push(fn);
                } else {
                    throw 'fn has to be a function';
                }
            },
        };
    }
])

.factory('Logos', [
    'Config',
    'gettext',
    function (Config, gettext) {
        return {
            getKeys: function () {
                return Config.get('logos_available').value;
            },
            getAll: function () {
                var self = this;
                return _.map(this.getKeys(), function (key) {
                    return self.get(key);
                });
            },
            get: function (key) {
                var config = Config.get(key);
                if (config) {
                    config.value.key = key;
                    return config.value;
                }
            },
            set: function (key, path) {
                var config = Config.get(key);
                if (config) {
                    config.value.path = path || '';
                    Config.save(key);
                }
            },
        };
    }
])

.factory('Fonts', [
    'Config',
    'gettext',
    function (Config, gettext) {
        var extensionFormatMap = {
            'ttf': 'truetype',
            'woff': 'woff',
        };

        return {
            getKeys: function () {
                return Config.get('fonts_available').value;
            },
            getAll: function () {
                var self = this;
                return _.map(this.getKeys(), function (key) {
                    return self.get(key);
                });
            },
            get: function (key) {
                var config = Config.get(key);
                if (config) {
                    config.value.key = key;
                    return config.value;
                }
            },
            getUrl: function (key) {
                var font = this.get(key);
                if (font) {
                    var path = font.path;
                    if (!path) {
                        return font.default;
                    }
                    return path;
                }
            },
            getForCss: function (key) {
                var url = this.getUrl(key);
                if (url) {
                    var ext = _.last(url.split('.'));
                    return "url('" + url + "') format('" +
                        extensionFormatMap[ext] + "')";
                }
            },
            set: function (key, path) {
                var config = Config.get(key);
                if (config) {
                    config.value.path = path || '';
                    Config.save(key);
                }
            },
        };
    }
])

.factory('Tag', [
    'DS',
    function(DS) {
        return DS.defineResource({
            name: 'core/tag',
        });
    }
])

.factory('Config', [
    '$http',
    'gettextCatalog',
    'DS',
    function($http, gettextCatalog, DS) {
        var configOptions;
        return DS.defineResource({
            name: 'core/config',
            idAttribute: 'key',
            translate: function (value) {
                return gettextCatalog.getString(value);
            }
        });
    }
])

.factory('ChatMessage', [
    'DS',
    function(DS) {
        return DS.defineResource({
            name: 'core/chat-message',
            relations: {
                belongsTo: {
                    'users/user': {
                        localField: 'user',
                        localKey: 'user_id',
                    }
                }
            }
        });
    }
])

/*
 * Provides a function for plugins to register as new plugin.
 *
 * Get all registerd plugins via 'OpenSlidesPlugins.getAll()'.
 *
 * Example code for plugins:
 *
 *  .config([
 *      'OpenSlidesPluginsProvider',
 *       function(OpenSlidesPluginsProvider) {
 *          OpenSlidesPluginsProvider.registerPlugin({
 *              name: 'openslides_votecollector',
 *              display_name: 'VoteCollector',
 *              languages: ['de']
 *          });
 *      }
 *  ])
 */
.provider('OpenSlidesPlugins', [
    function () {
        var provider = this;
        provider.plugins = [];
        provider.registerPlugin = function (plugin) {
            provider.plugins.push(plugin);
        };
        provider.$get = [
            function () {
                return {
                    getAll: function () {
                        return provider.plugins;
                    }
                };
            }
        ];
    }
])


// Configs for CKEditor which has to set while startup of OpenSlides
.config(
    function() {
        CKEDITOR.disableAutoInline = true;
    }
)

// Options for CKEditor used in various create and edit views.
// Required in core/base.js because MotionComment factory which used this
// factory has to placed in motions/base.js.
.factory('Editor', [
    'gettextCatalog',
    function (gettextCatalog) {
        var extraPlugins = [];
        return {
            registerDialog: function (name, dialog) {
                CKEDITOR.dialog.add(name, dialog);
            },
            registerPlugin: function (name, plugin) {
                CKEDITOR.plugins.add(name, plugin);
                extraPlugins.push(name);
            },
            /* Provide special keyword in the arguments for a special behaviour:
             * Example: getOptions('inline', 'YOffset')
             * Available keywords:
             *  - inline: smaller toolbar
             *  - YOffset: move the editor toolbar 40px up
             */
            getOptions: function () {
                var extraPluginsString = 'colorbutton,colordialog,find,sourcedialog,justify,showblocks';
                var registeredPluginsString = extraPlugins.join(',');
                if (registeredPluginsString) {
                    extraPluginsString += ',' + registeredPluginsString;
                }
                var options = {
                    on: {
                        instanceReady: function() {
                            // This adds a listener to ckeditor to remove unwanted blank lines on import.
                            // Clipboard content varies heavily in structure and html code, depending on the "sender".
                            // Here it is first parsed into a pseudo-DOM (two lines taken from a ckeditor
                            // paste example on the ckeditor site).
                            this.on('paste', function(evt) {
                                if (evt.data.type == 'html') {
                                    var fragment = CKEDITOR.htmlParser.fragment.fromHtml(evt.data.dataValue);
                                    var writer = new CKEDITOR.htmlParser.basicWriter();
                                    // html content will now be in a dom-like structure inside 'fragment'.
                                    this.filter.applyTo(fragment);
                                    if (fragment.children) {
                                        // If this fragment is DOM-like, it may contain nested properties
                                        // (being html nodes). Traverse the children and check if it is a
                                        // child only containing empty <br> or <p>.
                                        // new_content_children will finally contain all nodes that are
                                        // not empty.
                                        var new_content_children = [];
                                        _.forEach(fragment.children, function (child) {
                                            var empty = true;
                                            if (child.children){
                                                _.forEach(child.children, function(grandchild) {
                                                    if (grandchild.name != 'p' && grandchild.name != 'br') {
                                                        empty = false;
                                                    } else if (grandchild.isEmpty !== true) {
                                                        empty = false;
                                                    }
                                                });
                                                if (empty === false) {
                                                    new_content_children.push(child);
                                                }
                                            } else {
                                                if (child.name != 'p' && child.name != 'br' &&
                                                    child.isEmpty !== true){
                                                    new_content_children.push(child);
                                                }
                                            }
                                        });
                                        fragment.children = new_content_children;
                                    }
                                    fragment.writeHtml(writer);
                                    // Return the re-created fragment without the empty <p> and <br> into the
                                    // editor import processing (same as at the begin of the function: by ckeditor)
                                    evt.data.dataValue = writer.getHtml();
                                }
                            });
                        }
                    },
                    customConfig: '',
                    floatSpaceDockedOffsetY: _.indexOf(arguments, 'YOffset') > -1 ? 35 : 0,
                    disableNativeSpellChecker: false,
                    language_list: [
                        'fr:français',
                        'es:español',
                        'pt:português',
                        'en:english',
                        'de:deutsch',
                        'cs:čeština'],
                    language: gettextCatalog.getCurrentLanguage(),
                    allowedContent:
                        'h1 h2 h3 b i u strike sup sub strong em;' +
                        'blockquote p pre table' +
                        '(text-align-left,text-align-center,text-align-right,text-align-justify,os-split-before,os-split-after){text-align, float, padding};' +
                        'a[!href];' +
                        'img[!src,alt]{width,height,float, padding};' +
                        'tr th td caption;' +
                        'li(os-split-before,os-split-after); ol(os-split-before,os-split-after)[start]{list-style-type};' +
                        'ul(os-split-before,os-split-after){list-style};' +
                        'span[!*]{color,background-color}(os-split-before,os-split-after,os-line-number,line-number-*);' +
                        'br(os-line-break);',

                    // there seems to be an error in CKeditor that parses spaces in extraPlugins as part of the plugin name.
                    extraPlugins: extraPluginsString,
                    removePlugins: 'wsc,scayt,a11yhelp,filebrowser,sourcearea,liststyle,tabletools,tableselection,contextmenu,image',
                    removeButtons: 'Scayt,Anchor,Styles,HorizontalRule',
                };
                if (_.indexOf(arguments, 'inline') > -1) {
                    options.toolbarGroups = [
                        { name: 'basicstyles', groups: [ 'basicstyles', 'cleanup' ] },
                        { name: 'colors', groups: [ 'colors' ] },
                        { name: 'paragraph', groups: [ 'list'] },
                        { name: 'links', groups: [ 'links' ] },
                        { name: 'clipboard', groups: [ 'undo' ] },
                        { name: 'document', groups: [ 'mode' ] },
                    ];
                    options.removeButtons = 'Underline,Subscript,Superscript,PasteFromWord,PasteText,Scayt,Link,Unlink,Anchor,HorizontalRule,Table,Image,Maximize,Source,Format,About,Paste,Cut,Copy';
                } else {
                    options.toolbarGroups = [
                        { name: 'clipboard', groups: [ 'clipboard', 'undo' ] },
                        { name: 'editing', groups: [ 'find', 'selection', 'spellchecker', 'editing' ] },
                        { name: 'links', groups: [ 'links' ] },
                        { name: 'insert', groups: [ 'insert' ] },
                        { name: 'tools', groups: [ 'tools' ] },
                        { name: 'document', groups: [ 'mode' ] },
                        '/',
                        { name: 'styles', groups: [ 'styles' ] },
                        { name: 'basicstyles', groups: [ 'basicstyles', 'cleanup' ] },
                        { name: 'colors', groups: [ 'colors' ] },
                        { name: 'paragraph', groups: [ 'list', 'indent' ] },
                        { name: 'align'},
                        { name: 'paragraph', groups: [ 'blocks' ] }
                    ];
                }
                return options;
            }
        };
    }
])

/* Model for a projector.
 *
 * At the moment we use only one projector, so there will be only one object
 * in this model. It has the id 1. For later releases there will be multiple
 * projector objects.
 *
 * This model uses onConfilict: 'replace' instead of 'merge'. This is necessary
 * because the keys of the projector objects can change and old keys have to
 * be removed. See http://www.js-data.io/docs/dsdefaults#onconflict for
 * more information.
 */
.factory('Projector', [
    'DS',
    '$http',
    'EditForm',
    'Config',
    function(DS, $http, EditForm, Config) {
        return DS.defineResource({
            name: 'core/projector',
            onConflict: 'replace',
            relations: {
                hasMany: {
                    'core/projection-default': {
                        localField: 'projectiondefaults',
                        foreignKey: 'projector_id',
                    }
                },
            },
            methods: {
                controlProjector: function(action, direction) {
                    $http.post('/rest/core/projector/' + this.id + '/control_view/',
                            {"action": action, "direction": direction}
                    );
                },
                getFormOrStateForCurrentSlide: function () {
                    var return_dict;
                    angular.forEach(this.elements, function(value, key) {
                        if (value.name == 'agenda/list-of-speakers') {
                            return_dict = {
                                state: 'agenda.item.detail',
                                id: value.id,
                            };
                        } else if (
                            // TODO:
                            // Find generic solution for whitelist in getFormOrStateForCurrentSlide
                            // see https://github.com/OpenSlides/OpenSlides/issues/3130
                            value.name === 'topics/topic' ||
                            value.name === 'motions/motion' ||
                            value.name === 'motions/motion-block' ||
                            value.name === 'assignments/assignment' ||
                            value.name === 'mediafiles/mediafile' ||
                            value.name === 'users/user') {
                                return_dict = {
                                    form: EditForm.fromCollectionString(value.name),
                                    id: value.id,
                                };
                        }
                    });
                    return return_dict;
                },
                toggleBlank: function () {
                    $http.post('/rest/core/projector/' + this.id + '/control_blank/',
                        !this.blank
                    );
                },
                toggleBroadcast: function () {
                    $http.post('/rest/core/projector/' + this.id + '/broadcast/');
                }
            },
        });
    }
])

// This factory sends a request to /rest/core/projectors/project
// with the given data. Also it does the changes done by the server
// locally and may reverts them, if something went wrong.
.factory('ProjectHelper', [
    '$q',
    '$http',
    'Projector',
    function ($q, $http, Projector) {
        var uuid4 = function () {
            function s8() {
                return Math.floor((1 + Math.random()) * 0x100000000)
                    .toString(16)
                    .substring(1);
            }
            return s8() + s8() + s8() + s8();
        };

        return {
            project: function (data) {
                var projector;
                // get all projectors that will be changed.
                var projectorsChanged = _.filter(_.map(data.clear_ids, function (id) {
                    return Projector.get(id);
                }));
                if (data.prune && !_.includes(data.clear_ids, data.prune.id)) {
                    projector = Projector.get(data.prune.id);
                    if (projector) {
                        projectorsChanged.push(projector);
                    }
                }

                // copy original projectors in case we have to reconstruct those
                // _.cloneDeep and angular.clone does not work here; I'm not
                // exactly sure why..
                var originalProjectors = _.map(projectorsChanged, function (projector) {
                    var elements = {};
                    _.forEach(projector.elements, function (element, key) {
                        elements[key] = _.cloneDeep(element);
                    });
                    return {
                        id: projector.id,
                        elements: elements,
                        scroll: projector.scroll,
                        scale: projector.scale,
                        name: projector.name,
                        blank: projector.blank,
                        width: projector.width,
                        height: projector.height,
                        projectiondefaults: _.cloneDeep(projector.projectiondefaults),
                    };
                });

                // Clear every projector
                _.forEach(projectorsChanged, function (projector) {
                    var elements = {};
                    _.forEach(projector.elements, function (element, key) {
                        if (element.stable) {
                            elements[key] = element;
                        }
                    });
                    projector.elements = elements;
                });

                // Add the prune element if given
                if (data.prune) {
                    projector = _.find(projectorsChanged, function (projector) {
                        return projector.id === data.prune.id;
                    });
                    if (projector) {
                        projector.scroll = 0;
                        projector.elements[uuid4()] = data.prune.element;
                    }
                }

                Projector.inject(projectorsChanged);

                return $http.post('/rest/core/projector/project/', data).catch(
                    function (error) {
                        // revert the changes made earlier
                        Projector.inject(originalProjectors);
                        return $q.reject(error);
                    }
                );
            },
        };
    }
])

/* Model for all projection defaults */
.factory('ProjectionDefault', [
    'DS',
    function(DS) {
        return DS.defineResource({
            name: 'core/projection-default',
            relations: {
                belongsTo: {
                    'core/projector': {
                        localField: 'projector',
                        localKey: 'projector_id',
                    }
                }
            }
        });
    }
])

/* Model for ProjectorMessages */
.factory('ProjectorMessage', [
    'DS',
    'jsDataModel',
    'gettext',
    '$http',
    'Projector',
    function(DS, jsDataModel, gettext, $http, Projector) {
        var name = 'core/projector-message';
        return DS.defineResource({
            name: name,
            useClass: jsDataModel,
            verboseName: gettext('Message'),
            verbosenamePlural: gettext('Messages'),
            methods: {
                getResourceName: function () {
                    return name;
                },
                // Override the BaseModel.project function
                project: function(projectorId) {
                    // if this object is already projected on projectorId, delete this element from this projector
                    var isProjectedIds = this.isProjected();
                    var self = this;
                    var predicate = function (element) {
                        return element.name === name && element.id === self.id;
                    };
                    _.forEach(isProjectedIds, function (id) {
                        var uuid = _.findKey(Projector.get(id).elements, predicate);
                        $http.post('/rest/core/projector/' + id + '/deactivate_elements/', [uuid]);
                    });
                    // if it was the same projector before, just delete it but not show again
                    if (_.indexOf(isProjectedIds, projectorId) == -1) {
                        // Now check whether other messages are already projected and delete them
                        var elements = Projector.get(projectorId).elements;
                        _.forEach(elements, function (element, uuid) {
                            if (element.name === name) {
                                $http.post('/rest/core/projector/' + projectorId + '/deactivate_elements/', [uuid]);
                            }
                        });
                        return $http.post(
                            '/rest/core/projector/' + projectorId + '/activate_elements/',
                            [{name: name, id: self.id, stable: true}]
                        );
                    }
                },
            }
        });
    }
])

/* Model for Countdowns */
.factory('Countdown', [
    'DS',
    'jsDataModel',
    'gettext',
    '$rootScope',
    '$http',
    'Projector',
    function(DS, jsDataModel, gettext, $rootScope, $http, Projector) {
        var name = 'core/countdown';
        return DS.defineResource({
            name: name,
            useClass: jsDataModel,
            verboseName: gettext('Countdown'),
            verbosenamePlural: gettext('Countdowns'),
            methods: {
                getResourceName: function () {
                    return name;
                },
                start: function () {
                    // calculate end point of countdown (in seconds!)
                    var endTimestamp = Date.now() / 1000 - $rootScope.serverOffset + this.countdown_time;
                    this.running = true;
                    this.countdown_time = endTimestamp;
                    DS.save(name, this.id);
                },
                stop: function () {
                    // calculate rest duration of countdown (in seconds!)
                    var newDuration = Math.floor( this.countdown_time - Date.now() / 1000 + $rootScope.serverOffset );
                    this.running = false;
                    this.countdown_time = newDuration;
                    DS.save(name, this.id);
                },
                reset: function () {
                    this.running = false;
                    this.countdown_time = this.default_time;
                    DS.save(name, this.id);
                },
                // Override the BaseModel.project function
                project: function(projectorId) {
                    // if this object is already projected on projectorId, delete this element from this projector
                    var isProjectedIds = this.isProjected();
                    var self = this;
                    var predicate = function (element) {
                        return element.name == name && element.id == self.id;
                    };
                    _.forEach(isProjectedIds, function (id) {
                        var uuid = _.findKey(Projector.get(id).elements, predicate);
                        $http.post('/rest/core/projector/' + id + '/deactivate_elements/', [uuid]);
                    });
                    // if it was the same projector before, just delete it but not show again
                    if (_.indexOf(isProjectedIds, projectorId) == -1) {
                        return $http.post(
                            '/rest/core/projector/' + projectorId + '/activate_elements/',
                            [{name: name, id: self.id, stable: true}]
                        );
                    }
                },
            },
        });
    }
])

/* Two functions to convert between time duration in seconds <-> human readable time span.
 * E.g. 90 sec <-> 1:30 (min), 3661 sec <-> 1:01:01 (h)
 *
 * secondsToHumanTime: Expects seconds and give [h*:]mm[:ss]. The minutes part is always given, the hours
 *      and minutes could be controlled. The default are forced seconds and hours just if it is not 0.
 *      - seconds ('enabled', 'auto', 'disabled'): Whether to show seconds (Default 'enabled')
 *      - hours ('enabled', 'auto', 'disabled'): Whether to show hours (Default 'auto')
 *
 * humanTimeToSeconds: Expects [h*:]m*[:s*] with each part could have a variable length. The parsed time is
 *      in seconds. Minutes have to be given and hours and seconds are optional. One have to set 'seconds' or
 *      'hours' to true toparse these.
 *
 * params could be an object with the given settings, e.g. {ignoreHours: true}
 */
.factory('HumanTimeConverter', [
    function () {
        return {
            secondsToHumanTime: function (seconds, params) {
                if (!params) {
                    params = {seconds: 'enabled', hours: 'auto'};
                }
                if (!params.seconds) {
                    params.seconds = 'enabled';

                }
                if (!params.hours) {
                    params.hours = 'auto';
                }
                var time;
                // floor returns the largest integer of the absolut value of seconds
                var total = Math.floor(Math.abs(seconds));
                var h = Math.floor(total / 3600);
                var m = Math.floor(total % 3600 / 60);
                var s = Math.floor(total % 60);
                // Add leading "0" for double digit values
                time = ('0'+m).slice(-2); //minutes
                if ((params.seconds == 'auto' && s > 0) || params.seconds == 'enabled') {
                    s = ('0'+s).slice(-2);
                    time =  time + ':' + s;
                }
                if ((params.hours == 'auto' && h > 0) || params.hours == 'enabled') {
                    time = h + ':' + time;
                }
                if (seconds < 0) {
                    time = '-'+time;
                }
                return time;
            },
            humanTimeToSeconds: function (data, params) {
                if (!params) {
                    params = {seconds: false, hours: false};
                }
                var minLength = 1;
                if (params.seconds) {
                    minLength++;
                }
                if (params.hours){
                    minLength++;
                }

                var negative = data.charAt(0) == '-';
                var time = data.split(':');
                data = 0;
                if (time.length >= minLength) {
                    for (var i = 0; i < minLength; i++) {
                        data = data*60;
                        if (!isNaN(+time[i])) {
                            data += (+time[i]);
                        }
                    }
                    if (!params.seconds) { // the last field was minutes (e.g. h:mm)
                        data *= 60;
                    }
                    if (negative) {
                        data = -data;
                    }
                }
                return data;
            },
        };
    }
])

/* Converts a snake-case string to camelCase. Example:
 * 'motion-block-config' -> 'motionBlockConfig' */
.factory('CamelCase', [
    function () {
        return function (str) {
            return str.replace(/-([a-z])/g, function (match) {
                return match[1].toUpperCase();
            });
        };
    }
])

/* Return the specific EditForm for a given model. */
.factory('EditForm', [
    '$injector',
    'CamelCase',
    function ($injector, CamelCase) {
        return {
            fromCollectionString: function (collection) {
                var modelName = CamelCase(collection).split('/')[1];
                // Convert modelModel to ModelModelForm
                var formName = modelName.charAt(0).toUpperCase() + modelName.slice(1) + 'Form';
                return $injector.get(formName);
            },
        };
    }
])

/* Converts number of seconds into string "h:mm:ss" or "mm:ss" */
.filter('osSecondsToTime', [
    'HumanTimeConverter',
    function (HumanTimeConverter) {
        return function (seconds) {
            return HumanTimeConverter.secondsToHumanTime(seconds);
        };
    }
])

/* Converts number of minutes into string "h:mm" or "hh:mm" */
.filter('osMinutesToTime', [
    'HumanTimeConverter',
    function (HumanTimeConverter) {
        return function (minutes) {
            return HumanTimeConverter.secondsToHumanTime(minutes*60,
                { seconds: 'disabled',
                    hours: 'enabled' }
            );
        };
    }
])

// mark HTML as "trusted"
.filter('trusted', [
    '$sce',
    function ($sce) {
        return function(text) {
            return $sce.trustAsHtml(text);
        };
    }
])

// filters the requesting object (id=selfid) from a list of input objects
.filter('notself', function () {
    return function (input, selfid) {
        var result;
        if (selfid) {
            result = [];
            for (var key in input){
                var obj = input[key];
                if (selfid != obj.id) {
                    result.push(obj);
                }
            }
        } else {
            result = input;
        }
        return result;
    };
})

// Wraps the orderBy filter. But puts ("", null, undefined) last.
.filter('orderByEmptyLast', [
    '$filter',
    '$parse',
    function ($filter, $parse) {
        return function (array, sortPredicate, reverseOrder, compareFn) {
            var parsed = $parse(sortPredicate);
            var falsyItems = [];
            var truthyItems = _.filter(array, function (item) {
                var falsy = parsed(item) === void 0 || parsed(item) === null || parsed(item) === '';
                if (falsy) {
                    falsyItems.push(item);
                }
                return !falsy;
            });
            truthyItems = $filter('orderBy')(truthyItems, sortPredicate, reverseOrder, compareFn);
            return _.concat(truthyItems, falsyItems);
        };
    }
])

// Make sure that the DS factories are loaded by making them a dependency
.run([
    'ChatMessage',
    'Config',
    'Countdown',
    'ProjectorMessage',
    'Projector',
    'ProjectionDefault',
    'Tag',
    'Notify', // For setting up the autoupdate callback
    function (ChatMessage, Config, Countdown, ProjectorMessage, Projector, ProjectionDefault, Tag, Notify) {}
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.core.csv', [])

.factory('CsvDownload', [
    'Config',
    'FileSaver',
    function (Config, FileSaver) {
        var utf8_BOM = decodeURIComponent('%EF%BB%BF');
        return function (contentRows, filename) {
            var separator = Config.get('general_csv_separator').value;
            var rows = _.map(contentRows, function (row) {
                return row.join(separator);
            });
            var blob = new Blob([utf8_BOM + rows.join('\n')]);
            FileSaver.saveAs(blob, filename);
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.core.docx', [])

.factory('Html2DocxConverter', [
    '$q',
    'ImageConverter',
    function ($q, ImageConverter) {
        var PAGEBREAK = '<w:p><w:r><w:br w:type="page" /></w:r></w:p>';

        var createInstance = function () {
            var converter = {
                imageMap: {},
                documentImages: [],
                relationships: [],
                contentTypes: [],
            };

            var html2docx = function (html) {
                var docx = '';
                var tagStack = [];

                // With this variable, we keep track, if we are currently inside or outside of a paragraph.
                var inParagraph = true;
                // the text may not begin with a paragraph. If so, append one because word needs it.
                var skipFirstParagraphClosing = true;

                var handleTag = function (tag) {
                    if (tag.charAt(0) == "/") {  // A closing tag
                        // remove from stack
                        tagStack.pop();

                        // Special: end paragraphs
                        if (tag.indexOf('/p') === 0) {
                            docx += '</w:p>';
                            inParagraph = false;
                        }
                    } else { // now all other tags
                        var tagname = tag.split(' ')[0];
                        handleNamedTag(tagname, tag);
                    }
                    return docx;
                };
                var handleNamedTag = function (tagname, fullTag) {
                    var tag = {
                        tag: tagname,
                        attrs: {},
                    };
                    switch (tagname) {
                        case 'p':
                            if (inParagraph && !skipFirstParagraphClosing) {
                                // End the paragrapth, if there is one
                                docx += '</w:p>';
                            }
                            skipFirstParagraphClosing = false;
                            docx += '<w:p>';
                            inParagraph = true;
                            break;
                        case 'span':
                            var styleRegex = /(?:\"|\;\s?)([a-zA-z\-]+)\:\s?([a-zA-Z0-9\-\#]+)/g, matchSpan;
                            while ((matchSpan = styleRegex.exec(fullTag)) !== null) {
                                switch (matchSpan[1]) {
                                    case 'color':
                                            tag.attrs.color = matchSpan[2].slice(1); // cut off the #
                                        break;
                                    case 'background-color':
                                            tag.attrs.backgroundColor = matchSpan[2].slice(1); // cut off the #
                                        break;
                                    case 'text-decoration':
                                        if (matchSpan[2] === 'underline') {
                                            tag.attrs.underline = true;
                                        } else if (matchSpan[2] === 'line-through') {
                                            tag.attrs.strike = true;
                                        }
                                        break;
                                }
                            }
                            break;
                        case 'a':
                            var hrefRegex = /href="([^"]+)"/g;
                            var href = hrefRegex.exec(fullTag)[1];
                            tag.href = href;
                            break;
                        case 'img':
                            imageTag(tag, fullTag);
                            break;
                    }
                    if (tagname !== 'img' && tagname !== 'p') {
                        tagStack.push(tag);
                    }
                };
                var imageTag = function (tag, fullTag) {
                    // images has to be placed instantly, so there is no use of 'tag'.
                    var image = {};
                    var attributeRegex = /(\w+)=\"([^\"]*)\"/g, attributeMatch;
                    while ((attributeMatch = attributeRegex.exec(fullTag)) !== null) {
                        image[attributeMatch[1]] = attributeMatch[2];
                    }
                    if (image.src && converter.imageMap[image.src]) {
                        image.width = converter.imageMap[image.src].width;
                        image.height = converter.imageMap[image.src].height;

                        var rrId = converter.relationships.length + 1;
                        var imageId = converter.documentImages.length + 1;

                        // set name ('pic.jpg'), title, ext ('jpg'), mime ('image/jpeg')
                        image.name = _.last(image.src.split('/'));

                        var tmp = image.name.split('.');
                        image.ext = tmp.splice(-1);

                        // set name without extension as title if there isn't a title
                        if (!image.title) {
                            image.title = tmp.join('.');
                        }

                        image.mime = 'image/' + image.ext;
                        if (image.ext == 'jpe' || image.ext == 'jpg') {
                            image.mime = 'image/jpeg';
                        }

                        // x and y for the container and picture size in EMU (assuming 96dpi)!
                        var x = image.width * 914400 / 96;
                        var y = image.height * 914400 / 96;

                        // the image does not belong into a paragraph in ooxml
                        if (inParagraph) {
                            docx += '</w:p>';
                        }
                        docx += '<w:p><w:r><w:drawing><wp:inline distT="0" distB="0" distL="0" distR="0"><wp:extend cx="' + x +'" cy="' + y + '"/><wp:effectExtent l="0" t="0" r="0" b="0"/>' +
                            '<wp:docPr id="' + imageId + '" name="' + image.name + '" title="' + image.title + '" descr="' + image.title + '"/><wp:cNvGraphicFramePr>' +
                            '<a:graphicFrameLocks xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" noChangeAspect="1"/></wp:cNvGraphicFramePr>' +
                            '<a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"><a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">' +
                            '<pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture"><pic:nvPicPr><pic:cNvPr id="' + imageId + '" name="' +
                            image.name + '" title="' + image.title + '" descr="' + image.title + '"/><pic:cNvPicPr/></pic:nvPicPr><pic:blipFill><a:blip r:embed="rrId' + rrId + '"/><a:stretch>' +
                            '<a:fillRect/></a:stretch></pic:blipFill><pic:spPr bwMode="auto"><a:xfrm><a:off x="0" y="0"/><a:ext cx="' + x + '" cy="' + y + '"/></a:xfrm>' +
                            '<a:prstGeom prst="rect"><a:avLst/></a:prstGeom></pic:spPr></pic:pic></a:graphicData></a:graphic></wp:inline></w:drawing></w:r></w:p>';

                        // inParagraph stays untouched, the documents paragraph state is restored here
                        if (inParagraph) {
                            docx += '<w:p>';
                        }

                        // entries in documentImages, relationships and contentTypes
                        converter.documentImages.push({
                            src: image.src,
                            zipPath: 'word/media/' + image.name
                        });
                        converter.relationships.push({
                            Id: 'rrId' + rrId,
                            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
                            Target: 'media/' + image.name
                        });
                        converter.contentTypes.push({
                            PartName: '/word/media/' + image.name,
                            ContentType: image.mime
                        });
                    }
                };
                var handleText = function (text) {
                    // Start a new paragraph, if only loose text is there
                    if (!inParagraph) {
                        docx += '<w:p>';
                        inParagraph = true;
                    }
                    var docxPart = '<w:r><w:rPr>';
                    var hyperlink = false;
                    tagStack.forEach(function (tag) {
                        switch (tag.tag) {
                            case 'b':
                            case 'strong':
                                docxPart += '<w:b/><w:bCs/>';
                                break;
                            case 'em':
                            case 'i':
                                docxPart += '<w:i/><w:iCs/>';
                                break;
                            case 'span':
                                for (var key in tag.attrs) {
                                    switch (key) {
                                        case 'color':
                                            docxPart += '<w:color w:val="' + tag.attrs[key] + '"/>';
                                            break;
                                        case 'backgroundColor':
                                            docxPart += '<w:shd w:fill="' + tag.attrs[key] + '"/>';
                                            break;
                                        case 'underline':
                                            docxPart += '<w:u w:val="single"/>';
                                            break;
                                        case 'strike':
                                            docxPart += '<w:strike/>';
                                            break;
                                    }
                                }
                                break;
                            case 'u':
                                docxPart += '<w:u w:val="single"/>';
                                break;
                            case 'strike':
                                docxPart += '<w:strike/>';
                                break;
                            case 'a':
                                var id = converter.relationships.length + 1;
                                docxPart = '<w:hyperlink r:id="rrId' + id + '">' + docxPart;
                                docxPart += '<w:rStyle w:val="Internetlink"/>';
                                converter.relationships.push({
                                    Id: 'rrId' + id,
                                    Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink',
                                    Target: tag.href,
                                    TargetMode: 'External'
                                });
                                hyperlink = true;
                                break;
                        }
                    });
                    docxPart += '</w:rPr><w:t>' + text + '</w:t></w:r>';
                    if (hyperlink) {
                        docxPart += '</w:hyperlink>';
                    }

                    // append to docx
                    docx += docxPart;
                    return docx;
                };

                var replaceEntities = function () {
                    // replacing of special symbols:
                    docx = docx.replace(new RegExp('\&auml\;', 'g'), 'ä');
                    docx = docx.replace(new RegExp('\&uuml\;', 'g'), 'ü');
                    docx = docx.replace(new RegExp('\&ouml\;', 'g'), 'ö');
                    docx = docx.replace(new RegExp('\&Auml\;', 'g'), 'Ä');
                    docx = docx.replace(new RegExp('\&Uuml\;', 'g'), 'Ü');
                    docx = docx.replace(new RegExp('\&Ouml\;', 'g'), 'Ö');
                    docx = docx.replace(new RegExp('\&szlig\;', 'g'), 'ß');
                    docx = docx.replace(new RegExp('\&nbsp\;', 'g'), ' ');
                    docx = docx.replace(new RegExp('\&sect\;', 'g'), '§');

                    // remove all entities except gt, lt and amp
                    var entityRegex = /\&(?!gt|lt|amp)\w+\;/g, matchEntry, indexes = [];
                    while ((matchEntry = entityRegex.exec(docx)) !== null) {
                        indexes.push({
                            startId: matchEntry.index,
                            stopId: matchEntry.index + matchEntry[0].length
                        });
                    }
                    for (var i = indexes.length - 1; i>=0; i--) {
                        docx = docx.substring(0, indexes[i].startId) + docx.substring(indexes[i].stopId, docx.length);
                    }
                };

                var parse = function () {
                    if (html.substring(0,3) != '<p>') {
                        docx += '<w:p>';
                        skipFirstParagraphClosing = false;
                    }
                    html = html.split(/(<|>)/g);
                    // remove whitespaces and > brackets. Leave < brackets in there to check, whether
                    // the following string is a tag or text.
                    html = _.filter(html, function (part) {
                        var skippedCharsRegex = new RegExp('^([\s\n\r]|>)*$', 'g');
                        return !skippedCharsRegex.test(part);
                    });

                    for (var i = 0; i < html.length; i++) {
                        if (html[i] === '<') {
                            i++;
                            handleTag(html[i]);
                        } else {
                            handleText(html[i]);
                        }
                    }
                    // for finishing close the last paragraph (if open)
                    if (inParagraph) {
                        docx += '</w:p>';
                    }

                    replaceEntities();

                    return docx;
                };

                return parse();
            };

            // return a wrapper function for html2docx, that fetches all the images.
            converter.html2docx = function (html) {
                var imageSources = _.map($(html).find('img'), function (element) {
                    return element.getAttribute('src');
                });
                // Don't get images multiple times; just if the converter has not seen them befor.
                imageSources = _.filter(imageSources, function (src) {
                    return !converter.imageMap[src];
                });
                return $q(function (resolve) {
                    ImageConverter.toBase64(imageSources).then(function (_imageMap) {
                        _.forEach(_imageMap, function (value, key) {
                            converter.imageMap[key] = value;
                        });
                        var docx = html2docx(html);
                        resolve(docx);
                    });
                });
            };

            converter.updateZipFile = function (zip) {
                var updateRelationships = function (oldContent) {
                    var content = oldContent.split('\n');
                    _.forEach(converter.relationships, function (relationship) {
                        content[1] += '<Relationship';
                        _.forEach(relationship, function (value, key) {
                            content[1] += ' ' + key + '="' + value + '"';
                        });
                        content[1] += '/>';
                    });
                    return content.join('\n');
                };
                var updateContentTypes = function (oldContent) {
                    var content = oldContent.split('\n');
                    _.forEach(converter.contentTypes, function (type) {
                        content[1] += '<Override';
                        _.forEach(type, function (value, key) {
                            content[1] += ' ' + key + '="' + value + '"';
                        });
                        content[1] += '/>';
                    });
                    return content.join('\n');
                };
                // update relationships from 'relationships'
                var relationships = updateRelationships(zip.file('word/_rels/document.xml.rels').asText());
                zip.file('word/_rels/document.xml.rels', relationships);

                // update content type from 'contentTypes'
                var contentTypes = updateContentTypes(zip.file('[Content_Types].xml').asText());
                zip.file('[Content_Types].xml', contentTypes);

                converter.documentImages = _.uniqBy(converter.documentImages, 'src');
                _.forEach(converter.documentImages, function (image) {
                    var dataUrl = converter.imageMap[image.src].data;
                    var base64 = dataUrl.split(',')[1];
                    zip.file(image.zipPath, base64, {base64: true});
                });
                return zip;
            };

            return converter;
        };

        return {
            createInstance: createInstance,
        };
    }
]);

})();

(function () {

'use strict';

angular.module('OpenSlidesApp.core.pdf', [])

/*
 * General layout functions for building PDFs with pdfmake.
 */
.factory('PDFLayout', [
    'gettextCatalog',
    function(gettextCatalog) {
        var PDFLayout = {};
        var BallotCircleDimensions = {
            yDistance: 6,
            size: 8
        };

        // page title
        PDFLayout.createTitle = function(title) {
            return {
                text: title,
                style: 'title'
            };
        };

        // page subtitle
        PDFLayout.createSubtitle = function(subtitle) {
            return {
                text: subtitle.join('\n'),
                style: 'subtitle'
            };
        };

        // pagebreak
        PDFLayout.addPageBreak = function() {
            return [
                {
                    text: '',
                    pageBreak: 'after'
                }
            ];
        };

        // table row style
        PDFLayout.flipTableRowStyle = function(currentTableSize) {
            if (currentTableSize % 2 === 0) {
                return 'tableEven';
            } else {
                return 'tableOdd';
            }
        };

        // draws a circle
        PDFLayout.drawCircle = function(y, size) {
            return [
                {
                    type: 'ellipse',
                    x: 0,
                    y: y,
                    lineColor: 'black',
                    r1: size,
                    r2: size
                }
            ];
        };

        // returns an entry in the ballot with a circle to draw into
        PDFLayout.createBallotEntry = function(decision) {
            return {
                margin: [40+BallotCircleDimensions.size, 10, 0, 0],
                columns: [
                    {
                        width: 15,
                        canvas: PDFLayout.drawCircle(BallotCircleDimensions.yDistance,
                                BallotCircleDimensions.size)
                    },
                    {
                        width: 'auto',
                        text: decision
                    }
                ],
            };
        };

        // crop marks for ballot papers
        PDFLayout.getBallotLayoutLines = function() {
            return '{{ballot-placeholder-to-insert-functions-here}}';
        };

        // returns a promise for converting an image in data URL format with size information
        PDFLayout.imageURLtoBase64 = function(url) {
            var promise = new Promise(function(resolve, reject) {
                var img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onerror = function () {
                    reject({
                        msg: '<i class="fa fa-exclamation-triangle fa-lg spacer-right"></i>' +
                             gettextCatalog.getString('Error while generating PDF file') +
                             ': <code>' + gettextCatalog.getString('Cannot load image') + ' ' + url + '</code>',
                    });
                };
                img.onload = function () {
                    var canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    var ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    var dataURL = canvas.toDataURL('image/png');
                    var imageData = {
                        data: dataURL,
                        width: img.width,
                        height: img.height
                    };
                    resolve(imageData);
                };
                img.src = url;
            });
            return promise;
        };

        return PDFLayout;
    }
])


.factory('HTMLValidizer', function() {
    var HTMLValidizer = {};

    // In some cases copying from word to OpenSlides results in umlauts
    // that are the base letter and then the entity #776; to make the dots
    // above the base letter. This breaks the PDF.
    HTMLValidizer.replaceMalformedUmlauts = function (text) {
        return text.replace(/([aeiouAEIOUy])[\u0308]/g, function (match, baseChar) {
            return '&' + baseChar + 'uml;';
        });
    };


    //checks if str is valid HTML. Returns valid HTML if not,
    //return emptystring if empty
    HTMLValidizer.validize = function(str) {
        if (str) {
            str = HTMLValidizer.replaceMalformedUmlauts(str);
            // Sometimes, some \n are in the text instead of whitespaces. Replace them.
            str = str.replace(/\n/g, ' ');

            var a = document.createElement('div');
            a.innerHTML = str;
            angular.forEach(a.childNodes, function (child) {
                if (child.nodeType == 1) {
                    return str;
                }
            });
            return '<p>' + str + '</p>';
        } else {
            return ''; //needed for blank 'reasons' field
        }
    };
    return HTMLValidizer;
})


.factory('PdfMakeDocumentProvider', [
    '$q',
    'Config',
    'PDFLayout',
    'ImageConverter',
    function($q, Config, PDFLayout, ImageConverter) {
        /**
         * Provides the global document
         * @constructor
         * @param {object} contentProvider - Object with on method `getContent`, which
         * returns an array for content
         */
        //images shall contain the the logos as URL: base64Str, just like the converter
        var createInstance = function(contentProvider, noFooter) {
            // Logo urls
            var logoHeaderLeftUrl = Config.get('logo_pdf_header_L').value.path,
                logoHeaderRightUrl = Config.get('logo_pdf_header_R').value.path,
                logoFooterLeftUrl = Config.get('logo_pdf_footer_L').value.path,
                logoFooterRightUrl = Config.get('logo_pdf_footer_R').value.path;
            var imageMap = contentProvider.getImageMap ? contentProvider.getImageMap() : {};

            // PDF header
            var getHeader = function() {
                var columns = [];

                if (logoHeaderLeftUrl) {
                    if (logoHeaderLeftUrl.indexOf('/') === 0) {
                        logoHeaderLeftUrl = logoHeaderLeftUrl.substr(1); // remove trailing /
                    }
                    columns.push({
                        image: logoHeaderLeftUrl,
                        fit: [180, 40],
                        width: '20%'
                    });
                }

                var line1 = [
                    Config.translate(Config.get('general_event_name').value),
                    Config.translate(Config.get('general_event_description').value)
                ].filter(Boolean).join(' – ');
                var line2 = [
                    Config.get('general_event_location').value,
                    Config.get('general_event_date').value
                ].filter(Boolean).join(', ');
                var text = [line1, line2].join('\n');
                columns.push({
                    text: text,
                    fontSize: 10,
                    alignment: logoHeaderRightUrl ? 'left' : 'right',
                    margin: [0, 10, 0, 0],
                });

                if (logoHeaderRightUrl) {
                    if (logoHeaderRightUrl.indexOf('/') === 0) {
                        logoHeaderRightUrl = logoHeaderRightUrl.substr(1); // remove trailing /
                    }
                    columns.push({
                        image: logoHeaderRightUrl,
                        fit: [180, 40],
                        width: '20%'
                    });
                }

                return {
                    color: '#555',
                    fontSize: 9,
                    margin: [75, 30, 75, 10], // [left, top, right, bottom]
                    columns: columns,
                    columnGap: 10,
                };
            };


            // PDF footer
            // Used placeholder for currentPage and pageCount which
            // are replaced by dynamic footer function in pdf-worker.js.
            var getFooter = function() {
                var columns = [];

                // if there is a single logo, give it a lot of space
                var logoContainerWidth;
                var logoConteinerSize;
                if (logoFooterLeftUrl && logoFooterRightUrl) {
                    logoContainerWidth = '20%';
                    logoConteinerSize = [180, 40];
                } else {
                    logoContainerWidth = '80%';
                    logoConteinerSize = [400, 50];
                }

                // the position of the page number depends on the logos
                var pageNumberPosition;
                if (logoFooterLeftUrl && logoFooterRightUrl) {
                    pageNumberPosition = 'center';
                } else if (logoFooterLeftUrl && (!logoFooterRightUrl)) {
                    pageNumberPosition = 'right';
                } else if (logoFooterRightUrl && (!logoFooterLeftUrl)) {
                    pageNumberPosition = 'left';
                } else {
                    pageNumberPosition = Config.get('general_export_pdf_pagenumber_alignment').value;
                }

                if (logoFooterLeftUrl) {
                    if (logoFooterLeftUrl.indexOf('/') === 0) {
                        logoFooterLeftUrl = logoFooterLeftUrl.substr(1); // remove trailing /
                    }
                    columns.push({
                        image: logoFooterLeftUrl,
                        fit: logoConteinerSize,
                        width: logoContainerWidth,
                        alignment: 'left',
                    });
                }
                columns.push({
                    text: '{{currentPage}} / {{pageCount}}',
                    color: '#555',
                    fontSize: 9,
                    alignment: pageNumberPosition,
                    margin: [0, 15, 0, 0],
                });

                if (logoFooterRightUrl) {
                    if (logoFooterRightUrl.indexOf('/') === 0) {
                        logoFooterRightUrl = logoFooterRightUrl.substr(1); // remove trailing /
                    }
                    columns.push({
                        image: logoFooterRightUrl,
                        fit: logoConteinerSize,
                        width: logoContainerWidth,
                        alignment: 'right',
                    });
                }
                return {
                    margin: [75, 0, 75, 10],
                    columns: columns,
                    columnGap: 10,
                };
            };
            // Generates the document(definition) for pdfMake
            var getDocument = function() {
                var content = contentProvider.getContent();
                var standardFontsize = Config.get('general_export_pdf_fontsize').value;
                return {
                    pageSize: 'A4',
                    pageMargins: [75, 90, 75, 75],
                    defaultStyle: {
                        font: 'PdfFont',
                        fontSize: standardFontsize
                    },
                    header: getHeader(),
                    footerTpl: noFooter ? '' : getFooter(),
                    content: content,
                    styles: {
                        title: {
                            fontSize: 18,
                            margin: [0,0,0,20],
                            bold: true
                        },
                        subtitle: {
                            fontSize: 9,
                            margin: [0,-20,0,20],
                            color: 'grey'
                        },
                        preamble: {
                            fontSize: standardFontsize,
                            margin: [0,0,0,10],
                        },
                        userDataTitle: {
                            fontSize: 26,
                            margin: [0,0,0,0],
                            bold: true
                        },
                        textItem: {
                            fontSize: 11,
                            margin: [0,7]
                        },
                        heading2: {
                            fontSize: 14,
                            margin: [0,0,0,10],
                            bold: true
                        },
                        heading3: {
                            fontSize: 12,
                            margin: [0,10,0,0],
                            bold: true
                        },
                        userDataHeading: {
                            fontSize: 14,
                            margin: [0,10],
                            bold: true
                        },
                        userDataTopic: {
                            fontSize: 12,
                            margin: [0,5]
                        },
                        userDataValue: {
                            fontSize: 12,
                            margin: [15,5]
                        },
                        tocEntry: {
                            fontSize: 12,
                            margin: [0,0,0,0],
                            bold: false
                        },
                        tocCategoryEntry: {
                            fontSize: 12,
                            margin: [10,0,0,0],
                            bold: false
                        },
                        tocCategoryTitle: {
                            fontSize: 12,
                            margin: [0,0,0,4],
                            bold: true,
                        },
                        tocCategorySection: {
                            margin: [0,0,0,10],
                        },
                        listParent: {
                            fontSize: 12,
                            margin: [0,5]
                        },
                        listChild: {
                            fontSize: 10,
                            margin: [0,5]
                        },
                        tableHeader: {
                            bold: true,
                            fillColor: 'white'
                        },
                        tableEven: {
                            fillColor: 'white'
                        },
                        tableOdd: {
                            fillColor: '#eee'
                        },
                        tableConclude: {
                            fillColor: '#ddd',
                            bold: true
                        },
                        grey: {
                            fillColor: '#ddd',
                        },
                        lightgrey: {
                            fillColor: '#aaa',
                        },
                        bold: {
                            bold: true,
                        },
                        small: {
                            fontSize: 8,
                        }
                    }
                };
            };

            var getImageMap = function () {
                return imageMap;
            };

            return $q(function (resolve, reject) {
                var imageSources = [
                    logoHeaderLeftUrl,
                    logoHeaderRightUrl,
                    logoFooterLeftUrl,
                    logoFooterRightUrl,
                ];
                ImageConverter.toBase64(imageSources).then(function (_imageMap) {
                    _.forEach(_imageMap, function (data, path) {
                        if (!imageMap[path]) {
                            imageMap[path] = data;
                        }
                    });
                    resolve({
                        getDocument: getDocument,
                        getImageMap: getImageMap,
                    });
                }, reject);
            });
        };
        return {
            createInstance: createInstance,
        };
    }
])

.factory('PdfMakeBallotPaperProvider', [
    'PDFLayout',
    function(PDFLayout) {
        /**
         * Provides the global Document
         * @constructor
         * @param {object} contentProvider - Object with on method `getContent`, which returns an array for content
         */
        var createInstance = function(contentProvider) {
            /**
             * Generates the document(definition) for pdfMake
             * @function
             */
            var getDocument = function() {
                var content = contentProvider.getContent();
                return {
                    pageSize: 'A4',
                    pageMargins: [0, 0, 0, 0],
                    defaultStyle: {
                        font: 'PdfFont',
                        fontSize: 10
                    },
                    content: content,
                    styles: {
                        title: {
                            fontSize: 14,
                            bold: true,
                            margin: [30, 30, 0, 0]
                        },
                        description: {
                            fontSize: 11,
                            margin: [30, 0, 0, 0]
                        }
                    }
                };
            };

            var getImageMap = function() {
                return contentProvider.getImageMap();
            };

            return {
                getDocument: getDocument,
                getImageMap: getImageMap,
            };
        };
        return {
            createInstance: createInstance
        };
    }
])

.factory('PdfMakeConverter', [
    'HTMLValidizer',
    'Config',
    function(HTMLValidizer, Config) {
        /**
         * Converter component for HTML->JSON for pdfMake
         * @constructor
         * @param {object} images   - Key-Value structure representing image.src/BASE64 of images
         */
        var createInstance = function(images) {
            var slice = Function.prototype.call.bind([].slice),
                map = Function.prototype.call.bind([].map),

                DIFF_MODE_NORMAL = 0,
                DIFF_MODE_INSERT = 1,
                DIFF_MODE_DELETE = 2,

                // Space between list elements
                LI_MARGIN_BOTTOM = 8,

                /**
                 * Convertes HTML for use with pdfMake
                 * @function
                 * @param {object} html - html
                 * @param {string} lineNumberMode - [inline, outside, none]
                 */
                convertHTML = function(html, lineNumberMode) {
                    var elementStyles = {
                            'b': ['font-weight:bold'],
                            'strong': ['font-weight:bold'],
                            'u': ['text-decoration:underline'],
                            'em': ['font-style:italic'],
                            'i': ['font-style:italic'],
                            'h1': ['font-size:14', 'font-weight:bold'],
                            'h2': ['font-size:12', 'font-weight:bold'],
                            'h3': ['font-size:10', 'font-weight:bold'],
                            'h4': ['font-size:10', 'font-style:italic'],
                            'h5': ['font-size:10'],
                            'h6': ['font-size:10'],
                            'a': ['color:blue', 'text-decoration:underline'],
                            'strike': ['text-decoration:line-through'],
                            'del': ['color:red', 'text-decoration:line-through'],
                            'ins': ['color:green', 'text-decoration:underline']
                        },
                        classStyles = {
                            'delete': ['color:red', 'text-decoration:line-through'],
                            'insert': ['color:green', 'text-decoration:underline']
                        },
                        getLineNumber = function (element) {
                            if (element && element.nodeName == 'SPAN' && element.getAttribute('class') &&
                                element.getAttribute('class').indexOf('os-line-number') > -1) {
                                return element.getAttribute('data-line-number');
                            }
                        },
                        /**
                         *
                         * Removes all line number nodes (not line-breaks)
                         * and returns an array containing the reoved numbers in this format:
                         * { lineNumber: '<lineNumber>', marginBottom: <number> }
                         * where marginBottom is optional.
                         *
                         * @function
                         * @param {object} element
                         */
                        extractLineNumbers = function(element) {
                            var foundLineNumbers = [];
                            var lineNumber = getLineNumber(element);
                            if (lineNumber) {
                                foundLineNumbers.push({lineNumber: lineNumber});
                                element.parentNode.removeChild(element);
                            } else if (element.nodeName === 'BR') {
                                // Check if there is a new line, but it does not get a line number.
                                // If so, insert a dummy line, so the line nubers stays aligned with
                                // the text.
                                if (!getLineNumber(element.nextSibling)) {
                                    foundLineNumbers.push({lineNumber: ''});
                                }
                            } else {
                                var children = element.childNodes,
                                    childrenLength = children.length,
                                    childrenLineNumbers = [];
                                for (var i = 0; i < children.length; i++) {
                                    childrenLineNumbers = _.concat(childrenLineNumbers, extractLineNumbers(children[i]));
                                    if (children.length < childrenLength) {
                                        i -= (childrenLength - children.length);
                                        childrenLength = children.length;
                                    }
                                }
                                // If this is an list item, add some space to the lineNumbers:
                                if (childrenLineNumbers.length && element.nodeName === 'LI') {
                                    _.last(childrenLineNumbers).marginBottom = LI_MARGIN_BOTTOM;
                                }
                                foundLineNumbers = _.concat(foundLineNumbers, childrenLineNumbers);
                            }
                            return foundLineNumbers;
                        },
                        /**
                         * Parses Children of the current paragraph
                         * @function
                         * @param {object} converted  -
                         * @param {object} element   -
                         * @param {object} currentParagraph -
                         * @param {object} styles -
                         * @param {number} diff_mode
                         */
                        parseChildren = function(converted, element, currentParagraph, styles, diff_mode) {
                            var elements = [];
                            var children = element.childNodes;
                            if (children.length !== 0) {
                                _.forEach(children, function(child) {
                                    currentParagraph = ParseElement(elements, child, currentParagraph, styles, diff_mode);
                                });
                            }
                            if (elements.length !== 0) {
                                _.forEach(elements, function(el) {
                                    converted.push(el);
                                });
                            }
                            return currentParagraph;
                        },
                        /**
                         * Returns the color in a hex format (e.g. #12ff00).
                         * Tries to convert the rgb form into this.
                         * @function
                         * @param {string} color
                         */
                        parseColor = function (color) {
                            var hexRegex = new RegExp('^#([0-9a-f]{3}|[0-9a-f]{6})$');
                            // e.g. #fff or #ff0048
                            var rgbRegex = new RegExp('^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$');
                            // e.g. rgb(0,255,34) or rgb(22, 0, 0)
                            var nameRegex = new RegExp('^[a-z]+$');
                            // matches just text like 'red', 'black', 'green'

                            if (hexRegex.test(color)) {
                                return color;
                            } else if (rgbRegex.test(color)) {
                                var decimalColors = rgbRegex.exec(color).slice(1);
                                for (var i = 0; i < 3; i++) {
                                    var decimalValue = parseInt(decimalColors[i]);
                                    if (decimalValue > 255) {
                                        decimalValue = 255;
                                    }
                                    var hexString = '0' + decimalValue.toString(16);
                                    hexString = hexString.slice(-2);
                                    decimalColors[i] = hexString;
                                }
                                return '#' + decimalColors.join('');
                            } else if (nameRegex.test(color)) {
                                return color;
                            } else {
                                console.error('Could not parse color "' + color + '"');
                                return color;
                            }
                        },
                        /**
                         * Extracts the style from an object
                         * @function
                         * @param {object} o       - the current object
                         * @param {object} styles  - an array with styles
                         */
                        ComputeStyle = function(o, styles) {
                            styles.forEach(function(singleStyle) {
                                var styleDefinition = singleStyle.trim().toLowerCase().split(':');
                                var style = styleDefinition[0];
                                var value = styleDefinition[1];
                                if (styleDefinition.length === 2) {
                                    switch (style) {
                                        case 'padding-left':
                                            o.margin = [parseInt(value), 0, 0, 0];
                                            break;
                                        case 'font-size':
                                            o.fontSize = parseInt(value);
                                            break;
                                        case 'text-align':
                                            switch (value) {
                                                case 'right':
                                                case 'center':
                                                case 'justify':
                                                    o.alignment = value;
                                                    break;
                                            }
                                            break;
                                        case 'font-weight':
                                            switch (value) {
                                                case 'bold':
                                                    o.bold = true;
                                                    break;
                                            }
                                            break;
                                        case 'text-decoration':
                                            switch (value) {
                                                case 'underline':
                                                    o.decoration = 'underline';
                                                    break;
                                                case 'line-through':
                                                    o.decoration = 'lineThrough';
                                                    break;
                                            }
                                            break;
                                        case 'font-style':
                                            switch (value) {
                                                case 'italic':
                                                    o.italics = true;
                                                    break;
                                            }
                                            break;
                                        case 'color':
                                            o.color = parseColor(value);
                                            break;
                                        case 'background-color':
                                            o.background = parseColor(value);
                                            break;
                                    }
                                }
                            });
                        },
                        // A little helper function to check, if an element has the given class.
                        hasClass = function (element, className) {
                            var classes = element.getAttribute('class');
                            if (classes) {
                                classes = classes.toLowerCase().split(' ');
                                return _.indexOf(classes, className) > -1;
                            } else {
                                return false;
                            }
                        },
                        // Helper function for determinating whether a parent of element is a list item.
                        isInsideAList = function (element) {
                            var parent = element.parentNode;
                            while(parent !== null) {
                                if (parent.nodeName.toLowerCase() === 'li') {
                                    return true;
                                }
                                parent = parent.parentNode;
                            }
                            return false;
                        },
                        /**
                         * Parses a single HTML element
                         * @function
                         * @param {object} alreadyConverted  -
                         * @param {object} element   -
                         * @param {object} currentParagraph -
                         * @param {object} styles -
                         * @param {number} diff_mode
                         */
                        ParseElement = function(alreadyConverted, element, currentParagraph, styles, diff_mode) {
                            styles = styles ? _.clone(styles) : [];
                            var classes = [];
                            if (element.getAttribute) {
                                var nodeStyle = element.getAttribute('style');
                                if (nodeStyle) {
                                    nodeStyle.split(';').forEach(function(nodeStyle) {
                                        var tmp = nodeStyle.replace(/\s/g, '');
                                        styles.push(tmp);
                                    });
                                }
                                var nodeClass = element.getAttribute('class');
                                if (nodeClass) {
                                    classes = nodeClass.toLowerCase().split(' ');
                                    classes.forEach(function(nodeClass) {
                                        if (typeof(classStyles[nodeClass]) != 'undefined') {
                                            classStyles[nodeClass].forEach(function(style) {
                                                styles.push(style);
                                            });
                                        }
                                        if (nodeClass == 'insert') {
                                            diff_mode = DIFF_MODE_INSERT;
                                        }
                                        if (nodeClass == 'delete') {
                                            diff_mode = DIFF_MODE_DELETE;
                                        }
                                    });
                                }
                            }
                            var nodeName = element.nodeName.toLowerCase();
                            switch (nodeName) {
                                case 'h1':
                                case 'h2':
                                case 'h3':
                                case 'h4':
                                case 'h5':
                                case 'h6':
                                    if (lineNumberMode === 'outside' &&
                                            element.childNodes.length > 0 &&
                                            element.childNodes[0].getAttribute) {
                                        // A heading may have multiple lines, so handle line by line separated by line number elements
                                        var outerStack = create('stack');
                                        var currentCol, currentText;
                                        _.forEach(element.childNodes, function (node) {
                                            if (node.getAttribute && node.getAttribute('data-line-number')) {
                                                if (currentCol) {
                                                    ComputeStyle(currentCol, elementStyles[nodeName]);
                                                    outerStack.stack.push(currentCol);
                                                }
                                                currentText = create('text');
                                                currentCol = {
                                                    columns: [
                                                        getLineNumberObject({
                                                            lineNumber: node.getAttribute('data-line-number')
                                                        }),
                                                        currentText,
                                                    ],
                                                    margin: [0, 2, 0, 0],
                                                };
                                            } else {
                                                var parsedText = ParseElement([], node, create('text'), styles, diff_mode);
                                                // append the parsed text to the currentText
                                                _.forEach(parsedText.text, function (text) {
                                                    currentText.text.push(text);
                                                });
                                            }
                                        });
                                        ComputeStyle(currentCol, elementStyles[nodeName]);
                                        outerStack.stack.push(currentCol);
                                        outerStack.margin = [0, 0, 0, 0];
                                        if (!/h[1-6]/.test(element.previousSibling.nodeName.toLowerCase())) {
                                            outerStack.margin[1] = 10;
                                        }
                                        alreadyConverted.push(outerStack);
                                    } else {
                                        currentParagraph = create('text');
                                        currentParagraph.marginBottom = 4;
                                        currentParagraph.marginTop = 10;
                                        currentParagraph = parseChildren(alreadyConverted, element, currentParagraph, styles.concat(elementStyles[nodeName]), diff_mode);
                                        alreadyConverted.push(currentParagraph);
                                    }
                                    break;
                                case 'a':
                                case 'b':
                                case 'strong':
                                case 'u':
                                case 'em':
                                case 'i':
                                case 'ins':
                                case 'del':
                                case 'strike':
                                    currentParagraph = parseChildren(alreadyConverted, element, currentParagraph, styles.concat(elementStyles[nodeName]), diff_mode);
                                    break;
                                case 'table':
                                    var t = create('table', {
                                        widths: [],
                                        body: []
                                    });
                                    var border = element.getAttribute('border');
                                    var isBorder = false;
                                    if (border) {
                                        isBorder = (parseInt(border) === 1);
                                    } else {
                                        t.layout = 'noBorders';
                                    }
                                    currentParagraph = parseChildren(t.table.body, element, currentParagraph, styles, diff_mode);
                                    var widths = element.getAttribute('widths');
                                    if (!widths) {
                                        if (t.table.body.length !== 0) {
                                            if (t.table.body[0].length !== 0)
                                                for (var k = 0; k < t.table.body[0].length; k++)
                                                    t.table.widths.push('*');
                                        }
                                    } else {
                                        var w = widths.split(',');
                                        for (var ko = 0; ko < w.length; ko++) t.table.widths.push(w[ko]);
                                    }
                                    alreadyConverted.push(t);
                                    break;
                                case 'tbody':
                                    currentParagraph = parseChildren(alreadyConverted, element, currentParagraph, styles, diff_mode);
                                    break;
                                case 'tr':
                                    var row = [];
                                    currentParagraph = parseChildren(row, element, currentParagraph, styles, diff_mode);
                                    alreadyConverted.push(row);
                                    break;
                                case 'td':
                                    currentParagraph = create('text');
                                    var st = create('stack');
                                    st.stack.push(currentParagraph);
                                    var rspan = element.getAttribute('rowspan');
                                    if (rspan)
                                        st.rowSpan = parseInt(rspan);
                                    var cspan = element.getAttribute('colspan');
                                    if (cspan)
                                        st.colSpan = parseInt(cspan);
                                    currentParagraph = parseChildren(st.stack, element, currentParagraph, styles, diff_mode);
                                    alreadyConverted.push(st);
                                    break;
                                case 'span':
                                    if (element.getAttribute('data-line-number')) {
                                        if (lineNumberMode === 'inline') {
                                            if (diff_mode !== DIFF_MODE_INSERT) {
                                                var lineNumberInline = element.getAttribute('data-line-number'),
                                                    lineNumberObjInline = {
                                                        text: lineNumberInline,
                                                        color: 'gray',
                                                        fontSize: 5
                                                    };
                                                currentParagraph.text.push(lineNumberObjInline);
                                            }
                                        } else if (lineNumberMode === 'outside') {
                                            var lineNumberOutline;
                                            if (diff_mode === DIFF_MODE_INSERT) {
                                                lineNumberOutline = '';
                                            } else {
                                                lineNumberOutline = element.getAttribute('data-line-number');
                                            }
                                            var col = {
                                                columns: [
                                                    getLineNumberObject({
                                                        lineNumber: lineNumberOutline,
                                                    }),
                                                ]
                                            };
                                            currentParagraph = create('text');
                                            currentParagraph.lineHeight = 1.25;
                                            col.columns.push(currentParagraph);
                                            alreadyConverted.push(col);
                                        }
                                    }
                                    else {
                                        currentParagraph = parseChildren(alreadyConverted, element, currentParagraph, styles, diff_mode);
                                    }
                                    break;
                                case 'br':
                                    var brParent = element.parentNode;
                                    var brParentNodeName = brParent.nodeName;
                                    //in case of no or inline-line-numbers and the ignore os-line-breaks.
                                    if ((lineNumberMode === 'inline' || lineNumberMode === 'none') &&
                                                hasClass(element, 'os-line-break')) {
                                        break;
                                    } else {
                                        currentParagraph = create('text');
                                        if (lineNumberMode === 'outside' &&
                                                brParentNodeName !== 'LI' &&
                                                element.parentNode.parentNode.nodeName !== 'LI') {
                                            if (brParentNodeName === 'INS' || brParentNodeName === 'DEL') {

                                                var hasPrevSiblingALineNumber = function (element) {
                                                    // Iterare all nodes up to the top from element.
                                                    while (element) {
                                                        if (getLineNumber(element)) {
                                                            return true;
                                                        }
                                                        if (element.previousSibling) {
                                                            element = element.previousSibling;
                                                        } else {
                                                            element = element.parentNode;
                                                        }
                                                    }
                                                    return false;
                                                };
                                                if (hasPrevSiblingALineNumber(brParent)) {
                                                     currentParagraph.margin = [20, 0, 0, 0];
                                                 }
                                             } else {
                                                 currentParagraph.margin = [20, 0, 0, 0];
                                             }
                                        }
                                        // Add a dummy line, if the next tag is a BR tag again. The line could
                                        // not be empty otherwise it will be removed and the empty line is not displayed
                                        if (element.nextSibling && element.nextSibling.nodeName === 'BR') {
                                            currentParagraph.text.push(create('text', ' '));
                                        } else if (isInsideAList(element) && lineNumberMode === 'none') {
                                            // Put a spacer there, if there is one BR in a list
                                            var spacer = create('text', ' ');
                                            spacer.lineHeight = 0.25;
                                            alreadyConverted.push(spacer);
                                        }
                                        currentParagraph.lineHeight = 1.25;
                                        alreadyConverted.push(currentParagraph);
                                    }
                                    break;
                                case 'li':
                                case 'div':
                                    currentParagraph = create('text');
                                    currentParagraph.lineHeight = 1.25;
                                    var stackDiv = create('stack');
                                    if (_.indexOf(classes, 'os-split-before') > -1) {
                                        stackDiv.listType = 'none';
                                    }
                                    if (nodeName === 'li') {
                                        stackDiv.marginBottom = LI_MARGIN_BOTTOM;
                                    }
                                    stackDiv.stack.push(currentParagraph);
                                    ComputeStyle(stackDiv, styles);
                                    currentParagraph = parseChildren(stackDiv.stack, element, currentParagraph, [], diff_mode);
                                    alreadyConverted.push(stackDiv);
                                    break;
                                case 'p':
                                    var pObjectToPush; //determine what to push later
                                    currentParagraph = create('text');
                                    // If this element is inside a list (happens if copied from word), do not set spaces
                                    // and margins. Just leave the paragraph there..
                                    if (!isInsideAList(element)) {
                                        currentParagraph.margin = [0, 0, 0, 0];
                                        if (classes.indexOf('os-split-before') === -1) {
                                            currentParagraph.margin[1] = 8;
                                        }
                                        if (classes.indexOf('insert') > -1) {
                                            currentParagraph.margin[0] = 20;
                                        }
                                    }
                                    currentParagraph.lineHeight = 1.25;
                                    var stackP = create('stack');
                                    stackP.stack.push(currentParagraph);
                                    ComputeStyle(stackP, styles);
                                    currentParagraph = parseChildren(stackP.stack, element, currentParagraph, [], diff_mode);
                                    pObjectToPush = stackP; //usually we want to push stackP
                                    if (lineNumberMode === 'outside') {
                                        if (element.childNodes.length > 0) { //if we hit = 0, the code would fail
                                            // add empty line number column for inline diff or pragraph diff mode
                                            if (element.childNodes[0].tagName === 'INS' ||
                                                element.childNodes[0].tagName === 'DEL') {
                                                var pLineNumberPlaceholder = {
                                                    width: 20,
                                                    text: '',
                                                    fontSize: 8,
                                                    margin: [0, 2, 0, 0]
                                                };
                                                var pLineNumberPlaceholderCol = {
                                                    columns: [
                                                        pLineNumberPlaceholder,
                                                        stackP
                                                    ]
                                                };
                                                pObjectToPush = pLineNumberPlaceholderCol; //overwrite the object to push
                                            }
                                        }
                                    }
                                    alreadyConverted.push(pObjectToPush);
                                    break;
                                case 'img':
                                    var path = element.getAttribute('src');
                                    var height = images[path].height;
                                    var width = images[path].width;
                                    var maxWidth = 450;
                                    var scale = 100;

                                    var style = element.getAttribute('style');
                                    if (style) {
                                        var match = style.match(/width:\s*(\d+)\%/);
                                        if (match) {
                                            scale = parseInt(match[1]);
                                        }
                                    }

                                    // scale image
                                    width = (width * scale) / 100;
                                    height = (height * scale) / 100;

                                    if (width > maxWidth) {
                                        height = (height * maxWidth) / width;
                                        width = maxWidth;
                                    }

                                    // remove trailing / for the virtual file system (there is no root)
                                    if (path.indexOf('/') === 0) {
                                        path = path.substr(1);
                                    }
                                    alreadyConverted.push({
                                        image: path,
                                        width: width,
                                        height: height,
                                    });
                                    break;
                                case 'ul':
                                case 'ol':
                                    var list = create(nodeName);
                                    if (nodeName == 'ol') {
                                        var start = element.getAttribute('start');
                                        if (start) {
                                            list.start = start;
                                        }
                                    }
                                    ComputeStyle(list, styles);
                                    if (lineNumberMode === 'outside') {
                                        var lines = extractLineNumbers(element);
                                        currentParagraph = parseChildren(list[nodeName], element, currentParagraph, styles, diff_mode);
                                        if (lines.length > 0) {
                                            var listCol = {
                                                columns: [{
                                                    width: 20,
                                                    stack: []
                                                }]
                                            };
                                            _.forEach(lines, function(line) {
                                                listCol.columns[0].stack.push(getLineNumberObject(line));
                                            });
                                            listCol.columns.push(list);
                                            if (!hasClass(element, 'os-split-before')) {
                                                listCol.margin = [0, 5, 0, 0];
                                            }
                                            alreadyConverted.push(listCol);
                                        } else {
                                            list.margin = [20, 0, 0, 0];
                                            alreadyConverted.push(list);
                                        }
                                    } else {
                                        list.margin = [0, LI_MARGIN_BOTTOM, 0, 0];
                                        currentParagraph = parseChildren(list[nodeName], element, currentParagraph, styles, diff_mode);
                                        alreadyConverted.push(list);
                                    }
                                    break;
                                default:
                                    var defaultText = create('text', element.textContent.replace(/\n/g, ''));
                                    ComputeStyle(defaultText, styles);
                                    if (!currentParagraph) {
                                        currentParagraph = {};
                                        currentParagraph.text = [];
                                    }
                                    currentParagraph.text.push(defaultText);
                                    break;
                            }
                            return currentParagraph;
                        },
                        /**
                         * Parses HTML
                         * @function
                         * @param {string} converted      -
                         * @param {object} htmlText   -
                         */
                        ParseHtml = function(converted, htmlText) {
                            var html = HTMLValidizer.validize(htmlText);
                            html = $(html.replace(/\t/g, '').replace(/\n/g, ''));
                            var emptyParagraph = create('text');
                            slice(html).forEach(function(element) {
                                ParseElement(converted, element, null, [], DIFF_MODE_NORMAL);
                            });
                        },
                        /* Returns the object to push first into every column, that represents the given line. */
                        getLineNumberObject = function (line) {
                            var standardFontsize = Config.get('general_export_pdf_fontsize').value;
                            return {
                                width: 20,
                                text: [
                                    {
                                        text: ' ', // Add a blank with the normal font size here, so in rare cases the text
                                                   // is rendered on the next page and the linenumber on the previous page.
                                        fontSize: standardFontsize,
                                        decoration: '',
                                    },
                                    {
                                        text: line.lineNumber,
                                        color: 'gray',
                                        fontSize: standardFontsize - 2,
                                        decoration: '',
                                    },
                                ],
                                marginBottom: line.marginBottom,
                                lineHeight: 1.25,
                            };
                        },
                        content = [];
                    ParseHtml(content, html);
                    return content;
                },
                /**
                 * Creates containerelements for pdfMake
                 * e.g create('text':'MyText') result in { text: 'MyText' }
                 * or complex objects create('stack', [{text:'MyText'}, {text:'MyText2'}])
                 *for units / paragraphs of text
                 *
                 * @function
                 * @param {string} name      - name of the attribute holding content
                 * @param {object} content   - the actual content (maybe empty)
                 */
                create = function(name, content) {
                    var o = {};
                    content = content || [];
                    o[name] = content;
                    return o;
                };
            return {
                convertHTML: convertHTML,
                createElement: create
            };
        };
        return {
            createInstance: createInstance
        };
    }
])

.factory('ImageConverter', [
    '$q',
    'PDFLayout',
    function ($q, PDFLayout) {
        return {
            toBase64: function (imageSources) {
                var imageMap = {};
                var imagePromises = _.map(imageSources, function (imageSource) {
                    if (imageSource) {
                        return PDFLayout.imageURLtoBase64(imageSource).then(function (imgInfo) {
                            imageMap[imageSource] = imgInfo;
                        });
                    }
                });

                return $q(function (resolve, reject) {
                    //resolve promises to get base64
                    $q.all(imagePromises).then(function() {
                        resolve(imageMap);
                    }, reject);
                });
            }
        };
    }
])

// Creates the virtual filesystem for PdfMake.
.factory('PdfVfs', [
    '$q',
    '$http',
    'Fonts',
    'Config',
    function ($q, $http, Fonts, Config) {
        var urlCache = {}; // Caches the get request. Maps urls to base64 data ready to use.

        var loadFont = function (url) {
            return $q(function (resolve, reject) {
                // Get font
                return $http.get(url, {responseType: 'blob'}).then(function (success) {
                    // Convert to base64
                    var reader = new FileReader();
                    reader.readAsDataURL(success.data);
                    reader.onloadend = function() {
                        resolve(reader.result.split(',')[1]);
                    };
                }, function (error) {
                    reject(error);
                });
            });
        };

        /*
         * Returns a map from urls to arrays of font types used by PdfMake.
         * E.g. if the font 'regular' and 'bold' have the urls 'fonts/myFont.ttf',
         * the map fould be 'fonts/myFont.ttf': ['OSFont-regular.ttf', 'OSFont-bold.ttf']
         */
        var getUrlMapping = function () {
            var urlMap = {};
            var fonts = ['regular', 'italic', 'bold', 'bold_italic'];
            _.forEach(fonts, function (font) {
                var url = Fonts.getUrl('font_' + font);
                if (!urlMap[url]) {
                    urlMap[url] = [];
                }
                urlMap[url].push('OSFont-' + font + '.ttf');
            });
            return urlMap;
        };

        /*
         * Create the virtual filesystem needed by PdfMake for the fonts. Gets the url
         * mapping and loads all fonts via get requests or the urlCache.
         * Adds all image sources to the vfs given by the imageMap.
         */
        var getVfs = function (imageMap) {
            var vfs = {};
            _.forEach(imageMap || {}, function (data, path) {
                if (path.indexOf('/') === 0) {
                    path = path.substr(1); // remove trailing /
                }
                vfs[path] = data.data.split(',')[1];
            });
            return $q(function (resolve, reject) {
                var urls = getUrlMapping();
                var promises = _.chain(urls)
                    .map(function (filenames, url) {
                        if (urlCache[url]) {
                            // Just save the cache data into vfs.
                            _.forEach(filenames, function (filename) {
                                vfs[filename] = urlCache[url];
                            });
                            return false; // No promise here, it was all cached.
                        } else {
                            // Not in the cache, get the font and save the data into vfs.
                            return loadFont(url).then(function (data) {
                                urlCache[url] = data;
                                _.forEach(filenames, function (filename) {
                                    vfs[filename] = data;
                                });
                            });
                        }
                    })
                    .filter(function (promise) {
                        return promise;
                    })
                    .value();
                $q.all(promises).then(function () {
                    resolve(vfs);
                });
            });
        };

        return {
            get: getVfs,
        };
    }
])

.factory('PdfCreate', [
    '$timeout',
    '$q',
    'gettextCatalog',
    'FileSaver',
    'PdfVfs',
    'Messaging',
    function ($timeout, $q, gettextCatalog, FileSaver, PdfVfs, Messaging) {
        var filenameMessageMap = {};
        var b64toBlob = function(b64Data) {
            var byteCharacters = atob(b64Data);
            var byteNumbers = new Array(byteCharacters.length);
            for (var i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            var byteArray = new Uint8Array(byteNumbers);
            var blob = new Blob([byteArray]);
            return blob;
        };
        var stateChange = function (state, filename, error) {
            var text, timeout;
            switch (state) {
                case 'info':
                    text = '<i class="fa fa-spinner fa-pulse fa-lg spacer-right"></i>' +
                        gettextCatalog.getString('Generating PDF file') + ' (' + filename + ') ...';
                    break;
                case 'success':
                    text = '<i class="fa fa-check fa-lg spacer-right"></i>' +
                        gettextCatalog.getString('PDF successfully generated.');
                    timeout = 3000;
                    break;
                case 'error':
                    text = '<i class="fa fa-exclamation-triangle fa-lg spacer-right"></i>' +
                        gettextCatalog.getString('Error while generating PDF file') +
                        ' (' + filename + '): <code>' + error + '</code>';
                    break;
            }
            $timeout(function () {
                filenameMessageMap[filename] = Messaging.createOrEditMessage(
                    filenameMessageMap[filename], text, state, {timeout: timeout});
            }, 1);
        };
        return {
            getBase64FromDocument: function (documentProvider) {
                return $q(function (resolve, reject) {
                    PdfVfs.get(documentProvider.getImageMap()).then(function (vfs) {
                        var pdfWorker = new Worker('/static/js/workers/pdf-worker.js');
                        pdfWorker.addEventListener('message', function (event) {
                            resolve(event.data);
                        });
                        pdfWorker.addEventListener('error', function (event) {
                            reject(event);
                        });
                        pdfWorker.postMessage(JSON.stringify({
                            pdfDocument: documentProvider.getDocument(),
                            vfs: vfs,
                        }));
                    });
                });
            },
            // Struckture of pdfDocuments: { filname1: doc, filename2: doc, ...}
            getBase64FromMultipleDocuments: function (pdfDocuments) {
                // concat all image sources together
                var imageMap = {};
                _.forEach(pdfDocuments, function (doc) {
                    _.forEach(doc.getImageMap(), function (data, path) {
                        if (!imageMap[path]) {
                            imageMap[path] = data;
                        }
                    });
                });
                return $q(function (resolve, reject) {
                    PdfVfs.get(imageMap).then(function (vfs) {
                        var pdfWorker = new Worker('/static/js/workers/pdf-worker.js');
                        var resultCount = 0;
                        var base64Map = {}; // Maps filename to base64
                        pdfWorker.addEventListener('message', function (event) {
                            resultCount++;
                            var data = JSON.parse(event.data);
                            base64Map[data.filename] = data.base64;
                            if (resultCount === _.keys(pdfDocuments).length) {
                                resolve(base64Map);
                            }
                        });
                        pdfWorker.addEventListener('error', function (event) {
                            reject(event);
                        });
                        _.forEach(pdfDocuments, function (doc, filename) {
                            pdfWorker.postMessage(JSON.stringify({
                                filename: filename,
                                pdfDocument: doc.getDocument(),
                                vfs: vfs,
                            }));
                        });
                    });
                });
            },
            download: function (documentProvider, filename) {
                stateChange('info', filename);

                this.getBase64FromDocument(documentProvider).then(function (data) {
                    var blob = b64toBlob(data);
                    stateChange('success', filename);
                    FileSaver.saveAs(blob, filename);
                }, function (error) {
                    stateChange('error', filename, error.message);
                });
            },
        };
    }
]);

}());

(function () {

'use strict';

// The core module for the OpenSlides projector
angular.module('OpenSlidesApp.core.projector', ['OpenSlidesApp.core'])

// Can be used to find out if the projector or the side is used
.constant('REALM', 'projector')

.run([
    '$http',
    'autoupdate',
    'DS',
    function ($http, autoupdate, DS) {
        autoupdate.newConnect();

        // If the connection aborts, we try to ping the server with whoami requests. If
        // the server is flushed, we clear the datastore, so the message 'this projector
        // cannot be shown' will be displayed. Otherwise establish the websocket connection.
        autoupdate.registerRetryConnectCallback(function () {
            return $http.get('/users/whoami').then(function (success) {
                if (success.data.user_id === null && !success.data.guest_enabled) {
                    DS.clear();
                } else {
                    autoupdate.newConnect();
                }
            });
        });
    }
])

// Provider to register slides in a .config() statement.
.provider('slides', [
    function() {
        var slidesMap = {};

        this.registerSlide = function(name, config) {
            slidesMap[name] = config;
            return this;
        };

        this.$get = function($templateRequest, $q) {
            var self = this;
            return {
                getElements: function(projector) {
                    var elements = [];
                    var factory = this;
                    _.forEach(projector.elements, function(element) {
                        if (element.name in slidesMap) {
                            element.template = slidesMap[element.name].template;
                            elements.push(element);
                        } else {
                            console.error("Unknown slide: " + element.name);
                        }
                    });
                    return elements;
                }
            };
        };
    }
])

.config([
    'slidesProvider',
    function(slidesProvider) {
        slidesProvider.registerSlide('core/clock', {
            template: 'static/templates/core/slide_clock.html',
        });

        slidesProvider.registerSlide('core/countdown', {
            template: 'static/templates/core/slide_countdown.html',
        });

        slidesProvider.registerSlide('core/projector-message', {
            template: 'static/templates/core/slide_message.html',
        });
    }
])

.controller('LanguageAndFontCtrl', [
    '$scope',
    'Languages',
    'Config',
    'Projector',
    'ProjectorID',
    'Fonts',
    function ($scope, Languages, Config, Projector, ProjectorID, Fonts) {
        // for the dynamic title
        $scope.projectorId = ProjectorID();
        $scope.$watch(function () {
            return Projector.lastModified($scope.projectorId);
        }, function () {
            var projector = Projector.get($scope.projectorId);
            if (projector) {
                $scope.projectorName = projector.name;
            }
        });

        $scope.$watch(function () {
            return Config.lastModified('projector_language');
        }, function () {
            var lang = Config.get('projector_language');
            if (!lang || lang.value == 'browser') {
                $scope.selectedLanguage = Languages.getBrowserLanguage();
            } else {
                $scope.selectedLanguage = lang.value;
            }
            Languages.setCurrentLanguage($scope.selectedLanguage);
        });

        $scope.$watch(function () {
            return Config.lastModified('font_regular') +
                Config.lastModified('font_italic') +
                Config.lastModified('font_bold') +
                Config.lastModified('font_bold_italic');
        }, function () {
            $scope.font = Fonts.getForCss('font_regular');
            $scope.font_medium = Fonts.getForCss('font_italic');
            $scope.font_condensed = Fonts.getForCss('font_bold');
            $scope.font_condensed_light = Fonts.getForCss('font_bold_italic');
        });
    }
])

// Projector Container Controller
.controller('ProjectorContainerCtrl', [
    '$scope',
    '$timeout',
    '$location',
    'gettext',
    'Projector',
    function($scope, $timeout, $location, gettext, Projector) {
        $scope.showError = true;

        // watch for changes in Projector
        $scope.$watch(function () {
            return Projector.lastModified($scope.projectorId);
        }, function () {
            var projector = Projector.get($scope.projectorId);
            if (projector) {
                $scope.showError = false;
                $scope.projectorWidth = projector.width;
                $scope.projectorHeight = projector.height;
                $scope.recalculateIframe();
            } else {
                $scope.showError = true;
                // delay displaying the error message, because with a slow internet
                // connection, the autoupdate with the projector may be delayed. We
                // de not want to irritate the user by showing this error to early.
                $scope.error = '';
                $timeout(function () {
                    if ($scope.showError) {
                        $scope.error = gettext('Can not open the projector.');
                    }
                }, 3000);
            }
        });

        // recalculate the actual Iframesize and scale
        $scope.recalculateIframe = function () {
            var scale_width = window.innerWidth / $scope.projectorWidth;
            var scale_height = window.innerHeight / $scope.projectorHeight;

            // Iframe has to be scaled down or saceUp is activated
            if (scale_width <= scale_height) {
                // width is the reference
                $scope.iframeWidth = window.innerWidth;
                $scope.scale = scale_width;
                $scope.iframeHeight = $scope.projectorHeight * scale_width;
            } else {
                // height is the reference
                $scope.iframeHeight = window.innerHeight;
                $scope.scale = scale_height;
                $scope.iframeWidth = $scope.projectorWidth * scale_height;
            }
        };

        // watch for changes in the windowsize
        $(window).on("resize.doResize", function () {
            $scope.$apply(function() {
                $scope.recalculateIframe();
            });
        });

        $scope.$on("$destroy",function (){
            $(window).off("resize.doResize");
        });
    }
])

.controller('ProjectorCtrl', [
    '$scope',
    '$location',
    '$timeout',
    'Projector',
    'slides',
    'Config',
    'ProjectorID',
    'Logos',
    function($scope, $location, $timeout, Projector, slides, Config, ProjectorID, Logos) {
        var projectorId = ProjectorID();

        $scope.broadcast = 0;

        var setElements = function (projector) {
            // Get all elements, that should be projected.
            var newElements = [];
            var enable_clock = Config.get('projector_enable_clock');
            enable_clock = enable_clock ? enable_clock.value : true;
            _.forEach(slides.getElements(projector), function (element) {
                if (!element.error) {
                    // Exclude the clock if it should be disabled.
                    if (enable_clock || element.name !== 'core/clock') {
                        newElements.push(element);
                    }
                } else {
                    console.error("Error for slide " + element.name + ": " + element.error);
                }
            });

            // Now we have to align $scope.elements to newElements:
            // We cannot just assign them, because the ng-repeat would reload every
            // element. This should be prevented (see #3259). To change $scope.elements:
            // 1) remove all elements from scope, that are not in newElements (compared by the uuid)
            // 2) Every new element in newElements, that is not in $scope.elements, get inserted there.
            // 3) If there is the same element in newElements and $scope.elements every changed property
            //    is copied from the new element to the scope element.

            $scope.elements = _.filter($scope.elements, function (element) {
                return _.some(newElements, function (newElement) {
                    return element.uuid === newElement.uuid;
                });
            });

            _.forEach(newElements, function (newElement) {
                var matchingElement = _.find($scope.elements, function (element) {
                    return element.uuid === newElement.uuid;
                });
                if (matchingElement) {
                    // copy all changed properties.
                    _.forEach(newElement, function (value, key) {
                        // key has own property and does not start with a '$'.
                        if (newElement.hasOwnProperty(key) && key.indexOf('$') != 0) {
                            if (typeof matchingElement[key] === 'undefined' || matchingElement[key] !== value) {
                                matchingElement[key] = value;
                            }
                        }
                    });
                } else {
                    $scope.elements.push(newElement);
                }
            });
        };

        $scope.scroll = 0;
        var setScroll = function (scroll) {
            $scope.scroll = -250 * scroll;
        };

        $scope.$watch(function () {
            return Projector.lastModified(projectorId);
        }, function () {
            $scope.projector = Projector.get(projectorId);
            if ($scope.projector) {
                if ($scope.broadcast === 0) {
                    setElements($scope.projector);
                    $scope.blank = $scope.projector.blank;
                }
                setScroll($scope.projector.scroll);
            } else {
                // Blank projector on error
                $scope.elements = [];
                $scope.projector = {
                    scale: 0,
                    blank: true
                };
                setScroll(0);
            }
        });

        $scope.$watch(function () {
            return Config.lastModified('projector_broadcast');
        }, function () {
            var bc = Config.get('projector_broadcast');
            if (bc) {
                if ($scope.broadcast != bc.value) {
                    $scope.broadcast = bc.value;
                    if ($scope.broadcastDeregister) {
                        // revert to original $scope.projector
                        $scope.broadcastDeregister();
                        $scope.broadcastDeregister = null;
                        setElements($scope.projector);
                        $scope.blank = $scope.projector.blank;
                    }
                }
                if ($scope.broadcast > 0) {
                    // get elements and blank from broadcast projector
                    $scope.broadcastDeregister = $scope.$watch(function () {
                        return Projector.lastModified($scope.broadcast);
                    }, function () {
                        if ($scope.broadcast > 0) {
                            var broadcast_projector = Projector.get($scope.broadcast);
                            if (broadcast_projector) {
                                setElements(broadcast_projector);
                                $scope.blank = broadcast_projector.blank;
                            }
                        }
                    });
                }
            }
        });

        $scope.$watch(function () {
            return Config.lastModified('projector_enable_clock');
        }, function () {
            setElements($scope.projector);
        });

        $scope.$on('$destroy', function() {
            if ($scope.broadcastDeregister) {
                $scope.broadcastDeregister();
                $scope.broadcastDeregister = null;
            }
        });
    }
])

.controller('SlideClockCtrl', [
    '$scope',
    '$interval',
    function($scope, $interval) {
        // Attention! Each object that is used here has to be dealt on server side.
        // Add it to the coresponding get_requirements method of the ProjectorElement
        // class.
        $scope.servertime = ( Date.now() / 1000 - $scope.serverOffset ) * 1000;
        var interval = $interval(function () {
            $scope.servertime = ( Date.now() / 1000 - $scope.serverOffset ) * 1000;
        }, 30000); // Update the clock every 30 seconds

        $scope.$on('$destroy', function() {
            if (interval) {
                $interval.cancel(interval);
            }
        });
    }
])

.controller('SlideCountdownCtrl', [
    '$scope',
    '$interval',
    'Countdown',
    function($scope, $interval, Countdown) {
        // Attention! Each object that is used here has to be dealt on server side.
        // Add it to the coresponding get_requirements method of the ProjectorElement
        // class.
        var id = $scope.element.id;
        var interval;
        var calculateCountdownTime = function (countdown) {
            countdown.seconds = Math.floor( $scope.countdown.countdown_time - Date.now() / 1000 + $scope.serverOffset );
        };
        $scope.$watch(function () {
            return Countdown.lastModified(id);
        }, function () {
            $scope.countdown = Countdown.get(id);
            if (interval) {
                $interval.cancel(interval);
            }
            if ($scope.countdown) {
                if ($scope.countdown.running) {
                    calculateCountdownTime($scope.countdown);
                    interval = $interval(function () { calculateCountdownTime($scope.countdown); }, 1000);
                } else {
                    $scope.countdown.seconds = $scope.countdown.countdown_time;
                }
            }
        });
        $scope.$on('$destroy', function() {
            // Cancel the interval if the controller is destroyed
            if (interval) {
                $interval.cancel(interval);
            }
        });
    }
])

.controller('SlideMessageCtrl', [
    '$scope',
    'ProjectorMessage',
    'Projector',
    'ProjectorID',
    'gettextCatalog',
    function($scope, ProjectorMessage, Projector, ProjectorID, gettextCatalog) {
        // Attention! Each object that is used here has to be dealt on server side.
        // Add it to the coresponding get_requirements method of the ProjectorElement
        // class.
        var id = $scope.element.id;

        if ($scope.element.identify) {
            var projector = Projector.get(ProjectorID());
            $scope.identifyMessage = gettextCatalog.getString('Projector') + ' ' + projector.id + ': ' + gettextCatalog.getString(projector.name);
        } else {
            $scope.message = ProjectorMessage.get(id);
            ProjectorMessage.bindOne(id, $scope, 'message');
        }
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.core.remove-format-plugin', [
    'OpenSlidesApp.core',
])

/*
 * Plugin for the CKEditor that hooks into the removeformat plugin
 * which is a default plugin enabled by 'cleanup' in the config
 * toolbar.
 * We change the behavior of the removeformat command here:
 * It should not remove any tags and styles, but only the
 * 'DISALLOWED_STYLES'. Removeformat traverses through the DOM
 * and calles for every element the custom filter down below.
 * We change the element and return false, so the removeformat
 * plugin does not clean it up.
 */
.factory('OSRemoveFormatPlugin', [
    'Editor',
    'gettextCatalog',
    function (Editor, gettextCatalog) {
        var DISALLOWED_STYLES = ['color', 'background-color'];
        return {
            getPlugin: function () {
                return {
                    init: function (editor) {
                        editor.addRemoveFormatFilter(function (element) {
                            _.forEach(DISALLOWED_STYLES, function (style) {
                                element.removeStyle(style);
                            });
                            return false;
                        });
                    },
                };
            },
        };
    }
])

.run([
    'Editor',
    'OSRemoveFormatPlugin',
    function (Editor, OSRemoveFormatPlugin, gettext) {
        Editor.registerPlugin('OSRemoveFormat', OSRemoveFormatPlugin.getPlugin());
    }
]);

}());

(function () {

'use strict';

// The core module for the OpenSlides site
angular.module('OpenSlidesApp.core.site', [
    'OpenSlidesApp.core',
    'OpenSlidesApp.core.start',
    'OpenSlidesApp.core.csv',
    'OpenSlidesApp.core.remove-format-plugin',
    'OpenSlidesApp.poll.majority',
    'ui.router',
    'colorpicker.module',
    'formly',
    'formlyBootstrap',
    'localytics.directives',
    'ngDialog',
    'ngFileSaver',
    'ngMessages',
    'ckeditor',
    'luegg.directives',
    'xeditable',
    'rzModule',
])

// Can be used to find out if the projector or the side is used
.constant('REALM', 'site')

.factory('DateTimePickerTranslation', [
    'gettextCatalog',
    function (gettextCatalog) {
        return {
            getButtons: function () {
                return {
                    show: true,
                    now: {
                        show: true,
                        text: gettextCatalog.getString('now')
                    },
                    today: {
                        show: true,
                        text: gettextCatalog.getString('today')
                    },
                    clear: {
                        show: true,
                        text: gettextCatalog.getString('clear')
                    },
                    date: {
                        show: true,
                        text: gettextCatalog.getString('date')
                    },
                    time: {
                        show: true,
                        text: gettextCatalog.getString('time')
                    },
                    close: {
                        show: true,
                        text: gettextCatalog.getString('close')
                    }
                };
            }
        };
    }

])

// Provider to register entries for the main menu.
.provider('mainMenu', [
    function() {
        var mainMenuList = [];
        var scope;

        this.register = function(config) {
            mainMenuList.push(config);
        };

        this.$get = ['operator', function(operator) {
            return {
                registerScope: function (scope) {
                    this.scope = scope;
                },
                updateMainMenu: function () {
                    if (this.scope) {
                        this.scope.elements = this.getElements();
                    }
                },
                getElements: function() {
                    var elements = mainMenuList.filter(function (element) {
                        return typeof element.perm === "undefined" || operator.hasPerms(element.perm);
                    });

                    elements.sort(function (a, b) {
                        return a.weight - b.weight;
                    });
                    return elements;
                }
            };
        }];
    }
])

// Provider to register a searchable module/app.
.provider('Search', [
    function() {
        var searchModules = [];

        this.register = function(module) {
            searchModules.push(module);
        };

        this.$get = [
            function () {
                return {
                    getAll: function () {
                        return searchModules;
                    }
                };
            }
        ];
    }
])

.run([
    'editableOptions',
    'gettext',
    function (editableOptions, gettext) {
        editableOptions.theme = 'bs3';
        editableOptions.cancelButtonAriaLabel = gettext('Cancel');
        editableOptions.cancelButtonTitle = gettext('Cancel');
        editableOptions.clearButtonAriaLabel = gettext('Clear');
        editableOptions.clearButtonTitle = gettext('Clear');
        editableOptions.submitButtonAriaLabel = gettext('Submit');
        editableOptions.submitButtonTitle = gettext('Submit');
    }
])

.factory('WebpageTitle', [
    '$rootScope',
    function ($rootScope) {
        $rootScope.activeAppTitle = '';
        return {
            updateTitle: function (text) {
                $rootScope.activeAppTitle = text || '';
            },
        };
    }
])

// Watch for the basePerm on a stateChange and initialize the WebpageTitle factory
.run([
    '$rootScope',
    'operator',
    'WebpageTitle',
    function ($rootScope, operator, WebpageTitle) {
        $rootScope.$on('$stateChangeSuccess', function(event, toState) {
            WebpageTitle.updateTitle(toState.data ? toState.data.title : '');
            if (toState.data) {
                $rootScope.baseViewPermissionsGranted = toState.data.basePerm ?
                    operator.hasPerms(toState.data.basePerm) : true;
            } else {
                $rootScope.baseViewPermissionsGranted = true;
            }
            // Scroll to top on every state change
            $rootScope.gotoTop();
        });
    }
])

// Make the main content expandable
.run([
    '$rootScope',
    function ($rootScope) {
        $rootScope.$on('$stateChangeSuccess', function() {
            $rootScope.expandContent = false;
        });
        $rootScope.toggleExpandContent = function () {
            $rootScope.expandContent = !$rootScope.expandContent;
        };
    }
])

.config([
    'mainMenuProvider',
    'gettext',
    function (mainMenuProvider, gettext) {
        mainMenuProvider.register({
            'ui_sref': 'home',
            'img_class': 'home',
            'title': gettext('Home'),
            'weight': 100,
            'perm': 'core.can_see_frontpage',
        });

        mainMenuProvider.register({
            'ui_sref': 'config',
            'img_class': 'cog',
            'title': gettext('Settings'),
            'weight': 1000,
            'perm': 'core.can_manage_config',
        });
    }
])

.config([
    '$urlRouterProvider',
    '$locationProvider',
    function($urlRouterProvider, $locationProvider) {
        // define fallback url and html5Mode
        $urlRouterProvider.otherwise('/');
        $locationProvider.html5Mode(true);
    }
])

.config([
    '$httpProvider',
    function($httpProvider) {
        // Combine the django csrf system with the angular csrf system
        $httpProvider.defaults.xsrfCookieName = 'OpenSlidesCsrfToken';
        $httpProvider.defaults.xsrfHeaderName = 'X-CSRFToken';
    }
])


.config([
    '$stateProvider',
    '$urlMatcherFactoryProvider',
    function($stateProvider, $urlMatcherFactoryProvider) {
        // Make the trailing slash optional
        $urlMatcherFactoryProvider.strictMode(false);

        // Use stateProvider.decorator to give default values to our states
        $stateProvider.decorator('views', function(state, parent) {
            var result = {},
                views = parent(state);

            if (state.abstract || state.data && state.data.extern) {
                return views;
            }

            angular.forEach(views, function(config, name) {
                // Sets additional default values for templateUrl
                var templateUrl,
                    controller,
                    defaultControllers = {
                        create: 'CreateCtrl',
                        update: 'UpdateCtrl',
                        list: 'ListCtrl',
                        detail: 'DetailCtrl',
                    };

                // Split up state name
                // example: "motions.motion.detail.update" -> ['motions', 'motion', 'detail', 'update']
                var patterns = state.name.split('.');

                // set app and module name from state
                // - appName: patterns[0] (e.g. "motions")
                // - moduleNames: patterns without first element (e.g. ["motion", "detail", "update"])
                var appName = '';
                var moduleName = '';
                var moduleNames = [];
                if (patterns.length > 0) {
                    appName = patterns[0];
                    moduleNames = patterns.slice(1);
                }
                if (moduleNames.length > 0) {
                    // convert from camcelcase to dash notation
                    // example: ["motionBlock", "detail"] -> ["motion-block", "detail"]
                    for (var i = 0; i < moduleNames.length; i++) {
                        moduleNames[i] =  moduleNames[i].replace(/([a-z\d])([A-Z])/g, '$1-$2').toLowerCase();
                    }

                    // use special templateUrl for create and update view
                    // example: ["motion", "detail", "update"] -> "motion-form"
                    if (_.last(moduleNames).match(/(create|update)/)) {
                        moduleName = '/' + moduleNames[0] + '-form';
                    } else {
                        // convert modelNames array to url string
                        // example: ["motion-block", "detail"] -> "motion-block-detail"
                        moduleName = '/' + moduleNames.join('-');
                    }
                }
                templateUrl = 'static/templates/' + appName + moduleName + '.html';
                config.templateUrl = state.templateUrl || templateUrl;

                // controller
                if (patterns.length >= 3) {
                    controller = _.upperFirst(patterns[1]) + defaultControllers[_.last(patterns)];
                    config.controller = state.controller || controller;
                }
                result[name] = config;
            });
            return result;
        })

        .decorator('url', function(state, parent) {
            var defaultUrl;

            if (state.abstract) {
                defaultUrl = '';
            } else {
                var patterns = state.name.split('.'),
                    defaultUrls = {
                        create: '/new',
                        update: '/edit',
                        list: '',
                        // The id is expected to be an integer, if not, the url has to
                        // be defined manually
                        detail: '/{id:int}',
                    };

                defaultUrl = defaultUrls[_.last(patterns)];
            }

            state.url = state.url || defaultUrl;
            return parent(state);
        });
    }
])

.config([
    '$stateProvider',
    '$locationProvider',
    'gettext',
    function($stateProvider, $locationProvider, gettext) {
        // Core urls
        $stateProvider
            .state('home', {
                url: '/',
                templateUrl: 'static/templates/home.html',
                data: {
                    title: gettext('Home'),
                    basePerm: 'core.can_see_frontpage',
                },
            })
            .state('projector', {
                url: '/projector/{id:int}/',
                templateUrl: 'static/templates/projector-container.html',
                data: {extern: true},
                onEnter: function($window) {
                    $window.location.href = this.url;
                }
            })
            .state('real-projector', {
                url: '/real-projector/{id:int}/',
                templateUrl: 'static/templates/projector.html',
                data: {extern: true},
                onEnter: function($window) {
                    $window.location.href = this.url;
                }
            })
            .state('manage-projectors', {
                url: '/manage-projectors',
                templateUrl: 'static/templates/core/manage-projectors.html',
                controller: 'ManageProjectorsCtrl',
                data: {
                    title: gettext('Manage projectors'),
                    basePerm: 'core.can_manage_projector',
                },
            })
            .state('core', {
                url: '/core',
                abstract: true,
                template: "<ui-view/>",
            })

            // legal notice and version
            .state('legalnotice', {
                url: '/legalnotice',
                controller: 'LegalNoticeCtrl',
                data: {
                    title: gettext('Legal notice'),
                },
            })

            // privacy policy
            .state('privacypolicy', {
                url: '/privacypolicy',
                controller: 'PrivacyPolicyCtrl',
                data: {
                    title: gettext('Privacy policy'),
                },
            })

            //config
            .state('config', {
                url: '/config',
                controller: 'ConfigCtrl',
                data: {
                    title: gettext('Settings'),
                    basePerm: 'core.can_manage_config',
                },
            })

            // search
            .state('search', {
                url: '/search?q',
                controller: 'SearchCtrl',
                templateUrl: 'static/templates/search.html',
                data: {
                    title: gettext('Search'),
                },
            })

            // tag
            .state('core.tag', {
                url: '/tag',
                abstract: true,
                template: "<ui-view/>",
                data: {
                    title: gettext('Tags'),
                    basePerm: 'core.can_manage_tags',
                },
            })
            .state('core.tag.list', {})

            // Countdown
            .state('core.countdown', {
                url: '/countdown',
                abstract: true,
                template: "<ui-view/>",
                data: {
                    title: gettext('Countdown'),
                    basePerm: 'core.can_manage_projector',
                },
            })
            .state('core.countdown.detail', {
                resolve: {
                    countdownId: ['$stateParams', function($stateParams) {
                        return $stateParams.id;
                    }],
                }
            });

        $locationProvider.html5Mode(true);
    }
])

.factory('ProjectorMessageForm', [
    'Editor',
    'gettextCatalog',
    function (Editor, gettextCatalog) {
        return {
            getDialog: function (message) {
                return {
                    template: 'static/templates/core/projector-message-form.html',
                    controller: 'ProjectorMessageEditCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        projectorMessageId: function () {
                            return message.id;
                        }
                    },
                };
            },
            getFormFields: function () {
                return [
                    {
                        key: 'message',
                        type: 'editor',
                        templateOptions: {
                            label: gettextCatalog.getString('Message'),
                        },
                        data: {
                            ckeditorOptions: Editor.getOptions()
                        }
                    },
                ];
            },
        };
    }
])

.factory('TagForm', [
    'gettextCatalog',
    function (gettextCatalog) {
        return {
            getDialog: function (tag) {
                return {
                    template: 'static/templates/core/tag-form.html',
                    controller: (tag) ? 'TagUpdateCtrl' : 'TagCreateCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        tagId: function () {return tag ? tag.id : void 0;},
                    },
                };
            },
            getFormFields: function() {
                return [
                    {
                        key: 'name',
                        type: 'input',
                        templateOptions: {
                            label: gettextCatalog.getString('Name'),
                            required: true
                        }
                    },
                ];
            },
        };
    }
])

/* This factory handles the filtering of the OS-data-tables. It contains
 * all logic needed for the table header filtering. Things to configure:
 * - multiselectFilters: A dict associating the filter name to a list (empty per default). E.g.
 *       { tag: [],
 *         category: [], }
 * - booleanFilters: A dict containing a dict for every filter. The value property is a must.
 *   For displaying properties like displayName, choiceYes and choiceNo could be usefull. E.g.
 *      { isPresent: {
 *          value: undefined,
 *          displayName: gettext('Is present'), } }
 * - propertyList, propertyFunctionList, propertyDict: See function getObjectQueryString
 */
.factory('osTableFilter', [
    '$sessionStorage',
    function ($sessionStorage) {
        var createInstance = function (tableName) {
            var self = {
                multiselectFilters: {},
                booleanFilters: {},
                filterString: '',
            };
            var existsStorageEntry = function () {
                return $sessionStorage[tableName];
            };
            var storage = existsStorageEntry();
            if (storage) {
                self = storage;
            }

            self.existsStorageEntry = existsStorageEntry;
            self.save = function () {
                $sessionStorage[tableName] = self;
                self.changed();
            };
            self.areFiltersSet = function () {
                var areFiltersSet = _.find(self.multiselectFilters, function (filterList) {
                    return filterList.length > 0;
                });
                areFiltersSet = areFiltersSet || _.find(self.booleanFilters, function (filterDict) {
                    return filterDict.value !== undefined;
                });
                areFiltersSet = areFiltersSet || (self.filterString !== '');
                return areFiltersSet !== false;
            };
            self.reset = function (danger) {
                if (danger) {
                    return;
                }
                _.forEach(self.multiselectFilters, function (filterList, filter) {
                    self.multiselectFilters[filter] = [];
                });
                _.forEach(self.booleanFilters, function (filterDict, filter) {
                    self.booleanFilters[filter].value = undefined;
                });
                self.filterString = '';
                self.save();
            };
            self.operateMultiselectFilter = function (filter, id, danger) {
                if (!danger) {
                    if (_.indexOf(self.multiselectFilters[filter], id) > -1) {
                        // remove id
                        self.multiselectFilters[filter].splice(_.indexOf(self.multiselectFilters[filter], id), 1);
                    } else {
                        // add id
                        self.multiselectFilters[filter].push(id);
                    }
                    self.save();
                }
            };
            /* Three things are could be given to create the query string:
             * - propertyList: Just a list of object's properties like ['title', 'name']
             * - propertyFunktionList: A list of functions returning a property (e.g. [function(motion) {return motion.getTitle();}] for retrieving the motions title)
             * - propertyDict: A dict association properties that are lists to functions on how to handle them.
             *   E.g.: {'tags': function (tag) {return tag.name;}, }
             *         The list of tags will be mapped with this function to a list of strings (tag names).
             */
            self.getObjectQueryString = function (obj) {
                var stringList = [];
                _.forEach(self.propertyList, function (property) {
                    stringList.push(obj[property]);
                });
                _.forEach(self.propertyFunctionList, function (fn) {
                    stringList.push(fn(obj));
                });
                _.forEach(self.propertyDict, function (idFunction, property) {
                    stringList.push(_.map(obj[property], idFunction).join(' '));
                });
                return stringList.join(' ');
            };
            // Stub for callback
            self.changed = function () {};
            return self;
        };

        return {
            createInstance: createInstance
        };
    }
])

/* This factory takes care of the sorting of OS-data-tables. Things to configure:
 * - column: the default column which is the list sorted by (e.g.
 *   instance.column='title')
 */
.factory('osTableSort', [
    '$sessionStorage',
    function ($sessionStorage) {
        var createInstance = function (tableName) {
            var self = {
                column: '',
                reverse: false,
            };
            var storage = $sessionStorage[tableName];
            if (storage) {
                self = storage;
            }

            self.save = function () {
                $sessionStorage[tableName] = self;
            };
            self.toggle = function (column) {
                if (self.column === column) {
                    self.reverse = !self.reverse;
                }
                self.column = column;
                self.save();
            };
            return self;
        };

        return {
            createInstance: createInstance
        };
    }
])

/* Factory for pagination of the tables. Saves all settings (currentPage, ...)
 * to the session storage and recovers them when the table is reloaded.
 * You have to provide a 'tableName' where the settings are saved in the session
 * storage. Has to be unique for obvious reasons.
 * The 'itemsPerPage' is optional. If not given, it defaults to 25.
 */
.factory('osTablePagination', [
    '$rootScope',
    '$sessionStorage',
    function ($rootScope, $sessionStorage) {
        var createInstance = function (tableName, itemsPerPage) {
            // Defaults
            var self = {
                currentPage: 1,
                itemsPerPage: itemsPerPage || 25,
                limitBegin: 0,
            };

            // Check storage; maybe recover old state.
            var storage = $sessionStorage[tableName];
            if (storage) {
                self = storage;
            }

            self.save = function () {
                $sessionStorage[tableName] = self;
            };
            self.pageChanged = function () {
                self.limitBegin = (self.currentPage - 1) * self.itemsPerPage;
                self.save();
                $rootScope.gotoTop();
            };
            self.getPageCount = function (objs) {
                if (objs) {
                    return Math.ceil(objs.length/self.itemsPerPage);
                }
            };
            self.showNextPageArrow = function (objs) {
                if (objs) {
                    return self.currentPage != self.getPageCount(objs);
                }
            };
            self.showPrevPageArrow = function () {
                return self.currentPage != 1;
            };
            self.nextPage = function (objs) {
                if (objs && self.currentPage < self.getPageCount(objs)) {
                    self.currentPage++;
                    self.pageChanged();
                }
            };
            self.prevPage = function () {
                if (self.currentPage > 1) {
                    self.currentPage--;
                    self.pageChanged();
                }
            };
            return self;
        };

        return {
            createInstance: createInstance
        };
    }
])

/* This Factory could be used in any dialog, if the user should be warned, if another user
 * also has this dialog open. Use it like in this example in any dialog controller:
      var editingStoppedCallback = EditingWarning.editingStarted('editing_name' + item.id);
      $scope.$on('$destroy', editingStoppedCallback);
 */
.factory('EditingWarning', [
    'operator',
    'gettextCatalog',
    'Notify',
    'Messaging',
    function (operator, gettextCatalog, Notify, Messaging) {
        return {
            // This returns the callback function that the controller should call, if
            // the dialog got closed by the user. Provide a unique dialog name.
            editingStarted: function (dialogName) {
                // List of active editors
                var editorNames = [];
                var messagingId = dialogName + 'EditingWarning';
                // Add an editor (may come from open_request or open_response)
                var addActiveEditor = function (editorName) {
                    editorNames.push(editorName);
                    updateActiveEditors();
                };
                // Remove an editor, if he closes his dialog (dialog_closed)
                var removeActiveEditor = function (editorName) {
                    var firstIndex = _.indexOf(editorNames, editorName);
                    editorNames.splice(firstIndex, 1);
                    updateActiveEditors();
                };
                // Show a warning.
                var updateActiveEditors = function () {
                    if (editorNames.length === 0) {
                        Messaging.deleteMessage(messagingId);
                    } else {
                        // This block is only for getting the message string together...
                        var editorsWithoutAnonymous = _.filter(editorNames, function (name) {
                            return name;
                        });
                        var text = gettextCatalog.getString('Warning') + ': ';
                        if (editorsWithoutAnonymous.length === 0) { // Only anonymous
                            // Singular vs. plural
                            if (editorNames.length === 1) {
                                text += gettextCatalog.getString('One anonymous users is also editing this.');
                            } else {
                                text += editorNames.length + ' ' + gettextCatalog.getString('anonymous users are also editing this.');
                            }
                        } else {
                            // At least one named user. The max users to display is 5. Anonymous users doesn't get displayed
                            // by name, but the amount of users is shown.
                            text += _.slice(editorsWithoutAnonymous, 0, 5).join(', ');
                            if (editorsWithoutAnonymous.length > 5) {
                                // More than 5 users with names.
                                text += ', ... [+' + (editorNames.length - 5) + ']';
                            } else if (editorsWithoutAnonymous.length !== editorNames.length) {
                                // Less than 5 users, so the difference is calculated different.
                                text += ', ... [+' + (editorNames.length - editorsWithoutAnonymous.length) + ']';
                            }
                            // Singular vs. plural
                            if (editorNames.length === 1) {
                                text += ' ' + gettextCatalog.getString('is also editing this.');
                            } else {
                                text += ' ' + gettextCatalog.getString('are also editing this.');
                            }
                        }
                        Messaging.createOrEditMessage(messagingId, text, 'warning');
                    }
                };

                // The stucture of determinating which users are editing this dialog:
                // - send an open_query to every user with the name of this operator in the parameter. With
                //   this information all clients that listen to this request knows that this operator has
                //   opened the dialog.
                // - The clients, which have recieved the query send an answer (open_resonse) to this operator.
                // - The operator collects all resonses and fills the editornames list.
                // - If the dialog get closed, a dialog_closed is send. All recieven clients remove this
                //   operato from their editorNames list.
                var responseCallbackId = Notify.registerCallback(dialogName + '_open_response', function (notify) {
                    if (!notify.sendBySelf) {
                        addActiveEditor(notify.params.name);
                    }
                });
                var queryCallbackId = Notify.registerCallback(dialogName + '_open_query', function (notify) {
                    if (!notify.sendBySelf) {
                        addActiveEditor(notify.params.name);
                        if (notify.senderUserId) {
                            Notify.notify(dialogName + '_open_response', {
                                name: operator.user ? operator.user.short_name : '',
                            }, [notify.senderUserId]);
                        } else {
                            Notify.notify(dialogName + '_open_response', {
                                name: operator.user ? operator.user.short_name : '',
                            }, null, [notify.senderReplyChannelName]);
                        }
                    }
                });
                var closeCallbackId = Notify.registerCallback(dialogName + '_dialog_closed', function (notify) {
                    removeActiveEditor(notify.params.name);
                });
                // Send here the open_query to get the notify-chain started.
                Notify.notify(dialogName + '_open_query', {
                    name: operator.user ? operator.user.short_name : '',
                });
                // The function returned is to deregister the callbacks and send the dialog_closed notify, if
                // the dialog get closed.
                return function () {
                    Notify.deregisterCallbacks(responseCallbackId, queryCallbackId, closeCallbackId);
                    Messaging.deleteMessage(messagingId);
                    Notify.notify(dialogName + '_dialog_closed', {
                        name: operator.user ? operator.user.short_name : '',
                    });
                };
            },
        };
    }
])

/*
 * This filter filters all items in an array. If the filterArray is empty, the
 * array is passed. The filterArray contains numbers of the multiselect, e. g. [1, 3, 4].
 * Then, all items in the array are passed, if the item_id (get with id_function) matches
 * one of the ids in filterArray. id_function could also return a list of ids. Example:
 * Item 1 has two tags with ids [1, 4]. filterArray == [3, 4] --> match
 *
 * If -1 is in the array items without an id will not be filtered. This is for implementing
 * a filter option like: "All items without a category"
 */
.filter('MultiselectFilter', [
    function () {
        return function (array, filterArray, idFunction) {
            if (filterArray.length === 0) {
                return array;
            }
            var itemsWithoutProperty = _.indexOf(filterArray, -1) > -1;
            return Array.prototype.filter.call(array, function (item) {
                var id = idFunction(item);
                if (typeof id === 'number') {
                    id = [id];
                } else if (id === null || !id.length) {
                    return itemsWithoutProperty;
                }
                return _.intersection(id, filterArray).length > 0;
            });
        };
    }
])

.filter('osFilter', [
    function () {
        return function (array, string, getFilterString) {
            if (!string) {
                return array;
            }
            return Array.prototype.filter.call(array, function (item) {
                return getFilterString(item).toLowerCase().indexOf(string.toLowerCase()) > -1;
            });
        };
    }
])

// angular formly config options
.run([
    'formlyConfig',
    function (formlyConfig) {
        // NOTE: This next line is highly recommended. Otherwise Chrome's autocomplete
        // will appear over your options!
        formlyConfig.extras.removeChromeAutoComplete = true;

        // Configure custom types
        formlyConfig.setType({
            name: 'editor',
            extends: 'textarea',
            templateUrl: 'static/templates/core/editor.html',
        });
        formlyConfig.setType({
            name: 'password',
            extends: 'input',
            templateUrl: 'static/templates/core/password.html',
        });
        formlyConfig.setType({
            name: 'checkbox',
            templateUrl: 'static/templates/core/checkbox.html',
            overwriteOk: true,
        });
        formlyConfig.setType({
            name: 'checkbox-buttons',
            templateUrl: 'static/templates/core/checkbox-buttons.html',
            overwriteOk: true,
        });
        formlyConfig.setType({
            name: 'select-single',
            extends: 'select',
            templateUrl: 'static/templates/core/select-single.html'
        });
        formlyConfig.setType({
            name: 'select-multiple',
            extends: 'select',
            templateUrl: 'static/templates/core/select-multiple.html'
        });
        formlyConfig.setType({
            name: 'radio-buttons',
            templateUrl: 'static/templates/core/radio-buttons.html',
            wrapper: ['bootstrapHasError'],
            defaultOptions: {
                noFormControl: false
            }
        });
        formlyConfig.setType({
            name: 'file',
            extends: 'input',
            templateUrl: 'static/templates/core/file.html',
        });
    }
])

// html-tag os-form-field to generate generic from fields
// TODO: make it possible to use other fields then config fields
.directive('osFormField', [
    '$parse',
    'Config',
    'gettextCatalog',
    function($parse, Config, gettextCatalog) {
        var getHtmlType = function (type) {
            return {
                string: 'text',
                text: 'textarea',
                markupText: 'editor',
                integer: 'number',
                boolean: 'checkbox',
                choice: 'choice',
                comments: 'comments',
                colorpicker: 'colorpicker',
                datetimepicker: 'datetimepicker',
                majorityMethod: 'choice',
                translations: 'translations',
            }[type];
        };

        return {
            restrict: 'E',
            scope: true,
            templateUrl: 'static/templates/config-form-field.html',
            link: function ($scope, iElement, iAttrs, controller, transcludeFn) {
                var field = $parse(iAttrs.field)($scope);
                var config = Config.get(field.key);
                $scope.type = getHtmlType(field.input_type);
                if ($scope.type == 'choice') {
                    $scope.choices = field.choices;
                    $scope.value = config.value;
                } else {
                    $scope.value = gettextCatalog.getString(config.value);
                }
                $scope.label = field.label;
                $scope.key = 'field-' + field.key;
                $scope.help_text = field.help_text;
                $scope.default_value = field.default_value;
                $scope.reset = function () {
                    if ($scope.type == 'choice') {
                        $scope.value = $scope.default_value;
                    } else {
                        $scope.value = gettextCatalog.getString($scope.default_value);
                    }
                    $scope.save(field, $scope.value);
                };
            }
        };
    }
])

/* This directive provides a csv import template.
 * Papa Parse is used to parse the csv file. Accepted attributes:
 * * change:
 *   Callback if file changes. The one parameter is csv passing the parsed file
 * * config (optional):
 *   - accept: String with extensions: default '.csv .txt'
 *   - encodingOptions: List with encodings. Default ['UTF-8', 'ISO-8859-1']
 *   - parseConfig: a dict passed to PapaParse
 */
.directive('csvImport', [
    function () {
        return {
            restrict: 'E',
            templateUrl: 'static/templates/csv-import.html',
            scope: {
                change: '&',
                config: '=?',
            },
            controller: function ($scope, $element, $attrs, $location) {
                // set config if it is not given
                if (!$scope.config) {
                    $scope.config = {};
                }
                if (!$scope.config.parseConfig) {
                    $scope.config.parseConfig = {};
                }

                $scope.inputElement = angular.element($element[0].querySelector('#csvFileSelector'));

                // set accept and encoding
                $scope.accept = $scope.config.accept || '.csv';
                $scope.encodingOptions = $scope.config.encodingOptions || ['UTF-8'];
                $scope.encoding = $scope.encodingOptions[0];

                $scope.parse = function () {
                    var inputElement = $scope.inputElement[0];
                    if (!inputElement.files.length) {
                        $scope.change({csv: {data: {}}});
                    } else {
                        var parseConfig = _.defaults(_.clone($scope.config.parseConfig), {
                            delimiter: $scope.delimiter,
                            encoding: $scope.encoding,
                            header: false, // we do not want to have dicts in result
                            complete: function (csv) {
                                if (csv.data.length) {
                                    csv.meta.fields = csv.data[0];
                                }
                                else {
                                    csv.meta.fields = [];
                                }
                                csv.data = csv.data.splice(1); // do not interpret the header as data
                                $scope.$apply(function () {
                                    if (csv.meta.delimiter) {
                                        $scope.autodelimiter = csv.meta.delimiter;
                                    }
                                    $scope.change({csv: csv});
                                });
                            },
                            error: function () {
                                $scope.$apply(function () {
                                    $scope.change({csv: {data: {}}});
                                });
                            },
                        });

                        Papa.parse(inputElement.files[0], parseConfig);
                    }
                };

                $scope.clearFile = function () {
                    $scope.inputElement[0].value = '';
                    $scope.selectedFile = undefined;
                    $scope.parse();
                };

                $scope.inputElement.on('change', function () {
                    $scope.selectedFile = _.last($scope.inputElement[0].value.split('\\'));
                    $scope.parse();
                });
            },
        };
    }
])

.directive('messaging', [
    '$timeout',
    'Messaging',
    function ($timeout, Messaging) {
        return {
            restrict: 'E',
            templateUrl: 'static/templates/messaging.html',
            scope: {},
            controller: function ($scope, $element, $attrs, $location) {
                $scope.messages = {};

                var update = function () {
                    $scope.messages = Messaging.getMessages();
                };
                Messaging.registerMessageChangeCallback(update);

                $scope.close = function (id) {
                    Messaging.deleteMessage(id);
                };
            },
        };
    }
])

.controller('MainMenuCtrl', [
    '$scope',
    'mainMenu',
    function ($scope, mainMenu) {
        mainMenu.registerScope($scope);
        $scope.isMenuOpen = false;
        $scope.closeMenu = function () {
            $scope.isMenuOpen = false;
        };
    }
])

.controller('LanguageCtrl', [
    '$scope',
    'gettextCatalog',
    'Languages',
    'filterFilter',
    function ($scope, gettextCatalog, Languages, filterFilter) {
        $scope.languages = Languages.getLanguages();
        $scope.selectedLanguage = filterFilter($scope.languages, {selected: true});
        // controller to switch app language
        $scope.switchLanguage = function (lang) {
            $scope.languages = Languages.setCurrentLanguage(lang);
            $scope.selectedLanguage = filterFilter($scope.languages, {selected: true});
        };
    }
])

.controller('GotoTopCtrl', [
    '$scope',
    '$window',
    '$timeout',
    function ($scope, $window, $timeout) {
        $scope.show = false;
        angular.element($window).bind('scroll', function () {
            $timeout(function () {
                $scope.show = ($window.pageYOffset >= 150);
            });
        });
    }
])

.run([
    '$rootScope',
    '$window',
    function ($rootScope, $window) {
        $rootScope.gotoTop = function () {
            $window.scrollTo(0, 0);
        };
    }
])

// Prevent scrolling in number inputs. Instead of changing the number, the input
// is blurred and the window is scrolled. This is very important for our dialog
// forms, so a user didn't change a value, when he wants to scroll the form.
.run(function () {
    $('body').on('mousewheel', function (e) {
        if (e.target.nodeName === 'INPUT' && e.target.type === 'number') {
            $(e.target).blur();
        }
    });
})

// Projector Sidebar Controller
.controller('ProjectorSidebarCtrl', [
    '$scope',
    '$document',
    '$window',
    function ($scope, $document, $window) {
        $scope.isProjectorSidebar = false;
        $scope.showProjectorSidebar = function (show) {
            $scope.isProjectorSidebar = show;
        };

        // Sidebar scroll
        var marginTop = 20, // margin-top from #content
            marginBottom = 30, // 30px + 20px sidebar margin-bottom = 50px from footer
            sidebar;

        var sidebarScroll = function () {
            var sidebarHeight = sidebar.height(),
                sidebarOffset = sidebar.offset().top,
                sidebarMinOffset = $('#header').height() + $('#nav').height() + marginTop,
                documentHeight = $document.height(),
                windowHeight = $window.innerHeight,
                scrollTop = $window.pageYOffset;

            // First, check if there is a need to scroll: scroll if the sidebar is smaller then the content
            if (sidebarHeight < $('.col1').height()) {
                if ((scrollTop + marginTop + sidebarHeight) > (documentHeight - marginBottom)) {
                    // Stick to the bottom
                    var bottom = marginBottom + scrollTop + windowHeight - documentHeight;
                    sidebar.css({'position': 'fixed', 'top': '', 'bottom': bottom});
                } else if ((scrollTop + marginTop) > sidebarMinOffset) {
                    // scroll with the user
                    sidebar.css({'position': 'fixed', 'top': marginTop, 'bottom': ''});
                } else {
                    // Stick to the top
                    sidebar.css({'position': 'relative', 'top': 0, 'bottom': ''});
                }
            } else {
                // Stick to the top, if the sidebar is larger then the content
                sidebar.css({'position': 'relative', 'top': 0, 'bottom': ''});
            }
        };

        $scope.initSidebar = function () {
            sidebar = $('#sidebar');
            $scope.$watch(function () {
                return sidebar.height();
            }, sidebarScroll);
            angular.element($window).bind('scroll', sidebarScroll);
        };

    }
])

// Legal Notice Controller
.controller('LegalNoticeCtrl', [
    '$scope',
    '$http',
    function ($scope, $http) {
        $http.get('/core/version/').then(function (success) {
            $scope.core_version = success.data.openslides_version;
            $scope.core_license = success.data.openslides_license;
            $scope.core_url = success.data.openslides_url;
            $scope.plugins = success.data.plugins;
        });
    }
])

// Privacy Policy Controller
.controller('PrivacyPolicyCtrl', function () {})

// Config Controller
.controller('ConfigCtrl', [
    '$scope',
    '$timeout',
    'MajorityMethodChoices',
    'Config',
    'OpenSlidesConfigVariables',
    'gettextCatalog',
    'DateTimePickerTranslation',
    'Editor',
    function($scope, $timeout, MajorityMethodChoices, Config, OpenSlidesConfigVariables,
        gettextCatalog, DateTimePickerTranslation, Editor) {
        Config.bindAll({}, $scope, 'configs');
        $scope.configGroups = OpenSlidesConfigVariables;
        $scope.dateTimePickerTranslatedButtons = DateTimePickerTranslation.getButtons();

        $scope.ckeditorOptions = Editor.getOptions();
        $scope.ckeditorOptions.on.change = function (event) {
            // we could just retrieve the key, but we need the configOption object.
            var configOption_key = event.editor.element.$.id;

            // find configOption object
            var subgroups = _.flatMap($scope.configGroups, function (group) {
                return group.subgroups;
            });
            var items = _.flatMap(subgroups, function (subgroup) {
                return subgroup.items;
            });
            var configOption = _.find(items, function (_item) {
                return _item.key === configOption_key;
            });

            var editor = this;
            // The $timeout executes the given function in an angular context. Because
            // this is a standard JS event, all changes may not happen in the digist-cylce.
            // By using $timeout angular calls $apply for us that we do not have to care
            // about starting the digist-cycle.
            $timeout(function () {
                $scope.save(configOption, editor.getData());
            }, 1);
        };

        // save changed config value
        $scope.save = function(configOption, value) {
            Config.get(configOption.key).value = value;
            Config.save(configOption.key).then(function (success) {
                configOption.success = true;
                // fade out the success symbol after 2 seconds.
                $timeout(function () {
                    var element = $('#success-field-' + configOption.key);
                    element.fadeOut(800, function () {
                        configOption.success = void 0;
                    });
                }, 2000);
            }, function (error) {
                configOption.success = false;
                configOption.errorMessage = error.data.detail;
            });
        };

        // For comments input
        $scope.addComment = function (configOption, parent) {
            var maxId = _.max(_.keys(parent.value));
            if (maxId === undefined) {
                maxId = 1;
            } else {
                maxId = parseInt(maxId) + 1;
            }
            parent.value[maxId] = {
                name: gettextCatalog.getString('New'),
                public: false,
            };
            $scope.save(configOption, parent.value);
        };
        $scope.removeComment = function (configOption, parent, id) {
            parent.value[id] = null;
            $scope.save(configOption, parent.value);
        };

        // For custom translations input
        $scope.addTranslation = function (configOption, parent) {
            parent.value.push({
                original: gettextCatalog.getString('New'),
                translation: gettextCatalog.getString('New'),
            });
            $scope.save(configOption, parent.value);
        };
        $scope.removeTranslation = function (configOption, parent, index) {
            parent.value.splice(index, 1);
            $scope.save(configOption, parent.value);
        };

        // For majority method
        angular.forEach(
            _.filter($scope.configGroups, function (configGroup) {
                return configGroup.name === 'Motions' || configGroup.name === 'Elections';
            }),
            function (configGroup) {
                var configItem;
                _.forEach(configGroup.subgroups, function (subgroup) {
                    configItem = _.find(subgroup.items, ['input_type', 'majorityMethod']);
                    if (configItem !== undefined) {
                        // Break the forEach loop if we found something.
                        return false;
                    }
                });
                if (configItem !== undefined) {
                    configItem.choices = MajorityMethodChoices;
                }
            }
        );
    }
])

// Search Bar Controller
.controller('SearchBarCtrl', [
    '$scope',
    '$state',
    '$sanitize',
    function ($scope, $state, $sanitize) {
        $scope.search = function() {
            var query = _.escape($scope.querybar);
            $scope.querybar = '';
            $state.go('search', {q: query});
        };
    }
])

// Search Controller
.controller('SearchCtrl', [
    '$scope',
    '$filter',
    '$stateParams',
    'Search',
    'DS',
    'Motion',
    function ($scope, $filter, $stateParams, Search, DS, Motion) {
        $scope.searchresults = [];
        var searchModules = Search.getAll();

        // search function
        $scope.search = function() {
            $scope.results = [];
            var foundObjects = [];
            // search in rest properties of all defined searchModule
            // (does not found any related objects, e.g. speakers of items)
            _.forEach(searchModules, function(searchModule) {
                var result = {};
                result.verboseName = searchModule.verboseName;
                result.collectionName = searchModule.collectionName;
                result.urlDetailState = searchModule.urlDetailState;
                result.weight = searchModule.weight;
                result.checked = true;
                result.elements = $filter('filter')(DS.getAll(searchModule.collectionName), $scope.searchquery);
                $scope.results.push(result);
                _.forEach(result.elements, function(element) {
                    foundObjects.push(element);
                });
            });
            // search additionally in specific releations of all defined searchModules
            _.forEach(searchModules, function(searchModule) {
                _.forEach(DS.getAll(searchModule.collectionName), function(object) {
                    if (_.isFunction(object.hasSearchResult)) {
                        if (object.hasSearchResult(foundObjects, $scope.searchquery)) {
                            // releation found, check if object is not yet in search results
                            _.forEach($scope.results, function(result) {
                                if ((object.getResourceName() === result.collectionName) &&
                                        _.findIndex(result.elements, {'id': object.id}) === -1) {
                                    result.elements.push(object);
                                }
                            });
                        }
                    } else {
                        return false;
                    }
                });
            });
        };

        //get search string from parameters submitted from outside the scope
        if ($stateParams.q) {
            $scope.searchquery = $stateParams.q;
            $scope.search();
        }
    }
])

// Projector Control Controller
.controller('ProjectorControlCtrl', [
    '$scope',
    '$http',
    '$interval',
    '$state',
    '$q',
    '$filter',
    'Config',
    'Projector',
    'CurrentListOfSpeakersItem',
    'CurrentListOfSpeakersSlide',
    'ProjectionDefault',
    'ProjectorMessage',
    'Countdown',
    'gettextCatalog',
    'ngDialog',
    'ProjectorMessageForm',
    function($scope, $http, $interval, $state, $q, $filter, Config, Projector, CurrentListOfSpeakersItem,
        CurrentListOfSpeakersSlide, ProjectionDefault, ProjectorMessage, Countdown, gettextCatalog,
        ngDialog, ProjectorMessageForm) {
        ProjectorMessage.bindAll({}, $scope, 'messages');

        var intervals = [];
        var calculateCountdownTime = function (countdown) {
            countdown.seconds = Math.floor( countdown.countdown_time - Date.now() / 1000 + $scope.serverOffset );
        };
        var cancelIntervalTimers = function () {
            intervals.forEach(function (interval) {
                $interval.cancel(interval);
            });
        };
        $scope.$watch(function () {
            return Countdown.lastModified();
        }, function () {
            $scope.countdowns = Countdown.getAll();

            // stop ALL interval timer
            cancelIntervalTimers();
            $scope.countdowns.forEach(function (countdown) {
                if (countdown.running) {
                    calculateCountdownTime(countdown);
                    intervals.push($interval(function () { calculateCountdownTime(countdown); }, 1000));
                } else {
                    countdown.seconds = countdown.countdown_time;
                }
            });
        });
        $scope.$on('$destroy', function() {
            // Cancel all intervals if the controller is destroyed
            cancelIntervalTimers();
        });

        $scope.$watch(function () {
            return Projector.lastModified();
        }, function () {
            $scope.projectors = Projector.getAll();
            if (!$scope.active_projector) {
                $scope.active_projector = $filter('orderBy')($scope.projectors, 'id')[0];
            }
            $scope.setIframeSize($scope.active_projector);
            if ($scope.projectors.length === 1) {
                $scope.currentListOfSpeakersAsOverlay = true;
            }

            $scope.messageDefaultProjectorId = ProjectionDefault.filter({name: 'messages'})[0].projector_id;
            $scope.countdownDefaultProjectorId = ProjectionDefault.filter({name: 'countdowns'})[0].projector_id;
            $scope.listOfSpeakersDefaultProjectorId = ProjectionDefault.filter({name: 'agenda_current_list_of_speakers'})[0].projector_id;
        });
        // watch for changes in projector_broadcast and currentListOfSpeakersReference
        var last_broadcast;
        $scope.$watch(function () {
            return Config.lastModified();
        }, function () {
            var broadcast = Config.get('projector_broadcast').value;
            if (!last_broadcast || last_broadcast != broadcast) {
                last_broadcast = broadcast;
                $scope.broadcast = broadcast;
            }
            $scope.currentListOfSpeakersReference = $scope.config('projector_currentListOfSpeakers_reference');
        });

        $scope.changeProjector = function (projector) {
            $scope.active_projector = projector;
            $scope.setIframeSize(projector);
        };
        $scope.setIframeSize = function (projector) {
            $scope.scale = 256.0 / projector.width;
            $scope.iframeHeight = $scope.scale * projector.height;
        };

        $scope.editCurrentSlide = function (projector) {
            var data = projector.getFormOrStateForCurrentSlide();
            if (data) {
                if (data.form) {
                    ngDialog.open(data.form.getDialog({id: data.id}));
                } else {
                    $state.go(data.state, {id: data.id});
                }
            }
        };

        // *** countdown functions ***
        $scope.calculateCountdownTime = function (countdown) {
            countdown.seconds = Math.floor( countdown.countdown_time - Date.now() / 1000 + $scope.serverOffset );
        };
        $scope.editCountdown = function (countdown) {
            countdown.editFlag = false;
            countdown.description = countdown.new_description;
            Countdown.save(countdown);
            if (!countdown.running) {
                countdown.reset();
            }
        };
        $scope.addCountdown = function () {
            var default_time = parseInt($scope.config('projector_default_countdown'));
            var countdown = {
                description: '',
                default_time: default_time,
                countdown_time: default_time,
                running: false,
            };
            Countdown.create(countdown);
        };
        $scope.removeCountdown = function (countdown) {
            Countdown.destroy(countdown.id);
        };

        // *** message functions ***
        $scope.editMessage = function (message) {
            ngDialog.open(ProjectorMessageForm.getDialog(message));
        };
        $scope.addMessage = function () {
            var message = {message: ''};
            ProjectorMessage.create(message);
        };
        $scope.removeMessage = function (message) {
            ProjectorMessage.destroy(message.id);
        };

        /* Current list of speakers */
        $scope.currentListOfSpeakers = CurrentListOfSpeakersSlide;
        // Set the current overlay status
        if ($scope.currentListOfSpeakers.isProjected().length) {
            var isProjected = $scope.currentListOfSpeakers.isProjectedWithOverlayStatus();
            $scope.currentListOfSpeakersAsOverlay = isProjected[0].overlay;
        } else {
            $scope.currentListOfSpeakersAsOverlay = true;
        }
        // go to the list of speakers(management) of the currently displayed list of speakers reference slide
        $scope.goToListOfSpeakers = function() {
            var item = $scope.currentListOfSpeakersItem();
            if (item) {
                $state.go('agenda.item.detail', {id: item.id});
            }
        };
        $scope.currentListOfSpeakersItem = function () {
            return CurrentListOfSpeakersItem.getItem($scope.currentListOfSpeakersReference);
        };
        $scope.setOverlay = function (overlay) {
            $scope.currentListOfSpeakersAsOverlay = overlay;
            var isProjected = $scope.currentListOfSpeakers.isProjectedWithOverlayStatus();
            if (isProjected.length) {
                _.forEach(isProjected, function (mapping) {
                    if (mapping.overlay != overlay) { // change the overlay if it is different
                        $scope.currentListOfSpeakers.project(mapping.projectorId, overlay);
                    }
                });
            }
        };
    }
])

.controller('ProjectorMessageEditCtrl', [
    '$scope',
    'projectorMessageId',
    'ProjectorMessage',
    'ProjectorMessageForm',
    function ($scope, projectorMessageId, ProjectorMessage, ProjectorMessageForm) {
        $scope.formFields = ProjectorMessageForm.getFormFields();
        $scope.model = angular.copy(ProjectorMessage.get(projectorMessageId));

        $scope.save = function (message) {
            ProjectorMessage.inject(message);
            ProjectorMessage.save(message);
            $scope.closeThisDialog();
        };
    }
])

.controller('ManageProjectorsCtrl', [
    '$scope',
    '$http',
    '$timeout',
    'Projector',
    'ProjectionDefault',
    'Config',
    'ProjectorMessage',
    'ngDialog',
    function ($scope, $http, $timeout, Projector, ProjectionDefault, Config,
        ProjectorMessage, ngDialog) {
        ProjectionDefault.bindAll({}, $scope, 'projectiondefaults');

        /* Info on resolution calculating:
         * Internally the resolution is saved as (width, height) but the user has
         * an aspect ratio to choose and a width from 800 to 3840 (4K).*/
        $scope.aspectRatios = {
            '4:3': 4/3,
            '16:9': 16/9,
            '16:10': 16/10,
        };
        // when converting (x,y) -> (ratio, percentage) round issues may occur
        // (e.g. 800/600 != 4/3 with internal calculation issues). With this environment
        // is tested, if the calculated value is in the following interval:
        // [expected-environment; expected+environment]
        var RATIO_ENVIRONMENT = 0.05;

        // watch for changes in projector_broadcast
        // and projector_currentListOfSpeakers_reference
        var last_broadcast, last_clos;
        $scope.$watch(function () {
            return Config.lastModified();
        }, function () {
            var broadcast = $scope.config('projector_broadcast'),
            currentListOfSpeakers = $scope.config('projector_currentListOfSpeakers_reference');
            if (!last_broadcast || last_broadcast != broadcast) {
                last_broadcast = broadcast;
                $scope.broadcast = broadcast;
            }
            if (!last_clos || last_clos != currentListOfSpeakers) {
                last_clos = currentListOfSpeakers;
                $scope.currentListOfSpeakers = currentListOfSpeakers;
            }
        });

        // watch for changes in Projector, and recalc scale and iframeHeight
        var first_watch = true;
        $scope.resolutions = {};
        $scope.edit = [];
        $scope.sliders = {};
        $scope.$watch(function () {
            return Projector.lastModified();
        }, function () {
            $scope.projectors = Projector.getAll();
            $scope.projectors.forEach(function (projector) {
                projector.iframeScale = 256.0 / projector.width;
                projector.iframeHeight = projector.iframeScale * projector.height;
                if (first_watch) {
                    $scope.resolutions[projector.id] = {
                        width: projector.width,
                        height: projector.height
                    };
                    $scope.edit[projector.id] = false;
                    $scope.sliders[projector.id] = {
                        value: projector.width,
                        options: {
                            id: projector.id,
                            floor: 800,
                            ceil: 3840,
                            step: 10,
                            translate: function (value) {
                                return value + 'px';
                            },
                            onChange: function (v) {
                                $scope.calcResolution(projector);
                            },
                            onEnd: function (v) {
                                $scope.saveResolution(projector);
                            },
                            hideLimitLabels: true,
                        },
                    };
                    $scope.setAspectRatio(projector, $scope.getAspectRatio(projector));
                }
            });
            if ($scope.projectors.length) {
                first_watch = false;
            }
        });

        $scope.getAspectRatio = function (projector) {
            var ratio = projector.width/projector.height;
            var foundRatio = _.findKey($scope.aspectRatios, function (value) {
                return value >= (ratio-RATIO_ENVIRONMENT) && value <= (ratio+RATIO_ENVIRONMENT);
            });
            if (foundRatio === undefined) {
                return _.keys($scope.aspectRatios)[0];
            } else {
                return foundRatio;
            }
        };
        $scope.setAspectRatio = function (projector, aspectRatio) {
            $scope.resolutions[projector.id].aspectRatio = aspectRatio;
            $scope.resolutions[projector.id].aspectRatioNumber = $scope.aspectRatios[aspectRatio];
            $scope.calcResolution(projector);
        };
        $scope.calcResolution = function (projector) {
            var ratio = $scope.resolutions[projector.id].aspectRatioNumber;
            var width = $scope.sliders[projector.id].value;
            $scope.resolutions[projector.id].width = width;
            $scope.resolutions[projector.id].height = Math.round(width/ratio);
        };

        $scope.toggleEditMenu = function (projectorId) {
            $scope.edit[projectorId] = !$scope.edit[projectorId];
            $timeout(function () {
                $scope.$broadcast('rzSliderForceRender');
            });
        };

        // Set list of speakers reference
        $scope.setListOfSpeakers = function (projector) {
            Config.get('projector_currentListOfSpeakers_reference').value = projector.id;
            Config.save('projector_currentListOfSpeakers_reference');
        };

        // Projector functions
        $scope.setProjectionDefault = function (projector, projectiondefault) {
            if (projectiondefault.projector_id !== projector.id) {
                $http.post('/rest/core/projector/' + projector.id + '/set_projectiondefault/', projectiondefault.id);
            }
        };
        $scope.createProjector = function (name) {
            var projector = {
                name: name,
                config: {},
                scale: 0,
                scroll: 0,
                blank: false,
                projectiondefaults: [],
            };
            Projector.create(projector).then(function (projector) {
                $http.post('/rest/core/projector/' + projector.id + '/activate_elements/', [{
                    name: 'core/clock',
                    stable: true
                }]);
                $scope.resolutions[projector.id] = {
                    width: projector.width,
                    height: projector.height
                };
            });
        };
        $scope.deleteProjector = function (projector) {
            if (projector.id != 1) {
                Projector.destroy(projector.id);
            }
        };
        $scope.editCurrentSlide = function (projector) {
            var data = projector.getFormOrStateForCurrentSlide();
            if (data) {
                if (data.form) {
                    ngDialog.open(data.form.getDialog({id: data.id}));
                } else {
                    $state.go(data.state, {id: data.id});
                }
            }
        };
        $scope.editName = function (projector) {
            projector.config = projector.elements;
            Projector.save(projector);
        };
        $scope.saveResolution = function (projector) {
            $http.post(
                '/rest/core/projector/' + projector.id + '/set_resolution/',
                $scope.resolutions[projector.id]
            ).then(function (success) {
                $scope.resolutions[projector.id].error = null;
            }, function (error) {
                if (error.data) {
                    $scope.resolutions[projector.id].error = error.data.detail;
                } else {
                    $scope.resolutions[projector.id].error = null;
                }
            });
        };

        // Identify projectors
        $scope.identifyProjectors = function () {
            if ($scope.identifyPromise) {
                $timeout.cancel($scope.identifyPromise);
                $scope.removeIdentifierMessages();
            } else {
                // Create new Message
                var message = {
                    message: '',
                };
                ProjectorMessage.create(message).then(function(message){
                    $scope.projectors.forEach(function (projector) {
                        $http.post('/rest/core/projector/' + projector.id + '/activate_elements/', [{
                            name: 'core/projector-message',
                            stable: true,
                            id: message.id,
                            identify: true,
                        }]);
                    });
                    $scope.identifierMessage = message;
                });
                $scope.identifyPromise = $timeout($scope.removeIdentifierMessages, 3000);
            }
        };
        $scope.removeIdentifierMessages = function () {
            Projector.getAll().forEach(function (projector) {
                _.forEach(projector.elements, function (element, uuid) {
                    if (element.name === 'core/projector-message' && element.id === $scope.identifierMessage.id) {
                        $http.post('/rest/core/projector/' + projector.id + '/deactivate_elements/', [uuid]);
                    }
                });
            });
            ProjectorMessage.destroy($scope.identifierMessage.id);
            $scope.identifyPromise = null;
        };
    }
])

// Tag Controller
.controller('TagListCtrl', [
    '$scope',
    'Tag',
    'ngDialog',
    'TagForm',
    'gettext',
    'ErrorMessage',
    function($scope, Tag, ngDialog, TagForm, gettext, ErrorMessage) {
        Tag.bindAll({}, $scope, 'tags');
        $scope.alert = {};

        // setup table sorting
        $scope.sortColumn = 'name';
        $scope.reverse = false;
        // function to sort by clicked column
        $scope.toggleSort = function ( column ) {
            if ( $scope.sortColumn === column ) {
                $scope.reverse = !$scope.reverse;
            }
            $scope.sortColumn = column;
        };
        $scope.delete = function (tag) {
            Tag.destroy(tag.id).then(
                function(success) {
                    $scope.alert = {
                        type: 'success',
                        msg: gettext('The delete was successful.'),
                        show: true,
                    };
                }, function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
        $scope.editOrCreate = function (tag) {
            ngDialog.open(TagForm.getDialog(tag));
        };
    }
])

.controller('TagCreateCtrl', [
    '$scope',
    'Tag',
    'TagForm',
    'ErrorMessage',
    function($scope, Tag, TagForm, ErrorMessage) {
        $scope.model = {};
        $scope.alert = {};
        $scope.formFields = TagForm.getFormFields();
        $scope.save = function (tag) {
            Tag.create(tag).then(
                function (success) {
                    $scope.closeThisDialog();
                },
                function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('TagUpdateCtrl', [
    '$scope',
    'Tag',
    'tagId',
    'TagForm',
    'ErrorMessage',
    function($scope, Tag, tagId, TagForm, ErrorMessage) {
        $scope.model = angular.copy(Tag.get(tagId));
        $scope.alert = {};
        $scope.formFields = TagForm.getFormFields();
        $scope.save = function (tag) {
            Tag.inject(tag);
            Tag.save(tag).then(function(success) {
                $scope.closeThisDialog();
            }, function (error) {
                // save error: revert all changes by restore
                // the original object
                Tag.refresh(tag);
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };
    }
])

.controller('CountdownDetailCtrl', [
    '$scope',
    '$interval',
    'Countdown',
    'countdownId',
    function ($scope, $interval, Countdown, countdownId) {
        var interval;
        var calculateCountdownTime = function (countdown) {
            countdown.seconds = Math.floor( $scope.countdown.countdown_time - Date.now() / 1000 + $scope.serverOffset );
        };
        $scope.$watch(function () {
            return Countdown.lastModified(countdownId);
        }, function () {
            $scope.countdown = Countdown.get(countdownId);
            if (interval) {
                $interval.cancel(interval);
            }
            if ($scope.countdown) {
                if ($scope.countdown.running) {
                    calculateCountdownTime($scope.countdown);
                    interval = $interval(function () { calculateCountdownTime($scope.countdown); }, 1000);
                } else {
                    $scope.countdown.seconds = $scope.countdown.countdown_time;
                }
            }
        });
        $scope.$on('$destroy', function() {
            // Cancel the interval if the controller is destroyed
            if (interval) {
                $interval.cancel(interval);
            }
        });
    }
])

// counter of new (unread) chat messages
.value('NewChatMessages', [])

// ChatMessage Controller
.controller('ChatMessageCtrl', [
    '$scope',
    '$http',
    '$timeout',
    'ChatMessage',
    'NewChatMessages',
    function ($scope, $http, $timeout, ChatMessage, NewChatMessages) {
        ChatMessage.bindAll({}, $scope, 'chatmessages');
        $scope.unreadMessages = NewChatMessages.length;
        $scope.chatboxIsCollapsed = true;
        $scope.openChatbox = function () {
            $scope.chatboxIsCollapsed = !$scope.chatboxIsCollapsed;
            NewChatMessages = [];
            $scope.unreadMessages = NewChatMessages.length;
            $timeout(function () {
                angular.element('#messageInput').focus();
            }, 0);
        };
        $scope.sendMessage = function () {
            angular.element('#messageSendButton').addClass('disabled');
            angular.element('#messageInput').attr('disabled', '');
            $http.post(
                '/rest/core/chat-message/',
                {message: $scope.newMessage}
            ).then(function (success) {
                $scope.newMessage = '';
                angular.element('#messageSendButton').removeClass('disabled');
                angular.element('#messageInput').removeAttr('disabled');
                $timeout(function () {
                    angular.element('#messageInput').focus();
                }, 0);
            }, function (error) {
                angular.element('#messageSendButton').removeClass('disabled');
                angular.element('#messageInput').removeAttr('disabled');
            });
        };
        // increment unread messages counter for each new message
        $scope.$watch('chatmessages', function (newVal, oldVal) {
            // add new message id if there is really a new message which is not yet tracked
            if (oldVal.length > 0 && newVal.length > 0) {
                if ((oldVal[oldVal.length-1].id != newVal[newVal.length-1].id) &&
                    ($.inArray(newVal[newVal.length-1].id, NewChatMessages) == -1)) {
                    NewChatMessages.push(newVal[newVal.length-1].id);
                    $scope.unreadMessages = NewChatMessages.length;
                }
            } else if (newVal.length === 0) {
                NewChatMessages = [];
                $scope.unreadMessages = 0;
            }
        });

        $scope.clearChatHistory = function () {
            $http.post('/rest/core/chat-message/clear/');
        };
    }
])

// format time string for model ("s") and view format ("h:mm:ss" or "mm:ss")
.directive('minSecFormat', [
    'HumanTimeConverter',
    function (HumanTimeConverter) {
        return {
            require: 'ngModel',
            link: function(scope, element, attrs, ngModelController) {
                ngModelController.$parsers.push(function(data) {
                    //convert data from view format (mm:ss) to model format (s)
                    return HumanTimeConverter.humanTimeToSeconds(data, {seconds: true});
                });

                ngModelController.$formatters.push(function(data) {
                    //convert data from model format (s) to view format (mm:ss)
                    return HumanTimeConverter.secondsToHumanTime(data);
                });
            }
        };
    }
])

// format time string for model ("m") and view format ("h:mm" or "hh:mm")
.directive('hourMinFormat', [
    'HumanTimeConverter',
    function (HumanTimeConverter) {
        return {
            require: 'ngModel',
            link: function(scope, element, attrs, ngModelController) {
                ngModelController.$parsers.push(function(data) {
                    //convert data from view format (hh:mm) to model format (m)
                    return HumanTimeConverter.humanTimeToSeconds(data, {hours: true})/60;
                });

                ngModelController.$formatters.push(function(data) {
                    //convert data from model format (m) to view format (hh:mm)
                    return HumanTimeConverter.secondsToHumanTime(data*60,
                        { seconds: 'disabled',
                            hours: 'enabled' }
                    );
                });
            }
        };
    }
])

.directive('osFocusMe', [
    '$timeout',
    function ($timeout) {
        return {
            link: function (scope, element, attrs, model) {
                $timeout(function () {
                    element[0].focus();
                });
            }
        };
    }
])

.filter('toArray', function(){
    /*
     * Transforms an object to an array. Items of the array are the values of
     * the object elements.
     */
    return function(obj) {
        var result = [];
        angular.forEach(obj, function(val, key) {
            result.push(val);
        });
        return result;
    };
})

//Mark all core config strings for translation in Javascript
.config([
    'gettext',
    function (gettext) {
        gettext('Presentation and assembly system');
        gettext('Event name');
        gettext('<a href="http://www.openslides.org">OpenSlides</a> is a free ' +
                'web based presentation and assembly system for visualizing ' +
                'and controlling agenda, motions and elections of an ' +
                'assembly.');
        gettext('General');
        gettext('Event');
        gettext('Short description of event');
        gettext('Event date');
        gettext('Event location');
        gettext('Event organizer');
        gettext('Legal notice');
        gettext('Privacy policy');
        gettext('Front page title');
        gettext('Welcome to OpenSlides');
        gettext('Front page text');
        gettext('[Space for your welcome text.]');
        gettext('Allow access for anonymous guest users');
        gettext('Show this text on the login page');
        gettext('Separator used for all csv exports and examples');
        gettext('Page number alignment in PDF');
        gettext('Left');
        gettext('Center');
        gettext('Right');
        gettext('Standard font size in PDF');
        gettext('Show logo on projector');
        gettext('You can replace the logo by uploading an image and set it as ' +
                'the "Projector logo" in "files".');
        gettext('Projector');
        gettext('Projector language');
        gettext('Current browser language');
        gettext('Show title and description of event on projector');
        gettext('Display header and footer');
        gettext('Show the clock on projector');
        gettext('Background color of projector header and footer');
        gettext('Font color of projector header and footer');
        gettext('Font color of projector headline');
        gettext('Predefined seconds of new countdowns');
        gettext('Color for blanked projector');
        gettext('List of speakers overlay');
        gettext('Projector logo');
        gettext('Projector header image');
        gettext('PDF header logo (left)');
        gettext('PDF header logo (right)');
        gettext('PDF footer logo (left)');
        gettext('PDF footer logo (right)');
        gettext('Web interface header logo');
        gettext('PDF ballot paper logo');
        gettext('Custom translations');

        // Mark the string 'Default projector' here, because it does not appear in the templates.
        gettext('Default projector');
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.core.start', [])

.factory('OpenSlides', [
    '$http',
    '$rootScope',
    '$state',
    '$q',
    'DS',
    'autoupdate',
    'operator',
    'Group',
    'mainMenu',
    'ngDialog',
    'LoginDialog',
    function($http, $rootScope, $state, $q, DS, autoupdate, operator, Group, mainMenu, ngDialog, LoginDialog) {
        var OpenSlides = {
            bootup: function () {
                $rootScope.openslidesBootstrapDone = false;
                $http.get('/users/whoami/').then(function (success) {
                    $rootScope.guest_enabled = success.data.guest_enabled;
                    if (success.data.user_id === null && !success.data.guest_enabled) {
                        // Redirect to login dialog if user is not logged in.
                        $state.go('login', {guest_enabled: success.data.guest_enabled});
                    } else {
                        autoupdate.newConnect();
                        autoupdate.firstMessageDeferred.promise.then(function () {
                            operator.setUser(success.data.user_id, success.data.user);
                            $rootScope.operator = operator;
                            mainMenu.updateMainMenu();
                            $rootScope.openslidesBootstrapDone = true;
                        });
                    }
                });
            },
            shutdown: function () {
                // Close connection, clear the store and show the OS overlay.
                autoupdate.closeConnection();
                DS.clear();
                operator.setUser(null);
                $rootScope.openslidesBootstrapDone = false;
                $rootScope.operator = operator;
                // close all open dialogs (except the login dialog)
                _.forEach(ngDialog.getOpenDialogs(), function (id) {
                    if (id !== LoginDialog.id) {
                        ngDialog.close(id);
                    }
                });
            },
            reboot: function () {
                this.shutdown();
                this.bootup();
            },
        };

        // We need to 'ping' the server with a get request to whoami, because then we can decide,
        // if the server is down or respond with a 403 (this cannot be differentiated with websockets)
        autoupdate.registerRetryConnectCallback(function () {
            return $http.get('/users/whoami').then(function (success) {
                if (success.data.user_id === null && !success.data.guest_enabled) {
                    OpenSlides.shutdown();
                    // Redirect to login dialog if user is not logged in.
                    $state.go('login', {guest_enabled: success.data.guest_enabled});
                } else {
                    autoupdate.newConnect();
                }
            });
        });

        return OpenSlides;
    }
])

.run([
    'OpenSlides',
    function (OpenSlides) {
        OpenSlides.bootup();
    }
])

.run([
    '$rootScope',
    '$state',
    'operator',
    'User',
    'Group',
    'mainMenu',
    function ($rootScope, $state, operator, User, Group, mainMenu) {
        var permissionChangeCallback = function () {
            operator.reloadPerms();
            mainMenu.updateMainMenu();
            var stateData = $state.current.data;
            var basePerm = stateData ? stateData.basePerm : '';
            $rootScope.baseViewPermissionsGranted = basePerm ?
                operator.hasPerms(basePerm) : true;
        };

        $rootScope.$watch(function () {
            return Group.lastModified();
        }, function () {
            if (Group.getAll().length) {
                permissionChangeCallback();
            }
        });

        $rootScope.$watch(function () {
            return operator.user ? User.lastModified(operator.user.id) : true;
        }, function () {
            permissionChangeCallback();
        });
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.mediafiles.forms', [
    'gettext',
    'ngFileUpload',
    'ui.router',
    //TODO: Add deps for operator, User
])

// Service for mediafile form
.factory('MediafileForm', [
    'gettextCatalog',
    'operator',
    'User',
    function (gettextCatalog, operator, User) {
        return {
            // ngDialog for mediafile form
            getDialog: function (mediafile) {
                var dialog = {
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                };
                if (mediafile) {
                    dialog.template = 'static/templates/mediafiles/mediafile-form.html';
                    dialog.controller = 'MediafileUpdateCtrl';
                    dialog.resolve = {
                        mediafileId: function () {return mediafile ? mediafile.id : void 0;}
                    };
                } else {
                    dialog.template = 'static/templates/mediafiles/mediafile-upload-form.html';
                    dialog.controller = 'MediafileUploadCtrl';
                }
                return dialog;
            },
            getFormFields: function () {
                return [
                    {
                        key: 'title',
                        type: 'input',
                        templateOptions: {
                            label: gettextCatalog.getString('Title'),
                        },
                    },
                    {
                        key: 'hidden',
                        type: 'checkbox',
                        templateOptions: {
                            label: gettextCatalog.getString('Hidden'),
                        },
                        hide: !operator.hasPerms('mediafiles.can_see_hidden'),
                    },
                    {
                        key: 'uploader_id',
                        type: 'select-single',
                        templateOptions: {
                            label: gettextCatalog.getString('Uploaded by'),
                            options: User.getAll(),
                            ngOptions: 'option.id as option.full_name for option in to.options',
                            placeholder: gettextCatalog.getString('Select or search a participant ...')
                        },
                        hide: !operator.hasPerms('mediafiles.can_manage')
                    },
                ];

            }
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.mediafiles.image-plugin', [
    'OpenSlidesApp.mediafiles.resources',
    'gettext',
    'OpenSlidesApp.core',
])

.factory('ImageBrowserPlugin', [
    '$templateCache',
    'Mediafile',
    'gettextCatalog',
    'Editor',
    function ($templateCache, Mediafile, gettextCatalog, Editor) {
        return {
            getPlugin: function () {
                return {
                    init: function (editor) {
                        CKEDITOR.tools.imagebrowser = {};

                        // Initialize this dialog, if it is opened.
                        editor.on('dialogShow', function (event) {
                            var dialog = event.data;
                            if (dialog.getName() === 'imagebrowser-dialog') {
                                CKEDITOR.dialog.getCurrent().disableButton('ok');

                                // Load the main plugin template and paste it into the container
                                var template = $templateCache.get('static/templates/mediafiles/image-plugin.html');
                                if (!template) {
                                    throw 'Template for image plugin not found!';
                                }
                                $('#imageBrowserContainer').html(template);

                                // Load all images.
                                var images = '';
                                _.forEach(Mediafile.getAllImages(), function (image) {
                                        images += '<div class="image" onclick="CKEDITOR.tools.imagebrowser.selectImage(\'' +
                                            image.value + '\');" style="background-image:url(\'' +
                                            image.value + '\');" data-image="' + image.value + '"></div>';
                                });
                                $('#imageBrowser').html(images);

                                // Translate some strings. Angular tags are not available in CKEditor.
                                $('#scaleLabel').html(gettextCatalog.getString('Scale'));

                                // If the dialog was opened via double click, check the selected element. It
                                // may be an image, so preselect it.
                                var selectedElement = editor.getSelection().getStartElement();
                                if (selectedElement.is('img')) {
                                    // Check for given scale of this image.
                                    var styleAttr = $(selectedElement).attr('style');
                                    var scale;
                                    var scaleRegex = /width\s*:\s*(\d+)\s*%/g;
                                    var scaleMatch = scaleRegex.exec(styleAttr);
                                    if (scaleMatch) {
                                        scale = parseInt(scaleMatch[1]);
                                    }
                                    CKEDITOR.tools.imagebrowser.selectImage(
                                        selectedElement.getAttribute('src'), scale);
                                }
                                // Setup event listeners.
                                $('#image-scale').bind('keyup mouseup', function (event) {
                                    var scale = parseInt($('#image-scale').val());
                                    if (scale !== CKEDITOR.tools.imagebrowser.scale) {
                                        CKEDITOR.tools.imagebrowser.updateImageSize(scale);
                                    }
                                });
                            }
                        });
                        // React on double clicks in the textarea. If an image was selected, open this dialog.
                        editor.on('doubleclick', function (event) {
                            var element = event.data.element;
                            if (!element.isReadOnly()) {
                                if (element.is('img')) {
                                    event.data.dialog = 'imagebrowser-dialog';
                                    editor.getSelection().selectElement(element);
                                }
                            }
                        });
                        // Handler for selecting an image. It may be called by clicking on a thumbnail or by
                        // just giving the url. The scale is optional.
                        CKEDITOR.tools.imagebrowser.selectImage = function (url, scale) {
                            var browser = $('#imageBrowser');
                            _.forEach(browser.children(), function (child) { // check every available image
                                if (child.getAttribute('data-image') == url) { //match
                                    child.classList.add('selected');
                                    var image = $('#imagePreview img');
                                    // Setup an load event handler, so we can get the size of the image when loaded.
                                    image.on('load', function (event) {
                                        var w = event.target.naturalWidth;
                                        var h = event.target.naturalHeight;
                                        $('#originalSizeText').html(gettextCatalog.getString('Original size') +
                                            ': ' + w + ' &times; ' + h );
                                        $('#fullSizeContainer').width(w).height(h);
                                        if (scale !== undefined) {
                                            // Use custom scale.
                                            CKEDITOR.tools.imagebrowser.updateImageSize(scale);
                                        } else {
                                            CKEDITOR.tools.imagebrowser.updateImageSize(100);
                                        }
                                    });
                                    // Set the url of the main preview image.
                                    image.attr('src', url);
                                    $('#imagePreviewSection').removeClass('hidden');
                                    CKEDITOR.tools.imagebrowser.selected = url;
                                } else {
                                    // Wrong image, deselect it in the preview window.
                                    child.classList.remove('selected');
                                }
                            });
                        };
                        // Handler for updateing the image size.
                        CKEDITOR.tools.imagebrowser.updateImageSize = function (scale) {
                            if (isNaN(scale) || scale <= 0) {
                                CKEDITOR.dialog.getCurrent().disableButton('ok');
                            } else {
                                CKEDITOR.dialog.getCurrent().enableButton('ok');
                                CKEDITOR.tools.imagebrowser.scale = scale;
                                $('#imagePreview img').width(scale + '%');
                                $('#image-scale').val(scale);
                            }
                        };
                        // Insert the selected image into the textarea.
                        CKEDITOR.tools.imagebrowser.insertImage = function (url, scale) {
                            var editor = CKEDITOR.currentInstance;
                            var dialog = CKEDITOR.dialog.getCurrent();
                            var html = '<img src="' + url + '" data-cke-saved-src="' + url +
                                '" alt="' + url + '" style="width: ' + scale + '%;" />';
                            editor.config.allowedContent = true;
                            editor.insertHtml(html.trim());
                            dialog.hide();
                        };
                        editor.addCommand('imagebrowser-open', new CKEDITOR.dialogCommand('imagebrowser-dialog'));
                        // By naming the button 'image', it gets the same image as the original image button.
                        editor.ui.addButton('image', {
                            label: gettextCatalog.getString('Open image browser'),
                            command: 'imagebrowser-open',
                            toolbar: 'insert',
                        });
                    },
                };
            },
            getDialog: function () {
                return function (editor) {
                    return {
                        title: gettextCatalog.getString('Image browser'),
                        minWidth: 1000,
                        minHeight: 500,
                        contents: [
                            {
                                id: 'imagebrowser-tab1',
                                label: gettextCatalog.getString('Browse for images'),
                                elements: [
                                    {
                                        type: 'html',
                                        align: 'left',
                                        id: 'titleid',
                                        style: 'font-size: 20px; font-weight: bold;',
                                        html: gettextCatalog.getString('Browse for images'),
                                    }, {
                                        type: 'html',
                                        align: 'left',
                                        id: 'msg',
                                        style: '',
                                        html: '<div id="imageBrowserContainer"></div>'
                                    }
                                ],
                            },
                        ],
                        // insert image on OK.
                        onOk: function (event) {
                            var url = CKEDITOR.tools.imagebrowser.selected;
                            if (url) {
                                var scale = CKEDITOR.tools.imagebrowser.scale;
                                CKEDITOR.tools.imagebrowser.insertImage(url, scale);
                            }
                        },
                    };
                };
            },
        };
    }
])

.run([
    'Editor',
    'ImageBrowserPlugin',
    'gettext',
    function (Editor, ImageBrowserPlugin, gettext) {
        Editor.registerDialog('imagebrowser-dialog', ImageBrowserPlugin.getDialog());
        Editor.registerPlugin('imagebrowser', ImageBrowserPlugin.getPlugin());

        // mark all plugin strings
        gettext('Original size');
        gettext('Scale');
        gettext('Image browser');
        gettext('Browse for images');
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.mediafiles.list', [
    'gettext',
    'ngDialog',
    'OpenSlidesApp.mediafiles.forms',
    'OpenSlidesApp.mediafiles.resources',
    //TODO: Add deps for operator, User, Projector, ProjectionDefault, osTableFilter, osTableSort,
])

.controller('MediafileListCtrl', [
    '$http',
    '$scope',
    'gettext',
    'ngDialog',
    'osTableFilter',
    'osTableSort',
    'osTablePagination',
    'ProjectionDefault',
    'Projector',
    'User',
    'Mediafile',
    'MediafileForm',
    'Logos',
    'Fonts',
    function ($http, $scope, gettext, ngDialog, osTableFilter, osTableSort, osTablePagination,
              ProjectionDefault, Projector, User, Mediafile, MediafileForm, Logos, Fonts) {
        $scope.$watch(function () {
            return Mediafile.lastModified();
        }, function () {
            $scope.mediafiles = _.orderBy(Mediafile.getAll(), ['title']);
        });
        User.bindAll({}, $scope, 'users');
        $scope.$watch(function() {
            return Projector.lastModified();
        }, function() {
            $scope.projectors = Projector.getAll();
            updatePresentedMediafiles();
            var projectiondefault = ProjectionDefault.filter({name: 'mediafiles'})[0];
            if (projectiondefault) {
                $scope.defaultProjectorId = projectiondefault.projector_id;
            }
        });

        function updatePresentedMediafiles () {
            $scope.presentedMediafiles = [];
            Projector.getAll().forEach(function (projector) {
                var projectorElements = _.map(projector.elements, function(element) { return element; });
                var mediaElements = _.filter(projectorElements, function (element) {
                    return element.name === 'mediafiles/mediafile';
                });
                mediaElements.forEach(function (element) {
                    $scope.presentedMediafiles.push(element);
                });
            });
            if ($scope.presentedMediafiles.length) {
                $scope.isMeta = false;
            } else {
                $scope.isMeta = true;
            }
        }

        updatePresentedMediafiles();

        // Filtering
        $scope.filter = osTableFilter.createInstance('MediafilesTableFilter');

        if (!$scope.filter.existsStorageEntry()) {
            $scope.filter.booleanFilters = {
                isHidden: {
                    value: undefined,
                    displayName: gettext('Hidden'),
                    choiceYes: gettext('Is hidden'),
                    choiceNo: gettext('Is not hidden'),
                    needExtraPermission: true,
                },
                isPdf: {
                    value: undefined,
                    displayName: gettext('Is PDF'),
                    choiceYes: gettext('Is PDF file'),
                    choiceNo: gettext('Is no PDF file'),
                },
            };
        }
        $scope.filter.propertyList = ['title_or_filename'];
        $scope.filter.propertyFunctionList = [
            function (mediafile) {return mediafile.uploader.get_short_name();},
            function (mediafile) {return mediafile.mediafile.type;},
            function (mediafile) {return mediafile.mediafile.name;},
        ];
        // Sorting
        $scope.sort = osTableSort.createInstance('MediafileTableSort');
        if (!$scope.sort.column) {
            $scope.sort.column = 'title_or_filename';
        }
        $scope.sortOptions = [
            {name: 'title_or_filename',
             display_name: gettext('Title')},
            {name: 'mediafile.type',
             display_name: gettext('Type')},
            {name: 'filesize',
             display_name: gettext('File size')},
            {name: 'timestamp',
             display_name: gettext('Upload time')},
            {name: 'uploader.get_short_name()',
             display_name: gettext('Uploaded by')},
        ];

        // pagination
        $scope.pagination = osTablePagination.createInstance('MediafileTablePagination');

        // open new/edit dialog
        $scope.openDialog = function (mediafile) {
            ngDialog.open(MediafileForm.getDialog(mediafile));
        };

        // *** select mode functions ***
        $scope.isSelectMode = false;
        // check all checkboxes
        $scope.checkAll = function () {
            $scope.selectedAll = !$scope.selectedAll;
            _.forEach($scope.mediafiles, function (mediafile) {
                mediafile.selected = $scope.selectedAll;
            });
        };
        // uncheck all checkboxes if SelectMode is closed
        $scope.uncheckAll = function () {
            if (!$scope.isSelectMode) {
                $scope.selectedAll = false;
                _.forEach($scope.mediafiles, function (mediafile) {
                    mediafile.selected = false;
                });
            }
        };
        // delete all selected mediafiles
        $scope.deleteMultiple = function () {
            angular.forEach($scope.mediafiles, function (mediafile) {
                if (mediafile.selected)
                    Mediafile.destroy(mediafile.id);
            });
            $scope.isSelectMode = false;
            $scope.uncheckAll();
        };
        // delete single mediafile
        $scope.delete = function (mediafile) {
            Mediafile.destroy(mediafile.id);
        };

        // ** PDF presentation functions **/
        // show document on projector
        $scope.showMediafile = function (projectorId, mediafile) {
            var isProjectedIds = mediafile.isProjected();
            _.forEach(isProjectedIds, function (id) {
                $http.post('/rest/core/projector/' + id + '/clear_elements/');
            });
            if (_.indexOf(isProjectedIds, projectorId) == -1) {
                var postUrl = '/rest/core/projector/' + projectorId + '/prune_elements/';
                var data = [{
                        name: 'mediafiles/mediafile',
                        id: mediafile.id,
                        numPages: mediafile.mediafile.pages,
                        page: 1,
                        scale: 'page-fit',
                        rotate: 0,
                        visible: true,
                        playing: false,
                        fullscreen: mediafile.is_pdf || mediafile.is_image
                }];
                $http.post(postUrl, data);
            }
        };

        var sendMediafileCommand = function (mediafile, data) {
            var updateData = _.extend({}, mediafile);
            _.extend(updateData, data);
            var postData = {};
            postData[mediafile.uuid] = updateData;

            // Find Projector where the mediafile is projected
            $scope.projectors.forEach(function (projector) {
                if (_.find(projector.elements, function (e) {return e.uuid == mediafile.uuid;})) {
                    $http.post('/rest/core/projector/' + projector.id + '/update_elements/', postData);
                }
            });
        };

        $scope.getTitle = function (mediafile) {
            return Mediafile.get(mediafile.id).title;
        };

        $scope.getType = function (presentedMediafile) {
            var mediafile = Mediafile.get(presentedMediafile.id);
            return mediafile.is_pdf ? 'pdf' : mediafile.is_image ? 'image' : 'video';
        };

        $scope.mediafileGoToPage = function (mediafile, page) {
            page = parseInt(page);
            if (page > 0 && page <= mediafile.numPages) {
                sendMediafileCommand(
                    mediafile,
                    {page: page}
                );
            }
        };
        $scope.mediafileZoomIn = function (mediafile) {
            var scale = 1;
            if (parseFloat(mediafile.scale)) {
                scale = mediafile.scale;
            }
            sendMediafileCommand(
                mediafile,
                {scale: scale + 0.2}
            );
        };
        $scope.mediafileFit = function (mediafile) {
            sendMediafileCommand(
                mediafile,
                {scale: 'page-fit'}
            );
        };
        $scope.mediafileZoomOut = function (mediafile) {
            var scale = 1;
            if (parseFloat(mediafile.scale)) {
                scale = mediafile.scale;
            }
            sendMediafileCommand(
                mediafile,
                {scale: scale - 0.2}
            );
        };
        $scope.mediafileChangePage = function (mediafile, pageNum) {
            sendMediafileCommand(
                mediafile,
                {pageToDisplay: pageNum}
            );
        };
        $scope.mediafileRotate = function (mediafile) {
            var rotation = mediafile.rotate;
            if (rotation === 270) {
                rotation = 0;
            } else {
                rotation = rotation + 90;
            }
            sendMediafileCommand(
                mediafile,
                {rotate: rotation}
            );
        };
        $scope.mediafileToggleFullscreen = function (mediafile) {
            sendMediafileCommand(
                mediafile,
                {fullscreen: !mediafile.fullscreen}
            );
        };
        $scope.mediafileTogglePlaying = function (mediafile) {
            sendMediafileCommand(
                mediafile,
                {playing: !mediafile.playing}
            );
        };

        /** Logos and fonts **/
        $scope.logos = Logos.getAll();
        $scope.fonts = Fonts.getAll();
        $scope.hasProjectorHeaderLogo = function (mediafile) {
            return _.some(mediafile.getLogos(), function (logo) {
                return logo.key === 'logo_projector_header';
            });
        };
    }
])

/*
 * Special filter only for mediafile list view.
 */
.filter('hiddenFilter', [
    '$filter',
    'operator',
    function ($filter, operator) {
        return function (array) {
            if (operator.hasPerms('mediafiles.can_see_hidden')) {
                return array;
            }
            return Array.prototype.filter.call(array, function (item) {
                return !item.hidden;
            });
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.mediafiles.projector', [
    'OpenSlidesApp.mediafiles.resources',
    //TODO: Add deps for slidesProvider
])

.config([
    'slidesProvider',
    function (slidesProvider) {
        slidesProvider.registerSlide('mediafiles/mediafile', {
            template: 'static/templates/mediafiles/slide_mediafile.html'
        });
    }
])

.controller('SlideMediafileCtrl', [
    '$scope',
    '$timeout',
    'Mediafile',
    function ($scope, $timeout, Mediafile) {
        // load mediafile object
        Mediafile.bindOne($scope.element.id, $scope, 'mediafile');

        $scope.showPdf = true;

        // Watch for page changes in the projector element. Adjust the page
        // in the canvas scope, so the viewer can change the size automatically.
        $scope.$watch(function () {
            return $scope.element.page;
        }, function () {
            var canvasScope = angular.element('#pdf-canvas').scope();
            if (canvasScope) {
                canvasScope.pageNum = $scope.element.page;
            }
        });

        // Watch for scale changes. If the scale is changed, reload the pdf
        // viewer by just disable and re-enable it.
        $scope.$watch(function () {
            return $scope.element.scale;
        }, function () {
            $scope.showPdf = false;
            $timeout(function () {
                $scope.showPdf = true;
            }, 1);
        });

        // Allow the elements to render properly
        setTimeout(function() {
            if ($scope.mediafile) {
                if ($scope.mediafile.is_pdf) {
                    $scope.pdfName = $scope.mediafile.title;
                    $scope.pdfUrl = $scope.mediafile.mediafileUrl;
                } else if ($scope.mediafile.is_video) {
                    var player = angular.element.find('#video-player')[0];
                    if ($scope.element.playing) {
                        player.play();
                    } else {
                        player.pause();
                    }
                }
            }
        }, 0);
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.mediafiles.resources', [
    'gettext',
    'js-data',
    //TODO: Add deps for jsDataModel
])

.factory('Mediafile', [
    'DS',
    'gettext',
    'jsDataModel',
    'Logos',
    'Fonts',
    function (DS, gettext, jsDataModel, Logos, Fonts) {
        var name = 'mediafiles/mediafile';
        return DS.defineResource({
            name: name,
            useClass: jsDataModel,
            verboseName: gettext('Files'),
            verboseNamePlural: gettext('Files'),
            getAllImages: function () {
                var images = [];
                angular.forEach(this.getAll(), function(file) {
                    if (file.is_image) {
                        images.push({title: file.title, value: file.mediafileUrl});
                    }
                });
                return images;
            },
            methods: {
                getResourceName: function () {
                    return name;
                },
                // link name which is shown in search result
                getSearchResultName: function () {
                    return this.title;
                },
                // return true if a specific relation matches for given searchquery
                // (here: speakers)
                hasSearchResult: function (results) {
                    var mediafile = this;
                    // search for speakers (check if any user.id from already found users matches)
                    return _.some(results, function(result) {
                        if ((result.getResourceName() === "users/user") &&
                                (mediafile.uploader_id === result.id)) {
                            return true;
                        }
                    });
                },
                isUsedAsLogo: function () {
                    var mediafile = this;
                    return _.find(Logos.getAll(), function (logoPlaceholder) {
                        return logoPlaceholder.path === mediafile.mediafileUrl;
                    });
                },
                canBeUsedAsLogo: function () {
                    return this.is_image;
                },
                getLogos: function () {
                    var mediafile = this;
                    return _.filter(Logos.getAll(), function (logoPlaceholder) {
                        return logoPlaceholder.path === mediafile.mediafileUrl;
                    });
                },
                hasLogo: function (logo) {
                    var allUrls = _.map(this.getLogos(), function (logo) {
                       return logo.path;
                    });
                    return _.includes(allUrls, logo.path);
                },
                toggleLogo: function (logo) {
                    if (this.hasLogo(logo)) {
                        Logos.set(logo.key);
                    } else {
                        Logos.set(logo.key, this.mediafileUrl);
                    }
                },
                isUsedAsFont: function () {
                    var mediafile = this;
                    return _.find(Fonts.getAll(), function (font) {
                        return font.path === mediafile.mediafileUrl;
                    });
                },
                canBeUsedAsFont: function () {
                    return this.is_font;
                },
                getFonts: function () {
                    var mediafile = this;
                    return _.filter(Fonts.getAll(), function (font) {
                        return font.path === mediafile.mediafileUrl;
                    });
                },
                hasFont: function (font) {
                    var allUrls = _.map(this.getFonts(), function (font) {
                       return font.path;
                    });
                    return _.includes(allUrls, font.path);
                },
                toggleFont: function (font) {
                    if (this.hasFont(font)) {
                        Fonts.set(font.key);
                    } else {
                        Fonts.set(font.key, this.mediafileUrl);
                    }
                },
            },
            computed: {
                is_pdf: ['filetype', function (filetype) {
                    var PDF_FILE_TYPES = ['application/pdf'];
                    return _.includes(PDF_FILE_TYPES, filetype);
                }],
                is_image: ['filetype', function (filetype) {
                    var IMAGE_FILE_TYPES = ['image/png', 'image/jpeg', 'image/gif'];
                    return _.includes(IMAGE_FILE_TYPES, filetype);
                }],
                is_video: ['filetype', function (filetype) {
                    var VIDEO_FILE_TYPES = [ 'video/quicktime', 'video/mp4', 'video/webm',
                        'video/ogg', 'video/x-flv', 'application/x-mpegURL', 'video/MP2T',
                        'video/3gpp', 'video/x-msvideo', 'video/x-ms-wmv', 'video/x-matroska' ];
                    return _.includes(VIDEO_FILE_TYPES, filetype);
                }],
                is_presentable: ['is_pdf', 'is_image', 'is_video', function (is_pdf, is_image, is_video) {
                    return (is_pdf && !this.mediafile.encrypted) || is_image || is_video;
                }],
                is_font: [function () {
                    var FONT_FILE_EXTENSIONS = ['ttf', 'woff'];
                    var ext = _.last(this.mediafile.name.split('.'));
                    return _.includes(FONT_FILE_EXTENSIONS, ext);
                }],
                mediafileUrl: [function () {
                    return this.media_url_prefix + this.mediafile.name;
                }],
                filename: [function () {
                    var filename = this.mediafile.name;
                    return /\/(.+?)$/.exec(filename)[1];
                }],
                filetype: [function () {
                    return this.mediafile.type || gettext('undefined');
                }],
                title_or_filename: ['title', 'mediafile', function (title) {
                    return title || this.filename;
                }]
            },
            relations: {
                belongsTo: {
                    'users/user': {
                        localField: 'uploader',
                        localKey: 'uploader_id',
                    }
                }
            }
        });
    }
])

.run(['Mediafile', function (Mediafile) {}]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.mediafiles.site', [
    'OpenSlidesApp.mediafiles.list',
    'OpenSlidesApp.mediafiles.states',
    'OpenSlidesApp.mediafiles.update',
    'OpenSlidesApp.mediafiles.upload',
    'OpenSlidesApp.mediafiles.image-plugin',
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.mediafiles.states', [
    'gettext',
    'ui.router',
    //TODO: Add deps for mainMenuProvider
])

.config([
    'gettext',
    'mainMenuProvider',
    function (gettext, mainMenuProvider) {
        mainMenuProvider.register({
            'ui_sref': 'mediafiles.mediafile.list',
            'img_class': 'paperclip',
            'title': gettext('Files'),
            'weight': 600,
            'perm': 'mediafiles.can_see',
        });
    }
])

.config([
    'SearchProvider',
    'gettext',
    function (SearchProvider, gettext) {
        SearchProvider.register({
            'verboseName': gettext('Files'),
            'collectionName': 'mediafiles/mediafile',
            'urlDetailState': 'mediafiles.mediafile.detail',
            'weight': 600,
        });
    }
])

.config([
    'gettext',
    '$stateProvider',
    function (gettext, $stateProvider) {
        $stateProvider
        .state('mediafiles', {
            url: '/mediafiles',
            abstract: true,
            template: "<ui-view/>",
            data: {
                title: gettext('Files'),
                basePerm: 'mediafiles.can_see',
            },
        })
        .state('mediafiles.mediafile', {
            abstract: true,
            template: "<ui-view/>",
        })
        .state('mediafiles.mediafile.list', {});
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.mediafiles.update', [
    'OpenSlidesApp.mediafiles.resources',
    //TODO: Add deps for operator, User
])

.controller('MediafileUpdateCtrl', [
    '$scope',
    'operator',
    'User',
    'Mediafile',
    'mediafileId',
    'MediafileForm',
    'ErrorMessage',
    function ($scope, operator, User, Mediafile, mediafileId, MediafileForm, ErrorMessage) {
        $scope.alert = {};
        $scope.formFields = MediafileForm.getFormFields();

        // set initial values for form model by create deep copy of motion object
        // so list/detail view is not updated while editing
        $scope.model = angular.copy(Mediafile.get(mediafileId));

        // save mediafile
        $scope.save = function (mediafile) {
            // reset title and uploader_id if empty
            if (!mediafile.title) {
                mediafile.title = mediafile.filename;
            }
            if (!mediafile.uploader_id) {
                mediafile.uploader_id = operator.user.id;
            }
            // inject the changed mediafile (copy) object back into DS store
            Mediafile.inject(mediafile);
            // save change mediafile object on server
            Mediafile.save(mediafile).then(
                function (success) {
                    $scope.closeThisDialog();
                },
                function (error) {
                    Mediafile.refresh(mediafile);
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.mediafiles.upload', [
    'OpenSlidesApp.mediafiles.forms',
    'ngFileUpload',
])

.controller('MediafileUploadCtrl', [
    '$scope',
    '$q',
    'User',
    'Upload',
    'operator',
    'gettextCatalog',
    'ErrorMessage',
    function ($scope, $q, User, Upload, operator, gettextCatalog, ErrorMessage) {
        User.bindAll({}, $scope, 'users');
        $scope.alert = {};
        $scope.files = [];
        $scope.uploading = false;
        var idCounter = 0; // Used for uniqly identifing each file in $scope.files.

        // Convert bytes to human readable si units.
        var humanFileSize = function (bytes) {
            if(Math.abs(bytes) < 1000) {
                return bytes + ' B';
            }
            var units = ['kB','MB','GB','TB','PB','EB','ZB','YB'];
            var i = -1;
            do {
                bytes /= 1000;
                i++;
            } while(bytes >= 1000 && i < units.length - 1);

            return bytes.toFixed(1) + ' ' + units[i];
        };

        $scope.addFiles = function (files) {
            files = _.map(files, function (file) {
                idCounter += 1;
                // This is a client side representation used for the template
                return {
                    id: idCounter,
                    file: file,
                    title: file.name,
                    hidden: false,
                    uploader_id: operator.user.id,
                    name: file.name,
                    size: file.size,
                    humanSize: humanFileSize(file.size),
                    type: file.type,
                    progress: 0,
                };
            });
            // Add each file, that is not a duplicate to $scope.files
            _.forEach(files, function (file) {
                var duplicate = _.some($scope.files, function (_file) {
                    return file.name === _file.name &&
                        file.size === _file.size &&
                        file.type === _file.type;
                });
                if (!duplicate) {
                    $scope.files.push(file);
                }
            });
        };

        $scope.removeFile = function (id) {
            $scope.files = _.filter($scope.files, function (file) {
                return file.id !== id;
            });
        };

        // Add files via drag and drop
        $scope.$watch('dropFiles', function () {
            if ($scope.dropFiles) {
                $scope.addFiles($scope.dropFiles);
            }
        });

        // upload all files
        $scope.upload = function () {
            $scope.uploading = true;
            var promises = _.map($scope.files, function (file) {
                // clear error
                file.error = void 0;

                // Check, if all necessary fields are set.
                if (!file.title) {
                    file.title = file.file.name;
                }
                if (!file.uploader_id) {
                    file.uploader_id = operator.user.id;
                }

                return Upload.upload({
                    url: '/rest/mediafiles/mediafile/',
                    method: 'POST',
                    data: {
                        mediafile: file.file,
                        title: file.title,
                        uploader_id: file.uploader_id,
                        hidden: file.hidden
                    },
                }).then(
                    function (success) {
                        $scope.removeFile(file.id);
                    },
                    function (error) {
                        file.error = ErrorMessage.forAlert(error).msg;
                        return error;
                    },
                    function (progress) {
                        file.progress = parseInt(100.0 * progress.loaded / progress.total);
                    }
                );
            });

            $q.all(promises).then(function (success) {
                var errors = _.filter(success, function (entry) {
                    return entry;
                });

                if (errors.length) {
                    $scope.uploading = false;
                    var message = gettextCatalog.getString('Some files could not be uploaded');
                    $scope.alert = { type: 'danger', msg: message, show: true };
                } else {
                    $scope.close();
                }
            });
        };

        $scope.clear = function () {
            $scope.uploading = false;
            $scope.files = [];
        };

        $scope.close = function () {
            $scope.closeThisDialog();
        };
    }
])

.run([
    'gettext',
    function (gettext) {
        gettext('Some files could not be uploaded');
    }
]);

}());

(function () {

"use strict";

angular.module('OpenSlidesApp.motions', [
    'OpenSlidesApp.motions.motionBlock',
    'OpenSlidesApp.motions.lineNumbering',
    'OpenSlidesApp.motions.diff',
    'OpenSlidesApp.poll.majority',
    'OpenSlidesApp.users',
])

.factory('MotionState', [
    'DS',
    function (DS) {
        return DS.defineResource({
            name: 'motions/state',
            methods: {
                getNextStates: function () {
                    return _.map(this.next_states_id, function (stateId) {
                        return DS.get('motions/state', stateId);
                    });
                },
                getRecommendations: function () {
                    var params = {
                        where: {
                            'workflow_id': {
                                '==': this.workflow_id
                            },
                            'recommendation_label': {
                                '!=': null
                            }
                        }
                    };
                    return DS.filter('motions/state', params);
                }
            },
            relations: {
                hasOne: {
                    'motions/workflow': {
                        localField: 'workflow',
                        localKey: 'workflow_id',
                    }
                }
            },
        });
    }
])

.factory('Workflow', [
    'DS',
    function (DS) {
        return DS.defineResource({
            name: 'motions/workflow',
            methods: {
                getFirstState: function () {
                    return DS.get('motions/state', this.first_state_id);
                },
            },
            relations: {
                hasMany: {
                    'motions/state': {
                        localField: 'states',
                        foreignKey: 'workflow_id',
                    }
                }
            }
        });
    }
])

.factory('MotionPoll', [
    'DS',
    'gettextCatalog',
    'Config',
    'MajorityMethods',
    function (DS, gettextCatalog, Config, MajorityMethods) {
        return DS.defineResource({
            name: 'motions/motion-poll',
            relations: {
                belongsTo: {
                    'motions/motion': {
                        localField: 'motion',
                        localKey: 'motion_id',
                    }
                }
            },
            beforeInject: function (resource, instance) {
                var attrs = ['yes', 'no', 'abstain', 'votescast', 'votesinvalid', 'votesvalid'];
                _.forEach(attrs, function (attr) {
                    if (instance[attr] !== null) {
                        instance[attr] = parseFloat(instance[attr]);
                    }
                });
            },
            methods: {
                // Returns percent base. Returns undefined if calculation is not possible in general.
                getPercentBase: function (config, type) {
                    var base;
                    switch (config) {
                        case 'CAST':
                            if (this.votescast <= 0 || this.votesinvalid < 0) {
                                // It would be OK to check only this.votescast < 0 because 0
                                // is checked again later but this is a little bit faster.
                                break;
                            }
                            base = this.votescast;
                            /* falls through */
                        case 'VALID':
                            if (this.votesvalid < 0) {
                                base = void 0;
                                break;
                            }
                            if (typeof base === 'undefined' && type !== 'votescast' && type !== 'votesinvalid') {
                                base = this.votesvalid;
                            }
                            /* falls through */
                        case 'YES_NO_ABSTAIN':
                            if (this.abstain < 0) {
                                base = void 0;
                                break;
                            }
                            if (typeof base === 'undefined' && type !== 'votescast' && type !== 'votesinvalid' && type !== 'votesvalid') {
                                base = this.yes + this.no + this.abstain;
                            }
                            /* falls through */
                        case 'YES_NO':
                            if (this.yes < 0 || this.no < 0 || this.abstain === -1 ) {
                                // It is not allowed to set 'Abstain' to 'majority' but exclude it from calculation.
                                // Setting 'Abstain' to 'undocumented' is possible, of course.
                                base = void 0;
                                break;
                            }
                            if (typeof base === 'undefined' && (type === 'yes' || type === 'no')) {
                                base = this.yes + this.no;
                            }
                    }
                    return base;
                },

                // Returns object with value and percent for this poll.
                getVote: function (vote, type) {
                    if (!this.has_votes) {
                        // Return undefined if this poll has no votes.
                        return;
                    }

                    // Initial values
                    var value = '',
                        percentStr = '',
                        percentNumber,
                        config = Config.get('motions_poll_100_percent_base').value;

                    // Check special values
                    switch (vote) {
                        case -1:
                            value = gettextCatalog.getString('majority');
                            break;
                        case -2:
                            value = gettextCatalog.getString('undocumented');
                            break;
                        default:
                            if (vote >= 0) {
                                value = vote;
                            } else {
                                value = 0;  // Vote was not defined. Set value to 0.
                            }
                    }

                    // Calculate percent value
                    var base = this.getPercentBase(config, type);
                    if (base) {
                        percentNumber = Math.round(vote * 100 / (base) * 100) / 100;
                        percentStr = '(' + percentNumber + ' %)';
                    }
                    return {
                        'value': value,
                        'percentStr': percentStr,
                        'percentNumber': percentNumber,
                        'display': value + ' ' + percentStr
                    };
                },

                // Returns 0 or positive integer if quorum is reached or surpassed.
                // Returns negativ integer if quorum is not reached.
                // Returns undefined if we can not calculate the quorum.
                isReached: function (method) {
                    if (!this.has_votes) {
                        // Return undefined if this poll has no votes.
                        return;
                    }

                    var isReached;
                    var config = Config.get('motions_poll_100_percent_base').value;
                    var base = this.getPercentBase(config, 'yes');
                    if (base) {
                        // Provide result only if base is not undefined and not 0.
                        isReached = MajorityMethods[method](this.yes, base);
                    }
                    return isReached;
                }
            }
        });
    }
])

.provider('MotionPollDecimalPlaces', [
    function () {
        this.$get = ['$q', function ($q) {
            return {
                getPlaces: function (poll, find) {
                    if (find) {
                        return $q(function (resolve) {
                            resolve(0);
                        });
                    } else {
                        return 0;
                    }
                },
            };
        }];
    }
])

.factory('MotionStateAndRecommendationParser', [
    'DS',
    'gettextCatalog',
    function (DS, gettextCatalog) {
        return {
            formatMotion: function (motion) {
                return '[motion:' + motion.id + ']';
            },
            parse: function (recommendation) {
                return recommendation.replace(/\[motion:(\d+)\]/g, function (match, id) {
                    var motion = DS.get('motions/motion', id);
                    if (motion) {
                        return motion.identifier ? motion.identifier : motion.getTitle();
                    } else {
                        return gettextCatalog.getString('<unknown motion>');
                    }
                });
            },
        };
    }
])

.factory('Submitter', [
    'DS',
    function (DS) {
        return DS.defineResource({
            name: 'motions/submitter',
            relations: {
                belongsTo: {
                    'users/user': {
                        localField: 'user',
                        localKey: 'user_id',
                    }
                }
            }
        });
    }
])

.factory('Motion', [
    'DS',
    '$http',
    '$cacheFactory',
    'MotionPoll',
    'MotionStateAndRecommendationParser',
    'MotionChangeRecommendation',
    'MotionComment',
    'jsDataModel',
    'gettext',
    'gettextCatalog',
    'Config',
    'lineNumberingService',
    'diffService',
    'OpenSlidesSettings',
    'Projector',
    'ProjectHelper',
    'operator',
    'UnifiedChangeObjectCollission',
    function(DS, $http, $cacheFactory, MotionPoll, MotionStateAndRecommendationParser, MotionChangeRecommendation,
        MotionComment, jsDataModel, gettext, gettextCatalog, Config, lineNumberingService,
        diffService, OpenSlidesSettings, Projector, ProjectHelper, operator, UnifiedChangeObjectCollission) {

        var diffCache = $cacheFactory('motion.service');

        var name = 'motions/motion';
        return DS.defineResource({
            name: name,
            useClass: jsDataModel,
            verboseName: gettext('Motion'),
            verboseNamePlural: gettext('Motions'),
            validate: function (resource, data, callback) {
                MotionComment.populateFieldsReverse(data);
                callback(null, data);
            },
            computed: {
                isAmendment: function () {
                    return this.parent_id !== null;
                },
            },
            methods: {
                getResourceName: function () {
                    return name;
                },
                getVersion: function (versionId) {
                    versionId = versionId || this.active_version;
                    var index;
                    if (versionId == -1) {
                        index = this.versions.length - 1;
                    } else {
                        index = _.findIndex(this.versions, function (element) {
                            return element.id == versionId;
                        });
                    }
                    return this.versions[index] || {};
                },
                isParagraphBasedAmendment: function () {
                    var version = this.getVersion();
                    return this.isAmendment && version.amendment_paragraphs;
                },
                getTitle: function (versionId) {
                    return this.getVersion(versionId).title;
                },
                getAgendaTitle: function () {
                    var title = gettextCatalog.getString('Motion');
                    if (this.identifier) {
                        title += ' ' + this.identifier;
                    } else {
                        title += ' (' + this.getTitle() + ')';
                    }
                    return title;
                },
                getListOfSpeakersTitle: function () {
                    var title = gettextCatalog.getString('Motion');
                    if (this.identifier) {
                        title += ' ' + this.identifier;
                    } else {
                        title += ' (' + this.getTitle() + ')';
                    }
                    return title;
                },
                getTitleWithChanges: function (changeRecommendationMode, versionId) {
                    var titleChange = this.getTitleChangeRecommendation(versionId);
                    var title;
                    if (titleChange) {
                        if (changeRecommendationMode === "changed") {
                            title = titleChange.text;
                        } else if ((changeRecommendationMode === 'agreed' ||
                                changeRecommendationMode === 'modified_agreed') && !titleChange.rejected) {
                            title = titleChange.text;
                        } else {
                            title = this.getTitle();
                        }
                    } else {
                        title = this.getTitle();
                    }
                    return title;
                },
                getSequentialNumber: function () {
                    var id = this.id + '';
                    var zeros = Math.max(0, OpenSlidesSettings.MOTION_IDENTIFIER_MIN_DIGITS - id.length);
                    for (var i = 0; i < zeros; i++) {
                        id = '0' + id;
                    }
                    return id;
                },
                getText: function (versionId) {
                    return this.getVersion(versionId).text;
                },
                getTextWithLineBreaks: function (versionId, highlight, callback) {
                    var lineLength = Config.get('motions_line_length').value,
                        html = this.getVersion(versionId).text;

                    return lineNumberingService.insertLineNumbers(html, lineLength, highlight, callback);
                },
                getModifiedFinalVersionWithLineBreaks: function (versionId) {
                    var lineLength = Config.get('motions_line_length').value,
                        html = this.getVersion(versionId).modified_final_version;

                    return lineNumberingService.insertLineNumbers(html, lineLength);
                },
                getTextBetweenChanges: function (versionId, change1, change2, highlight) {
                    var line_from = (change1 ? change1.line_to : 1),
                        line_to = (change2 ? change2.line_from : null);

                    if (line_from > line_to) {
                        throw 'Invalid call of getTextBetweenChanges: change1 needs to be before change2';
                    }
                    if (line_from === line_to) {
                        return '';
                    }

                    return this.getTextInLineRange(versionId, line_from, line_to, highlight);
                },
                getTextInLineRange: function (versionId, line_from, line_to, highlight) {
                    var lineLength = Config.get('motions_line_length').value,
                        htmlRaw = this.getVersion(versionId).text;

                    var cacheKey = 'getTextInLineRange ' + line_from + ' ' + line_to + ' ' + highlight + ' ' +
                        lineNumberingService.djb2hash(htmlRaw),
                        cached = diffCache.get(cacheKey);
                    if (!angular.isUndefined(cached)) {
                        return cached;
                    }

                    var html = lineNumberingService.insertLineNumbers(htmlRaw, lineLength),
                        data;

                    try {
                        data = diffService.extractRangeByLineNumbers(html, line_from, line_to);
                    } catch (e) {
                        // This only happens (as far as we know) when the motion text has been altered (shortened)
                        // without modifying the change recommendations accordingly.
                        // That's a pretty serious inconsistency that should not happen at all,
                        // we're just doing some basic damage control here.
                        var msg = 'Inconsistent data. A change recommendation is probably referring to a non-existant line number.';
                        return '<em style="color: red; font-weight: bold;">' + msg + '</em>';
                    }

                    // Add "merge-before"-css-class if the first line begins in the middle of a paragraph. Used for PDF.
                    html = diffService.addCSSClassToFirstTag(data.outerContextStart + data.innerContextStart, "merge-before") +
                        data.html + data.innerContextEnd + data.outerContextEnd;
                    html = lineNumberingService.insertLineNumbers(html, lineLength, highlight, null, line_from);

                    diffCache.put(cacheKey, html);

                    return html;
                },
                getTextRemainderAfterLastChange: function(versionId, changes, highlight) {
                    var maxLine = 0;
                    for (var i = 0; i < changes.length; i++) {
                        if (changes[i].line_to > maxLine) {
                            maxLine = changes[i].line_to;
                        }
                    }

                    var lineLength = Config.get('motions_line_length').value,
                        html = lineNumberingService.insertLineNumbers(this.getVersion(versionId).text, lineLength),
                        data;

                    try {
                        data = diffService.extractRangeByLineNumbers(html, maxLine, null);
                    } catch (e) {
                        // This only happens (as far as we know) when the motion text has been altered (shortened)
                        // without modifying the change recommendations accordingly.
                        // That's a pretty serious inconsistency that should not happen at all,
                        // we're just doing some basic damage control here.
                        var msg = 'Inconsistent data. A change recommendation is probably referring to a non-existant line number.';
                        return '<em style="color: red; font-weight: bold;">' + msg + '</em>';
                    }

                    if (data.html !== '') {
                        // Add "merge-before"-css-class if the first line begins in the middle of a paragraph. Used for PDF.
                        html = diffService.addCSSClassToFirstTag(data.outerContextStart + data.innerContextStart, "merge-before") +
                            data.html + data.innerContextEnd + data.outerContextEnd;
                        html = lineNumberingService.insertLineNumbers(html, lineLength, highlight, null, maxLine);
                    } else {
                        // Prevents empty lines at the end of the motion
                        html = '';
                    }
                    return html;
                },
                _getTextWithChanges: function (versionId, highlight, lineBreaks, recommendation_filter, amendment_filter) {
                    var lineLength = Config.get('motions_line_length').value,
                        html = this.getVersion(versionId).text,
                        change_recommendations = this.getTextChangeRecommendations(versionId, 'DESC'),
                        amendments = this.getParagraphBasedAmendments();

                    var allChanges = [];
                    change_recommendations.filter(recommendation_filter).forEach(function(change) {
                        allChanges.push({"text": change.text, "line_from": change.line_from, "line_to": change.line_to});
                    });
                    amendments.filter(amendment_filter).forEach(function(amend) {
                        var change = amend.getAmendmentsAffectedLinesChanged();
                        allChanges.push({"text": change.text, "line_from": change.line_from, "line_to": change.line_to});
                    });

                    // Changes need to be applied from the bottom up, to prevent conflicts with changing line numbers.
                    allChanges.sort(function(change1, change2) {
                        if (change1.line_from < change2.line_from) {
                            return 1;
                        } else if (change1.line_from > change2.line_from) {
                            return -1;
                        }  else {
                            return 0;
                        }
                    });


                    allChanges.forEach(function(change) {
                        html = lineNumberingService.insertLineNumbers(html, lineLength, null, null, 1);
                        html = diffService.replaceLines(html, change.text, change.line_from, change.line_to);
                    });

                    if (lineBreaks) {
                        html = lineNumberingService.insertLineNumbers(html, lineLength, highlight, null, 1);
                    }

                    return html;
                },
                getTextWithAllChangeRecommendations: function (versionId, highlight, lineBreaks) {
                    return this._getTextWithChanges(versionId, highlight, lineBreaks, function() {
                        return true; // All change recommendations
                    }, function() {
                        return false; // No amendments
                    });
                },
                getTextWithAgreedChanges: function (versionId, highlight, lineBreaks) {
                    return this._getTextWithChanges(versionId, highlight, lineBreaks, function(recommendation) {
                        return !recommendation.rejected;
                    }, function(amendment) {
                        if (amendment.state && amendment.state.name === 'rejected') {
                            return false;
                        }
                        if (amendment.state && amendment.state.name === 'accepted') {
                            return true;
                        }
                        return (amendment.recommendation && amendment.recommendation.name === 'accepted');
                    });
                },
                getTextByMode: function(mode, versionId, highlight, lineBreaks) {
                    /*
                     * @param mode ['original', 'diff', 'changed', 'agreed', 'modified_agreed']
                     * @param versionId [if undefined, active_version will be used]
                     * @param highlight [the line number to highlight]
                     * @param lineBreaks [if line numbers / breaks should be included in the result]
                     */

                    lineBreaks = (lineBreaks === undefined ? true : lineBreaks);

                    var text;
                    switch (mode) {
                        case 'original':
                            if (lineBreaks) {
                                text = this.getTextWithLineBreaks(versionId, highlight);
                            } else {
                                text = this.getVersion(versionId).text;
                            }
                            break;
                        case 'diff':
                            var amendments_crs = this.getTextChangeRecommendations(versionId, 'ASC').map(function (cr) {
                                return cr.getUnifiedChangeObject();
                            }).concat(
                                this.getParagraphBasedAmendmentsForDiffView().map(function (amendment) {
                                    return amendment.getUnifiedChangeObject();
                                })
                            );
                            amendments_crs.sort(function (change1, change2) {
                                if (change1.line_from > change2.line_from) {
                                    return 1;
                                } else if (change1.line_from < change2.line_from) {
                                    return -1;
                                } else {
                                    return 0;
                                }
                            });

                            text = '';
                            for (var i = 0; i < amendments_crs.length; i++) {
                                if (i===0) {
                                    text += this.getTextBetweenChanges(versionId, null, amendments_crs[0], highlight);
                                } else if (amendments_crs[i - 1].line_to < amendments_crs[i].line_from) {
                                    text += this.getTextBetweenChanges(versionId, amendments_crs[i - 1], amendments_crs[i], highlight);

                                }
                                text += amendments_crs[i].getDiff(this, versionId, highlight);
                            }
                            text += this.getTextRemainderAfterLastChange(versionId, amendments_crs);

                            if (!lineBreaks) {
                                text = lineNumberingService.stripLineNumbers(text);
                            }
                            break;
                        case 'changed':
                            text = this.getTextWithAllChangeRecommendations(versionId, highlight, lineBreaks);
                            break;
                        case 'agreed':
                            text = this.getTextWithAgreedChanges(versionId, highlight, lineBreaks);
                            break;
                        case 'modified_agreed':
                            text = this.getModifiedFinalVersion(versionId);
                            if (text) {
                                // Insert line numbers
                                var lineLength = Config.get('motions_line_length').value;
                                text = lineNumberingService.insertLineNumbers(text, lineLength);
                            } else {
                                // Use the agreed version as fallback
                                text = this.getTextByMode('agreed', versionId, highlight, lineBreaks);
                            }
                            break;
                    }
                    return text;
                },
                getTextParagraphs: function(versionId, lineBreaks) {
                    /*
                     * @param versionId [if undefined, active_version will be used]
                     * @param lineBreaks [if line numbers / breaks should be included in the result]
                     */
                    var text;
                    if (lineBreaks) {
                        text = this.getTextWithLineBreaks(versionId);
                    } else {
                        text = this.getVersion(versionId).text;
                    }

                    return lineNumberingService.splitToParagraphs(text);
                },
                getTextHeadings: function(versionId) {
                    var html = this.getTextWithLineBreaks(versionId);
                    return lineNumberingService.getHeadingsWithLineNumbers(html);
                },
                getAmendmentParagraphsByMode: function (mode, versionId, lineBreaks) {
                    /*
                     * @param mode ['original', 'diff', 'changed']
                     * @param versionId [if undefined, active_version will be used]
                     * @param lineBreaks [if line numbers / breaks should be included in the result]
                     *
                     * Structure of the return array elements:
                     * {
                     *   "paragraphNo": paragraph number, starting with 0
                     *   "lineFrom": First line number of the affected paragraph
                     *   "lineTo": Last line number of the affected paragraph;
                     *             refers to the line breaking element at the end, i.e. the start of the following line
                     *   "text": the actual text
                     * }
                     */

                    lineBreaks = (lineBreaks === undefined ? true : lineBreaks);

                    var cacheKey = 'getAmendmentParagraphsByMode ' + mode + ' ' + versionId + ' ' + lineBreaks +
                        lineNumberingService.djb2hash(JSON.stringify(this.getVersion(versionId).amendment_paragraphs)),
                        cached = diffCache.get(cacheKey);
                    if (!angular.isUndefined(cached)) {
                        return cached;
                    }

                    var original_text = this.getParentMotion().getTextByMode('original', null, null, true);
                    var original_paragraphs = lineNumberingService.splitToParagraphs(original_text);

                    var output = [];

                    this.getVersion(versionId).amendment_paragraphs.forEach(function(paragraph_amend, paragraphNo) {
                        if (paragraph_amend === null) {
                            return;
                        }
                        if (original_paragraphs[paragraphNo] === undefined) {
                            throw "The amendment appears to have more paragraphs than the motion. This means, the data might be corrupt";
                        }
                        var paragraph_orig = original_paragraphs[paragraphNo];
                        var line_range = lineNumberingService.getLineNumberRange(paragraph_orig);
                        var line_length = Config.get('motions_line_length').value;
                        paragraph_orig = lineNumberingService.stripLineNumbers(paragraph_orig);

                        var text = null;

                        switch (mode) {
                            case "diff":
                                if (lineBreaks) {
                                    text = diffService.diff(paragraph_orig, paragraph_amend, line_length, line_range.from);
                                } else {
                                    text = diffService.diff(paragraph_orig, paragraph_amend);
                                }
                                break;
                            case "original":
                                text = paragraph_orig;
                                if (lineBreaks) {
                                    text = lineNumberingService.insertLineNumbers(text, line_length, null, null, line_range.from);
                                }
                                break;
                            case "changed":
                                text = paragraph_amend;
                                if (lineBreaks) {
                                    text = lineNumberingService.insertLineNumbers(text, line_length, null, null, line_range.from);
                                }
                                break;
                            default:
                                throw "Invalid text mode: " + mode;
                        }
                        output.push({
                            "paragraphNo": paragraphNo,
                            "lineFrom": line_range.from,
                            "lineTo": line_range.to,
                            "text": text
                        });
                    });

                    diffCache.put(cacheKey, output);

                    return output;
                },
                getAmendmentParagraphsLinesByMode: function (mode, versionId, lineBreaks) {
                    /*
                     * @param mode ['original', 'diff', 'changed']
                     * @param versionId [if undefined, active_version will be used]
                     * @param lineBreaks [if line numbers / breaks should be included in the result]
                     *
                     * Structure of the return array elements:
                     * {
                     *   "paragraphNo": paragraph number, starting with 0
                     *   "paragraphLineFrom": First line number of the affected paragraph
                     *   "paragraphLineTo": End of the affected paragraph (line number + 1)
                     *   "diffLineFrom": First line number of the affected lines
                     *   "diffLineTo": End of the affected lines (line number + 1)
                     *   "textPre": The beginning of the paragraph, before the diff
                     *   "text": the diff
                     *   "textPost": The end of the paragraph, after the diff
                     * }
                     */

                    if (!this.isParagraphBasedAmendment() || !this.getParentMotion()) {
                        return [];
                    }

                    var cacheKey = 'getAmendmentParagraphsLinesByMode ' + mode + ' ' + versionId + ' ' + lineBreaks +
                        lineNumberingService.djb2hash(JSON.stringify(this.getVersion(versionId).amendment_paragraphs)),
                        cached = diffCache.get(cacheKey);
                    if (!angular.isUndefined(cached)) {
                        return cached;
                    }

                    var original_text = this.getParentMotion().getTextByMode('original', null, null, true);
                    var original_paragraphs = lineNumberingService.splitToParagraphs(original_text);

                    var output = [];

                    this.getVersion(versionId).amendment_paragraphs.forEach(function(paragraph_amend, paragraphNo) {
                        if (paragraph_amend === null) {
                            return;
                        }
                        if (original_paragraphs[paragraphNo] === undefined) {
                            throw "The amendment appears to have more paragraphs than the motion. This means, the data might be corrupt";
                        }
                        var line_length = Config.get('motions_line_length').value,
                            paragraph_orig = original_paragraphs[paragraphNo],
                            paragraph_line_range = lineNumberingService.getLineNumberRange(paragraph_orig),
                            diff = diffService.diff(paragraph_orig, paragraph_amend),
                            affected_lines = diffService.detectAffectedLineRange(diff);

                        if (!affected_lines) {
                            return;
                        }

                        // TODO: Make this work..
                        var base_paragraph;
                        switch (mode) {
                            case 'original':
                                //base_paragraph = paragraph_orig;
                                //base_paragraph = diffService.diff(paragraph_orig, paragraph_orig, line_length, paragraph_line_range.from);
                                base_paragraph = diff;
                                break;
                            case 'diff':
                                base_paragraph = diff;
                                break;
                            case 'changed':
                                //base_paragraph = paragraph_amend;
                                //base_paragraph = diffService.diff(paragraph_amend, paragraph_amend, line_length, paragraph_line_range.from);
                                base_paragraph = diff;
                                break;
                        }

                        var textPre = '';
                        var textPost = '';
                        if (affected_lines.from > paragraph_line_range.from) {
                            textPre = diffService.extractRangeByLineNumbers(base_paragraph, paragraph_line_range.from, affected_lines.from);
                            if (lineBreaks) {
                                textPre = diffService.formatDiffWithLineNumbers(textPre, line_length, paragraph_line_range.from);
                            }
                        }
                        if (paragraph_line_range.to > affected_lines.to) {
                            textPost = diffService.extractRangeByLineNumbers(base_paragraph, affected_lines.to, paragraph_line_range.to);
                            if (lineBreaks) {
                                textPost = diffService.formatDiffWithLineNumbers(textPost, line_length, affected_lines.to);
                            }
                        }

                        var text = diffService.extractRangeByLineNumbers(base_paragraph, affected_lines.from, affected_lines.to);
                        if (lineBreaks) {
                            text = diffService.formatDiffWithLineNumbers(text, line_length, affected_lines.from);
                        }

                        output.push({
                            "paragraphNo": paragraphNo,
                            "paragraphLineFrom": paragraph_line_range.from,
                            "paragraphLineTo": paragraph_line_range.to,
                            "diffLineFrom": affected_lines.from,
                            "diffLineTo": affected_lines.to,
                            "textPre": textPre,
                            "text": text,
                            "textPost": textPost
                        });
                    });

                    diffCache.put(cacheKey, output);

                    return output;
                },
                getAmendmentParagraphsLinesDiff: function (versionId) {
                    /*
                     * @param versionId [if undefined, active_version will be used]
                     *
                     */
                    return this.getAmendmentParagraphsLinesByMode('diff', versionId, true);
                },
                getAmendmentsAffectedLinesChanged: function () {
                    var paragraph_diff = this.getAmendmentParagraphsByMode("diff")[0],
                        affected_lines = diffService.detectAffectedLineRange(paragraph_diff.text);

                    var extracted_lines = diffService.extractRangeByLineNumbers(paragraph_diff.text, affected_lines.from, affected_lines.to);

                    var diff_html = extracted_lines.outerContextStart + extracted_lines.innerContextStart +
                            extracted_lines.html + extracted_lines.innerContextEnd + extracted_lines.outerContextEnd;
                    diff_html = diffService.diffHtmlToFinalText(diff_html);

                    return {
                        "line_from": affected_lines.from,
                        "line_to": affected_lines.to,
                        "text": diff_html
                    };
                },
                getUnifiedChangeObject: function () {
                    var paragraph = this.getAmendmentParagraphsByMode("diff")[0];
                    var affected_lines = diffService.detectAffectedLineRange(paragraph.text);

                    if (!affected_lines) {
                        // no changes, no object to use
                        return null;
                    }

                    var extracted_lines = diffService.extractRangeByLineNumbers(paragraph.text, affected_lines.from, affected_lines.to);
                    var lineLength = Config.get('motions_line_length').value;

                    var diff_html = diffService.formatDiffWithLineNumbers(extracted_lines, lineLength, affected_lines.from);

                    var acceptance_state = null;
                    var rejection_state = null;
                    this.state.getRecommendations().forEach(function(state) {
                        if (state.name === "accepted") {
                            acceptance_state = state.id;
                        }
                        if (state.name === "rejected") {
                            rejection_state = state.id;
                        }
                    });

                    // The interface of this object needs to be synchronized with the same method in MotionChangeRecommendation
                    //
                    // The change object needs to be cached to prevent confusing Angular's change detection
                    // Otherwise, a new object would be created with every call, leading to flickering
                    var amendment = this;

                    if (this._change_object === undefined) {
                        // Properties that are guaranteed to be constant
                        this._change_object = {
                            "type": "amendment",
                            "id": "amendment-" + amendment.id,
                            "original": amendment,
                            "saveStatus": function () {
                                // The status needs to be reset first, as the workflow does not allow changing from
                                // acceptance to rejection directly or vice-versa.
                                amendment.setState(null).then(function () {
                                    if (amendment._change_object.accepted) {
                                        amendment.setState(acceptance_state);
                                    }
                                    if (amendment._change_object.rejected) {
                                        amendment.setState(rejection_state);
                                    }
                                });
                            },
                            "getDiff": function (motion, version, highlight) {
                                if (highlight > 0) {
                                    diff_html = lineNumberingService.highlightLine(diff_html, highlight);
                                }
                                return diff_html;
                            }
                        };
                    }

                    // Properties that might change when the Amendment is edited
                    this._change_object.line_from = affected_lines.from;
                    this._change_object.line_to = affected_lines.to;

                    this._change_object.accepted = false;
                    this._change_object.rejected = false;
                    if (this.state && this.state.name === 'rejected') {
                        this._change_object.rejected = true;
                    } else if (this.state && this.state.name === 'accepted') {
                        this._change_object.accepted = true;
                    } else if (this.recommendation && this.recommendation.name === 'rejected') {
                        this._change_object.rejected = true;
                    }

                    UnifiedChangeObjectCollission.populate(this._change_object);

                    return this._change_object;
                },
                setTextStrippingLineBreaks: function (text) {
                    this.text = lineNumberingService.stripLineNumbers(text);
                },
                setModifiedFinalVersionStrippingLineBreaks: function (html) {
                    this.modified_final_version = lineNumberingService.stripLineNumbers(html);
                },
                // Copies to final version to the modified_final_version field
                copyModifiedFinalVersionStrippingLineBreaks: function () {
                    var finalVersion = this.getTextByMode('agreed');
                    this.setModifiedFinalVersionStrippingLineBreaks(finalVersion);
                },
                getModifiedFinalVersion: function (versionId) {
                    return this.getVersion(versionId).modified_final_version;
                },
                getReason: function (versionId) {
                    return this.getVersion(versionId).reason;
                },
                // full state name - optional with custom state name extension
                // depended by state and provided by a custom comment field
                getStateName: function () {
                    var name = '';
                    if (this.state) {
                        name = gettextCatalog.getString(this.state.name);
                        if (this.state.show_state_extension_field) {
                            // check motion comment fields for flag 'forState'
                            var commentFieldForStateId = MotionComment.getFieldIdForFlag('forState');
                            if (commentFieldForStateId > -1) {
                                name += ' ' + this.comments[commentFieldForStateId];
                            }
                        }
                    }
                    return MotionStateAndRecommendationParser.parse(name);
                },
                // ID of the state - or null, if to be reset
                setState: function(state_id) {
                    if (state_id === null) {
                        return $http.put('/rest/motions/motion/' + this.id + '/set_state/', {});
                    } else {
                        return $http.put('/rest/motions/motion/' + this.id + '/set_state/', {'state': state_id});
                    }
                },
                // full recommendation string - optional with custom recommendationextension
                // depended by state and provided by a custom comment field
                getRecommendationName: function () {
                    var recommendation = '';
                    if (Config.get('motions_recommendations_by').value !== '' && this.recommendation) {
                        recommendation = gettextCatalog.getString(this.recommendation.recommendation_label);
                        if (this.recommendation.show_recommendation_extension_field) {
                            // check motion comment fields for flag 'forRecommendation'
                            var commentFieldForRecommendationId = MotionComment.getFieldIdForFlag('forRecommendation');
                            if (commentFieldForRecommendationId > -1) {
                                recommendation += ' ' + this.comments[commentFieldForRecommendationId];
                            }
                        }
                    }
                    return MotionStateAndRecommendationParser.parse(recommendation);
                },
                // ID of the state - or null, if to be reset
                setRecommendation: function(recommendation_id) {
                    if (recommendation_id === null) {
                        return $http.put('/rest/motions/motion/' + this.id + '/set_recommendation/', {});
                    } else {
                        return $http.put('/rest/motions/motion/' + this.id + '/set_recommendation/', {'recommendation': recommendation_id});
                    }
                },
                // link name which is shown in search result
                getSearchResultName: function () {
                    return this.getTitle();
                },
                // return true if a specific relation matches for given searchquery
                // e.g. submitter, supporters or category
                hasSearchResult: function (results, searchquery) {
                    var motion = this;
                    // search for submitters and supporters (check if any user.id from already found users matches)
                    var foundSomething = _.some(results, function(result) {
                        if (result.getResourceName() === "users/user") {
                            if (_.some(motion.submitters, {'id': result.id})) {
                                return true;
                            } else if (_.some(motion.supporters, { 'id': result.id })) {
                                return true;
                            }
                        }
                    });
                    // search for category
                    if (!foundSomething && motion.category && motion.category.name.match(new RegExp(searchquery, 'i'))) {
                        foundSomething = true;
                    }

                    // search for change recommendation
                    if (!foundSomething) {
                        var recommendations = MotionChangeRecommendation.filter({
                            where: {motion_version_id: this.active_version}
                        });
                        foundSomething = _.some(recommendations, function(recommendation) {
                            if (recommendation.text.match(new RegExp(searchquery, 'i'))) {
                                return true;
                            }
                        });
                    }
                    return foundSomething;
                },
                getTextChangeRecommendations: function (versionId, order) {
                    /*
                     * Returns all change recommendations for this given version, sorted by line
                     * @param versionId
                     * @param order ['DESC' or 'ASC' (default)]
                     * @returns {*}
                     */
                    versionId = versionId || this.active_version;
                    order = order || 'ASC';
                    return MotionChangeRecommendation.filter({
                        where: {
                            motion_version_id: versionId
                        },
                        orderBy: [
                            ['line_from', order]
                        ]
                    }).filter(function(change) {
                        return change.isTextRecommendation();
                    });
                },
                getTitleChangeRecommendation: function (versionId) {
                    /**
                     * Returns the change recommendation affecting the title, or null
                     * @param versionId
                     * @returns MotionChangeRecommendation|null
                     */
                    versionId = versionId || this.active_version;
                    var changes = MotionChangeRecommendation.filter({
                        where: {
                            motion_version_id: versionId,
                            line_from: 0,
                            line_to: 0
                        }
                    });
                    return (changes.length > 0 ? changes[0] : null);
                },
                getAmendments: function () {
                    return DS.filter('motions/motion', {parent_id: this.id});
                },
                hasAmendments: function () {
                    return DS.filter('motions/motion', {parent_id: this.id}).length > 0;
                },
                getParagraphBasedAmendments: function () {
                    return DS.filter('motions/motion', {parent_id: this.id}).filter(function(amendment) {
                        return (amendment.isParagraphBasedAmendment());
                    });
                },
                getParagraphBasedAmendmentsForDiffView: function () {
                    return _.filter(this.getParagraphBasedAmendments(), function(amendment) {
                        // If no accepted/rejected status is given, only amendments that have a recommendation
                        // of "accepted" and have not been officially rejected are to be shown in the diff-view
                        if (amendment.state && amendment.state.name === 'rejected') {
                            return false;
                        }
                        if (amendment.state && amendment.state.name === 'accepted') {
                            return true;
                        }
                        return (amendment.recommendation && amendment.recommendation.name === 'accepted');
                    });
                },
                getParentMotion: function () {
                    if (this.parent_id > 0) {
                        var parents = DS.filter('motions/motion', {id: this.parent_id});
                        if (parents.length > 0) {
                            return parents[0];
                        } else {
                            return null;
                        }
                    } else {
                        return null;
                    }
                },
                isAllowed: function (action) {
                    /*
                     * Return true if the requested user is allowed to do the specific action.
                     * There are the following possible actions.
                     * - see
                     * - update
                     * - update_submitters
                     * - delete
                     * - create_poll
                     * - support
                     * - unsupport
                     * - change_state
                     * - reset_state
                     * - change_comments
                     * - change_recommendation
                     * - can_manage
                     * - can_see_amendments
                     * - can_create_amendments
                     *
                     *  NOTE: If you update this function please think about
                     *        server permissions, see motions/views.py.
                     */
                    switch (action) {
                        case 'see':
                            return (
                                operator.hasPerms('motions.can_see') &&
                                (
                                    !this.state.required_permission_to_see ||
                                    operator.hasPerms(this.state.required_permission_to_see) ||
                                    (operator.user in this.submitters)
                                )
                            );
                        case 'update':
                            return (
                                operator.hasPerms('motions.can_manage') ||
                                (
                                    (_.indexOf(this.submitters, operator.user) !== -1) &&
                                    this.state.allow_submitter_edit
                                )
                            );
                        case 'update_submitters':
                            return operator.hasPerms('motions.can_manage');
                        case 'delete':
                            return (
                                operator.hasPerms('motions.can_manage') ||
                                (
                                    (_.indexOf(this.submitters, operator.user) !== -1) &&
                                    this.state.allow_submitter_edit
                                )
                            );
                        case 'create_poll':
                            return (
                                operator.hasPerms('motions.can_manage') &&
                                this.state &&
                                this.state.allow_create_poll
                            );
                        case 'support':
                            return (
                                operator.hasPerms('motions.can_support') &&
                                this.state.allow_support &&
                                Config.get('motions_min_supporters').value > 0 &&
                                (_.indexOf(this.submitters, operator.user) === -1) &&
                                (_.indexOf(this.supporters, operator.user) === -1)
                            );
                        case 'unsupport':
                            return this.state.allow_support && _.indexOf(this.supporters, operator.user) !== -1;
                        case 'change_state':
                            return operator.hasPerms('motions.can_manage');
                        case 'reset_state':
                            return operator.hasPerms('motions.can_manage');
                        case 'change_comments':
                            return operator.hasPerms('motions.can_manage_comments');
                        case 'change_recommendation':
                            return operator.hasPerms('motions.can_manage');
                        case 'can_manage':
                            return operator.hasPerms('motions.can_manage');
                        case 'can_see_amendments':
                            var result;
                            if (operator.hasPerms('motions.can_create')) {
                                result = Config.get('motions_amendments_enabled').value &&
                                    (this.hasAmendments() || this.isAllowed('can_create_amendment'));
                            } else if (operator.hasPerms('motions.can_see')) {
                                result = Config.get('motions_amendments_enabled').value && this.hasAmendments();
                            }
                            return result;
                        case 'can_create_amendment':
                            return (
                                operator.hasPerms('motions.can_create') &&
                                Config.get('motions_amendments_enabled').value &&
                                ( !this.isAmendment ||
                                  (this.isAmendment && OpenSlidesSettings.MOTIONS_ALLOW_AMENDMENTS_OF_AMENDMENTS))
                            );
                        default:
                            return false;
                    }
                },
                /* Overrides from jsDataModel factory.
                 * Also sets the projection mode if given; If not it projects in 'original' mode. */
                project: function (projectorId, mode) {
                    // if this object is already projected on projectorId, delete this element from this projector
                    var requestData = {
                        clear_ids: this.isProjected(),
                    };
                    // Was there a projector with the same id and mode as the given id and mode?
                    // If not, project the motion.
                    var wasProjectedBefore = _.some(this.isProjectedWithMode(), function (mapping) {
                        var value = (mapping.projectorId === projectorId);
                        if (mode) {
                            value = value && (mapping.mode === mode);
                        }
                        return value;
                    });
                    mode = mode || Config.get('motions_recommendation_text_mode').value;
                    if (!wasProjectedBefore) {
                        requestData.prune = {
                            id: projectorId,
                            element: {
                                name: name,
                                id: this.id,
                                mode: mode,
                            },
                        };
                    }
                    return ProjectHelper.project(requestData);
                },
                isProjected: function (mode) {
                    var self = this;
                    var predicate = function (element) {
                        var value = element.name === name &&
                            element.id === self.id;
                        if (mode) {
                            value = value && (element.mode === mode);
                        }
                        return value;
                    };
                    var projectorIds = [];
                    _.forEach(Projector.getAll(), function (projector) {
                        if (typeof _.findKey(projector.elements, predicate) === 'string') {
                            projectorIds.push(projector.id);
                        }
                    });
                    return projectorIds;
                },
                /* returns a list of mappings between projector id and mode:
                 * [ {projectorId: 2, mode: 'original'}, ... ] */
                isProjectedWithMode: function () {
                    var self = this;
                    var mapping = [];
                    _.forEach(Projector.getAll(), function (projector) {
                        _.forEach(projector.elements, function (element) {
                            if (element.name === name && element.id === self.id) {
                                mapping.push({
                                    projectorId: projector.id,
                                    mode: element.mode || 'original',
                                });
                            }
                        });
                    });
                    return mapping;
                },
                isRelatedProjected: function () {
                    // A motion related object is the list of speakers (through the agenda item)
                    if (this.agenda_item) {
                        return this.agenda_item.isListOfSpeakersProjected();
                    } else {
                        return [];
                    }
                },
            },
            relations: {
                belongsTo: {
                    'motions/category': {
                        localField: 'category',
                        localKey: 'category_id',
                    },
                    'motions/motion-block': {
                        localField: 'motionBlock',
                        localKey: 'motion_block_id',
                    },
                    'agenda/item': {
                        localKey: 'agenda_item_id',
                        localField: 'agenda_item',
                    }
                },
                hasMany: {
                    'core/tag': {
                        localField: 'tags',
                        localKeys: 'tags_id',
                    },
                    'mediafiles/mediafile': {
                        localField: 'attachments',
                        localKeys: 'attachments_id',
                    },
                    'users/user': {
                        localField: 'supporters',
                        localKeys: 'supporters_id',
                    },
                    'motions/motion-poll': {
                        localField: 'polls',
                        foreignKey: 'motion_id',
                    },
                    'motions/submitter': {
                        localField: 'submitters',
                        foreignKey: 'motion_id',
                    },
                },
                hasOne: {
                    'motions/state': [
                        {
                            localField: 'state',
                            localKey: 'state_id',
                        },
                        {
                            localField: 'recommendation',
                            localKey: 'recommendation_id',
                        }
                    ]
                }
            }
        });
    }
])

// Service for generic comment fields
.factory('MotionComment', [
    '$filter',
    'Config',
    'operator',
    'Editor',
    function ($filter, Config, operator, Editor) {
        return {
            isSpecialCommentField: function (field) {
                if (field) {
                    return field.forState || field.forRecommendation;
                } else {
                    return false;
                }
            },
            getCommentsFields: function () {
                var fields = Config.get('motions_comments').value;
                return $filter('excludeDeletedAndForbiddenCommentsFields')(fields);
            },
            getNoSpecialCommentsFields: function () {
                var fields = this.getCommentsFields();
                return $filter('excludeSpecialCommentsFields')(fields);
            },
            getFormFields: function () {
                var fields = this.getNoSpecialCommentsFields();
                return _.map(fields, function (field, id) {
                        return {
                            key: 'comment_' + id,
                            type: 'editor',
                            templateOptions: {
                                label: field.name,
                            },
                            data: {
                                ckeditorOptions: Editor.getOptions()
                            },
                            hide: !operator.hasPerms("motions.can_manage_comments")
                        };
                    }
                );
            },
            getFormField : function (id) {
                var fields = this.getNoSpecialCommentsFields();
                var field = fields[id];
                if (field) {
                    return {
                        key: 'comment_' + id,
                        type: 'editor',
                        templateOptions: {
                            label: field.name,
                        },
                        data: {
                            ckeditorOptions: Editor.getOptions()
                        },
                        hide: !operator.hasPerms("motions.can_manage_comments")
                    };
                }
            },
            populateFields: function (motion) {
                // Populate content of motion.comments to the single comment
                var fields = this.getCommentsFields();
                if (motion.comments) {
                    _.forEach(fields, function (field, id) {
                        motion['comment_' + id] = motion.comments[id];
                    });
                }
            },
            populateFieldsReverse: function (motion) {
                // Reverse equivalent to populateFields.
                var fields = this.getCommentsFields();
                motion.comments = {};
                _.forEach(fields, function (field, id) {
                    motion.comments[id] = motion['comment_' + id] || '';
                });
            },
            getFieldIdForFlag: function (flag) {
                var fields = this.getCommentsFields();
                return _.findKey(fields, [flag, true]);
            },
        };
    }
])

.filter('excludeSpecialCommentsFields', [
    'MotionComment',
    function (MotionComment) {
        return function (commentsFields) {
            var withoutSpecialCommentsFields = {};
            _.forEach(commentsFields, function (field, id) {
                if (!MotionComment.isSpecialCommentField(field)) {
                    withoutSpecialCommentsFields[id] = field;
                }
            });
            return withoutSpecialCommentsFields;
        };
    }
])

.filter('excludeDeletedAndForbiddenCommentsFields', [
    'MotionComment',
    'operator',
    function (MotionComment, operator) {
        return function (commentsFields) {
            var withoutDeletedAndForbiddenCommentsFields = {};
            _.forEach(commentsFields, function (field, id) {
                if (field && (field.public || operator.hasPerms('motions.can_see_comments'))) {
                    withoutDeletedAndForbiddenCommentsFields[id] = field;
                }
            });
            return withoutDeletedAndForbiddenCommentsFields;
        };
    }
])

.factory('Category', [
    'DS',
    function(DS) {
        return DS.defineResource({
            name: 'motions/category',
        });
    }
])

.factory('MotionChangeRecommendation', [
    'DS',
    'Config',
    'jsDataModel',
    'diffService',
    'lineNumberingService',
    'UnifiedChangeObjectCollission',
    'gettextCatalog',
    function (DS, Config, jsDataModel, diffService, lineNumberingService,
        UnifiedChangeObjectCollission, gettextCatalog) {
        return DS.defineResource({
            name: 'motions/motion-change-recommendation',
            useClass: jsDataModel,
            methods: {
                saveStatus: function() {
                    this.DSSave();
                },
                isTitleRecommendation: function() {
                    return (this.line_from === 0 && this.line_to === 0);
                },
                isTextRecommendation: function() {
                    return (this.line_from !== 0 || this.line_to !== 0);
                },
                getDiff: function(motion, version, highlight) {
                    var lineLength = Config.get('motions_line_length').value,
                        html = lineNumberingService.insertLineNumbers(motion.getVersion(version).text, lineLength),
                        data, oldText;

                    try {
                        data = diffService.extractRangeByLineNumbers(html, this.line_from, this.line_to);
                        oldText = data.outerContextStart + data.innerContextStart +
                            data.html + data.innerContextEnd + data.outerContextEnd;
                    } catch (e) {
                        // This only happens (as far as we know) when the motion text has been altered (shortened)
                        // without modifying the change recommendations accordingly.
                        // That's a pretty serious inconsistency that should not happen at all,
                        // we're just doing some basic damage control here.
                        var msg = 'Inconsistent data. A change recommendation is probably referring to a non-existant line number.';
                        return '<em style="color: red; font-weight: bold;">' + msg + '</em>';
                    }
                    oldText = lineNumberingService.insertLineNumbers(oldText, lineLength, null, null, this.line_from);
                    var diff = diffService.diff(oldText, this.text);

                    // If an insertion makes the line longer than the line length limit, we need two line breaking runs:
                    // - First, for the official line numbers, ignoring insertions (that's been done some lines before)
                    // - Second, another one to prevent the displayed including insertions to exceed the page width
                    diff = lineNumberingService.insertLineBreaksWithoutNumbers(diff, lineLength, true);

                    if (highlight > 0) {
                        diff = lineNumberingService.highlightLine(diff, highlight);
                    }

                    var origBeginning = data.outerContextStart + data.innerContextStart;
                    if (diff.toLowerCase().indexOf(origBeginning.toLowerCase()) === 0) {
                        // Add "merge-before"-css-class if the first line begins in the middle of a paragraph. Used for PDF.
                        diff = diffService.addCSSClassToFirstTag(origBeginning, "merge-before") + diff.substring(origBeginning.length);
                    }

                    return diff;
                },
                getType: function(original_full_html) {
                    return this.type;
                },
                getTitle: function(original_full_html) {
                    var title;
                    if (this.line_to > (this.line_from + 1)) {
                        title = gettextCatalog.getString('%TYPE% from line %FROM% to %TO%');
                    } else {
                        title = gettextCatalog.getString('%TYPE% in line %FROM%');
                    }
                    switch (this.getType(original_full_html)) {
                        case diffService.TYPE_INSERTION:
                            title = title.replace('%TYPE%', gettextCatalog.getString('Insertion'));
                            break;
                        case diffService.TYPE_DELETION:
                            title = title.replace('%TYPE%', gettextCatalog.getString('Deletion'));
                            break;
                        case diffService.TYPE_REPLACEMENT:
                            title = title.replace('%TYPE%', gettextCatalog.getString('Replacement'));
                            break;
                        case diffService.TYPE_OTHER:
                            title = title.replace('%TYPE%', this.other_description);
                            break;
                    }
                    title = title.replace('%FROM%', this.line_from).replace('%TO%', (this.line_to - 1));
                    return title;
                },
                getUnifiedChangeObject: function () {
                    // The interface of this object needs to be synchronized with the same method in Motion
                    //
                    // The change object needs to be cached to prevent confusing Angular's change detection
                    // Otherwise, a new object would be created with every call, leading to flickering
                    var recommendation = this;

                    if (this._change_object === undefined) {
                        // Properties that are guaranteed to be constant
                        this._change_object = {
                            "type": "recommendation",
                            "other_description": recommendation.other_description,
                            "id": "recommendation-" + recommendation.id,
                            "original": recommendation,
                            "saveStatus": function () {
                                recommendation.rejected = recommendation._change_object.rejected;
                                recommendation.saveStatus();
                            },
                            "getDiff": function (motion, version, highlight) {
                                return recommendation.getDiff(motion, version, highlight);
                            }
                        };
                    }
                    // Properties that might change when the Change Recommendation is edited
                    this._change_object.line_from = recommendation.line_from;
                    this._change_object.line_to = recommendation.line_to;
                    this._change_object.rejected = recommendation.rejected;
                    this._change_object.accepted = !recommendation.rejected;

                    UnifiedChangeObjectCollission.populate(this._change_object);

                    return this._change_object;
                }
            }
        });
    }
])

.factory('UnifiedChangeObjectCollission', [
    function () {
        return {
            populate: function (obj) {
                obj.otherChanges = [];
                obj.setOtherChangesForCollission = function (changes) {
                    obj.otherChanges = changes;
                };
                obj.getCollissions = function(onlyAccepted) {
                    return obj.otherChanges.filter(function(otherChange) {
                        if (onlyAccepted && !otherChange.accepted) {
                            return false;
                        }
                        return (otherChange.id !== obj.id && (
                            (otherChange.line_from >= obj.line_from && otherChange.line_from < obj.line_to) ||
                            (otherChange.line_to > obj.line_from && otherChange.line_to <= obj.line_to) ||
                            (otherChange.line_from < obj.line_from && otherChange.line_to > obj.line_to)
                        ));
                    });
                };
                obj.getAcceptedCollissions = function() {
                    return obj.getCollissions().filter(function(colliding) {
                        return colliding.accepted;
                    });
                };
                obj.setAccepted = function($event) {
                    if (obj.getAcceptedCollissions().length > 0) {
                        $event.preventDefault();
                        $event.stopPropagation();
                        return;
                    }
                    obj.accepted = true;
                    obj.rejected = false;
                    obj.saveStatus();
                };
                obj.setRejected = function($event) {
                    obj.rejected = true;
                    obj.accepted = false;
                    obj.saveStatus();
                };
            },
        };
    }
])

.run([
    'Motion',
    'Category',
    'Workflow',
    'MotionState',
    'MotionChangeRecommendation',
    'Submitter',
    function(Motion, Category, Workflow, MotionState, MotionChangeRecommendation, Submitter) {}
])


// Mark all motion workflow state strings for translation in JavaScript.
// (see motions/signals.py)
.config([
    'gettext',
    function (gettext) {
        // workflow 1
        gettext('Simple Workflow');
        gettext('submitted');
        gettext('accepted');
        gettext('Accept');
        gettext('Acceptance');
        gettext('rejected');
        gettext('Reject');
        gettext('Rejection');
        gettext('not decided');
        gettext('Do not decide');
        gettext('No decision');
        // workflow 2
        gettext('Complex Workflow');
        gettext('published');
        gettext('permitted');
        gettext('Permit');
        gettext('Permission');
        gettext('accepted');
        gettext('Accept');
        gettext('Acceptance');
        gettext('rejected');
        gettext('Reject');
        gettext('Rejection');
        gettext('withdrawed');
        gettext('Withdraw');
        gettext('adjourned');
        gettext('Adjourn');
        gettext('Adjournment');
        gettext('not concerned');
        gettext('Do not concern');
        gettext('No concernment');
        gettext('refered to committee');
        gettext('Refer to committee');
        gettext('Referral to committee');
        gettext('needs review');
        gettext('Needs review');
        gettext('rejected (not authorized)');
        gettext('Reject (not authorized)');
        gettext('Rejection (not authorized)');
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.motions.csv', [])

.factory('MotionCsvExport', [
    '$filter',
    'gettextCatalog',
    'Config',
    'CsvDownload',
    'lineNumberingService',
    function ($filter, gettextCatalog, Config, CsvDownload, lineNumberingService) {
        var makeHeaderline = function (params) {
            var headerline = ['Identifier', 'Title'];
            if (params.include.text) {
                headerline.push('Text');
            }
            if (params.include.reason) {
                headerline.push('Reason');
            }
            if (params.include.submitters) {
                headerline.push('Submitter');
            }
            headerline.push('Category');
            if (params.include.origin) {
                headerline.push('Origin');
            }
            if (params.include.motionBlock) {
                headerline.push('Motion block');
            }
            return _.map(headerline, function (entry) {
                return gettextCatalog.getString(entry);
            });
        };
        return {
            export: function (motions, params) {
                if (!params) {
                    params = {};
                }
                _.defaults(params, {
                    changeRecommendationMode: Config.get('motions_recommendation_text_mode').value,
                    include: {
                        text: true,
                        reason: true,
                        submitters: true,
                        origin: true,
                        motionBlock: true,
                        state: true,
                        recommendation: true,
                    },
                });
                params.filename = gettextCatalog.getString('motions') + '.csv';
                if (!_.includes(['original', 'changed', 'agreed'], params.changeRecommendationMode)) {
                    params.changeRecommendationMode = 'original';
                }

                var csvRows = [
                    makeHeaderline(params)
                ];
                _.forEach(motions, function (motion) {
                    var text = motion.getTextByMode(params.changeRecommendationMode, null, null, false);
                    var row = [];
                    // Identifier and title
                    row.push('"' + motion.identifier !== null ? motion.identifier : '' + '"');
                    row.push('"' + motion.getTitle() + '"');

                    // Text
                    if (params.include.text) {
                        row.push('"' + text + '"');
                    }

                    // Reason
                    if (params.include.reason) {
                        row.push('"' + motion.getReason() + '"');
                    }

                    // Submitters
                    if (params.include.submitters) {
                        var submitters = [];
                        _.forEach($filter('orderBy')(motion.submitters, 'weight'), function (user) {
                            var user_short_name = [
                                user.user.title,
                                user.user.first_name,
                                user.user.last_name
                            ].join(' ').trim();
                            submitters.push(user_short_name);
                        });
                        row.push('"' + submitters.join('; ') + '"');
                    }

                    // Category
                    var category = motion.category ? motion.category.name : '';
                    row.push('"' + category + '"');

                    // Origin
                    if (params.include.origin) {
                        row.push('"' + motion.origin + '"');
                    }

                    // Motion block
                    if (params.include.motionBlock) {
                        var blockTitle = motion.motionBlock ? motion.motionBlock.title : '';
                        row.push('"' + blockTitle + '"');
                    }

                    csvRows.push(row);
                });
                CsvDownload(csvRows, params.filename);
            },
            downloadExample: function () {
                var csvRows = [makeHeaderline({ include: {
                        text: true,
                        reason: true,
                        submitters: true,
                        origin: true,
                        motionBlock: true,
                        state: true,
                        recommendation: true,
                    }}),
                    // example entries
                    ['A1', 'Title 1', 'Text 1', 'Reason 1', 'Submitter A', 'Category A', 'Last Year Conference A', 'Block A'],
                    ['B1', 'Title 2', 'Text 2', 'Reason 2', 'Submitter B', 'Category B', '', 'Block A'],
                    [''  , 'Title 3', 'Text 3', '', '', '', '', ''],
                ];
                CsvDownload(csvRows, gettextCatalog.getString('motions-example') + '.csv');
            },
        };
    }
])

.factory('AmendmentCsvExport', [
    'gettextCatalog',
    'CsvDownload',
    'lineNumberingService',
    function (gettextCatalog, CsvDownload, lineNumberingService) {
        var makeHeaderline = function () {
            var headerline = ['Identifier', 'Submitters', 'Category', 'Motion block',
                'Leadmotion', 'Line', 'Old text', 'New text'];
            return _.map(headerline, function (entry) {
                return gettextCatalog.getString(entry);
            });
        };
        return {
            export: function (amendments) {
                var csvRows = [
                    makeHeaderline()
                ];
                _.forEach(amendments, function (amendment) {
                    var row = [];
                    // Identifier and title
                    row.push('"' + amendment.identifier !== null ? amendment.identifier : '' + '"');
                    // Submitters
                    var submitters = [];
                    angular.forEach(amendment.submitters, function(user) {
                        var user_short_name = [user.title, user.first_name, user.last_name].join(' ').trim();
                        submitters.push(user_short_name);
                    });
                    row.push('"' + submitters.join('; ') + '"');

                    // Category
                    var category = amendment.category ? amendment.category.name : '';
                    row.push('"' + category + '"');

                    // Motion block
                    var blockTitle = amendment.motionBlock ? amendment.motionBlock.title : '';
                    row.push('"' + blockTitle + '"');

                    // Lead motion
                    var leadmotion = amendment.getParentMotion();
                    if (leadmotion) {
                        var leadmotionTitle = leadmotion.identifier ? leadmotion.identifier + ': ' : '';
                        leadmotionTitle += leadmotion.getTitle();
                        row.push('"' + leadmotionTitle + '"');
                    } else {
                        row.push('""');
                    }

                    // changed paragraph
                    if (amendment.isParagraphBasedAmendment()) {
                        // TODO: get old and new paragraphLine. Resolve todo
                        // in motion.getAmendmentParagraphsLinesByMode
                        var p_old = amendment.getAmendmentParagraphsLinesByMode('original', null, false)[0];
                        //var p_new = amendment.getAmendmentParagraphsLinesByMode('changed', null, false)[0];
                        var lineStr = p_old.diffLineFrom;
                        if (p_old.diffLineTo != p_old.diffLineFrom + 1) {
                            lineStr += '-' + p_old.diffLineTo;
                        }
                        row.push('"' + lineStr + '"');
                        //row.push('"' + p_old.text.html + '"');
                        //row.push('"' + p_new.text.html + '"');

                        // Work around: Export the full paragraphs instead of changed lines
                        row.push('"' + amendment.getAmendmentParagraphsByMode('original', null, false)[0].text + '"');
                        row.push('"' + amendment.getAmendmentParagraphsByMode('changed', null, false)[0].text + '"');
                    } else {
                        row.push('""');
                        row.push('""');
                        row.push('"' + amendment.getText() + '"');
                    }

                    csvRows.push(row);
                });
                CsvDownload(csvRows, 'amendments-export.csv');
            },
        };
    }
]);

}());

(function () {

"use strict";

angular.module('OpenSlidesApp.motions.diff', ['OpenSlidesApp.motions.lineNumbering'])

.service('diffService', [
    'lineNumberingService',
    '$cacheFactory',
    function (lineNumberingService, $cacheFactory) {
        var ELEMENT_NODE = 1,
            TEXT_NODE = 3,
            DOCUMENT_FRAGMENT_NODE = 11;

        var diffCache = $cacheFactory('diff.service');

        this.TYPE_REPLACEMENT = 0;
        this.TYPE_INSERTION = 1;
        this.TYPE_DELETION = 2;
        this.TYPE_OTHER = 3;

        this.getLineNumberNode = function(fragment, lineNumber) {
            return fragment.querySelector('os-linebreak.os-line-number.line-number-' + lineNumber);
        };

        /**
         * @param {Element} element
         */
        this._getFirstLineNumberNode = function(element) {
            if (element.nodeType === TEXT_NODE) {
                return null;
            }
            if (element.nodeName === 'OS-LINEBREAK') {
                return element;
            }
            var found = element.querySelectorAll('OS-LINEBREAK');
            if (found.length > 0) {
                return found.item(0);
            } else {
                return null;
            }
        };

        /**
         * @param {Element} element
         */
        this._getLastLineNumberNode = function(element) {
            if (element.nodeType === TEXT_NODE) {
                return null;
            }
            if (element.nodeName === 'OS-LINEBREAK') {
                return element;
            }
            var found = element.querySelectorAll('OS-LINEBREAK');
            if (found.length > 0) {
                return found.item(found.length - 1);
            } else {
                return null;
            }
        };

        this._getNodeContextTrace = function(node) {
            var context = [],
                currNode = node;
            while (currNode) {
                context.unshift(currNode);
                currNode = currNode.parentNode;
            }
            return context;
        };

        this._isFirstNonemptyChild = function(node, child) {
            for (var i = 0; i < node.childNodes.length; i++) {
                if (node.childNodes[i] === child) {
                    return true;
                }
                if (node.childNodes[i].nodeType !== TEXT_NODE || node.childNodes[i].nodeValue.match(/\S/)) {
                    return false;
                }
            }
            return false;
        };

        // Adds elements like <OS-LINEBREAK class="os-line-number line-number-23" data-line-number="23"/>
        this._insertInternalLineMarkers = function(fragment) {
            if (fragment.querySelectorAll('OS-LINEBREAK').length > 0) {
                // Prevent duplicate calls
                return;
            }
            var lineNumbers = fragment.querySelectorAll('span.os-line-number'),
                lineMarker, maxLineNumber;

            for (var i = 0; i < lineNumbers.length; i++) {
                var insertBefore = lineNumbers[i];
                while (insertBefore.parentNode.nodeType !== DOCUMENT_FRAGMENT_NODE &&
                       this._isFirstNonemptyChild(insertBefore.parentNode, insertBefore)) {
                    insertBefore = insertBefore.parentNode;
                }
                lineMarker = document.createElement('OS-LINEBREAK');
                lineMarker.setAttribute('data-line-number', lineNumbers[i].getAttribute('data-line-number'));
                lineMarker.setAttribute('class', lineNumbers[i].getAttribute('class'));
                insertBefore.parentNode.insertBefore(lineMarker, insertBefore);
                maxLineNumber = lineNumbers[i].getAttribute('data-line-number');
            }

            // Add one more "fake" line number at the end and beginning, so we can select the last line as well
            lineMarker = document.createElement('OS-LINEBREAK');
            lineMarker.setAttribute('data-line-number', (parseInt(maxLineNumber) + 1));
            lineMarker.setAttribute('class', 'os-line-number line-number-' + (parseInt(maxLineNumber) + 1));
            fragment.appendChild(lineMarker);

            lineMarker = document.createElement('OS-LINEBREAK');
            lineMarker.setAttribute('data-line-number', '0');
            lineMarker.setAttribute('class', 'os-line-number line-number-0');
            fragment.insertBefore(lineMarker, fragment.firstChild);
        };

        // @TODO Check if this is actually necessary
        this._insertInternalLiNumbers = function(fragment) {
            if (fragment.querySelectorAll('LI[os-li-number]').length > 0) {
                // Prevent duplicate calls
                return;
            }
            var ols = fragment.querySelectorAll('OL');
            for (var i = 0; i < ols.length; i++) {
                var ol = ols[i],
                    liNo = 0;
                for (var j = 0; j < ol.childNodes.length; j++) {
                    if (ol.childNodes[j].nodeName == 'LI') {
                        liNo++;
                        ol.childNodes[j].setAttribute('os-li-number', liNo);
                    }
                }
            }
        };

        this._addStartToOlIfNecessary = function(node) {
            var firstLiNo = null;
            for (var i = 0; i < node.childNodes.length && firstLiNo === null; i++) {
                if (node.childNode[i].nodeName == 'LI') {
                    var lineNo = node.childNode[i].getAttribute('ol-li-number');
                    if (lineNo) {
                        firstLiNo = parseInt(lineNo);
                    }
                }
            }
            if (firstLiNo > 1) {
                node.setAttribute('start', firstLiNo);
            }
        };

        this._isWithinNthLIOfOL = function(olNode, descendantNode) {
            var nthLIOfOL = null;
            while (descendantNode.parentNode) {
                if (descendantNode.parentNode === olNode) {
                    var lisBeforeOl = 0,
                        foundMe = false;
                    for (var i = 0; i < olNode.childNodes.length && !foundMe; i++) {
                        if (olNode.childNodes[i] === descendantNode) {
                            foundMe = true;
                        } else if (olNode.childNodes[i].nodeName === 'LI') {
                            lisBeforeOl++;
                        }
                    }
                    nthLIOfOL = lisBeforeOl + 1;
                }
                descendantNode = descendantNode.parentNode;
            }
            return nthLIOfOL;
        };

       /*
        * Returns an array with the following values:
        * 0: the most specific DOM-node that contains both line numbers
        * 1: the context of node1 (an array of dom-elements; 0 is the document fragment)
        * 2: the context of node2 (an array of dom-elements; 0 is the document fragment)
        * 3: the index of [0] in the two arrays
        */
        this._getCommonAncestor = function(node1, node2) {
            var trace1 = this._getNodeContextTrace(node1),
                trace2 = this._getNodeContextTrace(node2),
                commonAncestor = null,
                commonIndex = null,
                childTrace1 = [],
                childTrace2 = [];

            for (var i = 0; i < trace1.length && i < trace2.length; i++) {
                if (trace1[i] == trace2[i]) {
                    commonAncestor = trace1[i];
                    commonIndex = i;
                }
            }
            for (i = commonIndex + 1; i < trace1.length; i++) {
                childTrace1.push(trace1[i]);
            }
            for (i = commonIndex + 1; i < trace2.length; i++) {
                childTrace2.push(trace2[i]);
            }
            return {
                'commonAncestor': commonAncestor,
                'trace1' : childTrace1,
                'trace2' : childTrace2,
                'index': commonIndex
            };
        };

        this._serializeTag = function(node) {
            if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
                // Fragments are only placeholders and do not have an HTML representation
                return '';
            }
            var html = '<' + node.nodeName;
            for (var i = 0; i < node.attributes.length; i++) {
                var attr = node.attributes[i];
                if (attr.name !== 'os-li-number') {
                    html += ' ' + attr.name + '="' + attr.value + '"';
                }
            }
            html += '>';
            return html;
        };

        this._serializeDom = function(node, stripLineNumbers) {
            if (node.nodeType === TEXT_NODE) {
                return node.nodeValue.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            }
            if (stripLineNumbers && (
                lineNumberingService._isOsLineNumberNode(node) || lineNumberingService._isOsLineBreakNode(node))) {
                return '';
            }
            if (node.nodeName === 'OS-LINEBREAK') {
                return '';
            }
            if (node.nodeName === 'BR') {
                var br = '<BR';
                for (i = 0; i < node.attributes.length; i++) {
                    var attr = node.attributes[i];
                    br += " " + attr.name + "=\"" + attr.value + "\"";
                }
                return br + '>';
            }

            var html = this._serializeTag(node);
            for (var i = 0; i < node.childNodes.length; i++) {
                if (node.childNodes[i].nodeType === TEXT_NODE) {
                    html += node.childNodes[i].nodeValue.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                } else if (!stripLineNumbers || (!lineNumberingService._isOsLineNumberNode(node.childNodes[i]) && !lineNumberingService._isOsLineBreakNode(node.childNodes[i]))) {
                    html += this._serializeDom(node.childNodes[i], stripLineNumbers);
                }
            }
            if (node.nodeType !== DOCUMENT_FRAGMENT_NODE) {
                html += '</' + node.nodeName + '>';
            }

            return html;
        };

        /**
         * Implementation hint: the first element of "toChildTrace" array needs to be a child element of "node"
         */
        this._serializePartialDomToChild = function(node, toChildTrace, stripLineNumbers) {
            if (lineNumberingService._isOsLineNumberNode(node) || lineNumberingService._isOsLineBreakNode(node)) {
                return '';
            }
            if (node.nodeName === 'OS-LINEBREAK') {
                return '';
            }

            var html = this._serializeTag(node);

            for (var i = 0, found = false; i < node.childNodes.length && !found; i++) {
                if (node.childNodes[i] === toChildTrace[0]) {
                    found = true;
                    var remainingTrace = toChildTrace;
                    remainingTrace.shift();
                    if (!lineNumberingService._isOsLineNumberNode(node.childNodes[i])) {
                        html += this._serializePartialDomToChild(node.childNodes[i], remainingTrace, stripLineNumbers);
                    }
                } else if (node.childNodes[i].nodeType === TEXT_NODE) {
                    html += node.childNodes[i].nodeValue;
                } else {
                    if (!stripLineNumbers || (!lineNumberingService._isOsLineNumberNode(node.childNodes[i]) &&
                      !lineNumberingService._isOsLineBreakNode(node.childNodes[i]))) {
                        html += this._serializeDom(node.childNodes[i], stripLineNumbers);
                    }
                }
            }
            if (!found) {
                console.trace();
                throw "Inconsistency or invalid call of this function detected (to)";
            }
            return html;
        };

        /**
         * Implementation hint: the first element of "toChildTrace" array needs to be a child element of "node"
         */
        this._serializePartialDomFromChild = function(node, fromChildTrace, stripLineNumbers) {
            if (lineNumberingService._isOsLineNumberNode(node) || lineNumberingService._isOsLineBreakNode(node)) {
                return '';
            }
            if (node.nodeName === 'OS-LINEBREAK') {
                return '';
            }

            var html = '';
            for (var i = 0, found = false; i < node.childNodes.length; i++) {
                if (node.childNodes[i] === fromChildTrace[0]) {
                    found = true;
                    var remainingTrace = fromChildTrace;
                    remainingTrace.shift();
                    if (!lineNumberingService._isOsLineNumberNode(node.childNodes[i])) {
                        html += this._serializePartialDomFromChild(node.childNodes[i], remainingTrace, stripLineNumbers);
                    }
                } else if (found) {
                    if (node.childNodes[i].nodeType === TEXT_NODE) {
                        html += node.childNodes[i].nodeValue;
                    } else {
                        if (!stripLineNumbers || (!lineNumberingService._isOsLineNumberNode(node.childNodes[i]) &&
                          !lineNumberingService._isOsLineBreakNode(node.childNodes[i]))) {
                            html += this._serializeDom(node.childNodes[i], stripLineNumbers);
                        }
                    }
                }
            }
            if (!found) {
                console.trace();
                throw "Inconsistency or invalid call of this function detected (from)";
            }
            if (node.nodeType !== DOCUMENT_FRAGMENT_NODE) {
                html += '</' + node.nodeName + '>';
            }
            return html;
        };

        /**
         * @param {string} html
         * @return {DocumentFragment}
         */
        this.htmlToFragment = function(html) {
            var fragment = document.createDocumentFragment(),
                div = document.createElement('DIV');
            div.innerHTML = html;
            while (div.childElementCount) {
                var child = div.childNodes[0];
                div.removeChild(child);
                fragment.appendChild(child);
            }
            return fragment;
        };

        /**
         * When a <li> with a os-split-before-class (set by extractRangeByLineNumbers) is edited when creating a
         * change recommendation and is split again in CKEditor, the second list items also gets that class.
         * This is not correct however, as the second one actually is a new list item. So we need to remove it again.
         *
         * @param {string} html
         * @returns {string}
         */
        this.removeDuplicateClassesInsertedByCkeditor = function(html) {
            var fragment = this.htmlToFragment(html);
            var items = fragment.querySelectorAll('li.os-split-before');
            for (var i = 0; i < items.length; i++) {
                if (!this._isFirstNonemptyChild(items[i].parentNode, items[i])) {
                    this.removeCSSClass(items[i], 'os-split-before');
                }
            }
            return this._serializeDom(fragment, false);
        };

        /**
         * Returns the HTML snippet between two given line numbers.
         *
         * Hint:
         * - The last line (toLine) is not included anymore, as the number refers to the line breaking element at the end of the line
         * - if toLine === null, then everything from fromLine to the end of the fragment is returned
         *
         * In addition to the HTML snippet, additional information is provided regarding the most specific DOM element
         * that contains the whole section specified by the line numbers (like a P-element if only one paragraph is selected
         * or the most outer DIV, if multiple sections selected).
         *
         * This additional information is meant to render the snippet correctly without producing broken HTML
         *
         * The return object has the following fields:
         * - html: The HTML between the two line numbers.
         *         Line numbers and automatically set line breaks are stripped.
         *         All HTML tags are converted to uppercase
         *         (e.g. Line 2</LI><LI>Line3</LI><LI>Line 4 <br>)
         * - ancestor: the most specific DOM element that contains the HTML snippet (e.g. a UL, if several LIs are selected)
         * - outerContextStart: An HTML string that opens all necessary tags to get the browser into the rendering mode
         *                      of the ancestor element (e.g. <DIV><UL> in the case of the multiple LIs)
         * - outerContectEnd:   An HTML string that closes all necessary tags from the ancestor element (e.g. </UL></DIV>
         * - innerContextStart: A string that opens all necessary tags between the ancestor
         *                      and the beginning of the selection (e.g. <LI>)
         * - innerContextEnd:   A string that closes all tags after the end of the selection to the ancestor (e.g. </LI>)
         * - previousHtml:      The HTML before the selected area begins (including line numbers)
         * - previousHtmlEndSnippet: A HTML snippet that closes all open tags from previousHtml
         * - followingHtml:     The HTML after the selected area
         * - followingHtmlStartSnippet: A HTML snippet that opens all HTML tags necessary to render "followingHtml"
         *
         *
         * In some cases, the returned HTML tags receive additional CSS classes, providing information both for
         * rendering it and for merging it again correctly.
         * - os-split-*:        These classes are set for all HTML Tags that have been split into two by this process,
         *                      e.g. if the fromLine- or toLine-line-break was somewhere in the middle of this tag.
         *                      If a tag is split, the first one receives "os-split-after", and the second one "os-split-before".
         * For example, for the following string <p>Line 1<br>Line 2<br>Line 3</p>:
         * - extracting line 1 to 2 results in <p class="os-split-after">Line 1</p>
         * - extracting line 2 to 3 results in <p class="os-split-after os-split-before">Line 2</p>
         * - extracting line 3 to null/4 results in <p class="os-split-before">Line 3</p>
         */
        this.extractRangeByLineNumbers = function(htmlIn, fromLine, toLine) {
            if (typeof(htmlIn) !== 'string') {
                throw 'Invalid call - extractRangeByLineNumbers expects a string as first argument';
            }

            var cacheKey = fromLine + "-" + toLine + "-" + lineNumberingService.djb2hash(htmlIn),
                cached = diffCache.get(cacheKey);

            if (!angular.isUndefined(cached)) {
                return cached;
            }

            var fragment = this.htmlToFragment(htmlIn);

            this._insertInternalLineMarkers(fragment);
            this._insertInternalLiNumbers(fragment);
            if (toLine === null) {
                var internalLineMarkers = fragment.querySelectorAll('OS-LINEBREAK');
                toLine = parseInt(internalLineMarkers[internalLineMarkers.length - 1].getAttribute("data-line-number"));
            }

            var fromLineNode = this.getLineNumberNode(fragment, fromLine),
                toLineNode = (toLine ? this.getLineNumberNode(fragment, toLine) : null),
                ancestorData = this._getCommonAncestor(fromLineNode, toLineNode);

            var fromChildTraceRel = ancestorData.trace1,
                fromChildTraceAbs = this._getNodeContextTrace(fromLineNode),
                toChildTraceRel = ancestorData.trace2,
                toChildTraceAbs = this._getNodeContextTrace(toLineNode),
                ancestor = ancestorData.commonAncestor,
                htmlOut = '',
                outerContextStart = '',
                outerContextEnd = '',
                innerContextStart = '',
                innerContextEnd = '',
                previousHtmlEndSnippet = '',
                followingHtmlStartSnippet = '',
                fakeOl, offset;

            fromChildTraceAbs.shift();
            var previousHtml = this._serializePartialDomToChild(fragment, fromChildTraceAbs, false);
            toChildTraceAbs.shift();
            var followingHtml = this._serializePartialDomFromChild(fragment, toChildTraceAbs, false);

            var currNode = fromLineNode,
                isSplit = false;
            while (currNode.parentNode) {
                if (!this._isFirstNonemptyChild(currNode.parentNode, currNode)) {
                    isSplit = true;
                }
                if (isSplit) {
                    this.addCSSClass(currNode.parentNode, 'os-split-before');
                }
                if (currNode.nodeName !== 'OS-LINEBREAK') {
                    previousHtmlEndSnippet += '</' + currNode.nodeName + '>';
                }
                currNode = currNode.parentNode;
            }

            currNode = toLineNode;
            isSplit = false;
            while (currNode.parentNode) {
                if (!this._isFirstNonemptyChild(currNode.parentNode, currNode)) {
                    isSplit = true;
                }
                if (isSplit) {
                    this.addCSSClass(currNode.parentNode, 'os-split-after');
                }
                if (currNode.parentNode.nodeName === 'OL') {
                    fakeOl = currNode.parentNode.cloneNode(false);
                    offset = (currNode.parentNode.getAttribute("start") ? parseInt(currNode.parentNode.getAttribute("start")) - 1 : 0);
                    fakeOl.setAttribute('start', (this._isWithinNthLIOfOL(currNode.parentNode, toLineNode) + offset).toString());
                    followingHtmlStartSnippet = this._serializeTag(fakeOl) + followingHtmlStartSnippet;
                } else {
                    followingHtmlStartSnippet = this._serializeTag(currNode.parentNode) + followingHtmlStartSnippet;
                }
                currNode = currNode.parentNode;
            }

            var found = false;
            isSplit = false;
            for (var i = 0; i < fromChildTraceRel.length && !found; i++) {
                if (fromChildTraceRel[i].nodeName === 'OS-LINEBREAK') {
                    found = true;
                } else {
                    if (!this._isFirstNonemptyChild(fromChildTraceRel[i], fromChildTraceRel[i + 1])) {
                        isSplit = true;
                    }
                    if (fromChildTraceRel[i].nodeName === 'OL') {
                        fakeOl = fromChildTraceRel[i].cloneNode(false);
                        offset = (fromChildTraceRel[i].getAttribute("start") ? parseInt(fromChildTraceRel[i].getAttribute("start")) - 1 : 0);
                        fakeOl.setAttribute('start', (offset + this._isWithinNthLIOfOL(fromChildTraceRel[i], fromLineNode)).toString());
                        innerContextStart += this._serializeTag(fakeOl);
                    } else {
                        if (i < (fromChildTraceRel.length - 1) && isSplit) {
                            this.addCSSClass(fromChildTraceRel[i], 'os-split-before');
                        }
                        innerContextStart += this._serializeTag(fromChildTraceRel[i]);
                    }
                }
            }
            found = false;
            for (i = 0; i < toChildTraceRel.length && !found; i++) {
                if (toChildTraceRel[i].nodeName === 'OS-LINEBREAK') {
                    found = true;
                } else {
                    innerContextEnd = '</' + toChildTraceRel[i].nodeName + '>' + innerContextEnd;
                }
            }

            found = false;
            for (i = 0; i < ancestor.childNodes.length; i++) {
                if (ancestor.childNodes[i] === fromChildTraceRel[0]) {
                    found = true;
                    fromChildTraceRel.shift();
                    htmlOut += this._serializePartialDomFromChild(ancestor.childNodes[i], fromChildTraceRel, true);
                } else if (ancestor.childNodes[i] === toChildTraceRel[0]) {
                    found = false;
                    toChildTraceRel.shift();
                    htmlOut += this._serializePartialDomToChild(ancestor.childNodes[i], toChildTraceRel, true);
                } else if (found === true) {
                    htmlOut += this._serializeDom(ancestor.childNodes[i], true);
                }
            }

            currNode = ancestor;
            while (currNode.parentNode) {
                if (currNode.nodeName === 'OL') {
                    fakeOl = currNode.cloneNode(false);
                    offset = (currNode.getAttribute("start") ? parseInt(currNode.getAttribute("start")) - 1 : 0);
                    fakeOl.setAttribute('start', (this._isWithinNthLIOfOL(currNode, fromLineNode) + offset).toString());
                    outerContextStart = this._serializeTag(fakeOl) + outerContextStart;
                } else {
                    outerContextStart = this._serializeTag(currNode) + outerContextStart;
                }
                outerContextEnd += '</' + currNode.nodeName + '>';
                currNode = currNode.parentNode;
            }

            var ret = {
                'html': htmlOut,
                'ancestor': ancestor,
                'outerContextStart': outerContextStart,
                'outerContextEnd': outerContextEnd,
                'innerContextStart': innerContextStart,
                'innerContextEnd': innerContextEnd,
                'previousHtml': previousHtml,
                'previousHtmlEndSnippet': previousHtmlEndSnippet,
                'followingHtml': followingHtml,
                'followingHtmlStartSnippet': followingHtmlStartSnippet
            };

            diffCache.put(cacheKey, ret);
            return ret;
        };

        /*
         * Convenience method that takes the html-attribute from an extractRangeByLineNumbers()-method,
         * wraps it with the context and adds line numbers.
         */
        this.formatDiffWithLineNumbers = function(diff, lineLength, firstLine) {
            var text = diff.outerContextStart + diff.innerContextStart + diff.html + diff.innerContextEnd + diff.outerContextEnd;
            text = lineNumberingService.insertLineNumbers(text, lineLength, null, null, firstLine);
            return text;
        };

        /*
         * This is a workardoun to prevent the last word of the inserted text from accidently being merged with the
         * first word of the following line.
         *
         * This happens as trailing spaces in the change recommendation's text are frequently stripped,
         * which is pretty nasty if the original text goes on after the affected line. So we insert a space
         * if the original line ends with one.
         */
        this._insertDanglingSpace = function(element) {
            if (element.childNodes.length > 0) {
                var lastChild = element.childNodes[element.childNodes.length - 1];
                if (lastChild.nodeType === TEXT_NODE && !lastChild.nodeValue.match(/[\S]/) && element.childNodes.length > 1) {
                    // If the text node only contains whitespaces, chances are high it's just space between block elmeents,
                    // like a line break between </LI> and </UL>
                    lastChild = element.childNodes[element.childNodes.length - 2];
                }
                if (lastChild.nodeType === TEXT_NODE) {
                    if (lastChild.nodeValue === '' || lastChild.nodeValue.substr(-1) !== ' ') {
                        lastChild.nodeValue += ' ';
                    }
                } else {
                    this._insertDanglingSpace(lastChild);
                }
            }
        };

        /*
         * This functions merges to arrays of nodes. The last element of nodes1 and the first element of nodes2
         * are merged, if they are of the same type.
         *
         * This is done recursively until a TEMPLATE-Tag is is found, which was inserted in this.replaceLines.
         * Using a TEMPLATE-Tag is a rather dirty hack, as it is allowed inside of any other element, including <ul>.
         *
         */
        this._replaceLinesMergeNodeArrays = function(nodes1, nodes2) {
            if (nodes1.length === 0) {
                return nodes2;
            }
            if (nodes2.length === 0) {
                return nodes1;
            }

            var out = [];
            for (var i = 0; i < nodes1.length - 1; i++) {
                out.push(nodes1[i]);
            }

            var lastNode = nodes1[nodes1.length - 1],
                firstNode = nodes2[0];
            if (lastNode.nodeType === TEXT_NODE && firstNode.nodeType === TEXT_NODE) {
                var newTextNode = lastNode.ownerDocument.createTextNode(lastNode.nodeValue + firstNode.nodeValue);
                out.push(newTextNode);
            } else if (lastNode.nodeName === firstNode.nodeName) {
                var newNode = lastNode.ownerDocument.createElement(lastNode.nodeName);
                for (i = 0; i < lastNode.attributes.length; i++) {
                    var attr = lastNode.attributes[i];
                    newNode.setAttribute(attr.name, attr.value);
                }

                // Remove #text nodes inside of List elements (OL/UL), as they are confusing
                var lastChildren, firstChildren;
                if (lastNode.nodeName === 'OL' || lastNode.nodeName === 'UL') {
                    lastChildren = [];
                    firstChildren = [];
                    for (i = 0; i < firstNode.childNodes.length; i++) {
                        if (firstNode.childNodes[i].nodeType === ELEMENT_NODE) {
                            firstChildren.push(firstNode.childNodes[i]);
                        }
                    }
                    for (i = 0; i < lastNode.childNodes.length; i++) {
                        if (lastNode.childNodes[i].nodeType === ELEMENT_NODE) {
                            lastChildren.push(lastNode.childNodes[i]);
                        }
                    }
                } else {
                    lastChildren = lastNode.childNodes;
                    firstChildren = firstNode.childNodes;
                }

                var children = this._replaceLinesMergeNodeArrays(lastChildren, firstChildren);
                for (i = 0; i < children.length; i++) {
                    newNode.appendChild(children[i]);
                }

                out.push(newNode);
            } else {
                if (lastNode.nodeName !== 'TEMPLATE') {
                    out.push(lastNode);
                }
                if (firstNode.nodeName !== 'TEMPLATE') {
                    out.push(firstNode);
                }
            }

            for (i = 1; i < nodes2.length; i++) {
                out.push(nodes2[i]);
            }

            return out;
        };

        /**
         *
         * @param {string} html
         * @returns {string}
         * @private
         */
        this._normalizeHtmlForDiff = function (html) {
            // Convert all HTML tags to uppercase, but leave the values of attributes unchanged
            // All attributes and CSS class names  are sorted alphabetically
            // If an attribute is empty, it is removed
            html = html.replace(/<(\/?[a-z]*)( [^>]*)?>/ig, function (html, tag, attributes) {
                var tagNormalized = tag.toUpperCase();
                if (attributes === undefined) {
                    attributes = "";
                }
                var attributesList = [],
                    attributesMatcher = /( [^"'=]*)(= *((["'])(.*?)\4))?/gi,
                    match;
                do {
                    match = attributesMatcher.exec(attributes);
                    if (match) {
                        var attrNormalized = match[1].toUpperCase(),
                            attrValue = match[5];
                        if (match[2] !== undefined) {
                            if (attrNormalized === ' CLASS') {
                                attrValue = attrValue.split(' ').sort().join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
                            }
                            attrNormalized += "=" + match[4] + attrValue + match[4];
                        }
                        if (attrValue !== '') {
                            attributesList.push(attrNormalized);
                        }
                    }
                } while (match);
                attributes = attributesList.sort().join('');
                return "<" + tagNormalized + attributes + ">";
            });

            var entities = {
                '&nbsp;': ' ',
                '&ndash;': '-',
                '&auml;': 'ä',
                '&ouml;': 'ö',
                '&uuml;': 'ü',
                '&Auml;': 'Ä',
                '&Ouml;': 'Ö',
                '&Uuml;': 'Ü',
                '&szlig;': 'ß',
                '&bdquo;': '„',
                '&ldquo;': '“',
                '&bull;': '•',
                '&sect;': '§',
                '&eacute;': 'é',
                '&euro;': '€'
            };

            html = html.replace(/\s+<\/P>/gi, '</P>').replace(/\s+<\/DIV>/gi, '</DIV>').replace(/\s+<\/LI>/gi, '</LI>');
            html = html.replace(/\s+<LI>/gi, '<LI>').replace(/<\/LI>\s+/gi, '</LI>');
            html = html.replace(/\u00A0/g, ' ');
            html = html.replace(/\u2013/g, '-');
            for (var ent in entities) {
                html = html.replace(new RegExp(ent, 'g'), entities[ent]);
            }

            // Newline characters: after closing block-level-elements, but not after BR (which is inline)
            html = html.replace(/(<br *\/?>)\n/gi, "$1");
            html = html.replace(/[ \n\t]+/gi, ' ');
            html = html.replace(/(<\/(div|p|ul|li|blockquote>)>) /gi, "$1\n");

            return html;
        };

        this._getAllNextSiblings = function(element) {
            var elements = [];
            while (element.nextSibling) {
                elements.push(element.nextSibling);
                element = element.nextSibling;
            }
            return elements;
        };

        this._getAllPrevSiblingsReversed = function(element) {
            var elements = [];
            while (element.previousSibling) {
                elements.push(element.previousSibling);
                element = element.previousSibling;
            }
            return elements;
        };

        /**
         * This returns the line number range in which changes (insertions, deletions) are encountered.
         * As in extractRangeByLineNumbers(), "to" refers to the line breaking element at the end, i.e. the start of the following line.
         *
         * @param {string} diffHtml
         */
        this.detectAffectedLineRange = function (diffHtml) {
            var cacheKey = lineNumberingService.djb2hash(diffHtml),
                cached = diffCache.get(cacheKey);
            if (!angular.isUndefined(cached)) {
                return cached;
            }

            var fragment = this.htmlToFragment(diffHtml);

            this._insertInternalLineMarkers(fragment);
            this._insertInternalLiNumbers(fragment);

            var changes = fragment.querySelectorAll('ins, del, .insert, .delete'),
                firstChange = changes.item(0),
                lastChange = changes.item(changes.length - 1),
                i, j;

            if (!firstChange || !lastChange) {
                // There are no changes
                return null;
            }

            var firstTrace = this._getNodeContextTrace(firstChange),
                lastLineNumberBefore = null;
            for (j = firstTrace.length - 1; j >= 0 && lastLineNumberBefore === null; j--) {
                var prevSiblings = this._getAllPrevSiblingsReversed(firstTrace[j]);
                for (i = 0; i < prevSiblings.length && lastLineNumberBefore === null; i++) {
                    lastLineNumberBefore = this._getLastLineNumberNode(prevSiblings[i]);
                }
            }

            var lastTrace = this._getNodeContextTrace(lastChange),
                firstLineNumberAfter = null;
            for (j = lastTrace.length - 1; j >= 0 && firstLineNumberAfter === null; j--) {
                var nextSiblings = this._getAllNextSiblings(lastTrace[j]);
                for (i = 0; i < nextSiblings.length && firstLineNumberAfter === null; i++) {
                    firstLineNumberAfter = this._getFirstLineNumberNode(nextSiblings[i]);
                }
            }

            var range = {
                "from": parseInt(lastLineNumberBefore.getAttribute("data-line-number")),
                "to": parseInt(firstLineNumberAfter.getAttribute("data-line-number"))
            };

            diffCache.put(cacheKey, range);
            return range;
        };

        /**
         * Removes .delete-nodes and <del>-Tags (including content)
         * Removes the .insert-classes and the wrapping <ins>-Tags (while maintaining content)
         * @param html
         */
        this.diffHtmlToFinalText = function(html) {
            var fragment = this.htmlToFragment(html);

            var delNodes = fragment.querySelectorAll('.delete, del');
            for (var i = 0; i < delNodes.length; i++) {
                delNodes[i].parentNode.removeChild(delNodes[i]);
            }

            var insNodes = fragment.querySelectorAll('ins');
            for (i = 0; i < insNodes.length; i++) {
                var ins = insNodes[i];
                while (ins.childNodes.length > 0) {
                    var child = ins.childNodes.item(0);
                    ins.removeChild(child);
                    ins.parentNode.insertBefore(child, ins);
                }
                ins.parentNode.removeChild(ins);
            }

            var insertNodes = fragment.querySelectorAll('.insert');
            for (i = 0;i < insertNodes.length; i++) {
                this.removeCSSClass(insertNodes[i], 'insert');
            }

            return this._serializeDom(fragment, false);
        };

        /**
         * @param {string} htmlOld
         * @param {string} htmlNew
         * @returns {number}
         */
        this.detectReplacementType = function (htmlOld, htmlNew) {
            htmlOld = this._normalizeHtmlForDiff(htmlOld);
            htmlNew = this._normalizeHtmlForDiff(htmlNew);

            if (htmlOld === htmlNew) {
                return this.TYPE_REPLACEMENT;
            }

            var i, foundDiff;
            for (i = 0, foundDiff = false; i < htmlOld.length && i < htmlNew.length && foundDiff === false; i++) {
                if (htmlOld[i] !== htmlNew[i]) {
                    foundDiff = true;
                }
            }

            var remainderOld = htmlOld.substr(i - 1),
                remainderNew = htmlNew.substr(i - 1),
                type = this.TYPE_REPLACEMENT;

            if (remainderOld.length > remainderNew.length) {
                if (remainderOld.substr(remainderOld.length - remainderNew.length) === remainderNew) {
                    type = this.TYPE_DELETION;
                }
            } else if (remainderOld.length < remainderNew.length) {
                if (remainderNew.substr(remainderNew.length - remainderOld.length) === remainderOld) {
                    type = this.TYPE_INSERTION;
                }
            }

            return type;
        };

        /**
         * @param {string} oldHtml
         * @param {string} newHTML
         * @param {number} fromLine
         * @param {number} toLine
         */
        this.replaceLines = function (oldHtml, newHTML, fromLine, toLine) {
            var data = this.extractRangeByLineNumbers(oldHtml, fromLine, toLine),
                previousHtml = data.previousHtml + '<TEMPLATE></TEMPLATE>' + data.previousHtmlEndSnippet,
                previousFragment = this.htmlToFragment(previousHtml),
                followingHtml = data.followingHtmlStartSnippet + '<TEMPLATE></TEMPLATE>' + data.followingHtml,
                followingFragment = this.htmlToFragment(followingHtml),
                newFragment = this.htmlToFragment(newHTML);

            if (data.html.length > 0 && data.html.substr(-1) === ' ') {
                this._insertDanglingSpace(newFragment);
            }

            var merged = this._replaceLinesMergeNodeArrays(previousFragment.childNodes, newFragment.childNodes);
            merged = this._replaceLinesMergeNodeArrays(merged, followingFragment.childNodes);

            var mergedFragment = document.createDocumentFragment();
            for (var i = 0; i < merged.length; i++) {
                mergedFragment.appendChild(merged[i]);
            }

            var forgottenTemplates = mergedFragment.querySelectorAll("TEMPLATE");
            for (i = 0; i < forgottenTemplates.length; i++) {
                var el = forgottenTemplates[i];
                el.parentNode.removeChild(el);
            }

            var forgottenSplitClasses = mergedFragment.querySelectorAll(".os-split-before, .os-split-after");
            for (i = 0; i < forgottenSplitClasses.length; i++) {
                this.removeCSSClass(forgottenSplitClasses[i], 'os-split-before');
                this.removeCSSClass(forgottenSplitClasses[i], 'os-split-after');
            }

            return this._serializeDom(mergedFragment, true);
        };

        this.addCSSClass = function (node, className) {
            if (node.nodeType !== ELEMENT_NODE) {
                return;
            }
            var classes = node.getAttribute('class');
            classes = (classes ? classes.split(' ') : []);
            if (classes.indexOf(className) === -1) {
                classes.push(className);
            }
            node.setAttribute('class', classes.join(' '));
        };

        this.removeCSSClass = function (node, className) {
            if (node.nodeType !== ELEMENT_NODE) {
                return;
            }
            var classes = node.getAttribute('class'),
                newClasses = [];
            classes = (classes ? classes.split(' ') : []);
            for (var i = 0; i < classes.length; i++) {
                if (classes[i] !== className) {
                    newClasses.push(classes[i]);
                }
            }
            if (newClasses.length === 0) {
                node.removeAttribute('class');
            } else {
                node.setAttribute('class', newClasses.join(' '));
            }
        };

        this.addDiffMarkup = function (originalHTML, newHTML, fromLine, toLine, diffFormatterCb) {
            var data = this.extractRangeByLineNumbers(originalHTML, fromLine, toLine),
                previousHtml = data.previousHtml + '<TEMPLATE></TEMPLATE>' + data.previousHtmlEndSnippet,
                previousFragment = this.htmlToFragment(previousHtml),
                followingHtml = data.followingHtmlStartSnippet + '<TEMPLATE></TEMPLATE>' + data.followingHtml,
                followingFragment = this.htmlToFragment(followingHtml),
                newFragment = this.htmlToFragment(newHTML),
                oldHTML = data.outerContextStart + data.innerContextStart + data.html +
                    data.innerContextEnd + data.outerContextEnd,
                oldFragment = this.htmlToFragment(oldHTML),
                el;

            var diffFragment = diffFormatterCb(oldFragment, newFragment);

            var mergedFragment = document.createDocumentFragment();
            while (previousFragment.firstChild) {
                el = previousFragment.firstChild;
                previousFragment.removeChild(el);
                mergedFragment.appendChild(el);
            }
            while (diffFragment.firstChild) {
                el = diffFragment.firstChild;
                diffFragment.removeChild(el);
                mergedFragment.appendChild(el);
            }
            while (followingFragment.firstChild) {
                el = followingFragment.firstChild;
                followingFragment.removeChild(el);
                mergedFragment.appendChild(el);
            }

            var forgottenTemplates = mergedFragment.querySelectorAll("TEMPLATE");
            for (var i = 0; i < forgottenTemplates.length; i++) {
                el = forgottenTemplates[i];
                el.parentNode.removeChild(el);
            }

            return this._serializeDom(mergedFragment, true);
        };

        /**
         * Adapted from http://ejohn.org/projects/javascript-diff-algorithm/
         * by John Resig, MIT License
         * @param {array} oldArr
         * @param {array} newArr
         * @returns {object}
         */
        this._diff = function (oldArr, newArr) {
            var ns = {},
                os = {},
                i;

            for (i = 0; i < newArr.length; i++) {
                if (ns[newArr[i]] === undefined)
                    ns[newArr[i]] = {rows: [], o: null};
                ns[newArr[i]].rows.push(i);
            }

            for (i = 0; i < oldArr.length; i++) {
                if (os[oldArr[i]] === undefined)
                    os[oldArr[i]] = {rows: [], n: null};
                os[oldArr[i]].rows.push(i);
            }

            for (i in ns) {
                if (ns[i].rows.length === 1 && typeof(os[i]) !== "undefined" && os[i].rows.length === 1) {
                    newArr[ns[i].rows[0]] = {text: newArr[ns[i].rows[0]], row: os[i].rows[0]};
                    oldArr[os[i].rows[0]] = {text: oldArr[os[i].rows[0]], row: ns[i].rows[0]};
                }
            }

            for (i = 0; i < newArr.length - 1; i++) {
                if (newArr[i].text !== null && newArr[i + 1].text === undefined && newArr[i].row + 1 < oldArr.length &&
                    oldArr[newArr[i].row + 1].text === undefined && newArr[i + 1] == oldArr[newArr[i].row + 1]) {
                    newArr[i + 1] = {text: newArr[i + 1], row: newArr[i].row + 1};
                    oldArr[newArr[i].row + 1] = {text: oldArr[newArr[i].row + 1], row: i + 1};
                }
            }

            for (i = newArr.length - 1; i > 0; i--) {
                if (newArr[i].text !== null && newArr[i - 1].text === undefined && newArr[i].row > 0 &&
                    oldArr[newArr[i].row - 1].text === undefined && newArr[i - 1] == oldArr[newArr[i].row - 1]) {
                    newArr[i - 1] = {text: newArr[i - 1], row: newArr[i].row - 1};
                    oldArr[newArr[i].row - 1] = {text: oldArr[newArr[i].row - 1], row: i - 1};
                }
            }

            return {o: oldArr, n: newArr};
        };

        this._tokenizeHtml = function (str) {
            var splitArrayEntriesEmbedSeparator = function (arr, by, prepend) {
                var newArr = [];
                for (var i = 0; i < arr.length; i++) {
                    if (arr[i][0] === '<' && (by === " " || by === "\n")) {
                        // Don't split HTML tags
                        newArr.push(arr[i]);
                        continue;
                    }

                    var parts = arr[i].split(by);
                    if (parts.length === 1) {
                        newArr.push(arr[i]);
                    } else {
                        var j;
                        if (prepend) {
                            if (parts[0] !== '') {
                                newArr.push(parts[0]);
                            }
                            for (j = 1; j < parts.length; j++) {
                                newArr.push(by + parts[j]);
                            }
                        } else {
                            for (j = 0; j < parts.length - 1; j++) {
                                newArr.push(parts[j] + by);
                            }
                            if (parts[parts.length - 1] !== '') {
                                newArr.push(parts[parts.length - 1]);
                            }
                        }
                    }
                }
                return newArr;
            };
            var splitArrayEntriesSplitSeparator = function (arr, by) {
                var newArr = [];
                for (var i = 0; i < arr.length; i++) {
                    if (arr[i][0] === '<') {
                        newArr.push(arr[i]);
                        continue;
                    }
                    var parts = arr[i].split(by);
                    for (var j = 0; j < parts.length; j++) {
                        if (j > 0) {
                            newArr.push(by);
                        }
                        newArr.push(parts[j]);
                    }
                }
                return newArr;
            };
            var arr = splitArrayEntriesEmbedSeparator([str], '<', true);
            arr = splitArrayEntriesEmbedSeparator(arr, '>', false);
            arr = splitArrayEntriesSplitSeparator(arr, " ");
            arr = splitArrayEntriesSplitSeparator(arr, ".");
            arr = splitArrayEntriesSplitSeparator(arr, ",");
            arr = splitArrayEntriesSplitSeparator(arr, "!");
            arr = splitArrayEntriesSplitSeparator(arr, "-");
            arr = splitArrayEntriesEmbedSeparator(arr, "\n", false);

            var arrWithoutEmptes = [];
            for (var i = 0; i < arr.length; i++) {
                if (arr[i] !== '') {
                    arrWithoutEmptes.push(arr[i]);
                }
            }

            return arrWithoutEmptes;
        };

        /**
         * @param {string} oldStr
         * @param {string} newStr
         * @returns {string}
         */
        this._diffString = function (oldStr, newStr) {
            oldStr = this._normalizeHtmlForDiff(oldStr.replace(/\s+$/, '').replace(/^\s+/, ''));
            newStr = this._normalizeHtmlForDiff(newStr.replace(/\s+$/, '').replace(/^\s+/, ''));

            var out = this._diff(this._tokenizeHtml(oldStr), this._tokenizeHtml(newStr));

            // This fixes the problem tested by "does not lose words when changes are moved X-wise"
            var lastRow = 0;
            for (var z = 0; z < out.n.length; z++) {
                if (out.n[z].row && out.n[z].row > lastRow) {
                    lastRow = out.n[z].row;
                }
                if (out.n[z].row && out.n[z].row < lastRow) {
                    out.o[out.n[z].row] = out.o[out.n[z].row].text;
                    out.n[z] = out.n[z].text;
                }
            }

            var str = "";
            var i;

            if (out.n.length === 0) {
                for (i = 0; i < out.o.length; i++) {
                    str += '<del>' + out.o[i] + "</del>";
                }
            } else {
                if (out.n[0].text === undefined) {
                    for (var k = 0; k < out.o.length && out.o[k].text === undefined; k++) {
                        str += '<del>' + out.o[k] + "</del>";
                    }
                }

                var currOldRow = 0;
                for (i = 0; i < out.n.length; i++) {
                    if (out.n[i].text === undefined) {
                        if (out.n[i] !== "") {
                            str += '<ins>' + out.n[i] + "</ins>";
                        }
                    } else if (out.n[i].row < currOldRow) {
                        str += '<ins>' + out.n[i].text + "</ins>";
                    } else {
                        var pre = "";

                        if ((i + 1) < out.n.length && out.n[i + 1].row !== undefined && out.n[i + 1].row > out.n[i].row + 1) {
                            for (var n = out.n[i].row + 1; n < out.n[i + 1].row; n++) {
                                if (out.o[n].text === undefined) {
                                    pre += '<del>' + out.o[n] + "</del>";
                                } else {
                                    pre += '<del>' + out.o[n].text + "</del>";
                                }
                            }
                        } else {
                            for (var j = out.n[i].row + 1; j < out.o.length && out.o[j].text === undefined; j++) {
                                pre += '<del>' + out.o[j] + "</del>";
                            }
                        }
                        str += out.n[i].text + pre;

                        currOldRow = out.n[i].row;
                    }
                }
            }

            return str.replace(/^\s+/g, '').replace(/\s+$/g, '').replace(/ {2,}/g, ' ');
        };

        /**
         * @param {string} html
         * @return {boolean}
         * @private
         */
        this._isValidInlineHtml = function(html) {
            // If there are no HTML tags, we assume it's valid and skip further checks
            if (!html.match(/<[^>]*>/)) {
                return true;
            }

            // We check if this is a valid HTML that closes all its tags again using the innerHTML-Hack to correct
            // the string and check if the number of HTML tags changes by this
            var doc = document.createElement('div');
            doc.innerHTML = html;
            var tagsBefore = (html.match(/</g) || []).length;
            var tagsCorrected = (doc.innerHTML.match(/</g) || []).length;
            if (tagsBefore !== tagsCorrected) {
                // The HTML has changed => it was not valid
                return false;
            }

            // If there is any block element inside, we consider it as broken, as this string will be displayed
            // inside of <ins>/<del> tags
            if (html.match(/<(div|p|ul|li|blockquote)\W/i)) {
                return false;
            }

            return true;
        };

        /**
         * @param {string} html
         * @returns {boolean}
         * @private
         */
        this._diffDetectBrokenDiffHtml = function(html) {
            // If other HTML tags are contained within INS/DEL (e.g. "<ins>Test</p></ins>"), let's better be cautious
            // The "!!(found=...)"-construction is only used to make jshint happy :)
            var findDel = /<del>(.*?)<\/del>/gi,
                findIns = /<ins>(.*?)<\/ins>/gi,
                found, inner;
            while (!!(found = findDel.exec(html))) {
                inner = found[1].replace(/<br[^>]*>/gi, '');
                if (inner.match(/<[^>]*>/)) {
                    return true;
                }
            }
            while (!!(found = findIns.exec(html))) {
                inner = found[1].replace(/<br[^>]*>/gi, '');
                if (!this._isValidInlineHtml(inner)) {
                    return true;
                }
            }

            // If non of the conditions up to now is met, we consider the diff as being sane
            return false;
        };

        this._diffParagraphs = function(oldText, newText, lineLength, firstLineNumber) {
            var oldTextWithBreaks, newTextWithBreaks, currChild;

            if (lineLength !== undefined) {
                oldTextWithBreaks = lineNumberingService.insertLineNumbersNode(oldText, lineLength, null, firstLineNumber);
                newTextWithBreaks = lineNumberingService.insertLineNumbersNode(newText, lineLength, null, firstLineNumber);
            } else {
                oldTextWithBreaks = document.createElement('div');
                oldTextWithBreaks.innerHTML = oldText;
                newTextWithBreaks = document.createElement('div');
                newTextWithBreaks.innerHTML = newText;
            }

            for (var i = 0; i < oldTextWithBreaks.childNodes.length; i++) {
                currChild = oldTextWithBreaks.childNodes[i];
                if (currChild.nodeType === TEXT_NODE) {
                    var wrapDel = document.createElement('del');
                    oldTextWithBreaks.insertBefore(wrapDel, currChild);
                    oldTextWithBreaks.removeChild(currChild);
                    wrapDel.appendChild(currChild);
                } else {
                    this.addCSSClass(currChild, 'delete');
                    this._removeColorStyles(currChild);
                }
            }
            for (i = 0; i < newTextWithBreaks.childNodes.length; i++) {
                currChild = newTextWithBreaks.childNodes[i];
                if (currChild.nodeType === TEXT_NODE) {
                    var wrapIns = document.createElement('ins');
                    newTextWithBreaks.insertBefore(wrapIns, currChild);
                    newTextWithBreaks.removeChild(currChild);
                    wrapIns.appendChild(currChild);
                } else {
                    this.addCSSClass(currChild, 'insert');
                    this._removeColorStyles(currChild);
                }
            }

            var mergedFragment = document.createDocumentFragment(),
                el;
            while (oldTextWithBreaks.firstChild) {
                el = oldTextWithBreaks.firstChild;
                oldTextWithBreaks.removeChild(el);
                mergedFragment.appendChild(el);
            }
            while (newTextWithBreaks.firstChild) {
                el = newTextWithBreaks.firstChild;
                newTextWithBreaks.removeChild(el);
                mergedFragment.appendChild(el);
            }

            return this._serializeDom(mergedFragment);
        };

        this.addCSSClassToFirstTag = function (html, className) {
            return html.replace(/<[a-z][^>]*>/i, function (match) {
                if (match.match(/class=["'][a-z0-9 _-]*["']/i)) {
                    return match.replace(/class=["']([a-z0-9 _-]*)["']/i, function (match2, previousClasses) {
                        return "class=\"" + previousClasses + " " + className + "\"";
                    });
                } else {
                    return match.substring(0, match.length - 1) + " class=\"" + className + "\">";
                }
            });
        };

        this._addClassToLastNode = function (html, className) {
            var node = document.createElement('div');
            node.innerHTML = html;
            var foundLast = false;
            for (var i = node.childNodes.length - 1; i >= 0 && !foundLast; i--) {
                if (node.childNodes[i].nodeType === ELEMENT_NODE) {
                    var classes = [];
                    if (node.childNodes[i].getAttribute("class")) {
                        classes = node.childNodes[i].getAttribute("class").split(" ");
                    }
                    classes.push(className);
                    node.childNodes[i].setAttribute("class", classes.sort().join(' ').replace(/^\s+/, '').replace(/\s+$/, ''));
                    foundLast = true;
                }
            }
            return node.innerHTML;
        };

        /**
         * This function removes color-Attributes from the styles of this node or a descendant,
         * as they interfer with the green/red color in HTML and PDF
         *
         * For the moment, it is sufficient to do this only in paragraph diff mode, as we fall back to this mode anyway
         * once we encounter SPANs or other tags inside of INS/DEL-tags
         *
         * @param {Element} node
         * @private
         */
        this._removeColorStyles = function (node) {
            var styles = node.getAttribute('style');
            if (styles && styles.indexOf('color') > -1) {
                var stylesNew = [];
                styles.split(';').forEach(function(style) {
                    if (!style.match(/^\s*color\s*:/i)) {
                        stylesNew.push(style);
                    }
                });
                if (stylesNew.join(";") === '') {
                    node.removeAttribute('style');
                } else {
                    node.setAttribute('style', stylesNew.join(";"));
                }
            }
            for (var i = 0; i < node.childNodes.length; i++) {
                if (node.childNodes[i].nodeType === ELEMENT_NODE) {
                    this._removeColorStyles(node.childNodes[i]);
                }
            }
        };

        /**
         * This fixes a very specific, really weird bug that is tested in the test case "does not a change in a very specific case".
         *
         * @param {string}diffStr
         * @return {string}
         * @private
         */
        this._fixWrongChangeDetection = function (diffStr) {
            if (diffStr.indexOf('<del>') === -1 || diffStr.indexOf('<ins>') === -1) {
                return diffStr;
            }

            var findDelGroupFinder = /(?:<del>.*?<\/del>)+/gi,
                found,
                returnStr = diffStr;

            while (!!(found = findDelGroupFinder.exec(diffStr))) {
                var del = found[0],
                    split = returnStr.split(del);

                var findInsGroupFinder = /^(?:<ins>.*?<\/ins>)+/gi,
                    foundIns = findInsGroupFinder.exec(split[1]);
                if (foundIns) {
                    var ins = foundIns[0];

                    var delShortened = del.replace(
                        /<del>((<BR CLASS="os-line-break"><\/del><del>)?(<span[^>]+os-line-number[^>]+?>)(\s|<\/?del>)*<\/span>)<\/del>/gi,
                        ''
                    ).replace(/<\/del><del>/g, '');
                    var insConv = ins.replace(/<ins>/g, '<del>').replace(/<\/ins>/g, '</del>').replace(/<\/del><del>/g, '');
                    if (delShortened.indexOf(insConv) !== -1) {
                        delShortened = delShortened.replace(insConv, '');
                        if (delShortened === '') {
                            returnStr = returnStr.replace(del + ins, del.replace(/<del>/g, '').replace(/<\/del>/g, ''));
                        }
                    }
                }
            }
            return returnStr;
        };

        /**
         * This function calculates the diff between two strings and tries to fix problems with the resulting HTML.
         * If lineLength and firstLineNumber is given, line numbers will be returned es well
         *
         * @param {string} htmlOld
         * @param {string} htmlNew
         * @param {number} lineLength - optional
         * @param {number} firstLineNumber - optional
         * @returns {string}
         */
        this.diff = function (htmlOld, htmlNew, lineLength, firstLineNumber) {
            var cacheKey = lineLength + ' ' + firstLineNumber + ' ' +
                    lineNumberingService.djb2hash(htmlOld) + lineNumberingService.djb2hash(htmlNew),
                cached = diffCache.get(cacheKey);
            if (!angular.isUndefined(cached)) {
                return cached;
            }

            // This fixes a really strange artefact with the diff that occures under the following conditions:
            // - The first tag of the two texts is identical, e.g. <p>
            // - A change happens in the next tag, e.g. inserted text
            // - The first tag occures a second time in the text, e.g. another <p>
            // In this condition, the first tag is deleted first and inserted afterwards again
            // Test case: "does not break when an insertion followes a beginning tag occuring twice"
            // The work around inserts to tags at the beginning and removes them afterwards again,
            // to make sure this situation does not happen (and uses invisible pseudo-tags in case something goes wrong)
            var workaroundPrepend = "<DUMMY><PREPEND>";

            // os-split-after should not be considered for detecting changes in paragraphs, so we strip it here
            // and add it afterwards.
            // We only do this for P for now, as for more complex types like UL/LI that tend to be nestend,
            // information would get lost by this that we will need to recursively merge it again later on.
            var oldIsSplitAfter = false,
                newIsSplitAfter = false;
            htmlOld = htmlOld.replace(/(\s*<p[^>]+class\s*=\s*["'][^"']*)os-split-after/gi, function(match, beginning) {
                oldIsSplitAfter = true;
                return beginning;
            });
            htmlNew = htmlNew.replace(/(\s*<p[^>]+class\s*=\s*["'][^"']*)os-split-after/gi, function(match, beginning) {
                newIsSplitAfter = true;
                return beginning;
            });

            // Performing the actual diff
            var str = this._diffString(workaroundPrepend + htmlOld, workaroundPrepend + htmlNew),
                diffUnnormalized = str.replace(/^\s+/g, '').replace(/\s+$/g, '').replace(/ {2,}/g, ' ');


            diffUnnormalized = this._fixWrongChangeDetection(diffUnnormalized);

            // Remove <del> tags that only delete line numbers
            // We need to do this before removing </del><del> as done in one of the next statements
            diffUnnormalized = diffUnnormalized.replace(
                /<del>((<BR CLASS="os-line-break"><\/del><del>)?(<span[^>]+os-line-number[^>]+?>)(\s|<\/?del>)*<\/span>)<\/del>/gi,
                function(found,tag,br,span) {
                    return (br !== undefined ? br : '') + span + ' </span>';
                }
            );

            diffUnnormalized = diffUnnormalized.replace(/<\/ins><ins>/gi, '').replace(/<\/del><del>/gi, '');

            // Move whitespaces around inserted P's out of the INS-tag
            diffUnnormalized = diffUnnormalized.replace(
                /<ins>(\s*)(<p( [^>]*)?>[\s\S]*?<\/p>)(\s*)<\/ins>/gim,
                function(match, whiteBefore, inner, tagInner, whiteAfter) {
                    return whiteBefore +
                        inner
                        .replace(/<p( [^>]*)?>/gi, function(match) {
                            return match + "<ins>";
                        })
                        .replace(/<\/p>/gi, "</ins></p>") +
                        whiteAfter;
                }
            );

            // Fixes HTML produced by the diff like this:
            // from: <del></P></del><ins> Inserted Text</P>\n<P>More inserted text</P></ins>
            // into: <ins> Inserted Text</ins></P>\n<P>More inserted text</ins></P>
            diffUnnormalized = diffUnnormalized.replace(
                /<del><\/p><\/del><ins>([\s\S]*?)<\/p><\/ins>/gim,
                "<ins>$1</ins></p>"
            );
            diffUnnormalized = diffUnnormalized.replace(
                /<ins>[\s\S]*?<\/ins>/gim,
                function(match) {
                    return match.replace(/(<\/p>\s*<p>)/gi, "</ins>$1<ins>");
                }
            );

            // If only a few characters of a word have changed, don't display this as a replacement of the whole word,
            // but only of these specific characters
            diffUnnormalized = diffUnnormalized.replace(/<del>([a-z0-9,_-]* ?)<\/del><ins>([a-z0-9,_-]* ?)<\/ins>/gi, function (found, oldText, newText) {
                var foundDiff = false, commonStart = '', commonEnd = '',
                    remainderOld = oldText, remainderNew = newText;

                while (remainderOld.length > 0 && remainderNew.length > 0 && !foundDiff) {
                    if (remainderOld[0] === remainderNew[0]) {
                        commonStart += remainderOld[0];
                        remainderOld = remainderOld.substr(1);
                        remainderNew = remainderNew.substr(1);
                    } else {
                        foundDiff = true;
                    }
                }

                foundDiff = false;
                while (remainderOld.length > 0 && remainderNew.length > 0 && !foundDiff) {
                    if (remainderOld[remainderOld.length - 1] === remainderNew[remainderNew.length - 1]) {
                        commonEnd = remainderOld[remainderOld.length - 1] + commonEnd;
                        remainderNew = remainderNew.substr(0, remainderNew.length - 1);
                        remainderOld = remainderOld.substr(0, remainderOld.length - 1);
                    } else {
                        foundDiff = true;
                    }
                }

                var out = commonStart;
                if (remainderOld !== '') {
                    out += '<del>' + remainderOld + '</del>';
                }
                if (remainderNew !== '') {
                    out += '<ins>' + remainderNew + '</ins>';
                }
                out += commonEnd;

                return out;
            });

            // Replace spaces in line numbers by &nbsp;
            diffUnnormalized = diffUnnormalized.replace(
                /<span[^>]+os-line-number[^>]+?>\s*<\/span>/gi,
                function(found) {
                    return found.toLowerCase().replace(/> <\/span/gi, ">&nbsp;</span");
                }
            );


            if (diffUnnormalized.substr(0, workaroundPrepend.length) === workaroundPrepend) {
                diffUnnormalized = diffUnnormalized.substring(workaroundPrepend.length);
            }

            var diff;
            if (this._diffDetectBrokenDiffHtml(diffUnnormalized)) {
                diff = this._diffParagraphs(htmlOld, htmlNew, lineLength, firstLineNumber);
            } else {
                diffUnnormalized = diffUnnormalized.replace(/<ins>.*?(\n.*?)*<\/ins>/gi, function (found) {
                    found = found.replace(/<(div|p|li)[^>]*>/gi, function(match) { return match + '<ins>'; });
                    found = found.replace(/<\/(div|p|li)[^>]*>/gi, function(match) { return '</ins>' + match; });
                    return found;
                });
                diffUnnormalized = diffUnnormalized.replace(/<del>.*?(\n.*?)*<\/del>/gi, function (found) {
                    found = found.replace(/<(div|p|li)[^>]*>/gi, function(match) { return match + '<del>'; });
                    found = found.replace(/<\/(div|p|li)[^>]*>/gi, function(match) { return '</del>' + match; });
                    return found;
                });
                diffUnnormalized = diffUnnormalized.replace(/^<del><p>(.*)<\/p><\/del>$/gi, function(match, inner) { return "<p>" + inner + "</p>"; });

                var node = document.createElement('div');
                node.innerHTML = diffUnnormalized;
                diff = node.innerHTML;

                if (lineLength !== undefined && firstLineNumber !== undefined) {
                    node = lineNumberingService.insertLineNumbersNode(diff, lineLength, null, firstLineNumber);
                    diff = node.innerHTML;
                }
            }

            if (oldIsSplitAfter || newIsSplitAfter) {
                diff = this._addClassToLastNode(diff, "os-split-after");
            }

            diffCache.put(cacheKey, diff);
            return diff;
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.motions.docx', ['OpenSlidesApp.core.docx'])

.factory('MotionDocxExport', [
    '$http',
    '$q',
    '$filter',
    'operator',
    'Config',
    'Category',
    'gettextCatalog',
    'FileSaver',
    'lineNumberingService',
    'Html2DocxConverter',
    'MotionComment',
    function ($http, $q, $filter, operator, Config, Category, gettextCatalog,
        FileSaver, lineNumberingService, Html2DocxConverter, MotionComment) {

        var PAGEBREAK = '<w:p><w:r><w:br w:type="page" /></w:r></w:p>';

        var converter;

        var getData = function (motions, params) {
            var data = {};
            // header
            var headerline1 = [
                Config.translate(Config.get('general_event_name').value),
                Config.translate(Config.get('general_event_description').value)
            ].filter(Boolean).join(' – ');
            var headerline2 = [
                Config.get('general_event_location').value,
                Config.get('general_event_date').value
            ].filter(Boolean).join(', ');
            data.header = [headerline1, headerline2].join('\n');

            // motion catalog title/preamble
            data.title = Config.translate(Config.get('motions_export_title').value);
            data.preamble = Config.get('motions_export_preamble').value;

            // categories
            var categories = getCategoriesData(motions);
            data.has_categories = categories.length === 0 ? false : true;
            data.categories_translation = gettextCatalog.getString('Categories');
            data.categories = categories;
            data.no_categories = gettextCatalog.getString('No categories available.');
            data.pagebreak_main = categories.length === 0 ? '' : PAGEBREAK;

            // motions
            data.tableofcontents_translation = gettextCatalog.getString('Table of contents');
            data.motions_list = getMotionShortData(motions, params);
            data.no_motions = gettextCatalog.getString('No motions available.');

            return $q(function (resolve) {
                getMotionFullData(motions, params).then(function (motionData) {
                    data.motions = motionData;
                    resolve(data);
                });
            });
        };

        var getCategoriesData = function (motions) {
            var categories = _.map(motions, function (motion) {
                if (motion.category) {
                    return {
                        prefix: motion.category.prefix,
                        name: motion.category.name,
                    };
                }
            });
            // clear out 'undefined' and make the categories unique.
            categories = _.uniqBy(_.filter(categories, function(category) {
                return category;
            }), 'prefix');
            var sortKey = Config.get('motions_export_category_sorting').value;
            return _.orderBy(categories, [sortKey]);
        };

        var getMotionShortData = function (motions, params) {
            return _.map(motions, function (motion) {
                return {
                    identifier: motion.identifier || '',
                    title: motion.getTitleWithChanges(params.changeRecommendationMode),
                };
            });
        };

        var getMotionFullData = function (motions, params) {
            // All translations
            var translation = gettextCatalog.getString('Motion'),
                sequential_translation = gettextCatalog.getString('Sequential number'),
                submitters_translation = gettextCatalog.getString('Submitters'),
                status_translation = gettextCatalog.getString('Status'),
                reason_translation = gettextCatalog.getString('Reason'),
                comment_translation = gettextCatalog.getString('Comments');
            var sequential_enabled = Config.get('motions_export_sequential_number').value;
            // promises for create the actual motion data
            var promises = _.map(motions, function (motion) {
                var title = motion.getTitleWithChanges(params.changeRecommendationMode);
                var text = params.include.text ? motion.getTextByMode(params.changeRecommendationMode, null, null, false) : '';
                var reason = params.include.reason ? motion.getReason() : '';
                var comments = getMotionComments(motion, params.includeComments);

                // Data for one motions. Must include translations, ...
                var motionData = {
                    // Translations
                    motion_translation: translation,
                    sequential_translation: sequential_translation,
                    submitters_translation: submitters_translation,
                    reason_translation: reason.length === 0 ? '' : reason_translation,
                    status_translation: status_translation,
                    comment_translation: comments.length === 0 ? '' : comment_translation,
                    sequential_enabled: sequential_enabled,
                    // Actual data
                    id: motion.id,
                    identifier: motion.identifier || '',
                    title: title,
                    submitters: params.include.submitters ? _.map(
                            $filter('orderBy')(motion.submitters, 'weight'), function (submitter) {
                                return submitter.user.get_full_name();
                            }
                        ).join(', ') : '',
                    status: motion.getStateName(),
                    // Miscellaneous stuff
                    preamble: gettextCatalog.getString(Config.get('motions_preamble').value),
                    pagebreak: PAGEBREAK,
                };
                // converting html to docx is async, so text, reason and comments are inserted here.
                return $q(function (resolve) {
                    var convertPromises = _.map(comments, function (comment) {
                        return converter.html2docx(comment.comment).then(function (commentAsDocx) {
                            comment.comment = commentAsDocx;
                        });
                    });
                    convertPromises.push(converter.html2docx(text).then(function (textAsDocx) {
                        motionData.text = textAsDocx;
                    }));
                    convertPromises.push(converter.html2docx(reason).then(function (reasonAsDocx) {
                        motionData.reason = reasonAsDocx;
                    }));
                    $q.all(convertPromises).then(function () {
                        motionData.comments = comments;
                        resolve(motionData);
                    });
                });
            });
            // resolve, if all motion data is fetched.
            return $q(function (resolve) {
                $q.all(promises).then(function (data) {
                    if (data.length) {
                        // clear pagebreak on last element
                        data[data.length - 1].pagebreak = '';
                    }
                    resolve(data);
                });
            });
        };

        var getMotionComments = function (motion, fieldsIncluded) {
            var fields = MotionComment.getNoSpecialCommentsFields();
            var comments = [];
            _.forEach(fieldsIncluded, function (ok, id) {
                if (ok && motion.comments[id]) {
                    var title = fields[id].name;
                    if (!fields[id].public) {
                        title += ' (' + gettextCatalog.getString('internal') + ')';
                    }
                    var comment = motion.comments[id];
                    if (comment.indexOf('<p>') !== 0) {
                        comment = '<p>' + comment + '</p>';
                    }
                    comments.push({
                        title: title,
                        comment: comment,
                    });
                }
            });
            return comments;
        };

        return {
            export: function (motions, params) {
                converter = Html2DocxConverter.createInstance();
                params = _.clone(params || {}); // Clone this to avoid sideeffects.
                _.defaults(params, {
                    changeRecommendationMode: Config.get('motions_recommendation_text_mode').value,
                    include: {
                        text: true,
                        reason: true,
                        submitters: true,
                    },
                    includeComments: {},
                });
                params.filename = gettextCatalog.getString('motions') + '.docx';
                if (!_.includes(['original', 'changed', 'agreed'], params.changeRecommendationMode)) {
                    params.changeRecommendationMode = 'original';
                }

                $http.get('/motions/docxtemplate/').then(function (success) {
                    var content = window.atob(success.data);
                    var doc = new Docxgen(content);

                    getData(motions, params).then(function (data) {
                        doc.setData(data);
                        doc.render();

                        var zip = doc.getZip();
                        zip = converter.updateZipFile(zip);

                        var out = zip.generate({type: 'blob'});
                        FileSaver.saveAs(out, params.filename);
                    });
                });
            },
        };
    }
]);

}());

(function () {

"use strict";

angular.module('OpenSlidesApp.motions.lineNumbering', [])

/**
 * Current limitations of this implementation:
 *
 * Only the following inline elements are supported:
 * - 'SPAN', 'A', 'EM', 'S', 'B', 'I', 'STRONG', 'U', 'BIG', 'SMALL', 'SUB', 'SUP', 'TT'
 * - 'INS' and 'DEL' are supported, but line numbering does not affect the content of 'INS'-elements
 *
 * Only other inline elements are allowed within inline elements.
 * No constructs like <a...><div></div></a> are allowed. CSS-attributes like 'display: block' are ignored.
 */

.service('lineNumberingService', [
    '$cacheFactory',
    function ($cacheFactory) {
        var ELEMENT_NODE = 1,
            TEXT_NODE = 3;

        // Counts the number of characters in the current line, beyond singe nodes.
        // Needs to be resetted after each line break and after entering a new block node.
        this._currentInlineOffset = null;

        // The last position of a point suitable for breaking the line. null or an object with the following values:
        // - node: the node that contains the position. Guaranteed to be a TextNode
        // - offset: the offset of the breaking characters (like the space)
        // Needs to be resetted after each line break and after entering a new block node.
        this._lastInlineBreakablePoint = null;

        // The line number counter
        this._currentLineNumber = null;

        // Indicates that we just entered a block element and we want to add a line number without line break at the beginning.
        this._prependLineNumberToFirstText = false;

        // A workaround to prevent double line numbers
        this._ignoreNextRegularLineNumber = false;

        // Decides if the content of inserted nodes should count as well. This is used so we can use the algorithm on a
        // text with inline diff annotations and get the same line numbering as with the original text (when set to false)
        this._ignoreInsertedText = false;

        var lineNumberCache = $cacheFactory('linenumbering.service');

        this.djb2hash = function(str) {
            var hash = 5381, char;
            for (var i = 0; i < str.length; i++) {
                char = str.charCodeAt(i);
                hash = ((hash << 5) + hash) + char;
            }
            return hash.toString();
        };

        this._isInlineElement = function (node) {
            var inlineElements = [
                'SPAN', 'A', 'EM', 'S', 'B', 'I', 'STRONG', 'U', 'BIG', 'SMALL', 'SUB', 'SUP', 'TT', 'INS', 'DEL',
                'STRIKE'
            ];
            return (inlineElements.indexOf(node.nodeName) > -1);
        };

        this._isIgnoredByLineNumbering = function (node) {
            if (node.nodeName === 'INS') {
                return this._ignoreInsertedText;
            } else if (this._isOsLineNumberNode(node)) {
                return true;
            } else {
                return false;
            }
        };

        this._isOsLineBreakNode = function (node) {
            var isLineBreak = false;
            if (node && node.nodeType === ELEMENT_NODE && node.nodeName === 'BR' && node.hasAttribute('class')) {
                var classes = node.getAttribute('class').split(' ');
                if (classes.indexOf('os-line-break') > -1) {
                    isLineBreak = true;
                }
            }
            return isLineBreak;
        };

        this._isOsLineNumberNode = function (node) {
            var isLineNumber = false;
            if (node && node.nodeType === ELEMENT_NODE && node.nodeName === 'SPAN' && node.hasAttribute('class')) {
                var classes = node.getAttribute('class').split(' ');
                if (classes.indexOf('os-line-number') > -1) {
                    isLineNumber = true;
                }
            }
            return isLineNumber;
        };

        this._getLineNumberNode = function(fragment, lineNumber) {
            return fragment.querySelector('.os-line-number.line-number-' + lineNumber);
        };

        this._htmlToFragment = function(html) {
            var fragment = document.createDocumentFragment(),
                div = document.createElement('DIV');
            div.innerHTML = html;
            while (div.childElementCount) {
                var child = div.childNodes[0];
                div.removeChild(child);
                fragment.appendChild(child);
            }
            return fragment;
        };

        this._fragmentToHtml = function(fragment) {
            var div = document.createElement('DIV');
            while (fragment.firstChild) {
                var child = fragment.firstChild;
                fragment.removeChild(child);
                div.appendChild(child);
            }
            return div.innerHTML;
        };

        this._createLineBreak = function () {
            var br = document.createElement('br');
            br.setAttribute('class', 'os-line-break');
            return br;
        };

        this._createLineNumber = function () {
            if (this._ignoreNextRegularLineNumber) {
                this._ignoreNextRegularLineNumber = false;
                return;
            }
            var node = document.createElement('span');
            var lineNumber = this._currentLineNumber;
            this._currentLineNumber++;
            node.setAttribute('class', 'os-line-number line-number-' + lineNumber);
            node.setAttribute('data-line-number', lineNumber + '');
            node.setAttribute('contenteditable', 'false');
            node.innerHTML = '&nbsp;'; // Prevent ckeditor from stripping out empty span's
            return node;
        };

        /**
         * Splits a TEXT_NODE into an array of TEXT_NODEs and BR-Elements separating them into lines.
         * Each line has a maximum length of 'length', with one exception: spaces are accepted to exceed the length.
         * Otherwise the string is split by the last space or dash in the line.
         *
         * @param node
         * @param length
         * @param highlight
         * @returns Array
         * @private
         */
        this._textNodeToLines = function (node, length, highlight) {
            var out = [],
                currLineStart = 0,
                i = 0,
                firstTextNode = true,
                service = this;
            var addLine = function (text, highlight) {
                var node;
                if (typeof highlight === 'undefined') {
                    highlight = -1;
                }
                if (firstTextNode) {
                    if (highlight === service._currentLineNumber - 1) {
                        node = document.createElement('span');
                        node.setAttribute('class', 'highlight');
                        node.innerHTML = text;
                    } else {
                        node = document.createTextNode(text);
                    }
                    firstTextNode = false;
                } else {
                    if (service._currentLineNumber === highlight && highlight !== null) {
                        node = document.createElement('span');
                        node.setAttribute('class', 'highlight');
                        node.innerHTML = text;
                    } else {
                        node = document.createTextNode(text);
                    }
                    out.push(service._createLineBreak());
                    if (service._currentLineNumber !== null) {
                        out.push(service._createLineNumber());
                    }
                }
                out.push(node);
                return node;
            };
            var addLinebreakToPreviousNode = function (node, offset) {
                var firstText = node.nodeValue.substr(0, offset + 1),
                    secondText = node.nodeValue.substr(offset + 1);
                var lineBreak = service._createLineBreak();
                var firstNode = document.createTextNode(firstText);
                node.parentNode.insertBefore(firstNode, node);
                node.parentNode.insertBefore(lineBreak, node);
                if (service._currentLineNumber !== null) {
                    node.parentNode.insertBefore(service._createLineNumber(), node);
                }
                node.nodeValue = secondText;
            };

            if (node.nodeValue === "\n") {
                out.push(node);
            } else {

                // This happens if a previous inline element exactly stretches to the end of the line
                if (this._currentInlineOffset >= length) {
                    out.push(service._createLineBreak());
                    if (this._currentLineNumber !== null) {
                        out.push(service._createLineNumber());
                    }
                    this._currentInlineOffset = 0;
                    this._lastInlineBreakablePoint = null;
                } else if (this._prependLineNumberToFirstText) {
                    if (this._ignoreNextRegularLineNumber) {
                        this._ignoreNextRegularLineNumber = false;
                    } else if (service._currentLineNumber !== null) {
                        out.push(service._createLineNumber());
                    }
                }
                this._prependLineNumberToFirstText = false;

                while (i < node.nodeValue.length) {
                    var lineBreakAt = null;
                    if (this._currentInlineOffset >= length) {
                        if (this._lastInlineBreakablePoint !== null) {
                            lineBreakAt = this._lastInlineBreakablePoint;
                        } else {
                            lineBreakAt = {
                                'node': node,
                                'offset': i - 1
                            };
                        }
                    }
                    if (lineBreakAt !== null && (node.nodeValue[i] !== ' ' && node.nodeValue[i] !== "\n")) {
                        if (lineBreakAt.node === node) {
                            // The last possible breaking point is in this text node
                            var currLine = node.nodeValue.substring(currLineStart, lineBreakAt.offset + 1);
                            addLine(currLine, highlight);

                            currLineStart = lineBreakAt.offset + 1;
                            this._currentInlineOffset = i - lineBreakAt.offset - 1;
                            this._lastInlineBreakablePoint = null;
                        } else {
                            // The last possible breaking point was not in this text not, but one we have already passed
                            var remainderOfPrev = lineBreakAt.node.nodeValue.length - lineBreakAt.offset - 1;
                            addLinebreakToPreviousNode(lineBreakAt.node, lineBreakAt.offset);

                            this._currentInlineOffset = i + remainderOfPrev;
                            this._lastInlineBreakablePoint = null;
                        }

                    }

                    if (node.nodeValue[i] === ' ' || node.nodeValue[i] === '-' || node.nodeValue[i] === "\n") {
                        this._lastInlineBreakablePoint = {
                            'node': node,
                            'offset': i
                        };
                    }

                    this._currentInlineOffset++;
                    i++;

                }
                var lastLine = addLine(node.nodeValue.substring(currLineStart), highlight);
                if (this._lastInlineBreakablePoint !== null) {
                    this._lastInlineBreakablePoint.node = lastLine;
                }
            }
            return out;
        };


        /**
         * Moves line breaking and line numbering markup before inline elements
         *
         * @param innerNode
         * @param outerNode
         * @private
         */
        this._moveLeadingLineBreaksToOuterNode = function (innerNode, outerNode) {
            if (this._isInlineElement(innerNode)) {
                if (this._isOsLineBreakNode(innerNode.firstChild)) {
                    var br = innerNode.firstChild;
                    innerNode.removeChild(br);
                    outerNode.appendChild(br);
                }
                if (this._isOsLineNumberNode(innerNode.firstChild)) {
                    var span = innerNode.firstChild;
                    innerNode.removeChild(span);
                    outerNode.appendChild(span);
                }
            }
        };

        this._lengthOfFirstInlineWord = function (node) {
            if (!node.firstChild) {
                return 0;
            }
            if (node.firstChild.nodeType === TEXT_NODE) {
                var parts = node.firstChild.nodeValue.split(' ');
                return parts[0].length;
            } else {
                return this._lengthOfFirstInlineWord(node.firstChild);
            }
        };

        this._insertLineNumbersToInlineNode = function (node, length, highlight) {
            var oldChildren = [], i;
            for (i = 0; i < node.childNodes.length; i++) {
                oldChildren.push(node.childNodes[i]);
            }

            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }

            for (i = 0; i < oldChildren.length; i++) {
                if (oldChildren[i].nodeType === TEXT_NODE) {
                    var ret = this._textNodeToLines(oldChildren[i], length, highlight);
                    for (var j = 0; j < ret.length; j++) {
                        node.appendChild(ret[j]);
                    }
                } else if (oldChildren[i].nodeType === ELEMENT_NODE) {
                    var firstword = this._lengthOfFirstInlineWord(oldChildren[i]),
                        overlength = ((this._currentInlineOffset + firstword) > length && this._currentInlineOffset > 0);
                    if (overlength && this._isInlineElement(oldChildren[i])) {
                        this._currentInlineOffset = 0;
                        this._lastInlineBreakablePoint = null;
                        node.appendChild(this._createLineBreak());
                        if (this._currentLineNumber !== null) {
                            node.appendChild(this._createLineNumber());
                        }
                    }
                    var changedNode = this._insertLineNumbersToNode(oldChildren[i], length, highlight);
                    this._moveLeadingLineBreaksToOuterNode(changedNode, node);
                    node.appendChild(changedNode);
                } else {
                    throw 'Unknown nodeType: ' + i + ': ' + oldChildren[i];
                }
            }

            return node;
        };

        this._calcBlockNodeLength = function (node, oldLength) {
            var newLength = oldLength;
            switch (node.nodeName) {
                case 'LI':
                    newLength -= 5;
                    break;
                case 'BLOCKQUOTE':
                    newLength -= 20;
                    break;
                case 'DIV':
                case 'P':
                    var styles = node.getAttribute("style"),
                        padding = 0;
                    if (styles) {
                        var leftpad = styles.split("padding-left:");
                        if (leftpad.length > 1) {
                            leftpad = parseInt(leftpad[1]);
                            padding += leftpad;
                        }
                        var rightpad = styles.split("padding-right:");
                        if (rightpad.length > 1) {
                            rightpad = parseInt(rightpad[1]);
                            padding += rightpad;
                        }
                        newLength -= (padding / 5);
                    }
                    break;
                case 'H1':
                    newLength *= 0.66;
                    break;
                case 'H2':
                    newLength *= 0.75;
                    break;
                case 'H3':
                    newLength *= 0.85;
                    break;
            }
            return Math.ceil(newLength);
        };

        this._insertLineNumbersToBlockNode = function (node, length, highlight) {
            this._currentInlineOffset = 0;
            this._lastInlineBreakablePoint = null;
            this._prependLineNumberToFirstText = true;

            var oldChildren = [], i;
            for (i = 0; i < node.childNodes.length; i++) {
                oldChildren.push(node.childNodes[i]);
            }

            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }

            for (i = 0; i < oldChildren.length; i++) {
                if (oldChildren[i].nodeType === TEXT_NODE) {
                    if (!oldChildren[i].nodeValue.match(/\S/)) {
                        // White space nodes between block elements should be ignored
                        var prevIsBlock = (i > 0 && !this._isInlineElement(oldChildren[i - 1]));
                        var nextIsBlock = (i < oldChildren.length - 1 && !this._isInlineElement(oldChildren[i + 1]));
                        if ((prevIsBlock && nextIsBlock) || (i === 0 && nextIsBlock) || (i === oldChildren.length - 1 && prevIsBlock)) {
                            node.appendChild(oldChildren[i]);
                            continue;
                        }
                    }
                    var ret = this._textNodeToLines(oldChildren[i], length, highlight);
                    for (var j = 0; j < ret.length; j++) {
                        node.appendChild(ret[j]);
                    }
                } else if (oldChildren[i].nodeType === ELEMENT_NODE) {
                    var firstword = this._lengthOfFirstInlineWord(oldChildren[i]),
                        overlength = ((this._currentInlineOffset + firstword) > length && this._currentInlineOffset > 0);
                    if (overlength && this._isInlineElement(oldChildren[i]) && !this._isIgnoredByLineNumbering(oldChildren[i])) {
                        this._currentInlineOffset = 0;
                        this._lastInlineBreakablePoint = null;
                        node.appendChild(this._createLineBreak());
                        if (this._currentLineNumber !== null) {
                            node.appendChild(this._createLineNumber());
                        }
                    }
                    var changedNode = this._insertLineNumbersToNode(oldChildren[i], length, highlight);
                    this._moveLeadingLineBreaksToOuterNode(changedNode, node);
                    node.appendChild(changedNode);
                } else {
                    throw 'Unknown nodeType: ' + i + ': ' + oldChildren[i];
                }
            }

            this._currentInlineOffset = 0;
            this._lastInlineBreakablePoint = null;
            this._prependLineNumberToFirstText = true;
            this._ignoreNextRegularLineNumber = false;

            return node;
        };

        this._insertLineNumbersToNode = function (node, length, highlight) {
            if (node.nodeType !== ELEMENT_NODE) {
                throw 'This method may only be called for ELEMENT-nodes: ' + node.nodeValue;
            }
            if (this._isIgnoredByLineNumbering(node)) {
                if (this._currentInlineOffset === 0 && this._currentLineNumber !== null) {
                    var lineNumberNode = this._createLineNumber();
                    if (lineNumberNode) {
                        node.insertBefore(lineNumberNode, node.firstChild);
                        this._ignoreNextRegularLineNumber = true;
                    }
                }
                return node;
            } else if (this._isInlineElement(node)) {
                return this._insertLineNumbersToInlineNode(node, length, highlight);
            } else {
                var newLength = this._calcBlockNodeLength(node, length);
                return this._insertLineNumbersToBlockNode(node, newLength, highlight);
            }
        };

        this._stripLineNumbers = function (node) {
            for (var i = 0; i < node.childNodes.length; i++) {
                if (this._isOsLineBreakNode(node.childNodes[i]) || this._isOsLineNumberNode(node.childNodes[i])) {
                    // If a newline character follows a line break, it's been very likely inserted by the WYSIWYG-editor
                    if (node.childNodes.length > (i + 1) && node.childNodes[i + 1].nodeType === TEXT_NODE) {
                        if (node.childNodes[i + 1].nodeValue[0] === "\n") {
                            node.childNodes[i + 1].nodeValue = " " + node.childNodes[i + 1].nodeValue.substring(1);
                        }
                    }
                    node.removeChild(node.childNodes[i]);
                    i--;
                } else {
                    this._stripLineNumbers(node.childNodes[i]);
                }
            }
        };

        this._nodesToHtml = function (nodes) {
            var root = document.createElement('div');
            for (var i in nodes) {
                if (nodes.hasOwnProperty(i)) {
                    root.appendChild(nodes[i]);
                }
            }
            return root.innerHTML;
        };

        /**
         *
         * @param {string} html
         * @param {number|string} lineLength
         * @param {number|null} highlight - optional
         * @param {number|null} firstLine
         */
        this.insertLineNumbersNode = function (html, lineLength, highlight, firstLine) {
            // Removing newlines after BRs, as they lead to problems like #3410
            if (html) {
                html = html.replace(/(<br[^>]*>)[\n\r]+/gi, '$1');
            }

            var root = document.createElement('div');
            root.innerHTML = html;

            this._currentInlineOffset = 0;
            this._lastInlineBreakablePoint = null;
            if (firstLine) {
                this._currentLineNumber = parseInt(firstLine);
            } else {
                this._currentLineNumber = 1;
            }
            if (highlight !== null) {
                highlight = parseInt(highlight);
            }
            this._prependLineNumberToFirstText = true;
            this._ignoreNextRegularLineNumber = false;
            this._ignoreInsertedText = true;

            return this._insertLineNumbersToNode(root, lineLength, highlight);
        };

        /**
         *
         * @param {string} html
         * @param {number} lineLength
         * @param {number|null} highlight - optional
         * @param {function} callback
         * @param {number} firstLine
         * @returns {string}
         */
        this.insertLineNumbers = function (html, lineLength, highlight, callback, firstLine) {
            var newHtml, newRoot;

            if (highlight > 0) {
                // Caching versions with highlighted line numbers is probably not worth it
                newRoot = this.insertLineNumbersNode(html, lineLength, highlight, firstLine);
                newHtml = newRoot.innerHTML;
            } else {
                var firstLineStr = (firstLine === undefined || firstLine === null ? '' : firstLine.toString());
                var cacheKey = this.djb2hash(firstLineStr + "-" + lineLength.toString() + html);
                newHtml = lineNumberCache.get(cacheKey);

                if (angular.isUndefined(newHtml)) {
                    newRoot = this.insertLineNumbersNode(html, lineLength, null, firstLine);
                    newHtml = newRoot.innerHTML;
                    lineNumberCache.put(cacheKey, newHtml);
                }
            }

            if (callback) {
                callback();
            }

            return newHtml;
        };

        /**
         * @param {string} html
         * @param {number} lineLength
         * @param {boolean} countInserted
         */
        this.insertLineBreaksWithoutNumbers = function (html, lineLength, countInserted) {
            var root = document.createElement('div');
            root.innerHTML = html;

            this._currentInlineOffset = 0;
            this._lastInlineBreakablePoint = null;
            this._currentLineNumber = null;
            this._prependLineNumberToFirstText = true;
            this._ignoreNextRegularLineNumber = false;
            this._ignoreInsertedText = !countInserted;

            var newRoot = this._insertLineNumbersToNode(root, lineLength, null);

            return newRoot.innerHTML;
        };

        /**
         * @param {string} html
         * @returns {string}
         */
        this.stripLineNumbers = function (html) {
            var root = document.createElement('div');
            root.innerHTML = html;
            this._stripLineNumbers(root);
            return root.innerHTML;
        };

        /**
         * @param {string} html
         * @returns {object}
         *          {"from": 23, "to": 42} ; "to" refers to the line breaking element at the end of the last line,
         *                                   i.e. the line number of the following line
         */
        this.getLineNumberRange = function (html) {
            var fragment = this._htmlToFragment(html),
                range = {
                    "from": null,
                    "to": null
                };
            var lineNumbers = fragment.querySelectorAll('.os-line-number');
            for (var i = 0; i < lineNumbers.length; i++) {
                var node = lineNumbers.item(i);
                var number = parseInt(node.getAttribute("data-line-number"));
                if (range.from === null || number < range.from) {
                    range.from = number;
                }
                if (range.to === null || (number + 1) > range.to) {
                    range.to = number + 1;
                }
            }
            return range;
        };

        /**
         * @param {string} html
         */
        this.getHeadingsWithLineNumbers = function (html) {
            var fragment = this._htmlToFragment(html),
                headings = [];
            var headingNodes = fragment.querySelectorAll('h1, h2, h3, h4, h5, h6');
            for (var i = 0; i < headingNodes.length; i++) {
                var heading = headingNodes.item(i);
                var linenumbers = heading.querySelectorAll('.os-line-number');
                if (linenumbers.length > 0) {
                    var number = parseInt(linenumbers.item(0).getAttribute("data-line-number"));
                    headings.push({
                        "lineNumber": number,
                        "level": parseInt(heading.nodeName.substr(1)),
                        "text": heading.innerText.replace(/^\s/, "").replace(/\s$/, "")
                    });
                }
            }
            return headings.sort(function(heading1, heading2) {
                if (heading1.lineNumber < heading2.lineNumber) {
                    return 0;
                } else if (heading1.lineNumber > heading2.lineNumber) {
                    return 1;
                } else {
                    return 0;
                }
            });
        };

        /**
         * @param {Element} node
         * @returns {array}
         * @private
         */
        this._splitNodeToParagraphs = function (node) {
            var elements = [];
            for (var i = 0; i < node.childNodes.length; i++) {
                var childNode = node.childNodes.item(i);

                if (childNode.nodeType === TEXT_NODE) {
                    continue;
                }
                if (childNode.nodeName === 'UL' || childNode.nodeName === 'OL') {
                    var start = 1;
                    if (childNode.getAttribute("start") !== null) {
                        start = parseInt(childNode.getAttribute("start"));
                    }
                    for (var j = 0; j < childNode.childNodes.length; j++) {
                        if (childNode.childNodes.item(j).nodeType === TEXT_NODE) {
                            continue;
                        }
                        var newParent = childNode.cloneNode(false);
                        if (childNode.nodeName === 'OL') {
                            newParent.setAttribute('start', start);
                        }
                        newParent.appendChild(childNode.childNodes.item(j).cloneNode(true));
                        elements.push(newParent);
                        start++;
                    }
                } else {
                    elements.push(childNode);
                }
            }
            return elements;
        };

        /**
         * Splitting the text into paragraphs:
         * - Each root-level-element is considered as a paragraph.
         *   Inline-elements at root-level are not expected and treated as block elements.
         *   Text-nodes at root-level are not expected and ignored. Every text needs to be wrapped e.g. by <p> or <div>.
         * - If a UL or OL is encountered, paragraphs are defined by the child-LI-elements.
         *   List items of nested lists are not considered as a paragraph of their own.
         *
         * @param {string} html
         * @return {string[]}
         */
        this.splitToParagraphs = function (html) {
            var fragment = this._htmlToFragment(html);
            return this._splitNodeToParagraphs(fragment).map(function(node) { return node.outerHTML; });
        };

        /**
         * Traverses up the DOM tree until it finds a node with a nextSibling, then returns that sibling
         *
         * @param node
         * @private
         */
        this._findNextAuntNode = function(node) {
            if (node.nextSibling) {
                return node.nextSibling;
            } else if (node.parentNode) {
                return this._findNextAuntNode(node.parentNode);
            } else {
                return null;
            }
        };

        this._highlightUntilNextLine = function(lineNumberNode) {
            var currentNode = lineNumberNode,
                foundNextLineNumber = false;

            do {
                var wasHighlighted = false;
                if (currentNode.nodeType === TEXT_NODE) {
                    var node = document.createElement('span');
                    node.setAttribute('class', 'highlight');
                    node.innerHTML = currentNode.nodeValue;
                    currentNode.parentNode.insertBefore(node, currentNode);
                    currentNode.parentNode.removeChild(currentNode);
                    currentNode = node;
                    wasHighlighted = true;
                } else {
                    wasHighlighted = false;
                }

                if (currentNode.childNodes.length > 0 && !this._isOsLineNumberNode(currentNode) && !wasHighlighted) {
                    currentNode = currentNode.childNodes[0];
                } else if (currentNode.nextSibling) {
                    currentNode = currentNode.nextSibling;
                } else {
                    currentNode = this._findNextAuntNode(currentNode);
                }

                if (this._isOsLineNumberNode(currentNode)) {
                    foundNextLineNumber = true;
                }
            } while (!foundNextLineNumber && currentNode !== null);
        };

        /**
         * @param {string} html
         * @param {number} lineNumber
         * @return {string}
         */
        this.highlightLine = function (html, lineNumber) {
            lineNumber = parseInt(lineNumber);
            var fragment = this._htmlToFragment(html),
                lineNumberNode = this._getLineNumberNode(fragment, lineNumber);

            if (lineNumberNode) {
                this._highlightUntilNextLine(lineNumberNode);
                html = this._fragmentToHtml(fragment);
            }

            return html;
        };
    }
]);


}());

(function () {

'use strict';

angular.module('OpenSlidesApp.motions.motionBlockProjector', [])


// MotionBlock projector elements

.config([
    'slidesProvider',
    function(slidesProvider) {
        slidesProvider.registerSlide('motions/motion-block', {
            template: 'static/templates/motions/slide_motion_block.html',
        });
    }
])

.controller('SlideMotionBlockCtrl', [
    '$scope',
    'Motion',
    'MotionBlock',
    function($scope, Motion, MotionBlock) {
        // Attention! Each object that is used here has to be dealt on server side.
        // Add it to the coresponding get_requirements method of the ProjectorElement
        // class.
        var id = $scope.element.id;
        MotionBlock.bindOne(id, $scope, 'motionBlock');

        // Returns a shortened motion title. If the title is longer then maxLength, it is
        // split at the last whitespace that is in maxLength. Three dots are added then.
        $scope.getShortTitle = function (motion) {
            var maxLength = 40;
            var title = motion.getTitle();

            if (title.length <= maxLength) {
                return title;
            }

            // Find last whitespace that is before maxLength. Split the title
            // there and append dots.
            var whitespaceIndex = -1;
            for (var i = 0; i < maxLength+1; i++) {
                if (title[i] === ' ') {
                    whitespaceIndex = i;
                }
            }

            if (whitespaceIndex === -1) {
                // just one long word.. split it :/
                return title.substr(0, maxLength) + '...';
            } else {
                return title.substr(0, whitespaceIndex) + '...';
            }
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.motions.motionBlock', [])


// MotionBlock model

.factory('MotionBlock', [
    'DS',
    'jsDataModel',
    'gettext',
    function(DS, jsDataModel, gettext) {
        var name = 'motions/motion-block';
        return DS.defineResource({
            name: name,
            useClass: jsDataModel,
            verboseName: gettext('Motion block'),
            methods: {
                getResourceName: function () {
                    return name;
                },
                getAgendaTitle: function () {
                    return this.title;
                },
            },
            relations: {
                belongsTo: {
                    'agenda/item': {
                        localKey: 'agenda_item_id',
                        localField: 'agenda_item',
                    }
                },
                hasMany: {
                    'motions/motion': {
                        localField: 'motions',
                        foreignKey: 'motion_block_id',
                        osProtectedRelation: true,
                    }
                },
            }
        });
    }
])

.run(['MotionBlock', function(MotionBlock) {}])

// MotionBlock views (list view, create dialog, update dialog)
.factory('MotionBlockForm', [
    '$http',
    'operator',
    'gettextCatalog',
    'Agenda',
    'AgendaTree',
    'ShowAsAgendaItemField',
    function ($http, operator, gettextCatalog, Agenda, AgendaTree, ShowAsAgendaItemField) {
        return {
            // Get ngDialog configuration.
            getDialog: function (motionBlock) {
                return {
                    template: 'static/templates/motions/motion-block-form.html',
                    controller: (motionBlock) ? 'MotionBlockUpdateCtrl' : 'MotionBlockCreateCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        motionBlockId: function () {return motionBlock ? motionBlock.id : void 0;}
                    }
                };
            },
            // Get angular-formly fields.
            getFormFields: function (isCreateForm) {
                var formFields = [
                    {
                        key: 'title',
                        type: 'input',
                        templateOptions: {
                            label: gettextCatalog.getString('Title')
                        }
                    },
                ];

                // show as agenda item + parent item
                if (isCreateForm) {
                    formFields.push(ShowAsAgendaItemField('motions.can_manage'));
                    formFields.push({
                        key: 'agenda_parent_id',
                        type: 'select-single',
                        templateOptions: {
                            label: gettextCatalog.getString('Parent item'),
                            options: AgendaTree.getFlatTree(Agenda.getAll()),
                            ngOptions: 'item.id as item.getListViewTitle() for item in to.options | notself : model.agenda_item_id',
                            placeholder: gettextCatalog.getString('Select a parent item ...')
                        },
                        hide: !operator.hasPerms('agenda.can_manage')
                    });
                }

                return formFields;
            }
        };
    }
])

.controller('MotionBlockListCtrl', [
    '$scope',
    'ngDialog',
    'MotionBlock',
    'MotionBlockForm',
    'Projector',
    'ProjectionDefault',
    function ($scope, ngDialog, MotionBlock, MotionBlockForm, Projector, ProjectionDefault) {
        $scope.$watch(function () {
            return Projector.lastModified();
        }, function () {
            var projectiondefault = ProjectionDefault.filter({name: 'motionBlocks'})[0];
            if (projectiondefault) {
                $scope.defaultProjectorId = projectiondefault.projector_id;
            }
        });
        // Two-way data binding for all MotionBlock instances.
        MotionBlock.bindAll({}, $scope, 'motionBlocks');

        // Dialog with a form to create or update a MotionBlock instance.
        $scope.openFormDialog = function (motionBlock) {
            ngDialog.open(MotionBlockForm.getDialog(motionBlock));
        };

        // Confirm dialog to delete a MotionBlock instance.
        $scope.delete = function (motionBlock) {
            MotionBlock.destroy(motionBlock.id);
        };
    }
])

.controller('MotionBlockDetailCtrl', [
    '$scope',
    '$http',
    'ngDialog',
    'Motion',
    'MotionBlockForm',
    'MotionBlock',
    'motionBlockId',
    'Projector',
    'ProjectionDefault',
    'WebpageTitle',
    'gettextCatalog',
    'ErrorMessage',
    function($scope, $http, ngDialog, Motion, MotionBlockForm, MotionBlock, motionBlockId, Projector,
        ProjectionDefault, WebpageTitle, gettextCatalog, ErrorMessage) {
        $scope.$watch(function () {
            return MotionBlock.lastModified(motionBlockId);
        }, function () {
            $scope.motionBlock = MotionBlock.get(motionBlockId);
            WebpageTitle.updateTitle(gettextCatalog.getString('Motion block') + ' ' +
                $scope.motionBlock.agenda_item.getTitle());
        });
        Motion.bindAll({}, $scope, 'motions');
        $scope.$watch(function () {
            return Projector.lastModified();
        }, function () {
            var projectiondefault = ProjectionDefault.filter({name: 'motionBlocks'})[0];
            if (projectiondefault) {
                $scope.defaultProjectorId = projectiondefault.projector_id;
            }
        });
        $scope.openDialog = function (motionBlock) {
            ngDialog.open(MotionBlockForm.getDialog(motionBlock));
        };
        $scope.followRecommendations = function () {
            $http.post('/rest/motions/motion-block/' + motionBlockId + '/follow_recommendations/').then(
                function (success) {
                $scope.alert = { type: 'success', msg: success.data.detail, show: true };
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };
        $scope.delete = function (motion) {
            motion.motion_block_id = null;
            motion.title = motion.getTitle(-1);
            motion.text = motion.getText(-1);
            motion.reason = motion.getReason(-1);
            Motion.save(motion);
        };
    }
])

.controller('MotionBlockCreateCtrl', [
    '$scope',
    'MotionBlock',
    'MotionBlockForm',
    'Config',
    function($scope, MotionBlock, MotionBlockForm, Config) {
        // Prepare form.
        $scope.model = {
            agenda_type: parseInt(Config.get('agenda_new_items_default_visibility').value),
        };

        // Get all form fields.
        $scope.formFields = MotionBlockForm.getFormFields(true);

        // Save form.
        $scope.save = function (motionBlock) {
            MotionBlock.create(motionBlock).then(
                function (success) {
                    $scope.closeThisDialog();
                },
                function (error) {
                    var message = '';
                    for (var e in error.data) {
                        message += e + ': ' + error.data[e] + ' ';
                    }
                    $scope.alert = {type: 'danger', msg: message, show: true};
                }
            );
        };
    }
])

.controller('MotionBlockUpdateCtrl', [
    '$scope',
    '$state',
    'MotionBlock',
    'MotionBlockForm',
    'motionBlockId',
    function($scope, $state, MotionBlock, MotionBlockForm, motionBlockId) {
        $scope.alert = {};

        // Prepare form. Set initial values by creating a deep copy of
        // motionBlock object so list/detail view is not updated while editing.
        var motionBlock = MotionBlock.get(motionBlockId);
        $scope.model = angular.copy(motionBlock);

        // Get all form fields.
        $scope.formFields = MotionBlockForm.getFormFields();

        // Save form.
        $scope.save = function (motionBlock) {
            // inject the changed motionBlock (copy) object back into DS store
            MotionBlock.inject(motionBlock);
            // save changed motionBlock object on server
            MotionBlock.create(motionBlock).then(
                function (success) {
                    $scope.closeThisDialog();
                },
                function (error) {
                    // Save error: revert all changes by restore
                    // (refresh) original motionBlock object from server
                    MotionBlock.refresh(motionBlock);  // TODO: Why do we need a refresh here?
                    var message = '';
                    for (var e in error.data) {
                        message += e + ': ' + error.data[e] + ' ';
                    }
                    $scope.alert = {type: 'danger', msg: message, show: true};
                }
            );
        };
    }
]);

}());

(function () {

"use strict";

angular.module('OpenSlidesApp.motions.motionservices', ['OpenSlidesApp.motions', 'OpenSlidesApp.motions.lineNumbering'])

/* Generic inline editing factory.
 *
 * getOriginalData: Function that should return the editor data. The editor object is passed.
 * saveData: Function that is called whith the editor object as argument. This function
 *      should prepare the save. If the function returns true, the save process won't be
 *      continued. Else a patch request is send.
 */
.factory('MotionInlineEditing', [
    'Motion',
    '$timeout',
    'gettextCatalog',
    function (Motion, $timeout, gettextCatalog) {
        var createInstance = function ($scope, motion, selector, versioning, ckeditorOptions, getOriginalData, saveData) {
            var obj = {
                active: false,
                changed: false,
                isEditable: false,
                trivialChange: false,
                originalHtml: null,
            };
            ckeditorOptions.readOnly = true;

            obj.setVersion = function (_motion, versionId) {
                motion = _motion; // If this is not updated,
                obj.originalHtml = motion.getTextWithLineBreaks(versionId);
                obj.changed = false;
                if (obj.editor) {
                    obj.editor.setReadOnly(true);
                    obj.editor.setData(obj.originalHtml);
                }
            };

            obj.enable = function () {
                obj.active = true;
                obj.isEditable = true;
                ckeditorOptions.language = localStorage.getItem('language');
                obj.editor = CKEDITOR.inline(selector, ckeditorOptions);
                obj.editor.on('change', function () {
                    $timeout(function() {
                        if (obj.editor.getData() !== obj.originalHtml) {
                            obj.changed = true;
                        } else {
                            obj.changed = false;
                        }
                    });
                });
                obj.revert();
            };

            obj.disable = function () {
                if (obj.editor) {
                    obj.editor.setReadOnly(true);
                    obj.editor.setData(obj.originalHtml, {
                        callback: function() {
                            obj.editor.destroy();
                        }
                    });
                }
                $timeout(function() {
                    obj.active = false;
                    obj.changed = false;
                    obj.isEditable = false;
                });
            };

            // sets editor content to the initial motion state
            obj.revert = function(originalData) {
                if (obj.editor) {
                    obj.originalHtml = getOriginalData(obj);
                    obj.editor.setData(
                        getOriginalData(obj), {
                        callback: function() {
                            obj.originalHtml = obj.editor.getData();
                            obj.editor.setReadOnly(false);
                            $timeout(function() {
                                obj.changed = false;
                            });
                            $timeout(function () {
                                obj.editor.focus();
                            }, 100);
                        }
                    });
                }
            };

            obj.save = function () {
                if (!saveData(obj)) {
                    obj.disable();

                    Motion.inject(motion);
                    // save change motion object on server
                    Motion.save(motion, {method: 'PATCH'}).then(
                        function (success) {
                            if (versioning) {
                                $scope.showVersion(motion.getVersion(-1));
                            }
                            obj.revert();
                        },
                        function (error) {
                            // save error: revert all changes by restore
                            // (refresh) original motion object from server
                            Motion.refresh(motion);
                            obj.revert();
                            var message = '';
                            for (var e in error.data) {
                                message += e + ': ' + error.data[e] + ' ';
                            }
                            $scope.alert = {type: 'danger', msg: message, show: true};
                        }
                    );
                }
            };

            return obj;
        };
        return {
            createInstance: createInstance
        };
    }
])

.factory('MotionCommentsInlineEditing', [
    'MotionInlineEditing',
    'Editor',
    function (MotionInlineEditing, Editor) {
        var createInstances = function ($scope, motion) {
            var commentsInlineEditing = {
                editors: {}, // Map comment id to editor instance.
            };
            var options = Editor.getOptions('inline', 'YOffset');
            _.forEachRight($scope.noSpecialCommentsFields, function (field, id) {
                var inlineEditing = MotionInlineEditing.createInstance($scope, motion,
                    'view-original-comment-inline-editor-' + id, false, options,
                    function (obj) {
                        return motion['comment_' + id];
                    },
                    function (obj) {
                        if (obj.editor) {
                            motion['comment_' + id] = obj.editor.getData();
                        }
                    }
                );
                commentsInlineEditing.editors[id] = inlineEditing;
            });
            commentsInlineEditing.saveToolbarVisible = function () {
                return _.some(commentsInlineEditing.editors, function (instance) {
                    return instance.changed && instance.active;
                });
            };
            commentsInlineEditing.active = function (commentId) {
                return commentsInlineEditing.editors[commentId].active;
            };
            commentsInlineEditing.save = function () {
                _.forEach(commentsInlineEditing.editors, function (instance) {
                    instance.save();
                });
            };
            commentsInlineEditing.revert = function () {
                _.forEach(commentsInlineEditing.editors, function (instance) {
                    instance.revert();
                });
            };
            commentsInlineEditing.enable = function (commentId) {
                commentsInlineEditing.editors[commentId].enable();
            };
            commentsInlineEditing.disable = function (commentId) {
                commentsInlineEditing.editors[commentId].disable();
            };

            return commentsInlineEditing;
        };
        return {
            createInstances: createInstances,
        };
    }
])

.factory('ChangeRecommendationCreate', [
    'ngDialog',
    'ChangeRecommendationTitleForm',
    'ChangeRecommendationTextForm',
    function(ngDialog, ChangeRecommendationTitleForm, ChangeRecommendationTextForm) {
        var MODE_INACTIVE = 0,
            MODE_SELECTING_FROM = 1,
            MODE_SELECTING_TO = 2,

            TITLE_DUMMY_LINE_NUMBER = 0;

        var obj = {
            mode: MODE_INACTIVE,
            lineFrom: 1,
            lineTo: 2,
            html: '',
            reviewingHtml: ''
        };

        var $scope, motion, version;

        obj._getAffectedLineNumbers = function () {
            var changeRecommendations = motion.getTextChangeRecommendations(version.id),
                affectedLines = [];
            for (var i = 0; i < changeRecommendations.length; i++) {
                var change = changeRecommendations[i];
                for (var j = change.line_from; j < change.line_to; j++) {
                    affectedLines.push(j);
                }
            }
            return affectedLines;
        };

        // startCreating is called right at the beginning after the users interacts with the text for the first time.
        // This ensures all necessary nodes have been initialized
        obj.startCreating = function () {
            if (obj.mode > MODE_SELECTING_FROM || !motion.isAllowed('can_manage')) {
                return;
            }

            $(".tt_change_recommendation_create_help").removeClass("opened");
            var $lineNumbers = $(".motion-text-original .os-line-number"),
                $title = $(".motion-title .change-title");
            if ($lineNumbers.filter(".selectable").length === 0) {
                obj.mode = MODE_SELECTING_FROM;
                var alreadyAffectedLines = obj._getAffectedLineNumbers();
                $lineNumbers.each(function () {
                    var $this = $(this),
                        lineNumber = $this.data("line-number");
                    if (alreadyAffectedLines.indexOf(lineNumber) === -1) {
                        $(this).addClass("selectable");
                    }
                });
                if (alreadyAffectedLines.indexOf(TITLE_DUMMY_LINE_NUMBER) === -1) {
                    $title.addClass("selectable");
                }
            }
        };

        obj.cancelCreating = function (ev) {
            var $target = $(ev.target),
                query = ".line-numbers-outside .os-line-number.selectable";
            if (!$target.is(query) && $target.parents(query).length === 0) {
                obj.mode = MODE_INACTIVE;
                obj.lineFrom = 0;
                obj.lineTo = 0;
                $(".motion-text-original .os-line-number").removeClass("selected selectable");
                obj.startCreating();
            }
        };

        obj.setFromLine = function (line) {
            obj.mode = MODE_SELECTING_TO;
            obj.lineFrom = line;

            var alreadyAffectedLines = obj._getAffectedLineNumbers(),
                foundCollission = false;

            $(".motion-text-original .os-line-number").each(function () {
                var $this = $(this);
                if ($this.data("line-number") >= line && !foundCollission) {
                    if (alreadyAffectedLines.indexOf($this.data("line-number")) === -1) {
                        $(this).addClass("selectable");
                    } else {
                        $(this).removeClass("selectable");
                        foundCollission = true;
                    }
                } else {
                    $(this).removeClass("selectable");
                }
            });

            var tt_pos = $(".motion-text-original .line-number-" + line).position().top - 45;
            $(".tt_change_recommendation_create_help").css("top", tt_pos).addClass("opened");
        };

        obj.titleClicked = function () {
            ngDialog.open(ChangeRecommendationTitleForm.getCreateDialog(motion, version));

            obj.mode = MODE_INACTIVE;
            obj.lineFrom = 0;
            obj.lineTo = 0;
            $(".motion-text-original .os-line-number").removeClass("selected selectable");
            obj.startCreating();
        };

        obj.setToLine = function (line) {
            if (line < obj.lineFrom) {
                return;
            }
            obj.mode = MODE_INACTIVE;
            ngDialog.open(ChangeRecommendationTextForm.getCreateDialog(motion, version, obj.lineFrom, line + 1));

            obj.lineFrom = 0;
            obj.lineTo = 0;
            $(".motion-text-original .os-line-number").removeClass("selected selectable");
            obj.startCreating();
        };

        obj.lineClicked = function (ev) {
            if (obj.mode === MODE_INACTIVE) {
                return;
            }
            if (obj.mode === MODE_SELECTING_FROM) {
                obj.setFromLine($(ev.target).data("line-number"));
                $(ev.target).addClass("selected");
            } else if (obj.mode === MODE_SELECTING_TO) {
                obj.setToLine($(ev.target).data("line-number"));
            }
        };

        obj.mouseOver = function (ev) {
            if (obj.mode !== MODE_SELECTING_TO) {
                return;
            }
            var hoverLine = $(ev.target).data("line-number");
            $(".motion-text-original .os-line-number").each(function () {
                var line = $(this).data("line-number");
                if (line >= obj.lineFrom && line <= hoverLine) {
                    $(this).addClass("selected");
                } else {
                    $(this).removeClass("selected");
                }
            });
        };

        obj.setVersion = function (_motion, _version) {
            motion = _motion;
            version = motion.getVersion(_version);
        };

        obj.editTextDialog = function(change_recommendation) {
            ngDialog.open(ChangeRecommendationTextForm.getEditDialog(change_recommendation));
        };

        obj.editTitleDialog = function(change_recommendation) {
            ngDialog.open(ChangeRecommendationTitleForm.getEditDialog(change_recommendation));
        };

        obj.init = function (_scope, _motion) {
            $scope = _scope;
            motion = _motion;
            version = motion.getVersion($scope.version);

            var $content = $("#content");
            $content.on("click", ".line-numbers-outside .os-line-number.selectable", obj.lineClicked);
            $content.on("click", ".motion-title .change-title.selectable", obj.titleClicked);
            $content.on("click", obj.cancelCreating);
            $content.on("mouseover", ".line-numbers-outside .os-line-number.selectable", obj.mouseOver);
            $content.on("mouseover", ".motion-text-original, .motion-title", obj.startCreating);

            $scope.$watch(function () {
                return $scope.change_recommendations.length;
            }, function () {
                if (obj.mode === MODE_INACTIVE || obj.mode === MODE_SELECTING_FROM) {
                    // Recalculate the affected lines so we cannot select lines affected by a recommendation
                    // that has just been created
                    $(".motion-text-original .os-line-number").removeClass("selected selectable");
                    $(".motion-title .change-title").removeClass("selected selectable");
                    obj.startCreating();
                }
            });

            $scope.$on("$destroy", function () {
                obj.destroy();
            });
        };

        obj.destroy = function () {
            var $content = $("#content");
            $content.off("click", ".line-numbers-outside .os-line-number.selectable", obj.lineClicked);
            $content.off("click", ".motion-title .change-title.selectable", obj.titleClicked);
            $content.off("click", obj.cancelCreating);
            $content.off("mouseover", ".line-numbers-outside .os-line-number.selectable", obj.mouseOver);
            $content.off("mouseover", ".motion-text-original, .motion-title", obj.startCreating);
        };

        return obj;
    }
])

.factory('ChangeRecommendationView', [
    'Motion',
    'MotionChangeRecommendation',
    'Config',
    'lineNumberingService',
    'diffService',
    '$interval',
    '$timeout',
    function (Motion, MotionChangeRecommendation, Config, lineNumberingService, diffService, $interval, $timeout) {
        var $scope, motion;

        var obj = {
            mode: 'original',
            context: null
        };

        obj.diffFormatterCb = function (change, oldFragment, newFragment) {
            for (var i = 0; i < oldFragment.childNodes.length; i++) {
                diffService.addCSSClass(oldFragment.childNodes[i], 'delete');
            }
            for (i = 0; i < newFragment.childNodes.length; i++) {
                diffService.addCSSClass(newFragment.childNodes[i], 'insert');
            }
            var mergedFragment = document.createDocumentFragment(),
                diffSection = document.createElement('SECTION'),
                el;

            mergedFragment.appendChild(diffSection);
            diffSection.setAttribute('class', 'diff');
            diffSection.setAttribute('data-change-id', change.id);

            while (oldFragment.firstChild) {
                el = oldFragment.firstChild;
                oldFragment.removeChild(el);
                diffSection.appendChild(el);
            }
            while (newFragment.firstChild) {
                el = newFragment.firstChild;
                newFragment.removeChild(el);
                diffSection.appendChild(el);
            }

            return mergedFragment;
        };

        obj.delete = function (changeId) {
            MotionChangeRecommendation.destroy(changeId);
        };

        obj.rejectAllChangeRecommendations = function (motion) {
            var changeRecommendations = MotionChangeRecommendation.filter({
                'where': {'motion_version_id': {'==': motion.active_version}}
            });
            _.forEach(changeRecommendations, function(change) {
                change.rejected = true;
                change.saveStatus();
            });
        };

        obj.repositionOriginalAnnotations = function () {
            var $changeRecommendationList = $('.change-recommendation-list'),
                $lineNumberReference = $('.motion-text-original');

            $changeRecommendationList.children().each(function() {
                var $this = $(this),
                    lineFrom = $this.data('line-from'),
                    lineTo = ($this.data('line-to') - 1),
                    $lineFrom = $lineNumberReference.find('.line-number-' + lineFrom),
                    $lineTo = $lineNumberReference.find('.line-number-' + lineTo),
                    fromTop = $lineFrom.position().top + 3,
                    toTop = $lineTo.position().top + 20,
                    height = (toTop - fromTop);

                if (height < 10) {
                    height = 10;
                }

                // $lineFrom.position().top seems to depend on the scrolling position when the line numbers
                // have position: absolute. Maybe a bug in the used version of jQuery?
                // This cancels the effect.
                /*
                if ($lineNumberReference.hasClass('line-numbers-outside')) {
                    fromTop += window.scrollY;
                }
                */

                $this.css({ 'top': fromTop, 'height': height });
            });
        };

        obj.copyToModifiedFinalVersion = function (motion, version) {
            if (!motion.isAllowed('update')) {
                throw 'No permission to update motion';
            }

            motion.copyModifiedFinalVersionStrippingLineBreaks();

            Motion.inject(motion);
            // save change motion object on server
            Motion.save(motion, {method: 'PATCH'}).then(null, function (error) {
                // save error: revert all changes by restore
                // (refresh) original motion object from server
                Motion.refresh(motion);
                var message = '';
                for (var e in error.data) {
                    message += e + ': ' + error.data[e] + ' ';
                }
                $scope.alert = {type: 'danger', msg: message, show: true};
            });
        };

        obj.deleteModifiedFinalVersion = function (motion, version) {
            if (!motion.isAllowed('update')) {
                throw 'No permission to update motion';
            }

            if (!motion.getModifiedFinalVersion(version)) {
                return;
            }

            motion.modified_final_version = '';

            Motion.inject(motion);
            // save change motion object on server
            Motion.save(motion, {method: 'PATCH'}).then(function (success) {
                $scope.viewChangeRecommendations.mode = 'agreed';
            }, function (error) {
                // save error: revert all changes by restore
                // (refresh) original motion object from server
                Motion.refresh(motion);
                var message = '';
                for (var e in error.data) {
                    message += e + ': ' + error.data[e] + ' ';
                }
                $scope.alert = {type: 'danger', msg: message, show: true};
            });
        };

        obj.newVersionIncludingChanges = function (motion, version) {
            if (!motion.isAllowed('update')) {
                throw 'No permission to update motion';
            }

            var newHtml = motion.getTextByMode('agreed');
            motion.setTextStrippingLineBreaks(newHtml);

            Motion.inject(motion);
            // save change motion object on server
            Motion.save(motion, {method: 'PATCH'}).then(
                function (success) {
                    $scope.showVersion(motion.getVersion(-1));
                },
                function (error) {
                    // save error: revert all changes by restore
                    // (refresh) original motion object from server
                    Motion.refresh(motion);
                    var message = '';
                    for (var e in error.data) {
                        message += e + ': ' + error.data[e] + ' ';
                    }
                    $scope.alert = {type: 'danger', msg: message, show: true};
                }
            );
        };

        obj.scrollToDiffBox = function (changeId) {
            obj.mode = 'diff';
            $timeout(function() {
                var $diffBox = $('.diff-box-' + changeId);
                $('html, body').animate({
                    scrollTop: $diffBox.offset().top - 50
                }, 300);
            }, 0, false);
        };

        // $scope.amendments_crs holds the change objects of all change recommendations regarding the text,
        // and all amendments with a "accepted"-recommendation, ordered by the first affected line number.
        obj.set_amendments_crs_watcher = function($scope, motion) {
            $scope.amendments_crs = [];
            $scope.change_recommendations = [];
            $scope.paragraph_amendments = [];
            $scope.has_proposed_changes = false;
            $scope.changed_version_has_collissions = false;

            var rebuild_amendments_crs = function () {
                $scope.amendments_crs = $scope.change_recommendations.map(function (cr) {
                    return cr.getUnifiedChangeObject();
                }).concat(
                    $scope.paragraph_amendments.map(function (amendment) {
                        return amendment.getUnifiedChangeObject();
                    })
                );
                $scope.amendments_crs.sort(function (change1, change2) {
                    if (change1.line_from > change2.line_from) {
                        return 1;
                    } else if (change1.line_from < change2.line_from) {
                        return -1;
                    } else {
                        return 0;
                    }
                });

                // Set all crs and amendments for collission detection.
                _.forEach($scope.amendments_crs, function (change) {
                    change.setOtherChangesForCollission($scope.amendments_crs);
                });

                $scope.has_proposed_changes = ($scope.amendments_crs.length > 0);
                $scope.changed_version_has_accepted_collissions = ($scope.amendments_crs.find(function(change) {
                    return (change.getCollissions(true).length !== 0);
                }) !== undefined);

                if (obj.context === 'site') {
                    if (!$scope.has_proposed_changes) {
                        $scope.setProjectionMode($scope.projectionModes[0]);
                    }
                    if ($scope.has_proposed_changes) {
                        $scope.disableMotionInlineEditing();
                    }
                }
            };

            $scope.$watch(function () {
                return MotionChangeRecommendation.lastModified();
            }, function () {
                $scope.change_recommendations = [];
                $scope.title_change_recommendation = null;
                MotionChangeRecommendation.filter({
                    'where': {'motion_version_id': {'==': motion.active_version}}
                }).forEach(function (change) {
                    if (change.isTextRecommendation()) {
                        $scope.change_recommendations.push(change);
                    }
                    if (change.isTitleRecommendation()) {
                        $scope.title_change_recommendation = change;
                    }
                });
                rebuild_amendments_crs();
            });

            $scope.$watch(function () {
                return Motion.lastModified();
            }, function () {
                if (motion) {
                    $scope.paragraph_amendments = motion.getParagraphBasedAmendmentsForDiffView();
                    rebuild_amendments_crs();
                }
            });
        };

        obj.setVersion = function (_motion/*, _version*/) {
            motion = _motion;
        };

        obj.initProjector = function (_scope, _motion, viewMode) {
            obj.context = 'projector';
            $scope = _scope;
            motion = _motion;

            obj.set_amendments_crs_watcher($scope, motion);
            obj.mode = viewMode;
        };

        obj.initSite = function (_scope, _motion, viewMode) {
            obj.context = 'site';
            $scope = _scope;
            motion = _motion;

            obj.set_amendments_crs_watcher($scope, motion);

            $scope.$evalAsync(function() {
                obj.repositionOriginalAnnotations();
            });
            $scope.$watch(function() {
                return $('.change-recommendation-list').children().length;
            }, obj.repositionOriginalAnnotations);

            var checkGotoOriginal = function () {
                if ($scope.amendments_crs.length === 0 && $scope.title_change_recommendation === null) {
                    obj.mode = 'original';
                }
            };
            $scope.$watch(function () {
                return $scope.amendments_crs.length;
            }, checkGotoOriginal);
            $scope.$watch(function () {
                return $scope.title_change_recommendation;
            }, checkGotoOriginal);

            var sizeCheckerLastSize = null,
                sizeCheckerLastClass = null,
                sizeChecker = $interval(function() {
                    var $holder = $(".motion-text-original"),
                        newHeight = $holder.height(),
                        classes = $holder.attr("class");
                    if (newHeight !== sizeCheckerLastSize || sizeCheckerLastClass !== classes) {
                        sizeCheckerLastSize = newHeight;
                        sizeCheckerLastClass = classes;
                        obj.repositionOriginalAnnotations();
                    }
                }, 100, 0, false);

            $scope.$on('$destroy', function() {
                $interval.cancel(sizeChecker);
            });

            obj.mode = viewMode;
        };

        return obj;
    }
]);

}());

(function () {

"use strict";

angular.module('OpenSlidesApp.motions.pdf', ['OpenSlidesApp.core.pdf'])

.factory('MotionContentProvider', [
    '$q',
    '$filter',
    'operator',
    'gettextCatalog',
    'PDFLayout',
    'PdfMakeConverter',
    'ImageConverter',
    'HTMLValidizer',
    'Category',
    'Config',
    'Motion',
    'MotionComment',
    'MotionPollDecimalPlaces',
    'OpenSlidesSettings',
    function($q, $filter, operator, gettextCatalog, PDFLayout, PdfMakeConverter, ImageConverter,
        HTMLValidizer, Category, Config, Motion, MotionComment, MotionPollDecimalPlaces, OpenSlidesSettings) {
        /**
         * Provides the content as JS objects for Motions in pdfMake context
         * @constructor
         */

        var createInstance = function(motion, motionVersion, params) {
            params = _.clone(params || {}); // Clone this to avoid sideeffects.
            _.defaults(params, {
                changeRecommendationMode: Config.get('motions_recommendation_text_mode').value,
                lineNumberMode: Config.get('motions_default_line_numbering').value,
                include: {
                    text: true,
                    reason: true,
                    state: true,
                    category: true,
                    submitters: true,
                    votingresult: true,
                    motionBlock: true,
                    origin: true,
                    recommendation: true,
                },
                includeComments: {},
            });

            var converter, imageMap = {};

            // Query all image sources from motion text and reason
            var getImageSources = function () {
                var text = motion.getTextByMode(params.changeRecommendationMode, null);
                var reason = motion.getReason();
                var comments = '';
                _.forEach(params.includeComments, function (ok, id) {
                    if (ok && motion.comments[id]) {
                        comments += HTMLValidizer.validize(motion.comments[id]);
                    }
                });
                var content = HTMLValidizer.validize(text) + HTMLValidizer.validize(motion.getReason()) + comments;
                var map = Function.prototype.call.bind([].map);
                return map($(content).find('img'), function(element) {
                    return element.getAttribute('src');
                });
            };

            // title
            var identifier = motion.identifier ? ' ' + motion.identifier : '';
            var titlePlain = motion.getTitleWithChanges(params.changeRecommendationMode, motionVersion);
            var title = PDFLayout.createTitle(gettextCatalog.getString('Motion') + identifier + ': ' + titlePlain);

            // subtitle and sequential number
            var subtitleLines = [];
            if (motion.parent_id) {
                var parentMotion = Motion.get(motion.parent_id);
                subtitleLines.push(
                    gettextCatalog.getString('Amendment to motion') + ': ' +
                    (parentMotion.identifier ? parentMotion.identifier : parentMotion.getTitle())
                );
            }
            if (Config.get('motions_export_sequential_number').value) {
                subtitleLines.push(gettextCatalog.getString('Sequential number') + ': ' +
                    motion.getSequentialNumber());
            }
            var subtitle = PDFLayout.createSubtitle(subtitleLines);

            // meta data table
            var metaTable = function() {
                var metaTableBody = [];

                // submitters
                var submitters = _.map(
                    $filter('orderBy')(motion.submitters, 'weight'), function (submitter) {
                        return submitter.user.get_full_name();
                    }
                ).join(', ');
                if (params.include.submitters) {
                    metaTableBody.push([
                        {
                            text: gettextCatalog.getString('Submitters') + ':',
                            style: ['bold', 'grey'],
                        },
                        {
                            text: submitters,
                            style: 'grey'
                        }
                    ]);
                }

                // state
                if (params.include.state) {
                    metaTableBody.push([
                        {
                            text: gettextCatalog.getString('State') + ':',
                            style: ['bold', 'grey']
                        },
                        {
                            text: motion.getStateName(),
                            style: 'grey'
                        }
                    ]);
                }

                // recommendation
                if (params.include.recommendation && motion.getRecommendationName()) {
                    metaTableBody.push([
                        {
                            text: Config.get('motions_recommendations_by').value + ':',
                            style: ['bold', 'grey']
                        },
                        {
                            text: motion.getRecommendationName(),
                            style: 'grey'
                        }
                    ]);
                }

                // category
                if (params.include.category && motion.category) {
                    metaTableBody.push([
                        {
                            text: gettextCatalog.getString('Category') + ':',
                            style: ['bold', 'grey'] },
                        {
                            text: motion.category.prefix + ' - ' + motion.category.name,
                            style: 'grey'
                        }
                    ]);
                }

                // motion block
                if (params.include.motionBlock && motion.motionBlock) {
                    metaTableBody.push([
                        {
                            text: gettextCatalog.getString('Motion block') + ':',
                            style: ['bold', 'grey'] },
                        {
                            text: motion.motionBlock.title,
                            style: 'grey'
                        }
                    ]);
                }

                // origin
                if (params.include.origin && motion.origin) {
                    metaTableBody.push([
                        {
                            text: gettextCatalog.getString('Origin') + ':',
                            style: ['bold', 'grey'] },
                        {
                            text: motion.origin,
                            style: 'grey'
                        }
                    ]);
                }

                // voting result
                if (params.include.votingresult && motion.polls.length > 0 && motion.polls[0].has_votes) {
                    var column1 = [];
                    var column2 = [];
                    var column3 = [];
                    motion.polls.map(function(poll, index) {
                        if (poll.has_votes) {
                            // votenumber
                            if (motion.polls.length > 1) {
                                column1.push(index + 1 + '. ' + gettextCatalog.getString('Vote'));
                                column2.push('');
                                column3.push('');
                            }
                            var precision = MotionPollDecimalPlaces.getPlaces(poll);
                            // yes
                            var yes = poll.getVote(poll.yes, 'yes');
                            column1.push(gettextCatalog.getString('Yes') + ':');
                            column2.push($filter('number')(yes.value, precision));
                            column3.push(yes.percentStr);
                            // no
                            var no = poll.getVote(poll.no, 'no');
                            column1.push(gettextCatalog.getString('No') + ':');
                            column2.push($filter('number')(no.value, precision));
                            column3.push(no.percentStr);
                            // abstain
                            var abstain = poll.getVote(poll.abstain, 'abstain');
                            column1.push(gettextCatalog.getString('Abstain') + ':');
                            column2.push($filter('number')(abstain.value, precision));
                            column3.push(abstain.percentStr);
                            // votes valid
                            if (poll.votesvalid) {
                                var valid = poll.getVote(poll.votesvalid, 'votesvalid');
                                column1.push(gettextCatalog.getString('Valid votes') + ':');
                                column2.push($filter('number')(valid.value, precision));
                                column3.push(valid.percentStr);
                            }
                            // votes invalid
                            if (poll.votesvalid) {
                                var invalid = poll.getVote(poll.votesinvalid, 'votesinvalid');
                                column1.push(gettextCatalog.getString('Invalid votes') + ':');
                                column2.push($filter('number')(invalid.value, precision));
                                column3.push(invalid.percentStr);
                            }
                            // votes cast
                            if (poll.votescast) {
                                var cast = poll.getVote(poll.votescast, 'votescast');
                                column1.push(gettextCatalog.getString('Votes cast') + ':');
                                column2.push($filter('number')(cast.value, precision));
                                column3.push(cast.percentStr);
                            }
                        }
                    });
                    metaTableBody.push([
                        {
                            text: gettextCatalog.getString('Voting result') + ':',
                            style: ['bold', 'grey']
                        },
                        {
                            columns: [
                                {
                                    text: column1.join('\n'),
                                    width: 'auto'
                                },
                                {
                                    text: column2.join('\n'),
                                    width: 'auto',
                                    alignment: 'right'
                                },
                                {
                                    text: column3.join('\n'),
                                    width: 'auto',
                                    alignment: 'right'
                                },
                            ],
                            columnGap: 7,
                            style: 'grey'
                        }
                    ]);
                }

                // summary of change recommendations (for motion diff version only)
                if (params.changeRecommendationMode === 'diff' && motion.changeRecommendations.length) {
                    var columnLineNumbers = [];
                    var columnChangeType = [];
                    angular.forEach(_.orderBy(motion.changeRecommendations, ['line_from']), function(change) {
                        if (change.isTitleRecommendation()) {
                            columnLineNumbers.push(
                                gettextCatalog.getString('Title') + ': '
                            );
                        } else {
                            // line numbers column
                            var line;
                            if (change.line_from >= change.line_to - 1) {
                                line = change.line_from;
                            } else {
                                line = change.line_from + ' - ' + (change.line_to - 1);
                            }
                            columnLineNumbers.push(
                                gettextCatalog.getString('Line') + ' ' + line + ': '
                            );
                        }
                        // change type column
                        if (change.getType(motion.getVersion(motionVersion).text) === 0) {
                            columnChangeType.push(gettextCatalog.getString("Replacement"));
                        } else if (change.getType(motion.getVersion(motionVersion).text) === 1) {
                            columnChangeType.push(gettextCatalog.getString("Insertion"));
                        } else if (change.getType(motion.getVersion(motionVersion).text) === 2) {
                            columnChangeType.push(gettextCatalog.getString("Deletion"));
                        } else if (change.getType(motion.getVersion(motionVersion).text) === 3) {
                            columnChangeType.push(change.other_description);
                        }
                    });
                    metaTableBody.push([
                        {
                            text: gettextCatalog.getString('Summary of change recommendations'),
                            style: ['bold', 'grey']
                        },
                        {
                            columns: [
                                {
                                    text: columnLineNumbers.join('\n'),
                                    width: 'auto'
                                },
                                {
                                    text: columnChangeType.join('\n'),
                                    width: 'auto'
                                }
                            ],
                            columnGap: 7,
                            style: 'grey'
                        }
                    ]);
                }

                if (metaTableBody.length) {
                    // build table
                    // Used placeholder for 'layout' functions whiche are
                    // replaced by lineWitdh/lineColor function in pfd-worker.js.
                    // TODO: Remove placeholder and us static values for LineWidth and LineColor
                    // if pdfmake has fixed this.
                    var metaTable = {
                        table: {
                            widths: ['35%','65%'],
                            body: metaTableBody,
                        },
                        margin: [0, 0, 0, 20],
                        layout: '{{motion-placeholder-to-insert-functions-here}}'
                    };
                    params.include.metatable = true;
                    return metaTable;
                } else {
                    return {};
                }
            };

            // motion title
            var motionTitle = function() {
                if (params.include.metatable && params.include.text && !motion.isParagraphBasedAmendment()) {
                    return [{
                        text: titlePlain,
                        style: 'heading3'
                    }];
                } else {
                    return {};
                }
            };

            // motion preamble
            var motionPreamble = function () {
                return {
                    text: Config.translate(Config.get('motions_preamble').value),
                    margin: [0, 10, 0, 0]
                };
            };

            var escapeHtml = function(text) {
                return text.replace(/&/, '&amp;').replace(/</, '&lt;').replace(/>/, '&gt;');
            };

            // motion text (with line-numbers)
            var motionText = function() {
                var content = [];
                if (params.include.text) {
                    var motionTextContent = '';
                    if (motion.isParagraphBasedAmendment()) {
                        // paragraph based amendment
                        var diffs = motion.getAmendmentParagraphsLinesDiff();
                        if (diffs.length) {
                            content.push(motionPreamble());
                            _.forEach(diffs, function (diff) {
                                motionTextContent += diff.textPre + diff.text + diff.textPost;
                            });
                        } else {
                            motionTextContent += gettextCatalog.getString('No changes at the text.');
                        }
                    } else {
                        // lead motion or normal amendment
                        content.push(motionPreamble());
                        var titleChange = motion.getTitleChangeRecommendation();
                        if (params.changeRecommendationMode === 'diff' && titleChange) {
                            motionTextContent += '<p><strong>' + gettextCatalog.getString('New title') + ':</strong> ' +
                                escapeHtml(titleChange.text) + '</p>';
                        }
                        motionTextContent += motion.getTextByMode(params.changeRecommendationMode, motionVersion);
                    }
                    content.push(converter.convertHTML(motionTextContent, params.lineNumberMode));
                }
                return content;
            };

            // motion reason heading
            var motionReason = function() {
                if (params.include.reason) {
                    var reason = [];
                    if (motion.getReason(motionVersion)) {
                        reason.push({
                            text:  gettextCatalog.getString('Reason'),
                            style: 'heading3',
                            marginTop: 25,
                        });
                        var width;
                        if (params.lineNumberMode == 'outside') {
                            width = '80%';
                        } else {
                            width = '100%';
                        }
                        reason.push({
                            columns: [
                                {
                                    width: width,
                                    stack: converter.convertHTML(motion.getReason(motionVersion), 'none'),
                                },
                            ]
                        });
                    }
                    return reason;
                }
            };

            // motion comments handling
            var motionComments = function () {
                if (_.keys(params.includeComments).length !== 0) {
                    var fields = MotionComment.getNoSpecialCommentsFields();
                    var comments = [];
                    _.forEach(params.includeComments, function (ok, id) {
                        if (ok && motion.comments[id]) {
                            var title = fields[id].name;
                            if (!fields[id].public) {
                                title += ' (' + gettextCatalog.getString('internal') + ')';
                            }
                            comments.push({
                                text: title,
                                style: 'heading3',
                                marginTop: 25,
                            });
                            comments.push(converter.convertHTML(motion.comments[id]));
                        }
                    });
                    return comments;
                }
            };

            // Generates content as a pdfmake consumable
            var getContent = function() {
                var content = [
                    title,
                    subtitle,
                    metaTable(),
                    motionTitle()
                ];
                content = content.concat(motionText());

                var reason = motionReason();
                if (reason) {
                    content.push(reason);
                }
                var comments = motionComments();
                if (comments) {
                    content.push(comments);
                }
                return content;
            };

            // getters
            var getTitle = function() {
                return motion.getTitle(motionVersion);
            };

            var getIdentifier = function() {
                return motion.identifier ? motion.identifier : '';
            };

            var getId = function() {
                return motion.id;
            };

            var getCategory = function() {
                return motion.category;
            };

            var getImageMap = function() {
                return imageMap;
            };

            return $q(function (resolve, reject) {
                ImageConverter.toBase64(getImageSources()).then(function (_imageMap) {
                    imageMap = _imageMap;
                    converter = PdfMakeConverter.createInstance(_imageMap);
                    resolve({
                        getContent: getContent,
                        getTitle: getTitle,
                        getIdentifier: getIdentifier,
                        getId: getId,
                        getCategory: getCategory,
                        getImageMap: getImageMap,
                    });
                }, reject);
            });
        };

        return {
            createInstance: createInstance
        };
    }
])

.factory('MotionPartialContentProvider', [
    '$q',
    'gettextCatalog',
    'Config',
    'PDFLayout',
    'PdfMakeConverter',
    'ImageConverter',
    'HTMLValidizer',
    function ($q, gettextCatalog, Config, PDFLayout, PdfMakeConverter, ImageConverter, HTMLValidizer) {
        /*
         * content should be an array of content blocks. Each content is an object providing a
         * heading and a text. E.g.
         * [{heading: 'comment1', text: '<html in here>'}, {heading: ...}, ...]
         * */
        var createInstance = function (motion, content) {

            var converter, imageMap = {};

            // Query all image sources from the content
            var getImageSources = function () {
                var imageSources = [];
                _.forEach(content, function (contentBlock) {
                    var html = HTMLValidizer.validize(contentBlock.text);
                    imageSources = imageSources.concat(_.map($(html).find('img'), function(element) {
                        return element.getAttribute('src');
                    }));
                });
                return imageSources;
            };

            // title
            var identifier = motion.identifier ? ' ' + motion.identifier : '';
            var title = PDFLayout.createTitle(
                    gettextCatalog.getString('Motion') + identifier + ': ' + motion.getTitle()
            );

            // subtitle and sequential number
            var subtitleLines = [];
            if (motion.parent_id) {
                var parentMotion = Motion.get(motion.parent_id);
                subtitleLines.push(
                    gettextCatalog.getString('Amendment to motion') + ': ' +
                    (parentMotion.identifier ? parentMotion.identifier : parentMotion.getTitle())
                );
            }
            if (Config.get('motions_export_sequential_number').value) {
                subtitleLines.push(gettextCatalog.getString('Sequential number') + ': ' +  motion.id);
            }
            var subtitle = PDFLayout.createSubtitle(subtitleLines);

            // meta data table
            var metaTable = function() {
                var metaTableBody = [];

                // submitters
                var submitters = _.map(motion.submitters, function (submitter) {
                    return submitter.user.get_full_name();
                }).join(', ');
                metaTableBody.push([
                    {
                        text: gettextCatalog.getString('Submitters') + ':',
                        style: ['bold', 'grey'],
                    },
                    {
                        text: submitters,
                        style: 'grey'
                    }
                ]);

                // state
                metaTableBody.push([
                    {
                        text: gettextCatalog.getString('State') + ':',
                        style: ['bold', 'grey']
                    },
                    {
                        text: motion.getStateName(),
                        style: 'grey'
                    }
                ]);

                // recommendation
                if (motion.getRecommendationName()) {
                    metaTableBody.push([
                        {
                            text: Config.get('motions_recommendations_by').value + ':',
                            style: ['bold', 'grey']
                        },
                        {
                            text: motion.getRecommendationName(),
                            style: 'grey'
                        }
                    ]);
                }

                // category
                if (motion.category) {
                    metaTableBody.push([
                        {
                            text: gettextCatalog.getString('Category') + ':',
                            style: ['bold', 'grey'] },
                        {
                            text: motion.category.prefix + ' - ' + motion.category.name,
                            style: 'grey'
                        }
                    ]);
                }

                // build table
                // Used placeholder for 'layout' functions whiche are
                // replaced by lineWitdh/lineColor function in pfd-worker.js.
                // TODO: Remove placeholder and us static values for LineWidth and LineColor
                // if pdfmake has fixed this.
                var metaTableJsonString = {
                    table: {
                        widths: ['30%','70%'],
                        body: metaTableBody,
                    },
                    margin: [0, 0, 0, 20],
                    layout: '{{motion-placeholder-to-insert-functions-here}}'
                };
                return metaTableJsonString;
            };

            var getContentBlockData = function (block) {
                var data = [];
                data.push({
                    text:  block.heading,
                    style: 'heading3',
                    marginTop: 25,
                });
                data.push(converter.convertHTML(block.text));
                return data;
            };

            // Generates content as a pdfmake consumable
            var getContent = function() {
                var pdfContent = [
                    title,
                    subtitle,
                    metaTable(),
                ];
                _.forEach(content, function (contentBlock) {
                    pdfContent.push(getContentBlockData(contentBlock));
                });
                return pdfContent;
            };

            var getImageMap = function () {
                return imageMap;
            };

            return $q(function (resolve, reject) {
                ImageConverter.toBase64(getImageSources()).then(function (_imageMap) {
                    imageMap = _imageMap;
                    converter = PdfMakeConverter.createInstance(_imageMap);
                    resolve({
                        getContent: getContent,
                        getImageMap: getImageMap,
                    });
                }, reject);
            });
        };

        return {
            createInstance: createInstance
        };
    }
])

.factory('PollContentProvider', [
    '$q',
    'PDFLayout',
    'gettextCatalog',
    'Config',
    'User',
    'ImageConverter',
    function($q, PDFLayout, gettextCatalog, Config, User, ImageConverter) {
        /**
        * Generates a content provider for polls
        * @constructor
        * @param {string} title - title of poll
        * @param {string} id - if of poll
        */
        var createInstance = function(title, id) {

            var logoBallotPaperUrl = Config.get('logo_pdf_ballot_paper').value.path;
            var imageMap = {};

            // PDF header
            var header = function() {
                var columns = [];

                var text = Config.get('general_event_name').value;
                columns.push({
                    text: text,
                    fontSize: 8,
                    alignment: 'left',
                    width: '60%'
                });

                // logo
                if (logoBallotPaperUrl) {
                    columns.push({
                        image: logoBallotPaperUrl,
                        fit: [90,25],
                        alignment: 'right',
                        width: '40%'
                    });
                }
                return {
                    color: '#555',
                    fontSize: 10,
                    margin: [30, 10, 10, -10], // [left, top, right, bottom]
                    columns: columns,
                    columnGap: 5
                };
            };

            /**
            * Returns a single section on the ballot paper
            * @function
            */
            var createSection = function() {
                var sheetend = 40;
                return {
                    stack: [
                        header(),
                        {
                            text: gettextCatalog.getString('Motion') + ' ' + id,
                            style: 'title',
                        },
                        {
                            text: title,
                            style: 'description'
                        },
                        PDFLayout.createBallotEntry(gettextCatalog.getString('Yes')),
                        PDFLayout.createBallotEntry(gettextCatalog.getString('No')),
                        PDFLayout.createBallotEntry(gettextCatalog.getString('Abstain')),
                    ],
                    margin: [0, 0, 0, sheetend],
                };
            };

            /**
            * Returns Content for single motion
            * @function
            * @param {string} id - if of poll
            */
            var getContent = function() {
                var content = [];
                var amount;
                var amount_method = Config.get('motions_pdf_ballot_papers_selection').value;
                switch (amount_method) {
                        case 'NUMBER_OF_ALL_PARTICIPANTS':
                            amount = User.getAll().length;
                            break;
                        case 'NUMBER_OF_DELEGATES':
                            //TODO: assumption that DELEGATES is always group id 2. This may not be true
                            var group_id = 2;
                            amount = User.filter({where: {'groups_id': {contains:group_id} }}).length;
                            break;
                        case 'CUSTOM_NUMBER':
                            amount = Config.get('motions_pdf_ballot_papers_number').value;
                            break;
                        default:
                            // should not happen.
                            amount = 0;
                }
                var fullpages = Math.floor(amount / 8);

                for (var i=0; i < fullpages; i++) {
                    content.push({
                        table: {
                            headerRows: 1,
                            widths: ['*', '*'],
                            body: [
                                [createSection(), createSection()],
                                [createSection(), createSection()],
                                [createSection(), createSection()],
                                [createSection(), createSection()]
                            ],
                            pageBreak: 'after'
                        },
                        layout: PDFLayout.getBallotLayoutLines(),
                        rowsperpage: 4
                    });
                }
                amount = amount  - (fullpages * 8);
                if (amount > 0) {
                    var partialpagebody = [];
                    while (amount > 1) {
                        partialpagebody.push([createSection(), createSection()]);
                        amount -=2;
                    }
                    if (amount == 1) {
                        partialpagebody.push([createSection(), '']);
                    }
                    content.push({
                        table: {
                            headerRows: 1,
                            widths: ['50%', '50%'],
                            body: partialpagebody
                        },
                        layout: PDFLayout.getBallotLayoutLines(),
                        rowsperpage: 4
                    });
                }
                return content;
            };

            var getImageMap = function () {
                return imageMap;
            };

            return $q(function (resolve, reject) {
                var imageSources = [
                    logoBallotPaperUrl,
                ];
                ImageConverter.toBase64(imageSources).then(function (_imageMap) {
                    imageMap = _imageMap;
                    resolve({
                        getContent: getContent,
                        getImageMap: getImageMap,
                    });
                }, reject);
            });
        };
        return {
            createInstance: createInstance
        };
    }
])

.factory('MotionCatalogContentProvider', [
    'gettextCatalog',
    'PDFLayout',
    'Category',
    'Config',
    function(gettextCatalog, PDFLayout, Category, Config) {
        /**
        * Constructor
        * @function
        * @param {object} allMotions - A sorted array of all motions to parse
        * @param {string} sorting - The way the catalog has been sorted. Necessary for ToC
        */
        var createInstance = function(allMotions, sorting) {

            var title = PDFLayout.createTitle(
                Config.translate(Config.get('motions_export_title').value)
            );

            var createPreamble = function() {
                var preambleText = Config.get('motions_export_preamble').value;
                if (preambleText) {
                    return {
                        text: preambleText,
                        style: "preamble"
                    };
                } else {
                    return "";
                }
            };

            var createTOContent = function() {
                var toc = [];
                var exportCategory = (sorting === 'identifier' || sorting === 'category.prefix');
                var uniqueCategories = getUniqueCategories();
                var tocTitle = {
                    text: gettextCatalog.getString('Table of contents'),
                    style: 'heading2'
                };

                // all motions need a page ID. We use the motion identifier for that
                _.forEach(allMotions, function (motion) {
                    motion.getContent()[0].id = ''+motion.getId();
                });

                if (exportCategory && uniqueCategories) {
                    // own table per category
                    var catTocBody = [];
                    _.forEach(uniqueCategories, function (category) {
                        // push the name of the category
                        // make a table for correct alignment
                        catTocBody.push({
                            table: {
                                body: [
                                    [
                                        {
                                            text: category.prefix + ' - ' + category.name,
                                            style: 'tocCategoryTitle'
                                        }
                                    ],
                                ]
                            },
                            layout: 'noBorders',
                        });

                        var tocBody = [];
                        _.forEach(allMotions, function (motion) {
                            if (motion.getCategory() && category.name === motion.getCategory().name) {
                                tocBody.push(tocLine(motion, 'tocCategoryEntry'));
                            }
                        });
                        catTocBody.push(tocTable(tocBody));
                    });

                    //handle thouse without category
                    var uncatTocBody = [];
                    _.forEach(allMotions, function (motion) {
                        if (!motion.getCategory()) {
                            uncatTocBody.push(tocLine(motion, 'tocEntry'));
                        }
                    });

                    // only push this array if there is at least one entry
                    if (uncatTocBody.length > 0) {
                        catTocBody.push(tocTable(uncatTocBody));
                    }

                    toc.push(catTocBody);
                } else {
                    // all categories in the same table
                    var tocBody = [];
                    _.forEach(allMotions, function (motion) {
                        tocBody.push(tocLine(motion, 'tocEntry'));
                    });
                    toc.push(tocTable(tocBody));
                }

                return [
                    tocTitle,
                    toc,
                    PDFLayout.addPageBreak()
                ];
            };

            // creates a new table of contents table body
            var tocTable = function (tocBody) {
                return {
                    table: {
                        widths: ['auto', '*', 'auto'],
                        body: tocBody
                    },
                    layout: 'noBorders',
                    style: 'tocCategorySection'
                };
            };

            // generates a line in the toc as list-object
            var tocLine = function (motion, style) {
                var firstColumn = "";
                if (motion.getIdentifier()) {
                    firstColumn = motion.getIdentifier();
                }
                return [
                    {
                        text: firstColumn,
                        style: style
                    },
                    {
                        text: motion.getTitle(),
                        style: 'tocEntry'
                    },
                    {
                        pageReference: ''+motion.getId(),
                        style: 'tocEntry',
                        alignment: 'right'
                    },
                ];
            };

            // returns a list of unique category names
            // necessary to create a ToC with categories
            // if a motions without category is found,
            // a corresponding entry should be added aswell
            var getUniqueCategories = function() {
                var categories = [];
                _.forEach(allMotions, function (motion) {
                    if (motion.getCategory()) {
                        categories.push(
                            {
                                name: motion.getCategory().name,
                                prefix: motion.getCategory().prefix
                            }
                        );
                    }
                });
                return _.uniqBy(categories, 'name');
            };

            // returns the pure content of the motion, parseable by pdfmake
            var getContent = function() {
                var motionContent = [];
                _.forEach(allMotions, function(motion, key) {
                    motionContent.push(motion.getContent());
                    if (key < allMotions.length - 1) {
                        motionContent.push(PDFLayout.addPageBreak());
                    }
                });
                var content = [];
                // print extra data (title, preamble, categories, toc) only for more than 1 motion
                if (allMotions.length > 1) {
                    content.push(
                        title,
                        createPreamble(),
                        createTOContent()
                    );
                }
                content.push(motionContent);
                return content;
            };

            var getImageMap = function () {
                var imageMap = {};
                _.forEach(allMotions, function (motion) {
                    _.forEach(motion.getImageMap(), function (data, path) {
                        if (!imageMap[path]) {
                            imageMap[path] = data;
                        }
                    });
                });
                return imageMap;
            };

            return {
                getContent: getContent,
                getImageMap: getImageMap,
            };
        };

        return {
            createInstance: createInstance
        };
    }
])

.factory('AmendmentContentProvider', [
    '$q',
    'ImageConverter',
    'PdfMakeConverter',
    'HTMLValidizer',
    'PDFLayout',
    'Config',
    'gettextCatalog',
    function ($q, ImageConverter, PdfMakeConverter, HTMLValidizer, PDFLayout, Config, gettextCatalog) {
        var createInstance = function (motions) {
            motions = _.filter(motions, function (motion) {
                return motion.parent_id;
            });

            var converter, imageMap = {};

            // Query all image sources from motion text and reason
            var getImageSources = function () {
                var sources = [];
                _.forEach(motions, function (motion) {
                    var text = motion.getText();
                    var reason = motion.getReason();
                    var content = HTMLValidizer.validize(text) + HTMLValidizer.validize(motion.getReason());
                    _.forEach($(content).find('img'), function (element) {
                        sources.push(element.getAttribute('src'));
                    });
                });
                return _.uniq(sources);
            };

            var createBundleContent = function (bundle) {
                return _.flatten(_.map(bundle, function (motion) {
                    var content = [];

                    // get diffs and title of the changed motions
                    var motionText;
                    var title = motion.identifier ? gettextCatalog.getString('Motion') + ' ' + motion.identifier : motion.getTitle();
                    if (motion.isParagraphBasedAmendment()) {
                        // get changed parts
                        var paragraphs = motion.getAmendmentParagraphsLinesDiff();
                        if (paragraphs.length) {
                            // Put the changed lines into the info column
                            var p = paragraphs[0];
                            title += ' (' + gettextCatalog.getString('Line') + ' ';
                            if (p.diffLineTo === p.diffLineFrom + 1) {
                                title += p.diffLineFrom;
                            } else {
                                title += p.diffLineFrom + '-' + p.diffLineTo;
                            }
                            title += ')';

                            // get the diff
                            motionText = p.text;
                        } else {
                            motionText = gettextCatalog.getString('No changes at the text.');
                        }
                    } else { // 'normal' amendment
                        motionText = motion.getText();
                    }
                    content.push({
                        text: title,
                        style: 'heading3',
                        marginTop: 15,
                    });

                    // submitters
                    var submitters = _.map(motion.submitters, function (submitter) {
                        return submitter.user.get_full_name();
                    }).join(', ');
                    content.push({
                        text: gettextCatalog.getString('Submitters') + ': ' + submitters,
                    });

                    // state
                    content.push({
                        text: gettextCatalog.getString('State') + ': ' + motion.getStateName(),
                    });

                    // recommendation
                    var recommendations_by = Config.get('motions_recommendations_by').value;
                    var recommendation = motion.getRecommendationName();
                    if (recommendations_by && recommendation) {
                        content.push({
                            text: recommendations_by + ': ' + recommendation,
                        });
                    }

                    return _.concat(content, converter.convertHTML(motionText, 'outside'));
                }));
            };

            var getBundleContent = function (bundle) {
                var leadMotion = bundle[0].getParentMotion();
                // title
                var title = leadMotion.identifier ? ' ' + leadMotion.identifier : '';
                title += ': ' + leadMotion.getTitle();
                title = PDFLayout.createTitle(gettextCatalog.getString('Amendments to motion') + title);

                var content = [title],
                    foundAmendments = [];

                var headings = leadMotion.getTextHeadings().map(function(heading) {
                    heading.amendments = [];
                    return heading;
                });
                bundle.forEach(function(amendment) {
                    var headingIdx = null;
                    var changes = amendment.getAmendmentParagraphsByMode('diff');
                    if (changes.length === 0) {
                        return;
                    }
                    var amendmentLineNumber = changes[0].lineFrom;
                    for (var i = 0; i < headings.length; i++) {
                        if (headings[i].lineNumber <= amendmentLineNumber) {
                            headingIdx = i;
                        }
                    }
                    if (headingIdx !== null) {
                        headings[headingIdx].amendments.push(amendment);
                        foundAmendments.push(amendment.id);
                    }
                });

                headings.forEach(function(heading) {
                    if (heading.amendments.length === 0) {
                        return;
                    }
                    content.push({
                        text: heading.text,
                        style: "heading2",
                        marginTop: 25,
                    });
                    content = _.concat(content, createBundleContent(heading.amendments));
                });

                // If there was an amendment that did not have a heading, we append it at the bottom
                var missedAmendments = [];
                bundle.forEach(function(amendment) {
                    if (foundAmendments.indexOf(amendment.id) === -1) {
                        missedAmendments.push(amendment);
                    }
                });
                if (missedAmendments.length > 0) {
                    content = _.concat(content, createBundleContent(missedAmendments));
                }

                return content;
            };

            // Generates content as a pdfmake consumable
            var getContent = function() {
                if (motions.length === 0) {
                    return [];
                }

                // Creates bundles of motions. All motions with the same parent are bundled together
                // respecting the order, in which they are sorted.
                // motionBundles is an array containing Arrays of motions with the same parent.
                var parentId = motions[0].parent_id;
                var motionBundles = [];
                var currentBundle = [];
                _.forEach(motions, function (motion) {
                    if (motion.parent_id === parentId) {
                        currentBundle.push(motion);
                    } else {
                        motionBundles.push(currentBundle);
                        currentBundle = [motion];
                        parentId = motion.parent_id;
                    }
                });
                motionBundles.push(currentBundle);

                // Make the amendment table for each motion bundle.
                return _.map(motionBundles, function (bundle, index) {
                    var content = getBundleContent(bundle);
                    if (index < motionBundles.length - 1) {
                        content.push(PDFLayout.addPageBreak());
                    }
                    return content;
                });
            };

            var getImageMap = function() {
                return imageMap;
            };

            return $q(function (resolve) {
                ImageConverter.toBase64(getImageSources()).then(function (_imageMap) {
                    imageMap = _imageMap;
                    converter = PdfMakeConverter.createInstance(_imageMap);
                    resolve({
                        getContent: getContent,
                        getImageMap: getImageMap,
                    });
                });
            });
        };

        return {
            createInstance: createInstance,
        };
    }
])

.factory('MotionPdfExport', [
    '$http',
    '$q',
    'operator',
    'Config',
    'gettextCatalog',
    'MotionChangeRecommendation',
    'HTMLValidizer',
    'PdfMakeConverter',
    'MotionContentProvider',
    'MotionCatalogContentProvider',
    'PdfMakeDocumentProvider',
    'PollContentProvider',
    'PdfMakeBallotPaperProvider',
    'MotionPartialContentProvider',
    'AmendmentContentProvider',
    'PdfCreate',
    'PDFLayout',
    'PersonalNoteManager',
    'MotionComment',
    'Messaging',
    'FileSaver',
    function ($http, $q, operator, Config, gettextCatalog, MotionChangeRecommendation, HTMLValidizer,
        PdfMakeConverter, MotionContentProvider, MotionCatalogContentProvider, PdfMakeDocumentProvider,
        PollContentProvider, PdfMakeBallotPaperProvider, MotionPartialContentProvider, AmendmentContentProvider,
        PdfCreate, PDFLayout, PersonalNoteManager, MotionComment, Messaging, FileSaver) {
        return {
            getDocumentProvider: function (motions, params, singleMotion) {
                params = _.clone(params || {}); // Clone this to avoid sideeffects.

                if (singleMotion) {
                    _.defaults(params, {
                        version: motions.active_version,
                    });
                    motions = [motions];
                }

                //save the arrays of all motions to an array
                angular.forEach(motions, function (motion) {
                    if (singleMotion) {
                        motion.changeRecommendations = MotionChangeRecommendation.filter({
                            'where': {'motion_version_id': {'==': params.version}}
                        });
                    } else {
                        motion.changeRecommendations = MotionChangeRecommendation.filter({
                            'where': {'motion_version_id': {'==': motion.active_version}}
                        });
                    }
                });

                var motionContentProviderArray = [];
                var motionContentProviderPromises = _.map(motions, function (motion) {
                    var version = (singleMotion ? params.version : motion.active_version);
                    return $q(function (resolve, reject) {
                        MotionContentProvider.createInstance(
                            motion, version, params
                        ).then(function (contentProvider) {
                            motionContentProviderArray.push(contentProvider);
                            resolve();
                        }, reject);
                    });
                });

                return $q(function (resolve, reject) {
                    $q.all(motionContentProviderPromises).then(function() {
                        var documentProviderPromise;
                        if (singleMotion) {
                            documentProviderPromise = PdfMakeDocumentProvider.createInstance(motionContentProviderArray[0]);
                        } else {
                            var motionCatalogContentProvider = MotionCatalogContentProvider.createInstance(motionContentProviderArray, params.column);
                            documentProviderPromise = PdfMakeDocumentProvider.createInstance(motionCatalogContentProvider);
                        }
                        documentProviderPromise.then(function (documentProvider) {
                            resolve(documentProvider);
                        }, reject);
                    }, reject);
                });
            },
            export: function (motions, params, singleMotion) {
                params = params || {};
                params.filename = gettextCatalog.getString('motions') + '.pdf';
                this.getDocumentProvider(motions, params, singleMotion).then(
                    function (documentProvider) {
                        PdfCreate.download(documentProvider, params.filename);
                    }, function (error) {
                        Messaging.addMessage(error.msg, 'error');
                    }
                );
            },
            exportZip: function (motions, params) {
                var messageId = Messaging.addMessage('<i class="fa fa-spinner fa-pulse fa-lg spacer-right"></i>' +
                    gettextCatalog.getString('Generating PDFs and ZIP archive') + ' ...', 'info');
                var zipFilename = params.filename || gettextCatalog.getString('motions') + '.zip';
                params.filename = void 0; // clear this, so we do not override the default filenames for each pdf.

                var self = this;
                var usedFilenames = [];
                var docMap = {};
                var docPromises = _.map(motions, function (motion) {
                    var identifier = motion.identifier ? '-' + motion.identifier : '';
                    var filename = gettextCatalog.getString('Motion') + identifier;

                    // If the filename is already in use, try to append a number to it (like '(2)')
                    if (_.includes(usedFilenames, filename)) {
                        var i = 1;
                        var filenameWithNumber = filename;
                        while(_.includes(usedFilenames, filenameWithNumber)) {
                            filenameWithNumber = filename + ' (' + i + ')';
                            i++;
                        }
                        filename = filenameWithNumber;
                    }
                    usedFilenames.push(filename);
                    filename += '.pdf';

                    return $q(function (resolve, reject) {
                        // get documentProvider for every motion.
                        self.getDocumentProvider(motion, params, true).then(function (documentProvider) {
                            docMap[filename] = documentProvider;
                            resolve();
                        }, reject);
                    });
                });
                $q.all(docPromises).then(function () {
                    PdfCreate.getBase64FromMultipleDocuments(docMap).then(function (pdfMap) {
                        var zip = new JSZip();
                        _.forEach(pdfMap, function (data, filename) {
                            zip.file(filename, data, {base64: true});
                        });
                        Messaging.createOrEditMessage(messageId, '<i class="fa fa-check fa-lg spacer-right"></i>' +
                            gettextCatalog.getString('ZIP successfully generated.'), 'success', {timeout: 3000});
                        zip.generateAsync({type: 'blob'}).then(function (content) {
                            FileSaver.saveAs(content, zipFilename);
                        });
                    }, function (error) {
                        Messaging.createOrEditMessage(messageId, '<i class="fa fa-exclamation-triangle fa-lg ' +
                            'spacer-right"></i>' + gettextCatalog.getString('Error while generating ZIP file') +
                            ': <code>' + error + '</code>', 'error');
                    });
                }, function (error) {
                    Messaging.createOrEditMessage(messageId, error.msg, 'error');
                });
            },
            createPollPdf: function (motion, version) {
                var id = motion.identifier.replace(' ', '');
                var title = motion.getTitle(version);
                var filename = gettextCatalog.getString('Motion') + '-' + id + '-' + gettextCatalog.getString('ballot-paper') + '.pdf';
                PollContentProvider.createInstance(title, id).then(function (pollContentProvider) {
                    var documentProvider = PdfMakeBallotPaperProvider.createInstance(pollContentProvider);
                    PdfCreate.download(documentProvider, filename);
                }, function (error) {
                    Messaging.addMessage(error.msg, 'error');
                });
            },
            exportPersonalNote: function (motion, filename) {
                var personalNote = PersonalNoteManager.getNote(motion);
                var content = [{
                    heading: gettextCatalog.getString('Personal note'),
                    text: personalNote ? personalNote.note : '',
                }];
                MotionPartialContentProvider.createInstance(motion, content).then(function (contentProvider) {
                    PdfMakeDocumentProvider.createInstance(contentProvider).then(function (documentProvider) {
                        PdfCreate.download(documentProvider, filename);
                    }, function (error) {
                        Messaging.addMessage(error.msg, 'error');
                    });
                }, function (error) {
                    Messaging.addMessage(error.msg, 'error');
                });
            },
            exportComment: function (motion, commentId, filename) {
                var field = MotionComment.getNoSpecialCommentsFields()[commentId];
                if (field && motion.comments[commentId]) {
                    var title = field.name;
                    if (!field.public) {
                        title += ' (' + gettextCatalog.getString('internal') + ')';
                    }
                    var content = [{
                        heading: title,
                        text: motion.comments[commentId],
                    }];
                    MotionPartialContentProvider.createInstance(motion, content).then(function (contentProvider) {
                        PdfMakeDocumentProvider.createInstance(contentProvider).then(function (documentProvider) {
                            PdfCreate.download(documentProvider, filename);
                        }, function (error) {
                            Messaging.addMessage(error.msg, 'error');
                        });
                    }, function (error) {
                        Messaging.addMessage(error.msg, 'error');
                    });
                }
            },
            exportAmendments: function (motions, filename) {
                AmendmentContentProvider.createInstance(motions).then(function (contentProvider) {
                    PdfMakeDocumentProvider.createInstance(contentProvider).then(function (documentProvider) {
                        PdfCreate.download(documentProvider, filename);
                    });
                });
            },
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.motions.projector', [
    'OpenSlidesApp.motions',
    'OpenSlidesApp.motions.motionservices',
    'OpenSlidesApp.motions.motionBlockProjector',
])

.config([
    'slidesProvider',
    function(slidesProvider) {
        slidesProvider.registerSlide('motions/motion', {
            template: 'static/templates/motions/slide_motion.html',
        });
    }
])

.controller('SlideMotionCtrl', [
    '$scope',
    '$timeout',
    'Config',
    'Motion',
    'MotionChangeRecommendation',
    'ChangeRecommendationView',
    'User',
    'Notify',
    'ProjectorID',
    'MotionPollDecimalPlaces',
    function($scope, $timeout, Config, Motion, MotionChangeRecommendation,
        ChangeRecommendationView, User, Notify, ProjectorID, MotionPollDecimalPlaces) {
        // Attention! Each object that is used here has to be dealt on server side.
        // Add it to the coresponding get_requirements method of the ProjectorElement
        // class.
        var motionId = $scope.element.id;
        $scope.mode = $scope.element.mode || 'original';
        $scope.lineNumberMode = Config.get('motions_default_line_numbering').value;

        var notifyNamePrefix = 'projector_' + ProjectorID() + '_motion_line_';
        var callbackId = Notify.registerCallback(notifyNamePrefix + 'request', function (params) {
            var line = params.params.line;
            if (!line) {
                return;
            }
            $scope.highlight = line;
            $timeout(function () {
                $scope.highlight = 0;
            }, 4000);

            var scrollTop = null;
            $('.line-number-' + line).each(function() {
                var top = $(this).offset().top;
                if (scrollTop === null || top < scrollTop) {
                    scrollTop = top;
                }
            });
            if (scrollTop) {
                scrollTop += (-$scope.scroll); // Add the (reversed) scrolling ontop
                var scroll = Math.floor((scrollTop/250) - 0.2);
                var channel = params.senderReplyChannelName;
                Notify.notify(notifyNamePrefix + 'answer', {scroll: scroll}, null, [channel], null);
            }
        });
        $scope.$on('$destroy', function () {
            Notify.deregisterCallback(callbackId);
        });

        User.bindAll({}, $scope, 'users');

        $scope.$watch(function () {
            return Motion.lastModified(motionId);
        }, function () {
            $scope.motion = Motion.get(motionId);
            $scope.amendment_diff_paragraphs = $scope.motion.getAmendmentParagraphsLinesDiff();
            $scope.viewChangeRecommendations.setVersion($scope.motion, $scope.motion.active_version);
            _.forEach($scope.motion.polls, function (poll) {
                MotionPollDecimalPlaces.getPlaces(poll, true).then(function (decimalPlaces) {
                    precisionCache[poll.id] = decimalPlaces;
                });
            });
        });

        var precisionCache = {};
        $scope.getPollVotesPrecision = function (poll) {
            if (!precisionCache[poll.id]) {
                return 0;
            }
            return precisionCache[poll.id];
        };

        // Change recommendation viewing
        $scope.viewChangeRecommendations = ChangeRecommendationView;
        $scope.viewChangeRecommendations.initProjector($scope, Motion.get(motionId), $scope.mode);
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.motions.site', [
    'OpenSlidesApp.motions',
    'OpenSlidesApp.motions.motionservices',
    'OpenSlidesApp.poll.majority',
    'OpenSlidesApp.core.pdf',
    'OpenSlidesApp.motions.docx',
    'OpenSlidesApp.motions.pdf',
    'OpenSlidesApp.motions.csv',
    'OpenSlidesApp.motions.workflow',
])

.config([
    'mainMenuProvider',
    'gettext',
    function (mainMenuProvider, gettext) {
        mainMenuProvider.register({
            'ui_sref': 'motions.motion.list',
            'img_class': 'file-text',
            'title': gettext('Motions'),
            'weight': 300,
            'perm': 'motions.can_see',
        });
    }
])

.config([
    'SearchProvider',
    'gettext',
    function (SearchProvider, gettext) {
        SearchProvider.register({
            'verboseName': gettext('Motions'),
            'collectionName': 'motions/motion',
            'urlDetailState': 'motions.motion.detail',
            'weight': 300,
        });
    }
])

.config([
    '$stateProvider',
    'gettext',
    function($stateProvider, gettext) {
        $stateProvider
            .state('motions', {
                url: '/motions',
                abstract: true,
                template: "<ui-view/>",
                data: {
                    title: gettext('Motions'),
                    basePerm: 'motions.can_see',
                },
            })
            .state('motions.motion', {
                abstract: true,
                template: "<ui-view/>",
            })
            .state('motions.motion.list', {})
            .state('motions.motion.detail', {
                resolve: {
                    motionId: ['$stateParams', function($stateParams) {
                        return $stateParams.id;
                    }],
                }
            })
            // redirects to motion detail and opens motion edit form dialog, uses edit url,
            // used by ui-sref links from agenda only
            // (from motion controller use MotionForm factory instead to open dialog in front of
            // current view without redirect)
            .state('motions.motion.detail.update', {
                onEnter: ['$stateParams', '$state', 'ngDialog', 'Motion',
                    function($stateParams, $state, ngDialog, Motion) {
                        ngDialog.open({
                            template: 'static/templates/motions/motion-form.html',
                            controller: 'MotionUpdateCtrl',
                            className: 'ngdialog-theme-default wide-form',
                            closeByEscape: false,
                            closeByDocument: false,
                            resolve: {
                                motionId: function () {return $stateParams.id;},
                            },
                            preCloseCallback: function () {
                                $state.go('motions.motion.detail', {motion: $stateParams.id});
                                return true;
                            }
                        });
                    }
                ]
            })
            .state('motions.motion.submitters', {
                url: '/submitters/{id:int}',
                controller: 'MotionSubmitterCtrl',
                resolve: {
                    motionId: ['$stateParams', function($stateParams) {
                        return $stateParams.id;
                    }],
                },
                data: {
                    title: gettext('Submitters'),
                    basePerm: 'motions.can_manage',
                },
            })
            .state('motions.motion.amendment-list', {
                url: '/{id:int}/amendments',
                controller: 'MotionAmendmentListStateCtrl',
                params: {
                    motionId: null,
                },
                resolve: {
                    motionId: ['$stateParams', function($stateParams) {
                        return $stateParams.id;
                    }],
                }
            })
            .state('motions.motion.allamendments', {
                url: '/amendments',
                templateUrl: 'static/templates/motions/motion-amendment-list.html',
                controller: 'MotionAmendmentListStateCtrl',
                resolve: {
                    motionId: function() { return void 0; },
                }
            })
            .state('motions.motion.import', {
                url: '/import',
                controller: 'MotionImportCtrl',
            })
            // categories
            .state('motions.category', {
                url: '/category',
                abstract: true,
                template: "<ui-view/>",
                data: {
                    title: gettext('Categories'),
                },
            })
            .state('motions.category.list', {})
            .state('motions.category.sort', {
                url: '/sort/{id}',
                controller: 'CategorySortCtrl',
                templateUrl: 'static/templates/motions/category-sort.html',
                resolve: {
                    categoryId: ['$stateParams', function($stateParams) {
                        return $stateParams.id;
                    }],
                },
            })
            // MotionBlock
            .state('motions.motionBlock', {
                url: '/blocks',
                abstract: true,
                template: '<ui-view/>',
                data: {
                    title: gettext('Motion blocks'),
                },
            })
            .state('motions.motionBlock.list', {})
            .state('motions.motionBlock.detail', {
                resolve: {
                    motionBlockId: ['$stateParams', function($stateParams) {
                        return $stateParams.id;
                    }],
                }
            })
            // redirects to motionBlock detail and opens motionBlock edit form dialog, uses edit url,
            // used by ui-sref links from agenda only
            // (from motionBlock controller use MotionBlockForm factory instead to open dialog in front
            // of current view without redirect)
            .state('motions.motionBlock.detail.update', {
                onEnter: ['$stateParams', '$state', 'ngDialog',
                    function($stateParams, $state, ngDialog) {
                        ngDialog.open({
                            template: 'static/templates/motions/motion-block-form.html',
                            controller: 'MotionBlockUpdateCtrl',
                            className: 'ngdialog-theme-default wide-form',
                            closeByEscape: false,
                            closeByDocument: false,
                            resolve: {
                                motionBlockId: function () {
                                    return $stateParams.id;
                                }
                            },
                            preCloseCallback: function() {
                                $state.go('motions.motionBlock.detail', {motionBlock: $stateParams.id});
                                return true;
                            }
                        });
                    }
                ],
            })
            // Workflows and states
            .state('motions.workflow', {
                url: '/workflow',
                abstract: true,
                template: '<ui-view/>',
                data: {
                    title: gettext('Workflows'),
                    basePerm: 'motions.can_manage',
                },
            })
            .state('motions.workflow.list', {})
            .state('motions.workflow.detail', {
                resolve: {
                    workflowId: ['$stateParams', function($stateParams) {
                        return $stateParams.id;
                    }],
                }
            });
    }
])

.factory('ChangeRecommendationTitleForm', [
    'gettextCatalog',
    'Editor',
    'Config',
    function(gettextCatalog) {
        return {
            // ngDialog for motion form
            getCreateDialog: function (motion, version) {
                return {
                    template: 'static/templates/motions/change-recommendation-form.html',
                    controller: 'ChangeRecommendationTitleCreateCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        motion: function() {
                            return motion;
                        },
                        version: function() {
                            return version;
                        }
                    }
                };
            },
            getEditDialog: function(change) {
                return {
                    template: 'static/templates/motions/change-recommendation-form.html',
                    controller: 'ChangeRecommendationTitleUpdateCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        change: function() {
                            return change;
                        }
                    }
                };
            },
            // angular-formly fields for motion form
            getFormFields: function () {
                return [
                    {
                        key: 'identifier',
                        type: 'input',
                        templateOptions: {
                            label: gettextCatalog.getString('Identifier')
                        },
                        hide: true
                    },
                    {
                        key: 'motion_version_id',
                        type: 'input',
                        templateOptions: {
                            label: gettextCatalog.getString('Motion')
                        },
                        hide: true
                    },
                    {
                        key: 'text',
                        type: 'input',
                        templateOptions: {
                            label: gettextCatalog.getString('New title'),
                            required: false
                        }
                    }
                ];
            }
        };
    }
])

.factory('ChangeRecommendationTextForm', [
    'gettextCatalog',
    'Editor',
    'Config',
    function(gettextCatalog, Editor) {
        return {
            // ngDialog for motion form
            getCreateDialog: function (motion, version, lineFrom, lineTo) {
                return {
                    template: 'static/templates/motions/change-recommendation-form.html',
                    controller: 'ChangeRecommendationTextCreateCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        motion: function() {
                            return motion;
                        },
                        version: function() {
                            return version;
                        },
                        lineFrom: function() {
                            return lineFrom;
                        },
                        lineTo: function() {
                            return lineTo;
                        }
                    }
                };
            },
            getEditDialog: function(change) {
                return {
                    template: 'static/templates/motions/change-recommendation-form.html',
                    controller: 'ChangeRecommendationTextUpdateCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        change: function() {
                            return change;
                        }
                    }
                };
            },
            // angular-formly fields for motion form
            getFormFields: function (line_from, line_to) {
                return [
                    {
                        key: 'identifier',
                        type: 'input',
                        templateOptions: {
                            label: gettextCatalog.getString('Identifier')
                        },
                        hide: true
                    },
                    {
                        key: 'motion_version_id',
                        type: 'input',
                        templateOptions: {
                            label: gettextCatalog.getString('Motion')
                        },
                        hide: true
                    },
                    {
                        key: 'line_from',
                        type: 'input',
                        templateOptions: {
                            label: gettextCatalog.getString('From Line')
                        },
                        hide: true
                    },
                    {
                        key: 'line_to',
                        type: 'input',
                        templateOptions: {
                            label: gettextCatalog.getString('To Line')
                        },
                        hide: true
                    },
                    {
                        key: 'type',
                        type: 'radio-buttons',
                        templateOptions: {
                            label: 'Type',
                            options: [
                                {name: gettextCatalog.getString('Replacement'), value: 0},
                                {name: gettextCatalog.getString('Insertion'), value: 1},
                                {name: gettextCatalog.getString('Deletion'), value: 2},
                                {name: gettextCatalog.getString('Other'), value: 3},
                            ]
                        }
                    },
                    {
                        key: 'other_description',
                        type: 'input',
                        templateOptions: {
                            label: gettextCatalog.getString('Description'),
                        },
                        hideExpression: "model.type !== 3",
                    },
                    {
                        key: 'text',
                        type: 'editor',
                        templateOptions: {
                            label: (
                                line_from == line_to - 1 ?
                                gettextCatalog.getString('Text in line %from%').replace(/%from%/, line_from) :
                                gettextCatalog.getString('Text from line %from% to %to%')
                                  .replace(/%from%/, line_from).replace(/%to%/, line_to - 1)
                            ),
                            required: false
                        },
                        data: {
                            ckeditorOptions: Editor.getOptions()
                        }
                    }
                ];
            }
        };
    }
])

// Service for choosing the paragraph of a given motion that is to be amended
.factory('AmendmentParagraphChooseForm', [
    function () {
        return {
            // ngDialog for motion form
            getDialog: function (motion, successCb) {
                return {
                    template: 'static/templates/motions/amendment-paragraph-choose-form.html',
                    controller: 'AmendmentParagraphChooseCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        motion: function () { return motion; },
                        successCb: function() { return successCb; },
                    }
                };
            }
        };
    }
])

// Service for generic motion form (create and update)
.factory('MotionForm', [
    '$filter',
    'gettextCatalog',
    'operator',
    'Editor',
    'MotionComment',
    'Category',
    'Config',
    'Mediafile',
    'MotionBlock',
    'Tag',
    'User',
    'Workflow',
    'Agenda',
    'AgendaTree',
    'ShowAsAgendaItemField',
    function ($filter, gettextCatalog, operator, Editor, MotionComment, Category, Config,
        Mediafile, MotionBlock, Tag, User, Workflow, Agenda, AgendaTree, ShowAsAgendaItemField) {
        return {
            // ngDialog for motion form
            // If motion is given and not null, we're editing an already existing motion
            // If parentMotion is give, we're dealing with an amendment
            // If paragraphNo is given as well, the amendment is paragraph-based
            // If paragraphTextPre is given, we're creating a modified version of another paragraph-based amendment
            getDialog: function (motion, parentMotion, paragraphNo, paragraphTextPre) {
                return {
                    template: 'static/templates/motions/motion-form.html',
                    controller: motion ? 'MotionUpdateCtrl' : 'MotionCreateCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        motionId: function () {return motion ? motion.id : void 0;},
                        parentMotion: function () {return parentMotion;},
                        paragraphNo: function () {return paragraphNo;},
                        paragraphTextPre: function () {return paragraphTextPre;}
                    }
                };
            },
            // angular-formly fields for motion form
            getFormFields: function (isCreateForm, isParagraphBasedAmendment) {
                if (!isParagraphBasedAmendment) { // catch null and undefined. Angular formy doesn't like this.
                    isParagraphBasedAmendment = false;
                }

                var workflows = Workflow.getAll();
                var images = Mediafile.getAllImages();
                var formFields = [];
                formFields.push({
                    key: 'identifier',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Identifier')
                    },
                    hide: true
                });

                if (isCreateForm) {
                    formFields.push({
                        key: 'submitters_id',
                        type: 'select-multiple',
                        templateOptions: {
                            label: gettextCatalog.getString('Submitters'),
                            options: User.getAll(),
                            ngOptions: 'option.id as option.full_name for option in to.options',
                            placeholder: gettextCatalog.getString('Select or search a submitter ...'),
                        },
                        hide: !operator.hasPerms('motions.can_manage')
                    });
                }

                formFields = formFields.concat([
                    {
                        key: 'title',
                        type: 'input',
                        templateOptions: {
                            label: gettextCatalog.getString('Title'),
                            required: true
                        },
                        hide: isParagraphBasedAmendment && isCreateForm
                    },
                    {
                        template: '<p class="spacer-top-lg no-padding">' + Config.translate(Config.get('motions_preamble').value) + '</p>'
                    },
                    {
                        key: 'text',
                        type: 'editor',
                        templateOptions: {
                            label: gettextCatalog.getString('Text'),
                            required: !isParagraphBasedAmendment // Deleting the whole paragraph in an amendment should be possible
                        },
                        data: {
                            ckeditorOptions: Editor.getOptions()
                        }
                    },
                    {
                        key: 'reason',
                        type: 'editor',
                        templateOptions: {
                            label: gettextCatalog.getString('Reason'),
                        },
                        data: {
                            ckeditorOptions: Editor.getOptions()
                        }
                    },
                    {
                        key: 'disable_versioning',
                        type: 'checkbox',
                        templateOptions: {
                            label: gettextCatalog.getString('Trivial change'),
                            description: gettextCatalog.getString("Don't create a new version.")
                        },
                        hide: true
                    }
                ]);

                // show as agenda item + parent item
                if (isCreateForm) {
                    formFields.push(ShowAsAgendaItemField('motions.can_manage'));
                    formFields.push({
                        key: 'agenda_parent_id',
                        type: 'select-single',
                        templateOptions: {
                            label: gettextCatalog.getString('Parent item'),
                            options: AgendaTree.getFlatTree(Agenda.getAll()),
                            ngOptions: 'item.id as item.getListViewTitle() for item in to.options | notself : model.agenda_item_id',
                            placeholder: gettextCatalog.getString('Select a parent item ...')
                        },
                        hide: !operator.hasPerms('agenda.can_manage')
                    });
                }

                // motion comments
                formFields = formFields.concat(MotionComment.getFormFields());

                // more
                formFields.push(
                    {
                        key: 'more',
                        type: 'checkbox',
                        templateOptions: {
                            label: gettextCatalog.getString('Show extended fields')
                        },
                        hide: !operator.hasPerms('motions.can_manage')
                    },
                    {
                        template: '<hr class="smallhr">',
                        hideExpression: '!model.more'
                    }
                );
                // attachments
                if (Mediafile.getAll().length > 0) {
                    formFields.push({
                        key: 'attachments_id',
                        type: 'select-multiple',
                        templateOptions: {
                            label: gettextCatalog.getString('Attachment'),
                            options: $filter('orderBy')(Mediafile.getAll(), 'title_or_filename'),
                            ngOptions: 'option.id as option.title_or_filename for option in to.options',
                            placeholder: gettextCatalog.getString('Select or search an attachment ...')
                        },
                        hideExpression: '!model.more'
                    });
                }
                // category
                if (Category.getAll().length > 0) {
                    formFields.push({
                        key: 'category_id',
                        type: 'select-single',
                        templateOptions: {
                            label: gettextCatalog.getString('Category'),
                            options: Category.getAll(),
                            ngOptions: 'option.id as option.name for option in to.options',
                            placeholder: gettextCatalog.getString('Select or search a category ...')
                        },
                        hideExpression: '!model.more'
                    });
                }
                // motion block
                if (MotionBlock.getAll().length > 0) {
                    formFields.push({
                        key: 'motion_block_id',
                        type: 'select-single',
                        templateOptions: {
                            label: gettextCatalog.getString('Motion block'),
                            options: MotionBlock.getAll(),
                            ngOptions: 'option.id as option.title for option in to.options',
                            placeholder: gettextCatalog.getString('Select or search a motion block ...')
                        },
                        hideExpression: '!model.more'
                    });
                }
                // origin
                formFields.push({
                    key: 'origin',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Origin'),
                    },
                    hideExpression: '!model.more'
                });
                // tags
                if (Tag.getAll().length > 0) {
                    formFields.push({
                        key: 'tags_id',
                        type: 'select-multiple',
                        templateOptions: {
                            label: gettextCatalog.getString('Tags'),
                            options: Tag.getAll(),
                            ngOptions: 'option.id as option.name for option in to.options',
                            placeholder: gettextCatalog.getString('Select or search a tag ...')
                        },
                        hideExpression: '!model.more'
                    });
                }
                // supporters
                if (Config.get('motions_min_supporters').value > 0) {
                    formFields.push({
                        key: 'supporters_id',
                        type: 'select-multiple',
                        templateOptions: {
                            label: gettextCatalog.getString('Supporters'),
                            options: User.getAll(),
                            ngOptions: 'option.id as option.full_name for option in to.options',
                            placeholder: gettextCatalog.getString('Select or search a supporter ...')
                        },
                        hideExpression: '!model.more'
                    });
                }
                // workflows
                if (workflows.length > 1) {
                    formFields.push({
                        key: 'workflow_id',
                        type: 'select-single',
                        templateOptions: {
                            label: gettextCatalog.getString('Workflow'),
                            optionsAttr: 'bs-options',
                            options: workflows,
                            ngOptions: 'option.id as option.name | translate for option in to.options',
                            placeholder: gettextCatalog.getString('Select or search a workflow ...')
                        },
                        hideExpression: '!model.more',
                    });
                }

                return formFields;
            }
        };
    }
])

.factory('MotionCommentForm', [
    'MotionComment',
    function (MotionComment) {
        return {
            // ngDialog for motion comment form
            getDialog: function (motion, commentFieldId) {
                return {
                    template: 'static/templates/motions/motion-comment-form.html',
                    controller: 'MotionCommentCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        motionId: function () {return motion.id;},
                        commentFieldId: function () {return commentFieldId;},
                    },
                };
            },
            // angular-formly fields for motion comment form
            getFormFields: function (commentFieldId) {
                return [
                    MotionComment.getFormField(commentFieldId)
                ];
            },
        };
    }
])

.factory('CategoryForm', [
    'gettextCatalog',
    function (gettextCatalog) {
        return {
            getDialog: function (category) {
                return {
                    template: 'static/templates/motions/category-form.html',
                    controller: category ? 'CategoryUpdateCtrl' : 'CategoryCreateCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        categoryId: function () {return category ? category.id : void 0;},
                    },
                };

            },
            getFormFields: function () {
                return [
                    {
                        key: 'prefix',
                        type: 'input',
                        templateOptions: {
                            label: gettextCatalog.getString('Prefix')
                        },
                    },
                    {
                        key: 'name',
                        type: 'input',
                        templateOptions: {
                            label: gettextCatalog.getString('Name')
                        },
                    }
                ];
            },
        };
    }
])

// Provide generic motionpoll form fields for poll update view
.factory('MotionPollForm', [
    'gettextCatalog',
    function (gettextCatalog) {
        return {
            getFormFields: function (precision) {
                var step = Math.pow(10, -precision);
                return [
                {
                    key: 'yes',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Yes'),
                        type: 'number',
                        step: step,
                        required: true
                    }
                },
                {
                    key: 'no',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('No'),
                        type: 'number',
                        step: step,
                        required: true
                    }
                },
                {
                    key: 'abstain',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Abstain'),
                        type: 'number',
                        step: step,
                        required: true
                    }
                },
                {
                    key: 'votesvalid',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Valid votes'),
                        step: step,
                        type: 'number'
                    }
                },
                {
                    key: 'votesinvalid',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Invalid votes'),
                        step: step,
                        type: 'number'
                    }
                },
                {
                    key: 'votescast',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Votes cast'),
                        step: step,
                        type: 'number'
                    }
                }];
            }
        };
    }
])

.factory('MotionExportForm', [
    'operator',
    'gettextCatalog',
    'Config',
    'MotionComment',
    function (operator, gettextCatalog, Config, MotionComment) {
        var noSpecialCommentsFields = MotionComment.getNoSpecialCommentsFields();
        return {
            getDialog: function (motions, params, singleMotion) {
                return {
                    template: 'static/templates/motions/motion-export-form.html',
                    controller: 'MotionExportCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        motions: function () {return motions;},
                        params: function () {return params;},
                        singleMotion: function () {return singleMotion;},
                    },
                };
            },
            getFormFields: function (singleMotion, motions, formatChangeCallback) {
                var fields = [];
                var commentsAvailable = _.keys(noSpecialCommentsFields).length !== 0;
                var someMotionsHaveAmendments = _.some(motions, function (motion) {
                    return motion.hasAmendments();
                });
                // if amendments amendments are already included. We owudl have them twice, if the option is enabled.
                if (Config.get('motions_amendments_main_table').value) {
                    someMotionsHaveAmendments = false;
                }
                var getMetaInformationOptions = function (disabled) {
                    if (!disabled) {
                        disabled = {};
                    }
                    var options = [
                        {name: gettextCatalog.getString('Submitters'), id: 'submitters', disabled: disabled.submitters},
                        {name: gettextCatalog.getString('State'), id: 'state', disabled: disabled.state},
                    ];
                    if (Config.get('motions_recommendations_by').value) {
                        options.push({
                            name: gettextCatalog.getString('Recommendation'),
                            id: 'recommendation',
                            disabled: disabled.recommendation
                        });
                    }
                    if (_.some(motions, function (motion) { return motion.category; })) {
                        options.push({
                            name: gettextCatalog.getString('Category'),
                            id: 'category',
                            disabled: disabled.category,
                        });
                    }
                    if (_.some(motions, function (motion) { return motion.motionBlock; })) {
                        options.push({
                            name: gettextCatalog.getString('Motion block'),
                            id: 'motionBlock',
                            disabled: disabled.motionBlock,
                        });
                    }
                    if (_.some(motions, function (motion) { return motion.origin; })) {
                        options.push({
                            name: gettextCatalog.getString('Origin'),
                            id: 'origin',
                            disabled: disabled.origin,
                        });
                    }
                    options.push({
                        name: gettextCatalog.getString('Voting result'),
                        id: 'votingresult',
                        disabled: disabled.votingResult
                    });
                    return options;
                };
                if (!singleMotion) {
                    fields = [
                        {
                            key: 'format',
                            type: 'radio-buttons',
                            templateOptions: {
                                label: gettextCatalog.getString('Format'),
                                options: [
                                    {name: 'PDF', value: 'pdf'},
                                    {name: 'CSV', value: 'csv'},
                                    {name: 'DOCX', value: 'docx'},
                                ],
                                change: formatChangeCallback,
                            },
                        }
                    ];
                }
                if (someMotionsHaveAmendments) {
                    fields.push({
                        key: 'amendments',
                        type: 'radio-buttons',
                        templateOptions: {
                            label: gettextCatalog.getString('Amendments'),
                            options: [
                                {name: gettextCatalog.getString('Include'), value: true},
                                {name: gettextCatalog.getString('Exclude'), value: false},
                            ],
                        },
                    });
                }
                if (operator.hasPerms('motions.can_manage')) {
                    fields.push.apply(fields, [
                        {
                            key: 'lineNumberMode',
                            type: 'radio-buttons',
                            templateOptions: {
                                label: gettextCatalog.getString('Line numbering'),
                                options: [
                                    {name: gettextCatalog.getString('None'), value: 'none'},
                                    {name: gettextCatalog.getString('inline'), value: 'inline'},
                                    {name: gettextCatalog.getString('outside'), value: 'outside'},
                                ],
                            },
                            hideExpression: "model.format !== 'pdf'",
                        },
                        {
                            key: 'lineNumberMode',
                            type: 'radio-buttons',
                            templateOptions: {
                                label: gettextCatalog.getString('Line numbering'),
                                options: [
                                    {name: gettextCatalog.getString('None'), value: 'none'},
                                    {name: gettextCatalog.getString('inline'), value: 'inline', disabled: true},
                                    {name: gettextCatalog.getString('outside'), value: 'outside', disabled: true},
                                ],
                            },
                            hideExpression: "model.format === 'pdf'",
                        },
                        {
                            key: 'changeRecommendationMode',
                            type: 'radio-buttons',
                            templateOptions: {
                                label: gettextCatalog.getString('Change recommendations'),
                                options: [
                                    {name: gettextCatalog.getString('Original version'), value: 'original'},
                                    {name: gettextCatalog.getString('Changed version'), value: 'changed'},
                                    {name: gettextCatalog.getString('Diff version'), value: 'diff'},
                                    {name: gettextCatalog.getString('Final version'), value: 'modified_agreed'},
                                ],
                            },
                            hideExpression: "model.format !== 'pdf'",
                        },
                        {
                            key: 'changeRecommendationMode',
                            type: 'radio-buttons',
                            templateOptions: {
                                label: gettextCatalog.getString('Change recommendations'),
                                options: [
                                    {name: gettextCatalog.getString('Original version'), value: 'original'},
                                    {name: gettextCatalog.getString('Changed version'), value: 'changed'},
                                    {name: gettextCatalog.getString('Diff version'), value: 'diff', disabled: true},
                                    {name: gettextCatalog.getString('Final version'), value: 'modified_agreed'},
                                ],
                            },
                            hideExpression: "model.format === 'pdf'",
                        },
                        {
                            key: 'include',
                            type: 'checkbox-buttons',
                            templateOptions: {
                                label: gettextCatalog.getString('Content'),
                                options: [
                                    {name: gettextCatalog.getString('Text'), id: 'text'},
                                    {name: gettextCatalog.getString('Reason'), id: 'reason'},
                                ],
                            },
                        },
                        {
                            key: 'include',
                            type: 'checkbox-buttons',
                            templateOptions: {
                                label: gettextCatalog.getString('Meta information'),
                                options: getMetaInformationOptions(),
                            },
                            hideExpression: "model.format !== 'pdf'",
                        },
                        {
                            key: 'include',
                            type: 'checkbox-buttons',
                            templateOptions: {
                                label: gettextCatalog.getString('Meta information'),
                                options: getMetaInformationOptions({votingResult: true}),
                            },
                            hideExpression: "model.format !== 'csv'",
                        },
                    ]);
                    if (commentsAvailable) {
                        fields.push({
                            key: 'includeComments',
                            type: 'checkbox-buttons',
                            templateOptions: {
                                label: gettextCatalog.getString('Comments'),
                                options: _.map(noSpecialCommentsFields, function (field, id) {
                                    return {
                                        name: gettextCatalog.getString(field.name),
                                        id: id,
                                    };
                                }),
                            },
                            hideExpression: "model.format === 'csv'",
                        });
                    }
                }
                if (!singleMotion) {
                    fields.push({
                        key: 'pdfFormat',
                        type: 'radio-buttons',
                        templateOptions: {
                            label: gettextCatalog.getString('PDF format'),
                            options: [
                                {name: gettextCatalog.getString('One PDF'), value: 'pdf'},
                                {name: gettextCatalog.getString('Multiple PDFs in a zip arcive'), value: 'zip'},
                            ],
                        },
                        hideExpression: "model.format !== 'pdf'",
                    });
                }
                return fields;
            },
        };
    }
])

.controller('MotionExportCtrl', [
    '$scope',
    'Config',
    'MotionExportForm',
    'MotionPdfExport',
    'MotionCsvExport',
    'MotionDocxExport',
    'motions',
    'params',
    'singleMotion',
    function ($scope, Config, MotionExportForm, MotionPdfExport, MotionCsvExport,
            MotionDocxExport, motions, params, singleMotion) {
        $scope.formFields = MotionExportForm.getFormFields(singleMotion, motions, function () {
            if ($scope.params.format !== 'pdf') {
                $scope.params.changeRecommendationMode = 'original';
                $scope.params.lineNumberMode = 'none';
                $scope.params.include.votingresult = false;
            }
            if ($scope.params.format === 'docx') {
                $scope.params.include.state = false;
                $scope.params.include.submitter = true;
                $scope.params.include.motionBlock = false;
                $scope.params.include.origin = false;
                $scope.params.include.recommendation = false;
            } else {
                $scope.params.include.state = true;
                $scope.params.include.motionBlock = true;
                $scope.params.include.origin = true;
                $scope.params.include.recommendation = true;
            }
            if ($scope.params.format === 'pdf') {
                $scope.params.include.state = true;
                $scope.params.include.votingresult = true;
            }
        });
        $scope.params = params || {};
        _.defaults($scope.params, {
            format: 'pdf',
            pdfFormat: 'pdf',
            changeRecommendationMode: Config.get('motions_recommendation_text_mode').value,
            lineNumberMode: Config.get('motions_default_line_numbering').value,
            amendments: false,
            include: {
                text: true,
                reason: true,
                state: true,
                category: true,
                submitters: true,
                votingresult: true,
                motionBlock: true,
                origin: true,
                recommendation: true,
            },
            includeComments: {},
        });
        // Always change the mode from agreed to modified_agreed. If a motion does not have a modified
        // final version, the agreed will be taken.
        if ($scope.params.changeRecommendationMode === 'agreed') {
            $scope.params.changeRecommendationMode = 'modified_agreed';
        }
        $scope.motions = motions;
        $scope.singleMotion = singleMotion;

        // Add amendments to motions. The amendments are sorted by their identifier
        var prepareAmendments = function (motions) {
            var allMotions = [];
            _.forEach(motions, function (motion) {
                allMotions.push(motion);
                allMotions = allMotions.concat(
                    _.sortBy(motion.getAmendments(), function (amendment) {
                        return amendment.identifier;
                    })
                );
            });
            return allMotions;
        };

        $scope.export = function () {
            if ($scope.params.amendments) {
                motions = prepareAmendments(motions);
            }
            switch ($scope.params.format) {
                case 'pdf':
                    if ($scope.params.pdfFormat === 'pdf') {
                        MotionPdfExport.export(motions, $scope.params, singleMotion);
                    } else {
                        MotionPdfExport.exportZip(motions, $scope.params);
                    }
                    break;
                case 'csv':
                    MotionCsvExport.export(motions, $scope.params);
                    break;
                case 'docx':
                    MotionDocxExport.export(motions, $scope.params);
                    break;
            }
            $scope.closeThisDialog();
        };
    }
])

// Cache for MotionPollDetailCtrl so that users choices are keeped during user actions (e. g. save poll form).
.value('MotionPollDetailCtrlCache', {})

// Child controller of MotionDetailCtrl for each single poll.
.controller('MotionPollDetailCtrl', [
    '$scope',
    'MajorityMethodChoices',
    'Config',
    'MotionPollDetailCtrlCache',
    'MotionPollDecimalPlaces',
    function ($scope, MajorityMethodChoices, Config, MotionPollDetailCtrlCache, MotionPollDecimalPlaces) {
        // Define choices.
        $scope.methodChoices = MajorityMethodChoices;
        // TODO: Get $scope.baseChoices from config_variables.py without copying them.

        $scope.votesPrecision = MotionPollDecimalPlaces.getPlaces($scope.poll);

        // Setup empty cache with default values.
        if (typeof MotionPollDetailCtrlCache[$scope.poll.id] === 'undefined') {
            MotionPollDetailCtrlCache[$scope.poll.id] = {
                method: $scope.config('motions_poll_default_majority_method'),
            };
        }

        // Fetch users choices from cache.
        $scope.method = MotionPollDetailCtrlCache[$scope.poll.id].method;

        // Define result function.
        $scope.isReached = function () {
            return $scope.poll.isReached($scope.method);
        };

        // Define template controll function
        $scope.hideMajorityCalculation = function () {
            return typeof $scope.isReached() === 'undefined' && $scope.method !== 'disabled';
        };

        // Save current values to cache on detroy of this controller.
        $scope.$on('$destroy', function() {
            MotionPollDetailCtrlCache[$scope.poll.id] = {
                method: $scope.method,
            };
        });
    }
])

.controller('MotionListCtrl', [
    '$scope',
    '$state',
    '$http',
    'gettext',
    'gettextCatalog',
    'operator',
    'ngDialog',
    'MotionForm',
    'Motion',
    'MotionComment',
    'Category',
    'Config',
    'Tag',
    'Workflow',
    'User',
    'Agenda',
    'MotionBlock',
    'Projector',
    'ProjectionDefault',
    'osTableFilter',
    'osTableSort',
    'osTablePagination',
    'MotionExportForm',
    'MotionPdfExport',
    'PersonalNoteManager',
    function($scope, $state, $http, gettext, gettextCatalog, operator, ngDialog, MotionForm, Motion,
                MotionComment, Category, Config, Tag, Workflow, User, Agenda, MotionBlock, Projector,
                ProjectionDefault, osTableFilter, osTableSort, osTablePagination, MotionExportForm,
                MotionPdfExport, PersonalNoteManager) {
        Category.bindAll({}, $scope, 'categories');
        MotionBlock.bindAll({}, $scope, 'motionBlocks');
        Tag.bindAll({}, $scope, 'tags');
        Workflow.bindAll({}, $scope, 'workflows');
        User.bindAll({}, $scope, 'users');
        Projector.bindAll({}, $scope, 'projectors');
        $scope.$watch(function () {
            return Projector.lastModified();
        }, function () {
            var projectiondefault = ProjectionDefault.filter({name: 'motions'})[0];
            if (projectiondefault) {
                $scope.defaultProjectorId = projectiondefault.projector_id;
            }
        });
        $scope.$watch(function () {
            return Motion.lastModified();
        }, function () {
            // get all main motions and order by identifier (after custom ordering)
            var motions;
            if (Config.get('motions_amendments_main_table').value) {
                motions = Motion.getAll();
            } else {
                motions = Motion.filter({parent_id: undefined});
            }

            $scope.motions = _.orderBy(motions, ['identifier']);
            _.forEach($scope.motions, function (motion) {
                MotionComment.populateFields(motion);
                motion.personalNote = PersonalNoteManager.getNote(motion);
                // For filtering, we cannot filter for .personalNote.star
                motion.star = motion.personalNote ? motion.personalNote.star : false;
                motion.hasPersonalNote = motion.personalNote ? !!motion.personalNote.note : false;
                if (motion.star === undefined) {
                    motion.star = false;
                }
            });
            $scope.collectStatesAndRecommendations();
        });
        $scope.alert = {};

        // Motion comments
        $scope.noSpecialCommentsFields = MotionComment.getNoSpecialCommentsFields();
        $scope.showCommentsFilter = function () {
            return _.keys($scope.noSpecialCommentsFields).length > 0;
        };

        // collect all states and all recommendations of all workflows
        $scope.collectStatesAndRecommendations = function () {
            // Special case: If it is the first time updated, update the state filter.
            // This causes to set the done/undone states correct on page load.
            var doStateFilterUpdate = !$scope.states;
            $scope.states = [];
            $scope.recommendations = [];
            var workflows = $scope.collectAllUsedWorkflows();
            _.forEach(workflows, function (workflow) {
                if (workflows.length > 1) {
                    var workflowHeader = {
                        headername: workflow.name,
                        workflowHeader: true,
                    };
                    $scope.states.push(workflowHeader);
                    $scope.recommendations.push(workflowHeader);
                }

                var firstEndStateSeen = false;
                _.forEach(_.orderBy(workflow.states, 'id'), function (state) {
                    if (state.next_states_id.length === 0 && !firstEndStateSeen) {
                        $scope.states.push({divider: true});
                        firstEndStateSeen = true;
                    }
                    $scope.states.push(state);
                    if (state.recommendation_label) {
                        $scope.recommendations.push(state);
                    }
                });
            });
            if (doStateFilterUpdate) {
                updateStateFilter();
            }
        };
        $scope.collectAllUsedWorkflows = function () {
            return _.filter(Workflow.getAll(), function (workflow) {
                return _.some($scope.motions, function (motion) {
                    return motion.state.workflow_id === workflow.id;
                });
            });
        };

        $scope.stateFilter = [];
        var updateStateFilter = function () {
            $scope.stateFilter = _.clone($scope.filter.multiselectFilters.state);

            var doneIndex = _.indexOf($scope.stateFilter, -1);
            if (doneIndex > -1) { // contains -1 (done)
                $scope.stateFilter.splice(doneIndex, 1); // remove -1
                _.forEach($scope.states, function (state) {
                    if (!state.workflowHeader && !state.divider) {
                        if (state.next_states_id.length === 0) { // add all done state
                            $scope.stateFilter.push(state.id);
                        }
                    }
                });
            }

            var undoneIndex = _.indexOf($scope.stateFilter, -2);
            if (undoneIndex > -1) { // contains -2 (undone)
                $scope.stateFilter.splice(undoneIndex, 1); // remove -2
                _.forEach($scope.states, function (state) {
                    if (!state.workflowHeader && !state.divider) {
                        if (state.next_states_id.length !== 0) { // add all undone state
                            $scope.stateFilter.push(state.id);
                        }
                    }
                });
            }
            $scope.stateFilter = _.uniq($scope.stateFilter);
        };

        // This value may be overritten, so the filters, sorting and pagination in an
        // derived view are independent to this view.
        var osTablePrefix = $scope.osTablePrefix || 'MotionTable';

        // Filtering
        $scope.filter = osTableFilter.createInstance(osTablePrefix + 'Filter');

        if (!$scope.filter.existsStorageEntry()) {
            $scope.filter.multiselectFilters = {
                state: [],
                category: [],
                motionBlock: [],
                tag: [],
                recommendation: [],
                comment: [],
            };
            $scope.filter.booleanFilters = {
                isFavorite: {
                    value: undefined,
                    choiceYes: gettext('Marked as favorite'),
                    choiceNo: gettext('Not marked as favorite'),
                },
                hasPersonalNote: {
                    value: undefined,
                    choiceYes: gettext('Personal note set'),
                    choiceNo: gettext('Personal note not set'),
                },
            };
        }
        $scope.filter.propertyList = ['identifier', 'origin'];
        $scope.filter.propertyFunctionList = [
            function (motion) {return motion.getTitle();},
            function (motion) {return motion.category ? motion.category.name : '';},
            function (motion) {return motion.motionBlock ? motion.motionBlock.name : '';},
            function (motion) {return motion.recommendation ? motion.getRecommendationName() : '';},
        ];
        $scope.filter.propertyDict = {
            'submitters': function (submitter) {
                return submitter.user.get_short_name();
            },
            'supporters': function (supporter) {
                return supporter.get_short_name();
            },
            'tags': function (tag) {
                return tag.name;
            },
        };
        $scope.getItemId = {
            state: function (motion) {return motion.state_id;},
            comment: function (motion) {
                var ids = [];
                _.forEach(motion.comments, function (comment, id) {
                    if (comment) {
                        ids.push(id);
                    }
                });
                return ids;
            },
            category: function (motion) {return motion.category_id;},
            motionBlock: function (motion) {return motion.motion_block_id;},
            tag: function (motion) {return motion.tags_id;},
            recommendation: function (motion) {return motion.recommendation_id;},
        };
        $scope.operateStateFilter = function (id, danger) {
            $scope.filter.operateMultiselectFilter('state', id, danger);
            updateStateFilter();
        };
        $scope.resetFilters = function (danger) {
            $scope.filter.reset(danger);
            updateStateFilter();
        };
        // Sorting
        $scope.sort = osTableSort.createInstance(osTablePrefix + 'Sort');
        if (!$scope.sort.column) {
            $scope.sort.column = 'identifier';
        }
        $scope.sortOptions = [
            {name: 'identifier',
             display_name: gettext('Identifier')},
            {name: 'getTitle()',
             display_name: gettext('Title')},
            {name: 'submitters[0].user.get_short_name()',
             display_name: gettext('Submitters')},
            {name: 'category.' + Config.get('motions_export_category_sorting').value,
             display_name: gettext('Category')},
            {name: 'motionBlock.title',
             display_name: gettext('Motion block')},
            {name: 'state.name',
             display_name: gettext('State')},
            {name: 'log_messages[log_messages.length-1].time',
             display_name: gettext('Creation date')},
            {name: 'log_messages[0].time',
             display_name: gettext('Last modified')},
        ];

        // pagination
        $scope.pagination = osTablePagination.createInstance(osTablePrefix + 'Pagination');

        $scope.hasTag = function (motion, tag) {
            return _.indexOf(motion.tags_id, tag.id) > -1;
        };

        $scope.save = function (motion) {
            Motion.save(motion, {method: 'PATCH'});
        };
        // delete single motion
        $scope.delete = function (motion) {
            Motion.destroy(motion.id);
        };
        $scope.toggleTag = function (motion, tag) {
            if ($scope.hasTag(motion, tag)) {
                // remove
                motion.tags_id = _.filter(motion.tags_id, function (tag_id){
                    return tag_id != tag.id;
                });
            } else {
                motion.tags_id.push(tag.id);
            }
            $scope.save(motion);
        };
        $scope.toggleCategory = function (motion, category) {
            if (motion.category_id == category.id) {
                motion.category_id = null;
            } else {
                motion.category_id = category.id;
            }
            $scope.save(motion);
        };
        $scope.toggleMotionBlock = function (motion, block) {
            if (motion.motion_block_id == block.id) {
                motion.motion_block_id = null;
            } else {
                motion.motion_block_id = block.id;
            }
            $scope.save(motion);
        };
        $scope.toggleStar = function (motion) {
            if (motion.personalNote) {
                motion.personalNote.star = !motion.personalNote.star;
            } else {
                motion.personalNote = {star: true};
            }
            PersonalNoteManager.saveNote(motion, motion.personalNote);
        };

        // open new/edit dialog
        $scope.openDialog = function (motion) {
            ngDialog.open(MotionForm.getDialog(motion));
        };
        // Export dialog
        $scope.openExportDialog = function (motions) {
            ngDialog.open(MotionExportForm.getDialog(motions, $scope.sort));
        };
        $scope.pdfExport = function (motions) {
            MotionPdfExport.export(motions);
        };

        // *** select mode functions ***
        $scope.isSelectMode = false;
        // check all checkboxes from filtered motions
        $scope.checkAll = function (motions) {
            $scope.selectedAll = !$scope.selectedAll;
            _.forEach(motions, function (motion) {
                motion.selected = $scope.selectedAll;
            });
        };
        // uncheck all checkboxes if isSelectMode is closed
        $scope.uncheckAll = function () {
            if (!$scope.isSelectMode) {
                $scope.selectedAll = false;
                _.forEach($scope.motions, function (motion) {
                    motion.selected = false;
                });
            }
        };
        var selectModeAction = function (motions, predicate) {
            angular.forEach(motions, function (motion) {
                if (motion.selected) {
                    predicate(motion);
                }
            });
            $scope.isSelectMode = false;
            $scope.uncheckAll();
        };
        // delete selected motions
        $scope.deleteMultiple = function (motions) {
            selectModeAction(motions, function (motion) {
                $scope.delete(motion);
            });
        };
        // set status for selected motions
        $scope.setStatusMultiple = function (motions, stateId) {
            selectModeAction(motions, function (motion) {
                $http.put('/rest/motions/motion/' + motion.id + '/set_state/', {'state': stateId});
            });
        };
        // set category for selected motions
        $scope.setCategoryMultiple = function (motions, categoryId) {
            selectModeAction(motions, function (motion) {
                motion.category_id = categoryId === 'no_category_selected' ? null : categoryId;
                $scope.save(motion);
            });
        };
        // set status for selected motions
        $scope.setMotionBlockMultiple = function (motions, motionBlockId) {
            selectModeAction(motions, function (motion) {
                motion.motion_block_id = motionBlockId === 'no_motionBlock_selected' ? null : motionBlockId;
                $scope.save(motion);
            });
        };
    }
])

.controller('MotionDetailCtrl', [
    '$scope',
    '$http',
    '$timeout',
    '$window',
    '$filter',
    'operator',
    'ngDialog',
    'gettextCatalog',
    'MotionForm',
    'AmendmentParagraphChooseForm',
    'ChangeRecommendationCreate',
    'ChangeRecommendationView',
    'MotionStateAndRecommendationParser',
    'MotionChangeRecommendation',
    'Motion',
    'MotionComment',
    'Category',
    'Mediafile',
    'Tag',
    'User',
    'Workflow',
    'Config',
    'motionId',
    'MotionInlineEditing',
    'MotionCommentsInlineEditing',
    'Editor',
    'Projector',
    'ProjectionDefault',
    'MotionBlock',
    'MotionPdfExport',
    'PersonalNoteManager',
    'Notify',
    'WebpageTitle',
    'EditingWarning',
    function($scope, $http, $timeout, $window, $filter, operator, ngDialog, gettextCatalog,
            MotionForm, AmendmentParagraphChooseForm, ChangeRecommendationCreate, ChangeRecommendationView,
            MotionStateAndRecommendationParser, MotionChangeRecommendation, Motion, MotionComment,
            Category, Mediafile, Tag, User, Workflow, Config, motionId, MotionInlineEditing,
            MotionCommentsInlineEditing, Editor, Projector, ProjectionDefault, MotionBlock,
            MotionPdfExport, PersonalNoteManager, Notify, WebpageTitle, EditingWarning) {
        var motion = Motion.get(motionId);
        Category.bindAll({}, $scope, 'categories');
        Mediafile.bindAll({}, $scope, 'mediafiles');
        Tag.bindAll({}, $scope, 'tags');
        User.bindAll({}, $scope, 'users');
        Workflow.bindAll({}, $scope, 'workflows');
        MotionBlock.bindAll({}, $scope, 'motionBlocks');
        Motion.bindAll({}, $scope, 'motions');


        $scope.$watch(function () {
            return Projector.lastModified();
        }, function () {
            $scope.projectors = Projector.getAll();
            var projectiondefault = ProjectionDefault.filter({name: 'motions'})[0];
            if (projectiondefault) {
                $scope.defaultProjectorId = projectiondefault.projector_id;
            }
        });
        $scope.$watch(function () {
            return Motion.lastModified(motionId);
        }, function () {
            $scope.motion = Motion.get(motionId);
            $scope.amendment_diff_paragraphs = $scope.motion.getAmendmentParagraphsLinesDiff();
            MotionComment.populateFields($scope.motion);
            if (motion.comments) {
                $scope.stateExtension = $scope.motion.comments[$scope.commentFieldForStateId];
                $scope.recommendationExtension = $scope.motion.comments[$scope.commentFieldForRecommendationId];
            }
            $scope.motion.personalNote = PersonalNoteManager.getNote($scope.motion);
            $scope.navigation.evaluate();

            var webpageTitle = gettextCatalog.getString('Motion') + ' ';
            if ($scope.motion.identifier) {
                webpageTitle += $scope.motion.identifier + ' - ';
            }
            webpageTitle += $scope.motion.getTitle();
            WebpageTitle.updateTitle(webpageTitle);

            $scope.createChangeRecommendation.setVersion(motion, motion.active_version);
            $scope.viewChangeRecommendations.setVersion(motion, motion.active_version);
        });
        $scope.$watch(function () {
            return Motion.lastModified();
        }, function () {
            $scope.motions = Motion.getAll();
            $scope.amendments = Motion.filter({parent_id: motion.id});
        });
        $scope.projectionModes = [
            {mode: 'original',
            label: 'Original version'},
            {mode: 'changed',
            label: 'Changed version'},
            {mode: 'diff',
            label: 'Diff version'},
            {mode: 'agreed',
            label: 'Final version'},
            {mode: 'modified_agreed',
            label: 'Final print template'},
        ];
        var motionDefaultRecommendationTextMode = Config.get('motions_recommendation_text_mode').value;
        // Change to the modified final version, if exists
        if (motionDefaultRecommendationTextMode === 'agreed' && motion.getModifiedFinalVersion()) {
            motionDefaultRecommendationTextMode = 'modified_agreed';
        }
        $scope.projectionMode = _.find($scope.projectionModes, function (mode) {
            return mode.mode == motionDefaultRecommendationTextMode;
        });
        if (motion.isProjected().length) {
            var modeMapping = motion.isProjectedWithMode();
            _.forEach($scope.projectionModes, function (mode) {
                if (mode.mode === modeMapping[0].mode) {
                    $scope.projectionMode = mode;
                }
            });
        }
        $scope.setProjectionMode = function (mode) {
            $scope.projectionMode = mode;
            var isProjected = motion.isProjectedWithMode();
            if (isProjected.length) {
                _.forEach(isProjected, function (mapping) {
                    if (mapping.mode != mode.mode) { // change the mode if it is different
                        motion.project(mapping.projectorId, mode.mode);
                    }
                });
            }
        };
        $scope.commentsFields = MotionComment.getCommentsFields();
        $scope.noSpecialCommentsFields = MotionComment.getNoSpecialCommentsFields();
        $scope.commentFieldForStateId = MotionComment.getFieldIdForFlag('forState');
        $scope.commentFieldForRecommendationId = MotionComment.getFieldIdForFlag('forRecommendation');
        $scope.version = motion.active_version;
        $scope.isCollapsed = true;
        $scope.lineNumberMode = Config.get('motions_default_line_numbering').value;
        $scope.setLineNumberMode = function(mode) {
            $scope.lineNumberMode = mode;
        };

        $scope.showAmendmentContext = false;
        $scope.setShowAmendmentContext = function($event) {
            $event.preventDefault();
            $event.stopPropagation();
            $scope.showAmendmentContext = !$scope.showAmendmentContext;
        };

        if (motion.parent_id) {
            Motion.bindOne(motion.parent_id, $scope, 'parent');
        }

        $scope.scrollToLine = 0;
        $scope.highlight = 0;
        $scope.linesForProjector = false;
        $scope.scrollToAndHighlight = function (line) {
            $scope.scrollToLine = line;
            $scope.highlight = line;

            // The same line number can occur twice in diff view; we scroll to the first one in this case
            var scrollTop = null;
            $('.line-number-' + line).each(function() {
                var top = $(this).offset().top;
                if (top > 0 && (scrollTop === null || top < scrollTop)) {
                    scrollTop = top;
                }
            });

            if (scrollTop) {
                // Scroll local; 50 pixel above the line, so it's not completely squeezed to the screen border
                $('html, body').animate({
                    'scrollTop': scrollTop - 50
                }, 1000);
                // remove the line highlight after 2 seconds.
                $timeout(function () {
                    $scope.highlight = 0;
                }, 2000);
            }

            $scope.scrollProjectorToLine(line);
        };
        $scope.scrollProjectorToLine = function (line) {
            var projectorIds = $scope.motion.isProjected();
            if (!$scope.linesForProjector || !line || !projectorIds.length) {
                return;
            }
            var projectorId = projectorIds[0];
            var notifyNamePrefix = 'projector_' + projectorId + '_motion_line_';

            // register callback
            var callbackId = Notify.registerCallback(notifyNamePrefix + 'answer', function (params) {
                Notify.deregisterCallback(callbackId);
                $http.post('/rest/core/projector/' + projectorId + '/set_scroll/', params.params.scroll);
            });

            // Query all projectors
            Notify.notify(notifyNamePrefix + 'request', {line: line}, null, null, [projectorId]);
        };
        $scope.toggleLinesForProjector = function () {
            $scope.linesForProjector = !$scope.linesForProjector;
            $scope.scrollProjectorToLine($scope.scrollToLine);
        };

        // open edit dialog
        $scope.openDialog = function (motion) {
            if ($scope.inlineEditing.active) {
                $scope.disableMotionInlineEditing();
            }
            ngDialog.open(MotionForm.getDialog(motion));
        };
        $scope.save = function (motion) {
            Motion.save(motion, {method: 'PATCH'});
        };
        // Navigation buttons
        $scope.navigation = {
            evaluate: function () {
                var motions = $filter('orderByEmptyLast')(Motion.getAll(), 'identifier');
                var thisIndex = _.findIndex(motions, function (motion) {
                    return motion.id === $scope.motion.id;
                });
                this.count = motions.length;
                this.nextMotion = thisIndex < motions.length-1 ? motions[thisIndex+1] : _.head(motions);
                this.previousMotion = thisIndex > 0 ? motions[thisIndex-1] : _.last(motions);
            },
        };
        // support
        $scope.support = function () {
            $http.post('/rest/motions/motion/' + motion.id + '/support/');
        };
        // unsupport
        $scope.unsupport = function () {
            $http.delete('/rest/motions/motion/' + motion.id + '/support/');
        };
        // open dialog for new amendment
        $scope.newAmendment = function () {
            var openMainDialog = function (paragraphNo) {
                var dialog = MotionForm.getDialog(null, motion, paragraphNo);
                dialog.scope = $scope;
                ngDialog.open(dialog);
            };

            if (Config.get('motions_amendments_text_mode').value === 'paragraph') {
                var dialog = AmendmentParagraphChooseForm.getDialog($scope.motion, openMainDialog);
                dialog.scope = $scope;
                ngDialog.open(dialog);
            } else {
                openMainDialog();
            }
        };
        // follow recommendation
        $scope.followRecommendation = function () {
            $http.post('/rest/motions/motion/' + motion.id + '/follow_recommendation/', {
                'recommendationExtension': $scope.recommendationExtension
            });
        };
        // toggle functions for meta information
        $scope.toggleCategory = function (category) {
            if ($scope.motion.category_id == category.id) {
                $scope.motion.category_id = null;
            } else {
                $scope.motion.category_id = category.id;
            }
            $scope.save($scope.motion);
        };
        $scope.toggleMotionBlock = function (block) {
            if ($scope.motion.motion_block_id == block.id) {
                $scope.motion.motion_block_id = null;
            } else {
                $scope.motion.motion_block_id = block.id;
            }
            $scope.save($scope.motion);

        };
        $scope.toggleTag = function (tag) {
            if (_.indexOf($scope.motion.tags_id, tag.id) > -1) {
                // remove
                $scope.motion.tags_id = _.filter($scope.motion.tags_id,
                    function (tag_id){
                        return tag_id != tag.id;
                    }
                );
            } else {
                $scope.motion.tags_id.push(tag.id);
            }
            $scope.save($scope.motion);
        };
        // save additional state field
        $scope.saveAdditionalStateField = function (stateExtension) {
            motion['comment_' + $scope.commentFieldForStateId] = stateExtension;
            $scope.save(motion);
        };
        // save additional recommendation field
        $scope.saveAdditionalRecommendationField = function (recommendationExtension) {
            motion['comment_' + $scope.commentFieldForRecommendationId] = recommendationExtension;
            $scope.save(motion);
        };
        $scope.addMotionToRecommendationField = function (motion) {
            $scope.recommendationExtension += MotionStateAndRecommendationParser.formatMotion(motion);
        };
        // create poll
        $scope.create_poll = function () {
            $http.post('/rest/motions/motion/' + motion.id + '/create_poll/', {});
        };
        // open poll update dialog
        $scope.openPollDialog = function (poll, voteNumber) {
            ngDialog.open({
                template: 'static/templates/motions/motion-poll-form.html',
                controller: 'MotionPollUpdateCtrl',
                className: 'ngdialog-theme-default',
                closeByEscape: false,
                closeByDocument: false,
                resolve: {
                    motionpollId: function () {
                        return poll.id;
                    },
                    voteNumber: function () {
                        return voteNumber;
                    }
                }
            });
        };
        // delete poll
        $scope.delete_poll = function (poll) {
            poll.DSDestroy();
        };
        // show specific version
        $scope.showVersion = function (version) {
            $scope.version = version.id;
            $scope.inlineEditing.setVersion(motion, version.id);
            $scope.reasonInlineEditing.setVersion(motion, version.id);
            $scope.createChangeRecommendation.setVersion(motion, version.id);
            $scope.viewChangeRecommendations.setVersion(motion, motion.active_version);
        };
        // permit specific version
        $scope.permitVersion = function (version) {
            $http.put('/rest/motions/motion/' + motion.id + '/manage_version/',
                {'version_number': version.version_number})
                .then(function(success) {
                    $scope.showVersion(version);
                });
        };
        // delete specific version
        $scope.deleteVersion = function (version) {
            $http.delete('/rest/motions/motion/' + motion.id + '/manage_version/',
                    {headers: {'Content-Type': 'application/json'},
                     data: JSON.stringify({version_number: version.version_number})})
                .then(function(success) {
                    $scope.showVersion({id: motion.active_version});
                });
        };
        // check if there is at least one comment field
        $scope.commentFieldsAvailable = function () {
            return _.keys($scope.noSpecialCommentsFields).length > 0;
        };
        // personal note
        // For pinning the personal note container we need to adjust the width with JS. We
        // do not use angular here, because on every window resize a digist cycle would trigger.
        // This costs too much performance. We use JQuery here, because it is fast for DOM
        // manipulation and very responsive.
        $scope.toggleStar = function () {
            if ($scope.motion.personalNote) {
                $scope.motion.personalNote.star = !$scope.motion.personalNote.star;
            } else {
                $scope.motion.personalNote = {star: true};
            }
            PersonalNoteManager.saveNote($scope.motion, $scope.motion.personalNote);
        };
        $scope.personalNotePinned = false;
        $scope.pinPersonalNote = function () {
            $scope.personalNotePinned = !$scope.personalNotePinned;
            if ($scope.personalNotePinned) {
                resizePersonalNoteContainer();
            } else {
                $('#personalNote').css('width', '');
            }
        };
        $scope.gotoPersonalNote = function () {
            var pos = $('#personalNote').offset();
            $window.scrollTo(pos.left, pos.top);
        };
        var resizePersonalNoteContainer = function () {
            if ($scope.personalNotePinned) {
                var width = $('#main-column').width() - 40; // Subtract 2x20px margin
                $('#personalNote').css('width', width + 'px');
            }
        };
        $(window).resize(resizePersonalNoteContainer);

        // Inline editing functions
        $scope.inlineEditing = MotionInlineEditing.createInstance($scope, motion,
            'view-original-text-inline-editor', true, Editor.getOptions('inline'),
            function (obj) {
                return motion.getTextWithLineBreaks($scope.version);
            },
            function (obj) {
                motion.setTextStrippingLineBreaks(obj.editor.getData());
                motion.disable_versioning = (obj.trivialChange &&
                    Config.get('motions_allow_disable_versioning').value);
            }
        );
        $scope.reasonInlineEditing = MotionInlineEditing.createInstance($scope, motion,
            'reason-inline-editor', true, Editor.getOptions('inline'),
            function (obj) {
                return motion.getReason($scope.version);
            },
            function (obj) {
                motion.reason = obj.editor.getData();
                motion.disable_versioning = (obj.trivialChange &&
                    Config.get('motions_allow_disable_versioning').value);
            }
        );
        $scope.modifiedFinalVersionInlineEditing = MotionInlineEditing.createInstance($scope, motion,
            'view-modified-agreed-inline-editor', true, Editor.getOptions('inline'),
            function (obj) {
                return motion.getModifiedFinalVersionWithLineBreaks($scope.version);
            },
            function (obj) {
                motion.setModifiedFinalVersionStrippingLineBreaks(obj.editor.getData());
                motion.disable_versioning = (obj.trivialChange &&
                    Config.get('motions_allow_disable_versioning').value);
            }
        );
        // Wrapper functions for $scope.inlineEditing, to warn other users.
        var editingStoppedCallback;
        $scope.enableMotionInlineEditing = function () {
            editingStoppedCallback = EditingWarning.editingStarted('motion_update_' + motion.id);
            if ($scope.motion.getReason($scope.version)) {
                $scope.reasonInlineEditing.enable();
            }
            $scope.inlineEditing.enable();
        };
        $scope.disableMotionInlineEditing = function () {
            if (editingStoppedCallback) {
                editingStoppedCallback();
            }
            if ($scope.motion && $scope.motion.getReason($scope.version)) {
                $scope.reasonInlineEditing.disable();
            }
            $scope.inlineEditing.disable();
        };
        $scope.textReasonSaveToolbarVisible = function () {
            return ($scope.inlineEditing.changed && $scope.inlineEditing.active) ||
                ($scope.reasonInlineEditing.changed && $scope.reasonInlineEditing.active);
        };
        $scope.textReasonSave = function () {
            if ($scope.motion.getReason($scope.version)) {
                $scope.reasonInlineEditing.save();
            }
            $scope.inlineEditing.save();
        };
        $scope.textReasonRevert = function () {
            if ($scope.motion.getReason($scope.version)) {
                $scope.reasonInlineEditing.revert();
            }
            $scope.inlineEditing.revert();
        };
        $scope.commentsInlineEditing = MotionCommentsInlineEditing.createInstances($scope, motion);
        $scope.personalNoteInlineEditing = MotionInlineEditing.createInstance($scope, motion,
            'personal-note-inline-editor', false, Editor.getOptions('inline'),
            function (obj) {
                return motion.personalNote ? motion.personalNote.note : '';
            },
            function (obj) {
                if (motion.personalNote) {
                    motion.personalNote.note = obj.editor.getData();
                } else {
                    motion.personalNote = {note: obj.editor.getData()};
                }
                PersonalNoteManager.saveNote(motion, motion.personalNote);
                obj.revert();
                obj.disable();
                return true; // Do not update the motion via patch request.
            }
        );

        // Change recommendation creation functions
        $scope.createChangeRecommendation = ChangeRecommendationCreate;
        $scope.createChangeRecommendation.init($scope, motion);

        // Change recommendation and amendment viewing
        $scope.viewChangeRecommendations = ChangeRecommendationView;
        $scope.viewChangeRecommendations.initSite($scope, motion, motionDefaultRecommendationTextMode);

        // PDF creating functions
        $scope.pdfExport = function () {
            var identifier = $scope.motion.identifier ? '-' + $scope.motion.identifier : '';
            var params = {
                filename: gettextCatalog.getString('Motion') + identifier + '.pdf',
                version: $scope.version,
                changeRecommendationMode: $scope.viewChangeRecommendations.mode,
                lineNumberMode: $scope.lineNumberMode,
            };
            MotionPdfExport.export(motion, params, true);
        };
        $scope.createPollPdf = function () {
            MotionPdfExport.createPollPdf($scope.motion, $scope.version);
        };
        $scope.exportComment = function (commentId) {
            var identifier = $scope.motion.identifier ? '-' + $scope.motion.identifier : '';
            var commentsString = ' - ' + gettextCatalog.getString('Comments');
            var filename = gettextCatalog.getString('Motion') + identifier + commentsString + '.pdf';
            MotionPdfExport.exportComment($scope.motion, commentId, filename);
        };
        $scope.exportPersonalNote = function () {
            var identifier = $scope.motion.identifier ? '-' + $scope.motion.identifier : '';
            var personalNoteString = ' - ' + gettextCatalog.getString('personal note');
            var filename = gettextCatalog.getString('Motion') + identifier + personalNoteString + '.pdf';
            MotionPdfExport.exportPersonalNote($scope.motion, filename);
        };
    }
])

.controller('ChangeRecommendationTitleUpdateCtrl', [
    '$scope',
    'MotionChangeRecommendation',
    'ChangeRecommendationTitleForm',
    'diffService',
    'change',
    'ErrorMessage',
    function ($scope, MotionChangeRecommendation, ChangeRecommendationTitleForm, diffService, change, ErrorMessage) {
        $scope.alert = {};
        $scope.model = angular.copy(change);

        // get all form fields
        $scope.formFields = ChangeRecommendationTitleForm.getFormFields();
        // save motion
        $scope.save = function (change) {
            // inject the changed change recommendation (copy) object back into DS store
            MotionChangeRecommendation.inject(change);
            // save changed change recommendation object on server
            MotionChangeRecommendation.save(change).then(
                function() {
                    $scope.closeThisDialog();
                },
                function (error) {
                    MotionChangeRecommendation.refresh(change);
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('ChangeRecommendationTitleCreateCtrl', [
    '$scope',
    'Motion',
    'MotionChangeRecommendation',
    'ChangeRecommendationTitleForm',
    'Config',
    'diffService',
    'motion',
    'version',
    function($scope, Motion, MotionChangeRecommendation, ChangeRecommendationTitleForm, Config, diffService, motion,
             version) {
        $scope.alert = {};

        $scope.model = {
            text: version.title,
            motion_version_id: version.id
        };

        // get all form fields
        $scope.formFields = ChangeRecommendationTitleForm.getFormFields();
        // save motion
        $scope.save = function (change) {
            change.line_from = 0;
            change.line_to = 0;
            MotionChangeRecommendation.create(change).then(
                function() {
                    $scope.closeThisDialog();
                }
            );
        };
    }
])

.controller('ChangeRecommendationTextUpdateCtrl', [
    '$scope',
    'MotionChangeRecommendation',
    'ChangeRecommendationTextForm',
    'diffService',
    'change',
    'ErrorMessage',
    function ($scope, MotionChangeRecommendation, ChangeRecommendationTextForm, diffService, change, ErrorMessage) {
        $scope.alert = {};
        $scope.model = angular.copy(change);
        $scope.model._change_object = undefined;

        // get all form fields
        $scope.formFields = ChangeRecommendationTextForm.getFormFields(change.line_from, change.line_to);
        // save motion
        $scope.save = function (change) {
            change.text = diffService.removeDuplicateClassesInsertedByCkeditor(change.text);
            // inject the changed change recommendation (copy) object back into DS store
            MotionChangeRecommendation.inject(change);
            // save changed change recommendation object on server
            MotionChangeRecommendation.save(change).then(
                function() {
                    $scope.closeThisDialog();
                },
                function (error) {
                    MotionChangeRecommendation.refresh(change);
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('ChangeRecommendationTextCreateCtrl', [
    '$scope',
    'Motion',
    'MotionChangeRecommendation',
    'ChangeRecommendationTextForm',
    'Config',
    'diffService',
    'motion',
    'version',
    'lineFrom',
    'lineTo',
    function($scope, Motion, MotionChangeRecommendation, ChangeRecommendationTextForm, Config, diffService, motion,
             version, lineFrom, lineTo) {
        $scope.alert = {};

        var html = motion.getTextWithLineBreaks(version.id),
            lineData = diffService.extractRangeByLineNumbers(html, lineFrom, lineTo);

        $scope.model = {
            text: lineData.outerContextStart + lineData.innerContextStart +
                lineData.html + lineData.innerContextEnd + lineData.outerContextEnd,
            line_from: lineFrom,
            line_to: lineTo,
            motion_version_id: version.id,
            type: 0
        };

        // get all form fields
        $scope.formFields = ChangeRecommendationTextForm.getFormFields(lineFrom, lineTo);
        // save motion
        $scope.save = function (motion) {
            motion.text = diffService.removeDuplicateClassesInsertedByCkeditor(motion.text);
            MotionChangeRecommendation.create(motion).then(
                function() {
                    $scope.closeThisDialog();
                }
            );
        };
    }
])

.controller('AmendmentParagraphChooseCtrl', [
    '$scope',
    '$state',
    'Motion',
    'motion',
    'successCb',
    function($scope, $state, Motion, motion, successCb) {
        $scope.model = angular.copy(motion);
        $scope.model.paragraph_selected = null;

        $scope.paragraphs = motion.getTextParagraphs(motion.active_version, true).map(function(text, index) {
            // This prevents an error in ng-repeater's duplication detection if two identical paragraphs occur
            return {
                "paragraphNo": index,
                "text": text
            };
        });

        $scope.gotoMotionForm = function() {
            var paragraphNo = parseInt($scope.model.paragraph_selected);
            successCb(paragraphNo);
            $scope.closeThisDialog();
        };
    }
])

.controller('MotionCreateCtrl', [
    '$scope',
    '$state',
    'gettext',
    'gettextCatalog',
    'operator',
    'Motion',
    'MotionForm',
    'parentMotion',
    'paragraphNo',
    'paragraphTextPre',
    'Category',
    'Config',
    'Mediafile',
    'Tag',
    'User',
    'Workflow',
    'Agenda',
    'ErrorMessage',
    function($scope, $state, gettext, gettextCatalog, operator, Motion, MotionForm, parentMotion,
        paragraphNo, paragraphTextPre, Category, Config, Mediafile, Tag, User, Workflow,
        Agenda, ErrorMessage) {
        Category.bindAll({}, $scope, 'categories');
        Mediafile.bindAll({}, $scope, 'mediafiles');
        Tag.bindAll({}, $scope, 'tags');
        User.bindAll({}, $scope, 'users');
        Workflow.bindAll({}, $scope, 'workflows');

        $scope.model = {
            agenda_type: parseInt(Config.get('agenda_new_items_default_visibility').value),
        };

        $scope.alert = {};

        // Check whether this is a new amendment.
        var isAmendment = parentMotion && parentMotion.id,
            isParagraphBasedAmendment = false;

        // Set default values for create form
        // ... for amendments add parent_id
        if (isAmendment) {
            if (Config.get('motions_amendments_text_mode').value === 'fulltext') {
                $scope.model.text = parentMotion.getText();
            }
            if (Config.get('motions_amendments_text_mode').value === 'paragraph' &&
                paragraphNo !== undefined) {
                var paragraphs = parentMotion.getTextParagraphs(parentMotion.active_version, false);
                $scope.model.text = paragraphs[paragraphNo];
                isParagraphBasedAmendment = true;
            }
            if (paragraphTextPre !== undefined) {
                $scope.model.text = paragraphTextPre;
            }
            if (parentMotion.identifier) {
                $scope.model.title = gettextCatalog.getString('Amendment to') +
                    ' ' + parentMotion.identifier;
            } else {
                $scope.model.title = gettextCatalog.getString('Amendment to motion ') +
                    ' ' + parentMotion.getTitle();
            }
            $scope.model.paragraphNo = paragraphNo;
            $scope.model.parent_id = parentMotion.id;
            $scope.model.category_id = parentMotion.category_id;
            $scope.model.motion_block_id = parentMotion.motion_block_id;
            Motion.bindOne($scope.model.parent_id, $scope, 'parent');
        }
        // ... preselect default workflow if exist
        var workflow = Workflow.get(Config.get('motions_workflow').value);
        if (!workflow) {
            workflow = _.first(Workflow.getAll());
        }
        if (workflow) {
            $scope.model.workflow_id = workflow.id;
        } else {
            $scope.alert = {
                type: 'danger',
                msg: gettextCatalog.getString('No workflows exists. You will not ' +
                    'be able to create a motion.'),
                show: true,
            };
        }

        // get all form fields
        $scope.formFields = MotionForm.getFormFields(true, isParagraphBasedAmendment);

        // save motion
        $scope.save = function (motion, gotoDetailView) {
            if (isAmendment && motion.paragraphNo !== undefined) {
                var orig_paragraphs = parentMotion.getTextParagraphs(parentMotion.active_version, false);
                motion.amendment_paragraphs = orig_paragraphs.map(function (_, idx) {
                    return (idx === motion.paragraphNo ? motion.text : null);
                });
            }

            // The attribute motion.agenda_parent_id is set by the form, see form definition.
            Motion.create(motion).then(
                function(success) {
                    if (isAmendment || gotoDetailView) {
                        $state.go('motions.motion.detail', {id: success.id});
                    }
                    $scope.closeThisDialog();
                },
                function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('MotionUpdateCtrl', [
    '$scope',
    '$state',
    'Motion',
    'Category',
    'Config',
    'Mediafile',
    'MotionForm',
    'Tag',
    'User',
    'Workflow',
    'Agenda',
    'motionId',
    'operator',
    'ErrorMessage',
    'EditingWarning',
    function ($scope, $state, Motion, Category, Config, Mediafile, MotionForm,
        Tag, User, Workflow, Agenda, motionId, operator, ErrorMessage,
        EditingWarning) {
        Category.bindAll({}, $scope, 'categories');
        Mediafile.bindAll({}, $scope, 'mediafiles');
        Tag.bindAll({}, $scope, 'tags');
        User.bindAll({}, $scope, 'users');
        Workflow.bindAll({}, $scope, 'workflows');
        $scope.alert = {};

        // set initial values for form model by create deep copy of motion object
        // so list/detail view is not updated while editing
        var motion = Motion.get(motionId);
        // We need to clone this by hand. angular and lodash are not capable of keeping
        // crossreferences out.
        $scope.model = {
            id: motion.id,
            parent_id: motion.parent_id,
            identifier: motion.identifier,
            title: motion.getTitle(),
            text: motion.getText(),
            reason: motion.getReason(),
            submitters_id: _.map(motion.submitters_id),
            supporters_id: _.map(motion.supporters_id),
            tags_id: _.map(motion.tags_id),
            state_id: motion.state_id,
            recommendation_id: motion.recommendation_id,
            origin: motion.origin,
            workflow_id: motion.workflow_id,
            comments: _.clone(motion.comments),
            attachments_id: _.map(motion.attachments_id),
            active_version: motion.active_version,
            agenda_item_id: motion.agenda_item_id,
            category_id: motion.category_id,
            motion_block_id: motion.motion_block_id,
        };
        // Clone comments
        _.forEach(motion.comments, function (comment, index) {
            $scope.model['comment_' + index] = comment;
        });
        $scope.model.disable_versioning = false;
        $scope.model.more = false;
        if (motion.isParagraphBasedAmendment()) {
            motion.getVersion(motion.active_version).amendment_paragraphs.forEach(function(paragraph_amend, paragraphNo) {
                // Hint: this assumes there is only one modified paragraph
                if (paragraph_amend !== null) {
                    $scope.model.text = paragraph_amend;
                    $scope.model.paragraphNo = paragraphNo;
                }
            });
            $scope.model.title = motion.getTitle();
        }

        // get all form fields
        $scope.formFields = MotionForm.getFormFields(false, motion.isParagraphBasedAmendment());
        // override default values for update form
        for (var i = 0; i < $scope.formFields.length; i++) {
            if ($scope.formFields[i].key == "identifier") {
                // show identifier field if the operator has manage permissions
               $scope.formFields[i].hide = !operator.hasPerms('motions.can_manage');
            }
            if ($scope.formFields[i].key == "title") {
                // get title of latest version
                $scope.formFields[i].defaultValue = motion.getTitle(-1);
            }
            if ($scope.formFields[i].key == "text") {
                // get text of latest version
                $scope.formFields[i].defaultValue = motion.getText(-1);
            }
            if ($scope.formFields[i].key == "reason") {
                // get reason of latest version
                $scope.formFields[i].defaultValue = motion.getReason(-1);
            }
            if ($scope.formFields[i].key == "disable_versioning") {
                if (Config.get('motions_allow_disable_versioning').value && motion.state.versioning) {
                    // check current state if versioning is active
                    $scope.formFields[i].hide = false;
                }
            }
            if ($scope.formFields[i].key == "workflow_id") {
               // get saved workflow id from state
               $scope.formFields[i].defaultValue = motion.state.workflow_id;
            }
        }

        // Displaying a warning, if other users edit this motion too
        var editingStoppedCallback = EditingWarning.editingStarted('motion_update_' + motionId);
        $scope.$on('$destroy', editingStoppedCallback);

        // Save motion
        $scope.save = function (model, gotoDetailView) {
            if ($scope.model.paragraphNo !== undefined) {
                var parentMotion = motion.getParentMotion();
                var orig_paragraphs = parentMotion.getTextParagraphs(parentMotion.active_version, false);
                $scope.model.amendment_paragraphs = orig_paragraphs.map(function (_, idx) {
                    return (idx === $scope.model.paragraphNo ? $scope.model.text : null);
                });
            }

            // inject the changed motion (copy) object back into DS store
            Motion.inject(model);
            // save changed motion object on server
            Motion.save(model).then(
                function(success) {
                    if (gotoDetailView) {
                        $state.go('motions.motion.detail', {id: success.id});
                    }
                    $scope.closeThisDialog();
                },
                function (error) {
                    // save error: revert all changes by restore
                    // (refresh) original motion object from server
                    Motion.refresh(model);
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('MotionCommentCtrl', [
    '$scope',
    'Motion',
    'MotionComment',
    'MotionCommentForm',
    'motionId',
    'commentFieldId',
    'gettextCatalog',
    'ErrorMessage',
    function ($scope, Motion, MotionComment, MotionCommentForm, motionId, commentFieldId,
        gettextCatalog, ErrorMessage) {
        $scope.alert = {};

        // set initial values for form model by create deep copy of motion object
        // so list/detail view is not updated while editing
        var motion = Motion.get(motionId);
        $scope.model = angular.copy(motion);
        $scope.formFields = MotionCommentForm.getFormFields(commentFieldId);

        var fields = MotionComment.getNoSpecialCommentsFields();
        var title = gettextCatalog.getString('Edit comment %%comment%% of motion %%motion%%');
        title = title.replace('%%comment%%', fields[commentFieldId].name);
        $scope.title = title.replace('%%motion%%', motion.getTitle());

        $scope.model.title = motion.getTitle(-1);
        $scope.model.text = motion.getText(-1);
        $scope.model.reason = motion.getReason(-1);

        if (motion.isParagraphBasedAmendment()) {
            motion.getVersion(motion.active_version).amendment_paragraphs.forEach(function(paragraph_amend, paragraphNo) {
                // Hint: this assumes there is only one modified paragraph
                if (paragraph_amend !== null) {
                    $scope.model.text = paragraph_amend;
                    $scope.model.paragraphNo = paragraphNo;
                }
            });
        }

        $scope.save = function (motion) {
            if (motion.isParagraphBasedAmendment()) {
                motion.getVersion(motion.active_version).amendment_paragraphs.forEach(function(paragraph_amend, paragraphNo) {
                    // Hint: this assumes there is only one modified paragraph
                    if (paragraph_amend !== null) {
                        $scope.model.text = paragraph_amend;
                        $scope.model.paragraphNo = paragraphNo;
                    }
                });
            }

            // inject the changed motion (copy) object back into DS store
            Motion.inject(motion);
            // save changed motion object on server
            Motion.save(motion).then(
                function(success) {
                    $scope.closeThisDialog();
                },
                function (error) {
                    // save error: revert all changes by restore
                    // (refresh) original motion object from server
                    Motion.refresh(motion);
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('MotionPollUpdateCtrl', [
    '$scope',
    'gettextCatalog',
    'MotionPoll',
    'MotionPollForm',
    'MotionPollDecimalPlaces',
    'motionpollId',
    'voteNumber',
    'ErrorMessage',
    function ($scope, gettextCatalog, MotionPoll, MotionPollForm, MotionPollDecimalPlaces,
        motionpollId, voteNumber, ErrorMessage) {
        // set initial values for form model by create deep copy of motionpoll object
        // so detail view is not updated while editing poll
        var motionpoll = MotionPoll.get(motionpollId);
        $scope.model = angular.copy(motionpoll);
        $scope.voteNumber = voteNumber;
        var precision = MotionPollDecimalPlaces.getPlaces(motionpoll);
        $scope.formFields = MotionPollForm.getFormFields(precision);
        $scope.alert = {};

        // save motionpoll
        $scope.save = function (poll) {
            poll.DSUpdate({
                    motion_id: poll.motion_id,
                    votes: {"Yes": poll.yes, "No": poll.no, "Abstain": poll.abstain},
                    votesvalid: poll.votesvalid,
                    votesinvalid: poll.votesinvalid,
                    votescast: poll.votescast
            })
            .then(function (success) {
                $scope.alert.show = false;
                $scope.closeThisDialog();
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };
    }
])

.controller('MotionSubmitterCtrl', [
    '$scope',
    '$filter',
    '$http',
    'User',
    'Motion',
    'motionId',
    'ErrorMessage',
    function ($scope, $filter, $http, User, Motion, motionId, ErrorMessage) {
        User.bindAll({}, $scope, 'users');
        $scope.submitterSelectBox = {};
        $scope.alert = {};

        $scope.$watch(function () {
            return Motion.lastModified(motionId);
        }, function () {
            $scope.motion = Motion.get(motionId);
            $scope.submitters = $filter('orderBy')($scope.motion.submitters, 'weight');
        });

        $scope.addSubmitter = function (userId) {
            $scope.submitterSelectBox = {};
            $http.post('/rest/motions/motion/' + $scope.motion.id + '/manage_submitters/', {
                'user': userId
            }).then(
                function (success) {
                    $scope.alert.show = false;
                }, function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };

        $scope.removeSubmitter = function (userId) {
            $http.delete('/rest/motions/motion/' + $scope.motion.id + '/manage_submitters/', {
                headers: {'Content-Type': 'application/json'},
                data: JSON.stringify({user: userId})
            }).then(
                function (success) {
                    $scope.alert.show = false;
                }, function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };

        // save reordered list of submitters
        $scope.treeOptions = {
            dropped: function (event) {
                var submitterIds = _.map($scope.submitters, function (submitter) {
                    return submitter.id;
                });
                $http.post('/rest/motions/motion/' + $scope.motion.id + '/sort_submitters/', {
                    submitters: submitterIds,
                });
            }
        };
    }
])

.controller('MotionAmendmentListStateCtrl', [
    '$scope',
    'motionId',
    function ($scope, motionId) {
        $scope.motionId = motionId;
        $scope.osTablePrefix = 'AmendmentTable';
    }
])

.controller('MotionAmendmentListCtrl', [
    '$scope',
    '$sessionStorage',
    '$state',
    'Motion',
    'MotionComment',
    'MotionForm',
    'PersonalNoteManager',
    'ngDialog',
    'MotionCommentForm',
    'MotionChangeRecommendation',
    'MotionPdfExport',
    'AmendmentCsvExport',
    'gettextCatalog',
    'gettext',
    function ($scope, $sessionStorage, $state, Motion, MotionComment, MotionForm,
        PersonalNoteManager, ngDialog, MotionCommentForm, MotionChangeRecommendation,
        MotionPdfExport, AmendmentCsvExport, gettextCatalog, gettext) {
        if ($scope.motionId) {
            $scope.leadMotion = Motion.get($scope.motionId);
        }

        var updateMotions = function () {
            // check, if lead motion is given
            var amendments;
            if ($scope.leadMotion) {
                amendments = Motion.filter({parent_id: $scope.leadMotion.id});
            } else {
                amendments = _.filter(Motion.getAll(), function (motion) {
                    return motion.parent_id;
                });
            }
            // always order by identifier (after custom ordering)
            $scope.amendments = _.orderBy(amendments, ['identifier']);

            _.forEach($scope.amendments, function (amendment) {
                MotionComment.populateFields(amendment);
                amendment.personalNote = PersonalNoteManager.getNote(amendment);
                // For filtering, we cannot filter for .personalNote.star
                amendment.star = amendment.personalNote ? amendment.personalNote.star : false;
                amendment.hasPersonalNote = amendment.personalNote ? !!amendment.personalNote.note : false;
                if (amendment.star === undefined) {
                    amendment.star = false;
                }

                // add a custom sort attribute
                var parentMotion = amendment.getParentMotion();
                amendment.parentMotionAndLineNumber = parentMotion.identifier;
                if (amendment.isParagraphBasedAmendment()) {
                    var paragraphs = amendment.getAmendmentParagraphsLinesDiff();
                    var diffLine = '0';
                    if (paragraphs.length) {
                        diffLine = '' + paragraphs[0].diffLineFrom;
                    }
                    while (diffLine.length < 6) {
                        diffLine = '0' + diffLine;
                    }
                    amendment.parentMotionAndLineNumber += ' ' + diffLine;
                }
            });

            // Get all lead motions
            $scope.leadMotions = _.orderBy(Motion.filter({parent_id: undefined}), ['identifier']);

            //updateCollissions();
        };

        var updateCollissions = function () {
            $scope.collissions = {};
            _.forEach($scope.amendments, function (amendment) {
                if (amendment.isParagraphBasedAmendment()) {
                    var parentMotion = amendment.getParentMotion();
                    // get all change recommendations _and_ changes by amendments from the
                    // parent motion. From all get the unified change object.
                    var parentChangeRecommendations = _.filter(
                        MotionChangeRecommendation.filter({
                            'where': {'motion_version_id': {'==': parentMotion.active_version}}
                        }), function (change) {
                            return change.isTextRecommendation();
                        }
                    );
                    var parentChanges = parentChangeRecommendations.map(function (cr) {
                        return cr.getUnifiedChangeObject();
                    }).concat(
                        _.map(parentMotion.getParagraphBasedAmendmentsForDiffView(), function (amendment) {
                            return amendment.getUnifiedChangeObject();
                        })
                    );
                    var change = amendment.getUnifiedChangeObject();
                    if (change) {
                        change.setOtherChangesForCollission(parentChanges);
                        $scope.collissions[amendment.id] = !!change.getCollissions().length;
                    }
                }
            });
        };

        //$scope.$watch(function () {
        //    return MotionChangeRecommendation.lastModified();
        //}, updateCollissions);

        $scope.$watch(function () {
            return Motion.lastModified();
        }, updateMotions);

        $scope.selectLeadMotion = function (motion) {
            $scope.leadMotion = motion;
            updateMotions();
            if ($scope.leadMotion) {
                $state.transitionTo('motions.motion.amendment-list',
                    {id: $scope.leadMotion.id},
                    {notify: false}
                );
            } else {
                $state.transitionTo('motions.motion.allamendments', {},
                    {notify: false}
                );
            }
        };

        // Save expand state so the session
        if ($sessionStorage.amendmentTableExpandState) {
            $scope.toggleExpandContent();
        }
        $scope.saveExpandState = function (state) {
            $sessionStorage.amendmentTableExpandState = state;
        };

        // add custom sorting
        $scope.sortOptions.unshift({
            name: 'parentMotionAndLineNumber',
            display_name: gettext('Parent motion and line number'),
        });
        if (!$scope.sort.column || $scope.sort.column === 'identifier') {
            $scope.sort.column = 'parentMotionAndLineNumber';
        }

        $scope.isTextExpandable = function (comment, characters) {
            comment = $(comment).text();
            return comment.length > characters;
        };
        $scope.getTextPreview = function (comment, characters) {
            comment = $(comment).text();
            if (comment.length > characters) {
                comment = comment.substr(0, characters) + '...';
            }
            return comment;
        };
        $scope.editComment = function (motion, fieldId) {
            ngDialog.open(MotionCommentForm.getDialog(motion, fieldId));
        };

        $scope.createModifiedAmendment = function (amendment) {
            var paragraphNo,
                paragraphText;
            if (amendment.isParagraphBasedAmendment()) {
                // We assume there is only one affected paragraph
                amendment.getVersion(amendment.active_version).amendment_paragraphs.forEach(function(parText, parNo) {
                    if (parText !== null) {
                        paragraphNo = parNo;
                        paragraphText = parText;
                    }
                });
            } else {
                paragraphText = amendment.getText();
            }
            ngDialog.open(MotionForm.getDialog(null, amendment.getParentMotion(), paragraphNo, paragraphText));
        };

        $scope.amendmentPdfExport = function (motions) {
            var filename;
            if ($scope.leadMotion) {
                filename = gettextCatalog.getString('Amendments to') + ' ' +
                    $scope.leadMotion.getTitle();
            } else {
                filename = gettextCatalog.getString('Amendments');
            }
            filename += '.pdf';
            MotionPdfExport.exportAmendments(motions, filename);
        };

        $scope.exportCsv = function (motions) {
            AmendmentCsvExport.export(motions);
        };
    }
])

.controller('MotionImportCtrl', [
    '$scope',
    '$q',
    'gettext',
    'Category',
    'Motion',
    'MotionBlock',
    'User',
    'MotionCsvExport',
    function ($scope, $q, gettext, Category, Motion, MotionBlock, User, MotionCsvExport) {
        // set initial data for csv import
        $scope.motions = [];

        // set csv
        $scope.csvConfig = {
            accept: '.csv, .txt',
            encodingOptions: ['UTF-8', 'ISO-8859-1'],
            parseConfig: {
                skipEmptyLines: true,
            },
        };

        var FIELDS = ['identifier', 'title', 'text', 'reason', 'submitter', 'category', 'origin', 'motionBlock'];
        $scope.motions = [];
        $scope.onCsvChange = function (csv) {
            $scope.motions = [];
            var motions = [];
            _.forEach(csv.data, function (row) {
                if (row.length >= 3) {
                    var filledRow = _.zipObject(FIELDS, row);
                    motions.push(filledRow);
                }
            });

            _.forEach(motions, function (motion) {
                motion.selected = true;
                // identifier
                if (motion.identifier !== '') {
                    // All motion objects are already loaded via the resolve statement from ui-router.
                    var motions = Motion.getAll();
                    if (_.find(motions, function (item) {
                        return item.identifier === motion.identifier;
                    })) {
                        motion.importerror = true;
                        motion.identifier_error = gettext('Error: Identifier already exists.');
                    }
                }
                // title
                if (!motion.title) {
                    motion.importerror = true;
                    motion.title_error = gettext('Error: Title is required.');
                }
                // text
                if (!motion.text) {
                    motion.importerror = true;
                    motion.text_error = gettext('Error: Text is required.');
                } else if (!motion.text.startsWith('<p>')) {
                    motion.text = '<p>' + motion.text + '</p>';
                }
                // Reason
                if (motion.reason && !motion.reason.startsWith('<p>')) {
                    motion.reason = '<p>' + motion.reason + '</p>';
                }
                // submitter
                if (motion.submitter && motion.submitter !== '') {
                    _.forEach(User.getAll(), function (user) {
                        var user_short_name = [user.title, user.first_name, user.last_name].join(' ').trim();
                        if (user_short_name == motion.submitter.trim()) {
                            motion.submitters_id = [user.id];
                            motion.submitter = user.full_name;
                        }
                    });
                    if (!motion.submitters_id) {
                        motion.submitter_create = gettext('New participant will be created.');
                    }
                }
                // category
                if (motion.category && motion.category !== '') {
                    angular.forEach(Category.getAll(), function (category) {
                        // search for existing category
                        if (category.name == motion.category.trim()) {
                            motion.category_id = category.id;
                            motion.category = category.name;
                        }
                    });
                    if (!motion.category_id) {
                        motion.category_create = gettext('New category will be created.');
                    }
                }
                // Motion block
                if (motion.motionBlock && motion.motionBlock !== '') {
                    angular.forEach(MotionBlock.getAll(), function (block) {
                        // search for existing block
                        if (block.title == motion.motionBlock.trim()) {
                            motion.motion_block_id = block.id;
                            motion.motionBlock = block.title;
                        }
                    });
                    if (!motion.motion_block_id) {
                        motion.motionBlock_create = gettext('New motion block will be created.');
                    }
                }

                $scope.motions.push(motion);
            });
            $scope.calcStats();
        };

        $scope.calcStats = function () {
            $scope.motionsWillNotBeImported = 0;
            $scope.motionsWillBeImported = 0;

            $scope.motions.forEach(function(motion) {
                if (!motion.importerror && motion.selected) {
                    $scope.motionsWillBeImported++;
                } else {
                    $scope.motionsWillNotBeImported++;
                }
            });
        };

        // Counter for creations
        $scope.usersCreated = 0;
        $scope.categoriesCreated = 0;

        // import from csv file
        $scope.import = function () {
            $scope.csvImporting = true;

            // Reset counters
            $scope.usersCreated = 0;
            $scope.categoriesCreated = 0;
            $scope.motionBlocksCreated = 0;

            var importedUsers = [];
            var importedCategories = [];
            var importedMotionBlocks = [];
            // collect users, categories and motion blocks
            angular.forEach($scope.motions, function (motion) {
                if (motion.selected && !motion.importerror) {
                    // collect user if not exists
                    if (!motion.submitters_id && motion.submitter) {
                        var index = motion.submitter.indexOf(' ');
                        var user = {
                            first_name: motion.submitter.substr(0, index),
                            last_name: motion.submitter.substr(index+1),
                            groups_id: []
                        };
                        importedUsers.push(user);
                    }
                    // collect category if not exists
                    if (!motion.category_id && motion.category) {
                        var category = {
                            name: motion.category,
                            prefix: motion.category.charAt(0)
                        };
                        importedCategories.push(category);
                    }
                    // collect motion block if not exists
                    if (!motion.motion_block_id && motion.motionBlock) {
                        var motionBlock = {
                            title: motion.motionBlock,
                        };
                        importedMotionBlocks.push(motionBlock);
                    }
                }
            });

            // unique users, categories and motion blocks
            var importedUsersUnique = _.uniqWith(importedUsers, function (u1, u2) {
                return u1.first_name == u2.first_name &&
                    u1.last_name == u2.last_name;
            });
            var importedCategoriesUnique = _.uniqWith(importedCategories, function (c1, c2) {
                return c1.name == c2.name;
            });
            var importedMotionBlocksUnique = _.uniqWith(importedMotionBlocks, function (c1, c2) {
                return c1.title == c2.title;
            });

            // Promises for users and categories
            var createPromises = [];

            // create users and categories
            _.forEach(importedUsersUnique, function (user) {
                createPromises.push(User.create(user).then(
                    function (success) {
                        user.id = success.id;
                        $scope.usersCreated++;
                    }
                ));
            });
            _.forEach(importedCategoriesUnique, function (category) {
                createPromises.push(Category.create(category).then(
                    function (success) {
                        category.id = success.id;
                        $scope.categoriesCreated++;
                    }
                ));
            });
            _.forEach(importedMotionBlocksUnique, function (motionBlock) {
                createPromises.push(MotionBlock.create(motionBlock).then(
                    function (success) {
                        motionBlock.id = success.id;
                        $scope.motionBlocksCreated++;
                    }
                ));
            });

            // wait for users and categories to create
            $q.all(createPromises).then( function() {
                angular.forEach($scope.motions, function (motion) {
                    if (motion.selected && !motion.importerror) {
                        // now, add user
                        if (!motion.submitters_id && motion.submitter) {
                            var index = motion.submitter.indexOf(' ');
                            var first_name = motion.submitter.substr(0, index);
                            var last_name = motion.submitter.substr(index+1);

                            // search for user, set id.
                            _.forEach(importedUsersUnique, function (user) {
                                if (user.first_name == first_name &&
                                    user.last_name == last_name) {
                                    motion.submitters_id = [user.id];
                                }
                            });
                        }
                        // add category
                        if (!motion.category_id && motion.category) {
                            var name = motion.category;

                            // search for category, set id.
                            _.forEach(importedCategoriesUnique, function (category) {
                                if (category.name == name) {
                                    motion.category_id = category.id;
                                }
                            });
                        }
                        // add motion block
                        if (!motion.motion_block_id && motion.motionBlock) {
                            var title = motion.motionBlock;

                            // search for motion block
                            _.forEach(importedMotionBlocksUnique, function (motionBlock) {
                                if (motionBlock.title == title) {
                                    motion.motion_block_id = motionBlock.id;
                                }
                            });
                        }


                        // finally create motion
                        Motion.create(motion).then(
                            function(success) {
                                motion.imported = true;
                            }
                        );
                    }
                });
            });
            $scope.csvimported = true;
        };
        $scope.clear = function () {
            $scope.motions = [];
        };
        // download CSV example file
        $scope.downloadCSVExample = function () {
            MotionCsvExport.downloadExample();
        };
    }
])

.controller('CategoryListCtrl', [
    '$scope',
    'Category',
    'ngDialog',
    'CategoryForm',
    function($scope, Category, ngDialog, CategoryForm) {
        Category.bindAll({}, $scope, 'categories');

        // setup table sorting
        $scope.sortColumn = 'name';
        $scope.reverse = false;
        // function to sort by clicked column
        $scope.toggleSort = function (column) {
            if ($scope.sortColumn === column) {
                $scope.reverse = !$scope.reverse;
            }
            $scope.sortColumn = column;
        };

        // delete selected category
        $scope.delete = function (category) {
            Category.destroy(category.id);
        };
        $scope.editOrCreate = function (category) {
            ngDialog.open(CategoryForm.getDialog(category));
        };
    }
])

.controller('CategoryCreateCtrl', [
    '$scope',
    'Category',
    'CategoryForm',
    'ErrorMessage',
    function($scope, Category, CategoryForm, ErrorMessage) {
        $scope.model = {};
        $scope.alert = {};
        $scope.formFields = CategoryForm.getFormFields();
        $scope.save = function (category) {
            Category.create(category).then(
                function (success) {
                    $scope.closeThisDialog();
                },
                function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('CategoryUpdateCtrl', [
    '$scope',
    'Category',
    'categoryId',
    'CategoryForm',
    'ErrorMessage',
    function ($scope, Category, categoryId, CategoryForm, ErrorMessage) {
        $scope.alert = {};
        $scope.model = angular.copy(Category.get(categoryId));
        $scope.formFields = CategoryForm.getFormFields();
        $scope.save = function (category) {
            Category.inject(category);
            Category.save(category).then(
                function (success) {
                    $scope.closeThisDialog();
                },
                function (error) {
                    // save error: revert all changes by restore
                    // (refresh) original category object from server
                    Category.refresh(category);
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('CategorySortCtrl', [
    '$scope',
    '$stateParams',
    '$http',
    'Category',
    'categoryId',
    'Motion',
    'ErrorMessage',
    function ($scope, $stateParams, $http, Category, categoryId, Motion, ErrorMessage) {
        Category.bindOne(categoryId, $scope, 'category');
        Motion.bindAll({}, $scope, 'motions');
        $scope.filter = { category_id: categoryId,
                          parent_id: null,
                          orderBy: 'identifier' };

        $scope.$watch(function () {
            return Motion.lastModified();
        }, function () {
            var motions = Motion.filter($scope.filter);
            $scope.items = _.map(motions, function (motion) {
                return {
                    id: motion.id,
                    item: motion
                };
            });
        });

        $scope.alert = {};
        // Numbers all motions in this category by the given order in $scope.items
        $scope.numbering = function () {
            // Create a list of all motion ids in the current order.
            var sorted_motions = [];
            $scope.items.forEach(function (item) {
                sorted_motions.push(item.item.id);
            });

            // renumber them
            $http.post('/rest/motions/category/' + $scope.category.id + '/numbering/',
                {'motions': sorted_motions} ).then(
            function (success) {
                $scope.alert = { type: 'success', msg: success.data.detail, show: true };
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };
    }
])

//mark all motions config strings for translation in javascript
.config([
    'gettext',
    function (gettext) {
        gettext('Motions');

        // subgroup General
        gettext('General');
        gettext('Workflow of new motions');
        gettext('Identifier');
        gettext('Numbered per category');
        gettext('Serially numbered');
        gettext('Set it manually');
        gettext('Motion preamble');
        gettext('The assembly may decide:');
        gettext('Default line numbering');
        /// Line numbering: Outside
        gettext('Outside');
        /// Line numbering: Inline
        gettext('Inline');
        /// Line numbering: None
        gettext('None');
        gettext('Line length');
        gettext('The maximum number of characters per line. Relevant when line numbering is enabled. Min: 40');
        gettext('Hide reason on projector');
        gettext('Hide meta information box on projector');
        gettext('Hide recommendation on projector');
        gettext('Stop submitting new motions by non-staff users');
        gettext('Allow to disable versioning');
        gettext('Name of recommender');
        gettext('Default text version for change recommendations');
        gettext('Will be displayed as label before selected recommendation. Use an empty value to disable the recommendation system.');
        gettext('Edit comment %%comment%% of motion %%motion%%');

        // subgroup Amendments
        gettext('Amendments');
        gettext('Activate amendments');
        gettext('Show amendments together with motions');
        gettext('Prefix for the identifier for amendments');
        gettext('Apply text for new amendments');
        gettext('The title of the motion is always applied.');
        gettext('Amendment to');
        gettext('How to create new amendments');
        gettext('Empty text field');
        gettext('Edit the whole motion text');
        gettext('Paragraph-based, Diff-enabled');

        // subgroup Supporters
        gettext('Supporters');
        gettext('Number of (minimum) required supporters for a motion');
        gettext('Choose 0 to disable the supporting system.');
        gettext('Remove all supporters of a motion if a submitter edits his ' +
                'motion in early state');

        // subgroup Supporters
        gettext('Comments');
        gettext('Comment fields for motions');
        gettext('Public');
        gettext('Private');

        // subgroup Voting and ballot papers
        gettext('Voting and ballot papers');
        gettext('The 100 % base of a voting result consists of');
        gettext('Yes/No/Abstain');
        gettext('Yes/No');
        gettext('All valid ballots');
        gettext('All casted ballots');
        gettext('Disabled (no percents)');
        gettext('Required majority');
        gettext('Default method to check whether a motion has reached the required majority.');
        gettext('Simple majority');
        gettext('Two-thirds majority');
        gettext('Three-quarters majority');
        gettext('Disabled');
        gettext('Number of ballot papers (selection)');
        gettext('Number of all delegates');
        gettext('Number of all participants');
        gettext('Use the following custom number');
        gettext('Custom number of ballot papers');

        // subgroup PDF and DOCX
        gettext('Title for PDF and DOCX documents (all motions)');
        gettext('Preamble text for PDF and DOCX documents (all motions)');
        gettext('Sort categories by');
        gettext('Include the sequential number in PDF and DOCX');

        // misc strings (used dynamically in templates by translate filter)
        gettext('needed');
        gettext('Amendment');
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.motions.workflow', [])

.controller('WorkflowListCtrl', [
    '$scope',
    'Workflow',
    'ngDialog',
    'ErrorMessage',
    function ($scope, Workflow, ngDialog, ErrorMessage) {
        $scope.alert = {};
        Workflow.bindAll({}, $scope, 'workflows');
        $scope.create = function () {
            ngDialog.open({
                template: 'static/templates/motions/workflow-edit.html',
                controller: 'WorkflowCreateCtrl',
                className: 'ngdialog-theme-default wide-form',
                closeByEscape: false,
                closeByDocument: false,
            });
        };
        $scope.delete = function (workflow) {
            Workflow.destroy(workflow).then(null, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };
    }
])

.controller('WorkflowDetailCtrl', [
    '$scope',
    '$sessionStorage',
    'permissions',
    'Workflow',
    'MotionState',
    'workflowId',
    'ngDialog',
    'gettext',
    'gettextCatalog',
    'ErrorMessage',
    function ($scope, $sessionStorage, permissions, Workflow, MotionState, workflowId,
        ngDialog, gettext, gettextCatalog, ErrorMessage) {
        $scope.permissions = permissions;
        $scope.alert = {};

        $scope.$watch(function () {
            return Workflow.lastModified(workflowId);
        }, function () {
            $scope.workflow = Workflow.get(workflowId);
            $scope.states = $scope.workflow.states;
            $scope.states = _.orderBy($scope.states, 'id');
            _.forEach($scope.states, function (state) {
                state.newActionWord = gettextCatalog.getString(state.action_word);
                state.newRecommendationLabel = gettextCatalog.getString(state.recommendation_label);
            });
        });

        $scope.booleanMembers = [
            {name: 'allow_support',
             displayName: gettext('Allow support'),},
            {name: 'allow_create_poll',
             displayName: gettext('Allow create poll'),},
            {name: 'allow_submitter_edit',
             displayName: gettext('Allow submitter edit'),},
            {name: 'versioning',
             displayName: gettext('Versioning'),},
            {name: 'leave_old_version_active',
             displayName: gettext('Leave old version active'),},
            {name: 'dont_set_identifier',
             displayName: gettext('Set identifier'),
             inverse: true,},
            {name: 'show_state_extension_field',
             displayName: gettext('Show state extension field'),},
            {name: 'show_recommendation_extension_field',
             displayName: gettext('Show recommendation extension field'),}
        ];
        $scope.cssClasses = {
            'danger': gettext('Red'),
            'success': gettext('Green'),
            'warning': gettext('Yellow'),
            'default': gettext('Grey'),
            'primary': gettext('Blue'),
        };
        $scope.getPermissionDisplayName = function (permission) {
            if (permission) {
                return _.find($scope.permissions, function (perm) {
                    return perm.value === permission;
                }).display_name;
            }
        };
        $scope.clickPermission = function (state, permission) {
            state.required_permission_to_see =
                state.required_permission_to_see === permission.value ? '' : permission.value;
            $scope.save(state);
        };
        $scope.xor = function (a, b) {
            return (a && !b) || (!a && b);
        };

        $scope.changeBooleanMember = function (state, memberName) {
            state[memberName] = !state[memberName];
            $scope.save(state);
        };
        $scope.setMember = function (state, member, value) {
            state[member] = value;
            $scope.save(state);
        };
        $scope.clickNextStateEntry = function (state, clickedStateId) {
            var index = state.next_states_id.indexOf(clickedStateId);
            if (index > -1) { // remove now
                state.next_states_id.splice(index, 1);
            } else { // add
                state.next_states_id.push(clickedStateId);
            }
            $scope.save(state);
        };
        $scope.save = function (state) {
            MotionState.save(state).then(null, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };

        // Save expand state so the session
        if ($sessionStorage.motionStateTableExpandState) {
            $scope.toggleExpandContent();
        }
        $scope.saveExpandState = function (state) {
            $sessionStorage.motionStateTableExpandState = state;
        };

        $scope.openStateDialog = function (state) {
            ngDialog.open({
                template: 'static/templates/motions/state-edit.html',
                controller: state ? 'StateRenameCtrl' : 'StateCreateCtrl',
                className: 'ngdialog-theme-default wide-form',
                closeByEscape: false,
                closeByDocument: false,
                resolve: {
                    state: function () {return state;},
                    workflow: function () {return $scope.workflow;},
                }
            });
        };
        $scope.openWorkflowDialog = function () {
            ngDialog.open({
                template: 'static/templates/motions/workflow-edit.html',
                controller: 'WorkflowRenameCtrl',
                className: 'ngdialog-theme-default wide-form',
                closeByEscape: false,
                closeByDocument: false,
                resolve: {
                    workflow: function () {return $scope.workflow;},
                }
            });
        };

        $scope.delete = function (state) {
            MotionState.destroy(state).then(null, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };
    }
])

.controller('WorkflowCreateCtrl', [
    '$scope',
    'Workflow',
    'ErrorMessage',
    function ($scope, Workflow, ErrorMessage) {
        $scope.save = function () {
            var workflow = {
                name: $scope.newName,
            };
            Workflow.create(workflow).then(function (success) {
                $scope.closeThisDialog();
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };
    }
])

.controller('WorkflowRenameCtrl', [
    '$scope',
    'workflow',
    'Workflow',
    'gettextCatalog',
    'ErrorMessage',
    function ($scope, workflow, Workflow, gettextCatalog, ErrorMessage) {
        $scope.workflow = workflow;
        $scope.newName = gettextCatalog.getString(workflow.name);
        $scope.save = function () {
            workflow.name = $scope.newName;
            Workflow.save(workflow).then(function (success) {
                $scope.closeThisDialog();
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };
    }
])

.controller('StateCreateCtrl', [
    '$scope',
    'workflow',
    'MotionState',
    'ErrorMessage',
    function ($scope, workflow, MotionState, ErrorMessage) {
        $scope.newName = '';
        $scope.actionWord = '';
        $scope.save = function () {
            var state = {
                name: $scope.newName,
                action_word: $scope.actionWord,
                workflow_id: workflow.id,
                allow_create_poll: true,
                allow_support: true,
                allow_submitter_edit: true,
            };
            MotionState.create(state).then(function () {
                $scope.closeThisDialog();
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };
    }
])

.controller('StateRenameCtrl', [
    '$scope',
    'MotionState',
    'state',
    'gettextCatalog',
    'ErrorMessage',
    function ($scope, MotionState, state, gettextCatalog, ErrorMessage) {
        $scope.state = state;
        $scope.newName = gettextCatalog.getString(state.name);
        $scope.actionWord = gettextCatalog.getString(state.action_word);
        $scope.save = function () {
            state.name = $scope.newName;
            state.action_word = $scope.actionWord;
            MotionState.save(state).then(function () {
                $scope.closeThisDialog();
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.poll.majority', [])

.value('MajorityMethodChoices', [
    {'value': 'simple_majority', 'display_name': 'Simple majority'},
    {'value': 'two-thirds_majority', 'display_name': 'Two-thirds majority'},
    {'value': 'three-quarters_majority', 'display_name': 'Three-quarters majority'},
    {'value': 'disabled', 'display_name': 'Disabled'},
])

.factory('MajorityMethods', [
    function () {
        return {
            'simple_majority': function (vote, base) {
                return Math.ceil(-(base / 2 - vote)) - 1;
            },
            'two-thirds_majority': function (vote, base) {
                var result = -(base * 2 - vote * 3) / 3;
                if (result % 1 !== 0) {
                    result = Math.ceil(result) - 1;
                }
                return result;
            },
            'three-quarters_majority': function (vote, base) {
                var result = -(base * 3 - vote * 4) / 4;
                if (result % 1 !== 0) {
                    result = Math.ceil(result) - 1;
                }
                return result;
            },
            'disabled': function () {
                return undefined;
            },
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.topics', [])

.factory('Topic', [
    'DS',
    'jsDataModel',
    'gettext',
    function(DS, jsDataModel, gettext) {
        var name = 'topics/topic';
        return DS.defineResource({
            name: name,
            useClass: jsDataModel,
            verboseName: gettext('Topic'),
            methods: {
                getResourceName: function () {
                    return name;
                },
                getAgendaTitle: function () {
                    return this.title;
                },
                getCSVExportText: function () {
                    return this.text;
                },
            },
            relations: {
                belongsTo: {
                    'agenda/item': {
                        localKey: 'agenda_item_id',
                        localField: 'agenda_item',
                    }
                },
                hasMany: {
                    'mediafiles/mediafile': {
                        localField: 'attachments',
                        localKeys: 'attachments_id',
                    }
                }
            }
        });
    }
])

.run(['Topic', function(Topic) {}]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.topics.csv', [])

.factory('TopicsCsvExample', [
    'gettextCatalog',
    'CsvDownload',
    function (gettextCatalog, CsvDownload) {
        var makeHeaderline = function () {
            var headerline = ['Title', 'Text', 'Duration', 'Comment', 'Internal item'];
            return _.map(headerline, function (entry) {
                return gettextCatalog.getString(entry);
            });
        };
        return {
            downloadExample: function () {
                var csvRows = [makeHeaderline(),
                    // example entries
                    ['Demo 1', 'Demo text 1', '1:00', 'test comment', ''],
                    ['Break', '', '0:10', '', '1'],
                    ['Demo 2', 'Demo text 2', '1:30', '', '']

                ];
                CsvDownload(csvRows, gettextCatalog.getString('agenda-example') + '.csv');
            },
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.topics.projector', ['OpenSlidesApp.topics'])

.config([
    'slidesProvider',
    function (slidesProvider) {
        slidesProvider.registerSlide('topics/topic', {
            template: 'static/templates/topics/slide_topic.html'
        });
    }
])

.controller('SlideTopicCtrl', [
    '$scope',
    'Topic',
    function($scope, Topic) {
        // Attention! Each object that is used here has to be dealt on server side.
        // Add it to the coresponding get_requirements method of the ProjectorElement
        // class.
        var id = $scope.element.id;
        Topic.bindOne(id, $scope, 'topic');
    }
]);

})();

(function () {

'use strict';

angular.module('OpenSlidesApp.topics.site', ['OpenSlidesApp.topics', 'OpenSlidesApp.topics.csv'])

.config([
    '$stateProvider',
    'gettext',
    function($stateProvider, gettext) {
        $stateProvider
            .state('topics', {
                url: '/topics',
                abstract: true,
                template: "<ui-view/>",
                data: {
                    title: gettext('Topics'),
                },
            })
            .state('topics.topic', {
                abstract: true,
                template: "<ui-view/>",
            })
            .state('topics.topic.detail', {
                resolve: {
                    topicId: ['$stateParams', function($stateParams) {
                        return $stateParams.id;
                    }],
                }
            })
            // redirects to topic detail and opens topic edit form dialog, uses edit url,
            // used by ui-sref links from agenda only
            // (from topic controller use TopicForm factory instead to open dialog in front
            // of current view without redirect)
            .state('topics.topic.detail.update', {
                onEnter: ['$stateParams', '$state', 'ngDialog',
                    function($stateParams, $state, ngDialog) {
                        ngDialog.open({
                            template: 'static/templates/topics/topic-form.html',
                            controller: 'TopicUpdateCtrl',
                            className: 'ngdialog-theme-default wide-form',
                            closeByEscape: false,
                            closeByDocument: false,
                            resolve: {
                                topicId: function() {
                                    return $stateParams.id;
                                },
                            },
                            preCloseCallback: function() {
                                $state.go('topics.topic.detail', {topic: $stateParams.id});
                                return true;
                            }
                        });
                    }],
            })
            .state('topics.topic.import', {
                url: '/import',
                controller: 'TopicImportCtrl',
            });
    }
])

.factory('TopicForm', [
    '$filter',
    'gettextCatalog',
    'operator',
    'Editor',
    'Mediafile',
    'Agenda',
    'AgendaTree',
    'ShowAsAgendaItemField',
    function ($filter, gettextCatalog, operator, Editor, Mediafile, Agenda,
        AgendaTree, ShowAsAgendaItemField) {
        return {
            // ngDialog for topic form
            getDialog: function (topic) {
                return {
                    template: 'static/templates/topics/topic-form.html',
                    controller: (topic) ? 'TopicUpdateCtrl' : 'TopicCreateCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        topicId: function () {return topic ? topic.id: void 0;}
                    },
                };
            },
            getFormFields: function (isCreateForm) {
                var images = Mediafile.getAllImages();
                var formFields = [
                {
                    key: 'title',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Title'),
                        required: true
                    }
                },
                {
                    key: 'text',
                    type: 'editor',
                    templateOptions: {
                        label: gettextCatalog.getString('Text')
                    },
                    data: {
                        ckeditorOptions: Editor.getOptions(images)
                    }
                }];
                // attachments
                if (Mediafile.getAll().length > 0) {
                    formFields.push({
                        key: 'attachments_id',
                        type: 'select-multiple',
                        templateOptions: {
                            label: gettextCatalog.getString('Attachment'),
                            options: $filter('orderBy')(Mediafile.getAll(), 'title_or_filename'),
                            ngOptions: 'option.id as option.title_or_filename for option in to.options',
                            placeholder: gettextCatalog.getString('Select or search an attachment ...')
                        }
                    });
                }

                // show as agenda item + parent item
                if (isCreateForm) {
                    formFields.push(ShowAsAgendaItemField('agenda.can_manage'));
                    formFields.push({
                        key: 'agenda_parent_id',
                        type: 'select-single',
                        templateOptions: {
                            label: gettextCatalog.getString('Parent item'),
                            options: AgendaTree.getFlatTree(Agenda.getAll()),
                            ngOptions: 'item.id as item.getListViewTitle() for item in to.options | notself : model.agenda_item_id',
                            placeholder: gettextCatalog.getString('Select a parent item ...')
                        },
                        hide: !operator.hasPerms('agenda.can_manage')
                    });
                }

                return formFields;
            }
        };
    }
])

.controller('TopicDetailCtrl', [
    '$scope',
    'ngDialog',
    'TopicForm',
    'Topic',
    'topicId',
    'Projector',
    'ProjectionDefault',
    'WebpageTitle',
    'gettextCatalog',
    function($scope, ngDialog, TopicForm, Topic, topicId, Projector, ProjectionDefault, WebpageTitle,
        gettextCatalog) {
        $scope.$watch(function () {
            return Topic.lastModified(topicId);
        }, function () {
            $scope.topic = Topic.get(topicId);
            WebpageTitle.updateTitle(gettextCatalog.getString('Topic') + ' ' +
                $scope.topic.agenda_item.getTitle());
        });
        $scope.$watch(function () {
            return Projector.lastModified();
        }, function () {
            var projectiondefault = ProjectionDefault.filter({name: 'topics'})[0];
            if (projectiondefault) {
                $scope.defaultProjectorId = projectiondefault.projector_id;
            }
        });
        $scope.openDialog = function (topic) {
            ngDialog.open(TopicForm.getDialog(topic));
        };
    }
])

.controller('TopicCreateCtrl', [
    '$scope',
    '$state',
    'Topic',
    'TopicForm',
    'Agenda',
    'Config',
    'ErrorMessage',
    function($scope, $state, Topic, TopicForm, Agenda, Config, ErrorMessage) {
        $scope.model = {
            agenda_type: 1,  // Default is a public item. The config field
                             // 'agenda_new_items_default_visibility' is not used.
        };
        // get all form fields
        $scope.formFields = TopicForm.getFormFields(true);
        // save form
        $scope.save = function (topic) {
            Topic.create(topic).then(
                function (success) {
                    $scope.closeThisDialog();
                }, function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('TopicUpdateCtrl', [
    '$scope',
    '$state',
    'Topic',
    'TopicForm',
    'Agenda',
    'topicId',
    'ErrorMessage',
    function($scope, $state, Topic, TopicForm, Agenda, topicId, ErrorMessage) {
        var topic = Topic.get(topicId);
        $scope.alert = {};
        // set initial values for form model by create deep copy of topic object
        // so list/detail view is not updated while editing
        $scope.model = angular.copy(topic);
        // get all form fields
        $scope.formFields = TopicForm.getFormFields();

        // save form
        $scope.save = function (topic) {
            // inject the changed topic (copy) object back into DS store
            Topic.inject(topic);
            // save changed topic object on server
            Topic.save(topic).then(
                function(success) {
                    $scope.closeThisDialog();
                },
                function (error) {
                    // save error: revert all changes by restore
                    // (refresh) original topic object from server
                    Topic.refresh(topic);
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('TopicImportCtrl', [
    '$scope',
    'gettext',
    'Agenda',
    'Topic',
    'HumanTimeConverter',
    'TopicsCsvExample',
    function($scope, gettext, Agenda, Topic, HumanTimeConverter, TopicsCsvExample) {
        // Big TODO: Change wording from "item" to "topic".
        // import from textarea
        $scope.importByLine = function () {
            if ($scope.itemlist) {
                $scope.titleItems = _.filter($scope.itemlist[0].split("\n"));
                $scope.importcounter = 0;
                _.forEach($scope.titleItems, function(title, index) {
                    var item = {title: title};
                    item.agenda_type = 1;  // The new topic is not hidden.
                    item.agenda_weight = 1000 + index;
                    // TODO: create all items in bulk mode
                    Topic.create(item).then(
                        function(success) {
                            $scope.importcounter++;
                        }
                    );
                });
            }
        };

        // *** CSV import ***
        $scope.csvConfig = {
            accept: '.csv, .txt',
            encodingOptions: ['UTF-8', 'ISO-8859-1'],
            parseConfig: {
                skipEmptyLines: true,
            },
        };
        var FIELDS = ['title', 'text', 'duration', 'comment', 'is_hidden'];
        $scope.items = [];
        $scope.onCsvChange = function (csv) {
            $scope.items = [];

            var items = [];
            _.forEach(csv.data, function (row) {
                if (row.length > 1) {
                    var filledRow = _.zipObject(FIELDS, row);
                    items.push(filledRow);
                }
            });

            _.forEach(items, function (item, index) {
                item.selected = true;

                if (!item.title) {
                    item.importerror = true;
                    item.title_error = gettext('Error: Title is required.');
                }
                // duration
                if (item.duration) {
                    var time = HumanTimeConverter.humanTimeToSeconds(item.duration, {hours: true})/60;
                    if (time <= 0) { // null instead of 0 or negative duration
                        time = null;
                    }
                    item.duration = time;
                } else {
                    delete item.duration;
                }
                // is_hidden
                if (item.is_hidden) {
                    if (item.is_hidden == '1') {
                        item.type = 2;
                    } else {
                        item.type = 1;
                    }
                } else {
                    item.type = 1;
                }
                // set weight for right csv row order
                // (Use 1000+ to protect existing items and prevent collision
                // with new items which use weight 10000 as default.)
                item.weight = 1000 + index;
                $scope.items.push(item);
            });
            $scope.calcStats();
        };

        $scope.calcStats = function () {
            $scope.itemsWillNotBeImported = 0;
            $scope.itemsWillBeImported = 0;

            $scope.items.forEach(function(item) {
                if (item.selected && !item.importerror) {
                    $scope.itemsWillBeImported++;
                } else {
                    $scope.itemsWillNotBeImported++;
                }
            });
        };

        // import from csv file
        $scope.import = function () {
            $scope.csvImporting = true;
            angular.forEach($scope.items, function (item) {
                if (item.selected && !item.importerror) {
                    item.agenda_type = item.type;
                    item.agenda_comment = item.comment;
                    item.agenda_duration = item.duration;
                    item.agenda_weight = item.weight;
                    Topic.create(item).then(
                        function(success) {
                            item.imported = true;
                        }
                    );
                }
            });
            $scope.csvimported = true;
        };
        $scope.clear = function () {
            $scope.items = null;
        };
        // download CSV example file
        $scope.downloadCSVExample = function () {
            TopicsCsvExample.downloadExample();
        };
     }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.users', [])

.factory('User', [
    'DS',
    'Group',
    'jsDataModel',
    'gettext',
    'gettextCatalog',
    'Config',
    function(DS, Group, jsDataModel, gettext, gettextCatalog, Config) {
        var name = 'users/user';
        return DS.defineResource({
            name: name,
            useClass: jsDataModel,
            verboseName: gettext('Participants'),
            verboseNamePlural: gettext('Participants'),
            computed: {
                full_name: function () {
                    return this.get_full_name();
                },
                short_name: function () {
                    return this.get_short_name();
                },
            },
            methods: {
                getResourceName: function () {
                    return name;
                },
                /*
                 * Returns a short form of the name.
                 *
                 * Example:
                 * - Dr. Max Mustermann
                 * - Professor Dr. Enders, Christoph
                 */
                get_short_name: function() {
                    var title = _.trim(this.title),
                        firstName = _.trim(this.first_name),
                        lastName = _.trim(this.last_name),
                        name = '';
                    if (Config.get('users_sort_by') && Config.get('users_sort_by').value == 'last_name') {
                        if (lastName && firstName) {
                            name += [lastName, firstName].join(', ');
                        } else {
                            name += lastName || firstName;
                        }
                    } else {
                        name += [firstName, lastName].join(' ');
                    }
                    if (name.trim() === '') {
                        name = this.username;
                    }
                    if (title !== '') {
                        name = title + ' ' + name;
                    }
                    return name.trim();
                },
                /*
                 * Returns a long form of the name.
                 *
                 * Example:
                 * - Dr. Max Mustermann (Villingen)
                 * - Professor Dr. Enders, Christoph (Leipzig)
                 */
                get_full_name: function() {
                    var name = this.get_short_name(),
                        structure_level = _.trim(this.structure_level),
                        number = _.trim(this.number),
                        addition = [];

                    // addition: add number and structure level
                    if (structure_level) {
                        addition.push(structure_level);
                    }
                    if (number) {
                        addition.push(
                            /// abbreviation for number
                            gettextCatalog.getString('No.') + ' ' + number
                        );
                    }
                    if (addition.length > 0) {
                        name += ' (' + addition.join(' · ') + ')';
                    }
                    return name.trim();
                },
                getPerms: function() {
                    var allPerms = [];
                    var allGroups = [];
                    if (this.groups_id) {
                        allGroups = this.groups_id.slice(0);
                    }
                    if (allGroups.length === 0) {
                        allGroups.push(1); // add default group
                    }
                    _.forEach(allGroups, function(groupId) {
                        var group = Group.get(groupId);
                        if (group) {
                            _.forEach(group.permissions, function(perm) {
                                allPerms.push(perm);
                            });
                        }
                    });
                    return _.uniq(allPerms);
                },
                // link name which is shown in search result
                getSearchResultName: function () {
                    return this.get_full_name();
                },
                // subtitle of search result
                getSearchResultSubtitle: function () {
                    return "Participant";
                },
            },
            relations: {
                hasMany: {
                    'users/group': {
                        localField: 'groups',
                        localKey: 'groups_id',
                    }
                }
            }
        });
    }
])

.factory('Group', [
    'DS',
    function(DS) {
        var name = 'users/group';
        var permissions;
        return DS.defineResource({
            name: name,
        });
    }
])

.factory('PersonalNote', [
    'DS',
    function (DS) {
        var name = 'users/personal-note';
        return DS.defineResource({
            name: name,
            relations: {
                hasOne: {
                    'users/user': {
                        localField: 'user',
                        localKey: 'user_id',
                    }
                }
            }
        });
    }
])

.run([
    'User',
    'Group',
    'PersonalNote',
    function(User, Group) {}
])

// Mark strings for translation in JavaScript.
.config([
    'gettext',
    function (gettext) {
        // default group names (from users/signals.py)
        gettext('Default');
        gettext('Delegates');
        gettext('Staff');
        gettext('Committees');
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.users.csv', [])

.factory('UserCsvExport', [
    '$filter',
    'Group',
    'gettextCatalog',
    'CsvDownload',
    function ($filter, Group, gettextCatalog, CsvDownload) {
        var makeHeaderline = function () {
            var headerline = ['Title', 'Given name', 'Surname', 'Structure level', 'Participant number', 'Groups',
                'Comment', 'Is active', 'Is present', 'Is a committee', 'Initial password', 'Email'];
            return _.map(headerline, function (entry) {
                return gettextCatalog.getString(entry);
            });
        };
        return {
            export: function (users) {
                var csvRows = [
                    makeHeaderline()
                ];
                _.forEach(users, function (user) {
                    var groups = _.map(user.groups_id, function (id) {
                        return gettextCatalog.getString(Group.get(id).name);
                    }).join(',');
                    var row = [];
                    row.push('"' + user.title + '"');
                    row.push('"' + user.first_name + '"');
                    row.push('"' + user.last_name + '"');
                    row.push('"' + user.structure_level + '"');
                    row.push('"' + user.number + '"');
                    row.push('"' + groups + '"');
                    row.push('"' + user.comment + '"');
                    row.push(user.is_active ? '1' : '0');
                    row.push(user.is_present ? '1' : '0');
                    row.push(user.is_committee ? '1' : '0');
                    row.push('"' + user.default_password + '"');
                    row.push('"' + user.email + '"');
                    csvRows.push(row);
                });
                CsvDownload(csvRows, gettextCatalog.getString('participants') + '.csv');
            },

            downloadExample: function () {
                // try to get an example with two groups and one with one group
                var groups = $filter('orderBy')(Group.getAll(), 'id');
                var csvGroups = '';
                var csvGroup = '';
                if (groups.length >= 3) { // do not pick groups[0], this is the default group
                    csvGroups = '"' + gettextCatalog.getString(groups[1].name) +
                                ', ' + gettextCatalog.getString(groups[2].name) + '"';
                }
                if (groups.length >= 2) {
                    csvGroup = gettextCatalog.getString(groups[groups.length - 1].name); // take last group
                }

                var csvRows = [makeHeaderline(),
                    // example entries
                    ['Dr.', 'Max', 'Mustermann', 'Berlin','1234567890', csvGroups, 'xyz', '1', '1', '', 'initialPassword', ''],
                    ['', 'John', 'Doe', 'Washington','75/99/8-2', csvGroup, 'abc', '1', '1', '', '', 'john.doe@email.com'],
                    ['', 'Fred', 'Bloggs', 'London', '', '', '', '', '', '', '', ''],
                    ['', '', 'Executive Board', '', '', '', '', '', '', '1', '', ''],

                ];
                CsvDownload(csvRows, gettextCatalog.getString('participants-example') + '.csv');
            }
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.users.pdf', ['OpenSlidesApp.core.pdf'])

.factory('UserListContentProvider', [
    'gettextCatalog',
    'PDFLayout',
    'Group',
    function(gettextCatalog, PDFLayout, Group) {

        var createInstance = function(userList) {
            var groups = Group.getAll();

            //use the Predefined Functions to create the title
            var title = PDFLayout.createTitle(gettextCatalog.getString('List of participants'));

            //function to generate the user list
            var createUserList = function() {
                var userJsonList = [];

                angular.forEach(userList, function (user, counter) {

                    //parse for the group names
                    var userGroups = [];
                    angular.forEach(user.groups_id, function (id) {
                        if (id) {
                            angular.forEach(groups, function(group) {
                                if (id == group.id) {
                                    userGroups.push(gettextCatalog.getString(group.name));
                                }
                            });
                        }
                    });

                    var userJsonObj = [
                        {
                            text: "" + (counter+1),
                            style: PDFLayout.flipTableRowStyle(userJsonList.length)
                        },
                        {
                            text: user.short_name,
                            style: PDFLayout.flipTableRowStyle(userJsonList.length)
                        },
                        {
                            text: user.structure_level,
                            style: PDFLayout.flipTableRowStyle(userJsonList.length)
                        },
                        {
                            text: userGroups.join(', '),
                            style: PDFLayout.flipTableRowStyle(userJsonList.length)
                        }
                    ];
                    userJsonList.push(userJsonObj);
                });

                var userTableBody = [
                    [
                        {
                            text: '#',
                            style: 'tableHeader'
                        },
                        {
                            text: gettextCatalog.getString('Name'),
                            style: 'tableHeader'
                        },
                        {
                            text: gettextCatalog.getString('Structure level'),
                            style: 'tableHeader'
                        },
                        {
                            text: gettextCatalog.getString('Groups'),
                            style: 'tableHeader'
                        }
                    ]
                ];
                userTableBody = userTableBody.concat((userJsonList));

                var userTableJsonString = {
                    table: {
                        widths: ['auto', '*', 'auto', 'auto'],
                        headerRows: 1,
                        body: userTableBody
                    },
                    layout: 'headerLineOnly'
                };

                return userTableJsonString;
            };

            var getContent = function() {
                return [
                    title,
                    createUserList()
                ];
            };

            return {
                getContent: getContent
            };
        };

        return {
            createInstance: createInstance
        };
    }
])

.factory('UserAccessDataListContentProvider', [
    'gettextCatalog',
    'PDFLayout',
    'Config',
    function(gettextCatalog, PDFLayout, Config) {

        var createInstance = function(userList) {

            var createUserHeadLine = function(user) {
                var titleLine = [];
                titleLine.push({
                    text: user.get_short_name(),
                    style: 'userDataTitle'
                });
                if (user.structure_level) {
                    titleLine.push({
                        text: user.structure_level,
                        style: 'userDataHeading'
                    });
                }
                return titleLine;
            };

            var createAccessDataContent = function(user) {
                // wlan access data
                var columnWifi = [
                    {
                        text: gettextCatalog.getString('WLAN access data'),
                        style: 'userDataHeading'
                    },
                    {
                        text: gettextCatalog.getString('WLAN name (SSID)') + ':',
                        style: 'userDataTopic'
                    },
                    {
                        text: Config.get('users_pdf_wlan_ssid').value || '-',
                        style: 'userDataValue'
                    },
                    {
                        text: gettextCatalog.getString('WLAN password') + ':',
                        style: 'userDataTopic'
                    },
                    {
                        text: Config.get('users_pdf_wlan_password').value || '-',
                        style: 'userDataValue'
                    },
                    {
                        text: gettextCatalog.getString('WLAN encryption') + ':',
                        style: 'userDataTopic'
                    },
                    {
                        text: Config.get('users_pdf_wlan_encryption').value || '-',
                        style: 'userDataValue'
                    },
                    {
                        text: '\n'
                    }
                ];
                // wifi qr code
                if (Config.get('users_pdf_wlan_ssid').value && Config.get('users_pdf_wlan_encryption').value) {
                    var wifiQrCode = 'WIFI:S:' + Config.get('users_pdf_wlan_ssid').value +
                        ';T:' + Config.get('users_pdf_wlan_encryption').value +
                        ';P:' + Config.get('users_pdf_wlan_password').value + ';;';
                    columnWifi.push(
                        {
                            qr: wifiQrCode,
                            fit: 120,
                            margin: [0, 0, 0, 8]
                        },
                        {
                            text: gettextCatalog.getString('Scan this QR code to connect to WLAN.'),
                            style: 'small'
                        }
                    );
                }

                // openslides access data
                var columnOpenSlides = [
                    {
                        text: gettextCatalog.getString('OpenSlides access data'),
                        style: 'userDataHeading'
                    },
                    {
                        text: gettextCatalog.getString('Username') + ':',
                        style: 'userDataTopic'
                    },
                    {
                        text: user.username,
                        style: 'userDataValue'
                    },
                    {
                        text: gettextCatalog.getString('Initial password') + ':',
                        style: 'userDataTopic'
                    },
                    {
                        text: user.default_password,
                        style: 'userDataValue'
                    },
                    {
                        text: 'URL:',
                        style: 'userDataTopic'
                    },
                    {
                        text: Config.get('users_pdf_url').value  || '-',
                        link: Config.get('users_pdf_url').value,
                        style: 'userDataValue'
                    },
                    {
                        text: '\n'
                    }
                ];
                // url qr code
                if (Config.get('users_pdf_url').value) {
                    columnOpenSlides.push(
                        {
                            qr: Config.get('users_pdf_url').value,
                            fit: 120,
                            margin: [0, 0, 0, 8]
                        },
                        {
                            text: gettextCatalog.getString('Scan this QR code to open URL.'),
                            style: 'small'
                        }
                    );
                }

                var accessDataColumns = {
                    columns: [
                        columnWifi,
                        columnOpenSlides,
                    ],
                    margin: [0, 20]
                };

                return accessDataColumns;
            };

            var createWelcomeText = function() {
                return [
                    {
                        text:   Config.translate(Config.get('users_pdf_welcometitle').value),
                        style: 'userDataHeading'
                    },
                    {
                        text:   Config.translate(Config.get('users_pdf_welcometext').value),
                        style: 'userDataTopic'
                    }
                ];
            };

            var getContent = function() {
                var content = [];
                angular.forEach(userList, function (user, index) {
                    content.push(createUserHeadLine(user));
                    content.push(createAccessDataContent(user));
                    content.push(createWelcomeText());
                    // No pagebreak after the last user
                    if (index !== userList.length - 1) {
                        content.push({
                            text: '',
                            pageBreak: 'after'
                        });
                    }
                });

                return [
                    content
                ];
            };

            return {
                getContent: getContent
            };
        };

        return {
            createInstance: createInstance
        };
    }
])

.factory('UserPdfExport', [
    'gettextCatalog',
    'UserListContentProvider',
    'UserAccessDataListContentProvider',
    'PdfMakeDocumentProvider',
    'PdfCreate',
    'Messaging',
    function (gettextCatalog, UserListContentProvider, UserAccessDataListContentProvider,
        PdfMakeDocumentProvider, PdfCreate, Messaging) {
        return {
            exportUserList: function (users) {
                var filename = gettextCatalog.getString('List of participants') + '.pdf';
                var userListContentProvider = UserListContentProvider.createInstance(users);
                PdfMakeDocumentProvider.createInstance(userListContentProvider).then(
                    function (documentProvider) {
                        PdfCreate.download(documentProvider, filename);
                    }, function (error) {
                        Messaging.addMessage(error.msg, 'error');
                    }
                );
            },
            exportUserAccessDataList: function (users) {
                var filename = gettextCatalog.getString('List of access data') + '.pdf';
                var userAccessDataListContentProvider = UserAccessDataListContentProvider.createInstance(
                    users);
                // no footer here
                PdfMakeDocumentProvider.createInstance(userAccessDataListContentProvider, true).then(
                    function (documentProvider) {
                        PdfCreate.download(documentProvider, filename, true);
                    }, function (error) {
                        Messaging.addMessage(error.msg, 'error');
                    }
                );
            }
        };
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.users.projector', ['OpenSlidesApp.users'])

.config([
    'slidesProvider',
    function(slidesProvider) {
        slidesProvider.registerSlide('users/user', {
            template: 'static/templates/users/slide_user.html',
        });
    }
])

.controller('SlideUserCtrl', [
    '$scope',
    'User',
    function($scope, User) {
        // Attention! Each object that is used here has to be dealt on server side.
        // Add it to the coresponding get_requirements method of the ProjectorElement
        // class.
        var id = $scope.element.id;
        User.bindOne(id, $scope, 'user');
    }
]);

}());

(function () {

'use strict';

angular.module('OpenSlidesApp.users.site', [
    'OpenSlidesApp.users',
    'OpenSlidesApp.core.pdf',
    'OpenSlidesApp.users.pdf',
    'OpenSlidesApp.users.csv',
])

.config([
    'mainMenuProvider',
    'gettext',
    function (mainMenuProvider, gettext) {
        mainMenuProvider.register({
            'ui_sref': 'users.user.list',
            'img_class': 'user',
            'title': gettext('Participants'),
            'weight': 500,
            'perm': 'users.can_see_name',
        });
    }
])
.config([
    'SearchProvider',
    'gettext',
    function (SearchProvider, gettext) {
        SearchProvider.register({
            'verboseName': gettext('Participants'),
            'collectionName': 'users/user',
            'urlDetailState': 'users.user.detail',
            'weight': 500,
        });
    }
])

.config([
    '$stateProvider',
    'gettext',
    function($stateProvider, gettext) {
        $stateProvider
        .state('users', {
            url: '/users',
            abstract: true,
            template: "<ui-view/>",
            data: {
                title: gettext('Participants'),
                basePerm: 'users.can_see_name',
            },
        })
        .state('users.user', {
            abstract: true,
            template: "<ui-view/>",
        })
        .state('users.user.list', {})
        .state('users.user.create', {})
        .state('users.user.detail', {
            resolve: {
                userId: ['$stateParams', function($stateParams) {
                    return $stateParams.id;
                }]
            }
        })
        .state('users.user.change-password', {
            url: '/change-password/{id}',
            controller: 'UserChangePasswordCtrl',
            templateUrl: 'static/templates/users/user-change-password.html',
            resolve: {
                userId: ['$stateParams', function($stateParams) {
                    return $stateParams.id;
                }]
            }
        })
        .state('users.user.import', {
            url: '/import',
            controller: 'UserImportCtrl',
        })
        .state('users.user.presence', {
            url: '/presence',
            controller: 'UserPresenceCtrl',
        })
        // groups
        .state('users.group', {
            url: '/groups',
            abstract: true,
            template: "<ui-view/>",
            data: {
                title: gettext('Groups'),
            },
        })
        .state('users.group.list', {})
        .state('login', {
            template: null,
            url: '/login',
            params: {
                guest_enabled: false,
                msg: null,
            },
            onEnter: ['$state', '$stateParams', 'ngDialog', 'LoginDialog', function($state, $stateParams, ngDialog, LoginDialog) {
                LoginDialog.id = ngDialog.open({
                    template: 'static/templates/core/login-form.html',
                    controller: 'LoginFormCtrl',
                    showClose: $stateParams.guest_enabled,
                    closeByEscape: $stateParams.guest_enabled,
                    closeByDocument: $stateParams.guest_enabled,
                }).id;
            }],
            data: {
                title: 'Login',
            },
        });
    }
])

.value('LoginDialog', {})

/*
 * Directive to check for permissions
 *
 * This is the Code from angular.js ngIf.
 *
 * TODO: find a way not to copy the code.
*/
.directive('osPerms', [
    '$animate',
    function($animate) {
        return {
            multiElement: true,
            transclude: 'element',
            priority: 600,
            terminal: true,
            restrict: 'A',
            $$tlb: true,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements, perms;
                if ($attr.osPerms[0] === '!') {
                    perms = _.trimStart($attr.osPerms, '!');
                } else {
                    perms = $attr.osPerms;
                }
                $scope.$watch(
                    function (scope) {
                        return scope.operator && scope.operator.hasPerms(perms);
                    },
                    function (value) {
                        if ($attr.osPerms[0] === '!') {
                            value = !value;
                        }
                        if (value) {
                            if (!childScope) {
                                $transclude(function(clone, newScope) {
                                    childScope = newScope;
                                    clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
                                    // Note: We only need the first/last node of the cloned nodes.
                                    // However, we need to keep the reference to the jqlite wrapper as it might be changed later
                                    // by a directive with templateUrl when its template arrives.
                                    block = {
                                        clone: clone
                                    };
                                    $animate.enter(clone, $element.parent(), $element);
                                });
                            }
                        } else {
                            if (previousElements) {
                                previousElements.remove();
                                previousElements = null;
                            }
                            if (childScope) {
                                childScope.$destroy();
                                childScope = null;
                            }
                            if (block) {
                                previousElements = getBlockNodes(block.clone);
                                $animate.leave(previousElements).then(function() {
                                    previousElements = null;
                                });
                                block = null;
                            }
                        }
                    }
                );
            }
        };
    }
])

.factory('PasswordGenerator', [
    function () {
        return {
            generate: function (length) {
                if (!length) {
                    length = 8;
                }
                var chars = 'abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789',
                pw = '';
                for (var i = 0; i < length; ++i) {
                    pw += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return pw;
            }
        };
    }
])

.factory('PersonalNoteManager', [
    'PersonalNote',
    'operator',
    function (PersonalNote, operator) {
        var _getPersonalNoteObject = function (resourceName) {
            var personalNote = _.find(PersonalNote.getAll(), function (pn) {
                return pn.user_id === operator.user.id;
            });
            if (!personalNote) {
                personalNote = {
                    notes: {},
                };
            }
            if (!personalNote.notes[resourceName]) {
                personalNote.notes[resourceName] = {};
            }
            return personalNote;
        };
        var get = function (resourceName, id) {
            return _getPersonalNoteObject(resourceName).notes[resourceName][id];
        };
        var save = function (resourceName, id, note) {
            var personalNote = _getPersonalNoteObject(resourceName);
            personalNote.notes[resourceName][id] = note;
            if (personalNote.id) {
                return PersonalNote.save(personalNote);
            } else {
                return PersonalNote.create(personalNote);
            }
        };
        return {
            getNote: function (obj) {
                if (typeof obj.getResourceName === 'undefined') {
                    throw 'The Object has to be a js data model!';
                }
                return get(obj.getResourceName(), obj.id);
            },
            saveNote: function (obj, note) {
                if (typeof obj.getResourceName === 'undefined') {
                    throw 'The Object has to be a js data model!';
                }
                return save(obj.getResourceName(), obj.id, note);
            },
        };
    }
])

// Service for generic assignment form (create and update)
.factory('UserForm', [
    '$http',
    'gettextCatalog',
    'Editor',
    'Group',
    'Mediafile',
    'PasswordGenerator',
    function ($http, gettextCatalog, Editor, Group, Mediafile, PasswordGenerator) {
        return {
            // ngDialog for user form
            getDialog: function (user) {
                return {
                    template: 'static/templates/users/user-form.html',
                    controller: (user) ? 'UserUpdateCtrl' : 'UserCreateCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                    resolve: {
                        userId: function () {return user ? user.id : void 0;},
                    }
                };
            },
            // angular-formly fields for user form
            getFormFields: function (hideOnCreateForm) {
                var images = Mediafile.getAllImages();
                return [
                {
                    className: "row",
                    fieldGroup: [
                        {
                            key: 'title',
                            type: 'input',
                            className: "col-xs-2 no-padding-left",
                            templateOptions: {
                                label: gettextCatalog.getString('Title')
                            }
                        },
                        {
                            key: 'first_name',
                            type: 'input',
                            className: "col-xs-5 no-padding",
                            templateOptions: {
                                label: gettextCatalog.getString('Given name')
                            }
                        },
                        {
                            key: 'last_name',
                            type: 'input',
                            className: "col-xs-5 no-padding-right",
                            templateOptions: {
                                label: gettextCatalog.getString('Surname')
                            }
                        }
                    ]
                },
                {
                    key: 'email',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Email')
                    },
                },
                {
                    className: "row",
                    fieldGroup: [
                        {
                            key: 'structure_level',
                            type: 'input',
                            className: "col-xs-9 no-padding-left",
                            templateOptions: {
                                label: gettextCatalog.getString('Structure level'),
                            }
                        },
                        {   key: 'number',
                            type: 'input',
                            className: "col-xs-3 no-padding-left no-padding-right",
                            templateOptions: {
                                label:gettextCatalog.getString('Participant number')
                            }
                        }
                    ]
                },
                {
                    key: 'username',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Username')
                    },
                    hide: hideOnCreateForm
                },
                {
                    key: 'groups_id',
                    type: 'select-multiple',
                    templateOptions: {
                        label: gettextCatalog.getString('Groups'),
                        options: Group.filter({where: {id: {'>': 1}}}),
                        ngOptions: "option.id as option.name | translate for option in to.options | orderBy: 'id'",
                        placeholder: gettextCatalog.getString('Select or search a group ...')
                    }
                },
                {
                    key: 'default_password',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Initial password'),
                        description: gettextCatalog.getString('Initial password can not be changed.'),
                        addonRight: {
                            text: gettextCatalog.getString('Generate'),
                            class: 'fa fa-magic',
                            onClick:function (options, scope) {
                                scope.$parent.model.default_password = PasswordGenerator.generate();
                            }
                        }
                    },
                    hide: !hideOnCreateForm
                },
                {
                    key: 'comment',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Comment'),
                        description: gettextCatalog.getString('Only for internal notes.')
                    }
                },
                {
                    key: 'more',
                    type: 'checkbox',
                    templateOptions: {
                        label: gettextCatalog.getString('Show extended fields')
                    }
                },
                {
                    template: '<hr class="smallhr">',
                    hideExpression: '!model.more'
                },
                {
                    key: 'is_present',
                    type: 'checkbox',
                    templateOptions: {
                        label: gettextCatalog.getString('Is present'),
                        description: gettextCatalog.getString('Designates whether this user is in the room or not.')
                    },
                    defaultValue: true,
                    hideExpression: '!model.more'
                },
                {
                    key: 'is_active',
                    type: 'checkbox',
                    templateOptions: {
                        label: gettextCatalog.getString('Is active'),
                        description: gettextCatalog.getString(
                            'Designates whether this user should be treated as ' +
                            'active. Unselect this instead of deleting the account.')
                    },
                    defaultValue: true,
                    hideExpression: '!model.more'
                },
                {
                    key: 'is_committee',
                    type: 'checkbox',
                    templateOptions: {
                        label: gettextCatalog.getString('Is a committee'),
                        description: gettextCatalog.getString(
                            'Designates whether this user should be treated as a committee.')
                    },
                    defaultValue: false,
                    hideExpression: '!model.more'
                },
                {
                    key: 'about_me',
                    type: 'editor',
                    templateOptions: {
                        label: gettextCatalog.getString('About me'),
                    },
                    data: {
                        ckeditorOptions: Editor.getOptions(images)
                    },
                    hideExpression: '!model.more'
                }
                ];
            }
        };
    }
])

.factory('UserProfileForm', [
    'gettextCatalog',
    'Editor',
    'Mediafile',
    function (gettextCatalog, Editor, Mediafile) {
        return {
            // ngDialog for user form
            getDialog: function () {
                return {
                    template: 'static/templates/users/profile-password-form.html',
                    controller: 'UserProfileCtrl',
                    className: 'ngdialog-theme-default wide-form',
                    closeByEscape: false,
                    closeByDocument: false,
                };
            },
            // angular-formly fields for user form
            getFormFields: function (hideOnCreateForm) {
                var images = Mediafile.getAllImages();
                return [
                {
                    key: 'username',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Username'),
                        required: true
                    },
                },
                {
                    key: 'email',
                    type: 'input',
                    templateOptions: {
                        label: gettextCatalog.getString('Email')
                    },
                },
                {
                    key: 'about_me',
                    type: 'editor',
                    templateOptions: {
                        label: gettextCatalog.getString('About me'),
                    },
                    data: {
                        ckeditorOptions: Editor.getOptions(images)
                    },
                }
                ];
            }
        };
    }
])

.factory('UserPasswordForm', [
    'gettextCatalog',
    function (gettextCatalog) {
        return {
            // ngDialog for user form
            getDialog: function () {
                return {
                    template: 'static/templates/users/profile-password-form.html',
                    controller: 'UserPasswordCtrl',
                    className: 'ngdialog-theme-default',
                    closeByEscape: false,
                    closeByDocument: false,
                };
            },
            // angular-formly fields for user form
            getFormFields: function (hideOnCreateForm) {
                return [
                {
                    key: 'oldPassword',
                    type: 'password',
                    templateOptions: {
                        label: gettextCatalog.getString('Old password'),
                        required: true
                    },
                },
                {
                    key: 'newPassword',
                    type: 'password',
                    templateOptions: {
                        label: gettextCatalog.getString('New password'),
                        required: true
                    },
                },
                {
                    key: 'newPassword2',
                    type: 'password',
                    templateOptions: {
                        label: gettextCatalog.getString('Confirm new password'),
                        required: true
                    },
                },
                ];
            }
        };
    }
])

.controller('UserListCtrl', [
    '$scope',
    '$http',
    'ngDialog',
    'UserForm',
    'User',
    'Group',
    'PasswordGenerator',
    'Projector',
    'ProjectionDefault',
    'Config',
    'UserCsvExport',
    'osTableFilter',
    'osTableSort',
    'osTablePagination',
    'gettext',
    'UserPdfExport',
    'InvitationEmails',
    'ErrorMessage',
    function($scope, $http, ngDialog, UserForm, User, Group, PasswordGenerator,
        Projector, ProjectionDefault, Config, UserCsvExport, osTableFilter, osTableSort,
        osTablePagination, gettext, UserPdfExport, InvitationEmails, ErrorMessage) {
        $scope.$watch(function () {
            return User.lastModified();
        }, function () {
            $scope.users = _.orderBy(User.getAll(), ['first_name']);
            _.forEach($scope.users, function (user) {
                user.has_last_email_send = !!user.last_email_send;
            });
            if ($scope.updateUsers) {
                $scope.updateUsers();
            }
        });
        Group.bindAll({where: {id: {'>': 1}}}, $scope, 'groups');
        $scope.$watch(function () {
            return Projector.lastModified();
        }, function () {
            var projectiondefault = ProjectionDefault.filter({name: 'users'})[0];
            if (projectiondefault) {
                $scope.defaultProjectorId = projectiondefault.projector_id;
            }
        });
        $scope.alert = {};

        // Filtering
        $scope.filter = osTableFilter.createInstance('UserTableFilter');

        if (!$scope.filter.existsStorageEntry()) {
            $scope.filter.multiselectFilters = {
                group: [],
            };
            $scope.filter.booleanFilters = {
                isPresent: {
                    value: undefined,
                    displayName: gettext('Present'),
                    choiceYes: gettext('Is present'),
                    choiceNo: gettext('Is not present'),
                    needExtraPermission: true,
                },
                isActive: {
                    value: undefined,
                    displayName: gettext('Active'),
                    choiceYes: gettext('Is active'),
                    choiceNo: gettext('Is not active'),
                    needExtraPermission: true,
                },
                isCommittee: {
                    value: undefined,
                    displayName: gettext('Committee'),
                    choiceYes: gettext('Is a committee'),
                    choiceNo: gettext('Is not a committee'),
                },
                hasLastEmailSend: {
                    value: undefined,
                    displayName: gettext('Last email send'),
                    choiceYes: gettext('Got an email'),
                    choiceNo: gettext("Didn't get an email"),
                },
            };
        }
        $scope.filter.propertyList = ['first_name', 'last_name', 'username', 'title',
            'number', 'comment', 'structure_level'];
        $scope.filter.propertyDict = {
            'groups_id' : function (group_id) {
                return Group.get(group_id).name;
            },
        };
        $scope.getItemId = {
            group: function (user) {return user.groups_id;},
        };
        // Sorting
        $scope.sort = osTableSort.createInstance('UserTableSort');
        if (!$scope.sort.column) {
            $scope.sort.column = $scope.config('users_sort_by');
        }
        $scope.sortOptions = [
            {name: 'first_name',
             display_name: gettext('Given name')},
            {name: 'last_name',
             display_name: gettext('Surname')},
            {name: 'is_present',
             display_name: gettext('Present')},
            {name: 'is_active',
             display_name: gettext('Active')},
            {name: 'is_committee',
             display_name: gettext('Committee')},
            {name: 'number',
             display_name: gettext('Number')},
            {name: 'structure_level',
             display_name: gettext('Structure level')},
            {name: 'comment',
             display_name: gettext('Comment')},
            {name: 'last_email_send',
             display_name: gettext('Last email send')},
        ];

        // pagination
        $scope.pagination = osTablePagination.createInstance('UserTablePagination');

        // Toggle group from user
        $scope.toggleGroup = function (user, group) {
            if (_.indexOf(user.groups_id, group.id) > -1) {
                user.groups_id = _.filter(user.groups_id, function (group_id) {
                    return group_id != group.id;
                });
            } else {
                user.groups_id.push(group.id);
            }
            $scope.save(user);
        };
        // open new/edit dialog
        $scope.openDialog = function (user) {
            ngDialog.open(UserForm.getDialog(user));
        };
        // save changed user
        $scope.save = function (user) {
            User.save(user).then(
                function(success) {
                    //user.quickEdit = false;
                    $scope.alert.show = false;
                },
                function(error){
                    $scope.alert = ErrorMessage.forAlert(error);
                });
        };
        // delete single user
        $scope.delete = function (user) {
            User.destroy(user.id);
        };
        // *** select mode functions ***
        $scope.isSelectMode = false;
        // check all checkboxes
        $scope.checkAll = function () {
            $scope.selectedAll = !$scope.selectedAll;
            _.forEach($scope.usersFiltered, function (user) {
                user.selected = $scope.selectedAll;
            });
        };
        // uncheck all checkboxes if isSelectMode is closed
        $scope.uncheckAll = function () {
            if (!$scope.isSelectMode) {
                $scope.selectedAll = false;
                angular.forEach($scope.users, function (user) {
                    user.selected = false;
                });
            }
        };
        var selectModeAction = function (predicate) {
            angular.forEach($scope.usersFiltered, function (user) {
                if (user.selected) {
                    predicate(user);
                }
            });
            $scope.isSelectMode = false;
            $scope.uncheckAll();
        };
        // delete all selected users
        $scope.deleteMultiple = function () {
            selectModeAction(function (user) {
                $scope.delete(user);
            });
        };
        // add group for selected users
        $scope.addGroupMultiple = function (group) {
            if (group) {
                selectModeAction(function (user) {
                    user.groups_id.push(group);
                    User.save(user);
                });
            }
        };
        // remove group for selected users
        $scope.removeGroupMultiple = function (group) {
            if (group) {
                selectModeAction(function (user) {
                    var groupIndex = _.indexOf(user.groups_id, parseInt(group));
                    if (groupIndex > -1) {
                        user.groups_id.splice(groupIndex, 1);
                        User.save(user);
                    }
                });
            }
        };
        // generate new passwords
        $scope.generateNewPasswordsMultiple = function () {
            selectModeAction(function (user) {
                var newPassword = PasswordGenerator.generate();
                user.default_password = newPassword;
                User.save(user);
                $http.post(
                    '/rest/users/user/' + user.id + '/reset_password/',
                    {'password': newPassword}
                );
            });
        };
        // set boolean properties (is_active, is_present, is_committee)
        $scope.setBoolPropertyMultiple = function (property, value) {
            selectModeAction(function (user) {
                user[property] = value;
                User.save(user);
            });
        };
        // Send invitation emails
        $scope.sendInvitationEmails = function () {
            InvitationEmails.send($scope.usersFiltered).then(function (success) {
                $scope.alert = success;
                $scope.isSelectMode = false;
                $scope.uncheckAll();
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
                $scope.isSelectMode = false;
                $scope.uncheckAll();
            });
        };

        // Export as PDF
        $scope.pdfExportUserList = function () {
            UserPdfExport.exportUserList($scope.usersFiltered);
        };
        $scope.pdfExportUserAccessDataList = function () {
            UserPdfExport.exportUserAccessDataList($scope.usersFiltered);
        };
        // Export as a csv file
        $scope.csvExport = function () {
            UserCsvExport.export($scope.usersFiltered);
        };
    }
])

.factory('InvitationEmails', [
    '$http',
    'User',
    'Config',
    'gettextCatalog',
    function ($http, User, Config, gettextCatalog) {
        return {
            // Returns the request promise. If it was successfull, a nice message for
            // an alert is generated and the alert-object is returned.
            send: function (users) {
                var user_ids = _
                    .chain(users)
                    .filter(function (user) {
                        return user.selected;
                    })
                    .map(function (user) {
                        return user.id;
                    })
                    .value();
                var subject = gettextCatalog.getString(Config.get('users_email_subject').value);
                var message = gettextCatalog.getString(Config.get('users_email_body').value);

                return $http.post('/rest/users/user/mass_invite_email/', {
                    user_ids: user_ids,
                    subject: subject,
                    message: message,
                }).then(function (success) {
                    var numEmails = success.data.count;
                    var noEmailIds = success.data.no_email_ids;
                    var type = 'success', msg;
                    if (numEmails === 0) {
                        type = 'danger';
                        msg = gettextCatalog.getString('No emails were send.');
                    } else if (numEmails === 1) {
                        msg = gettextCatalog.getString('One email was send sucessfully.');
                    } else {
                        msg = gettextCatalog.getString('%num% emails were send sucessfully.').replace('%num%', numEmails);
                    }

                    if (noEmailIds.length) {
                        type = 'warning';
                        msg += ' ';

                        if (noEmailIds.length === 1) {
                            msg += gettextCatalog.getString('The user %user% has no email, so the invitation email could not be send.');
                        } else {
                            msg += gettextCatalog.getString('The users %user% have no email, so the invitation emails could not be send.');
                        }

                        // This one builds a username string like "user1, user2 and user3" with the full names.
                        var lastUsername, userString = _
                            .chain(noEmailIds)
                            .map(function (id) {
                                var user = User.get(id);
                                return user ? user.get_full_name() : '';
                            })
                            .filter(function (username) {
                                return username;
                            })
                            .tap(function (names) {
                                if (names.length !== 1) {
                                    lastUsername = names.pop();
                                }
                            })
                            .join(', ')
                            .thru(function (names) {
                                return lastUsername ? names + ' ' + gettextCatalog.getString('and') + ' ' + lastUsername : names;
                            })
                            .value();
                        msg = msg.replace('%user%', userString);
                    }

                    return {
                        msg: msg,
                        type: type,
                        show: true,
                    };
                });
            },
        };
    }
])

.controller('UserDetailCtrl', [
    '$scope',
    'ngDialog',
    'UserForm',
    'User',
    'userId',
    'Group',
    'Projector',
    'ProjectionDefault',
    'gettextCatalog',
    'WebpageTitle',
    function($scope, ngDialog, UserForm, User, userId, Group, Projector, ProjectionDefault, gettextCatalog,
        WebpageTitle) {
        Group.bindAll({where: {id: {'>': 1}}}, $scope, 'groups');
        $scope.$watch(function () {
            return User.lastModified(userId);
        }, function () {
            $scope.user = User.get(userId);
            WebpageTitle.updateTitle(gettextCatalog.getString('Participant') + ' ' + $scope.user.get_short_name());
        });
        $scope.$watch(function () {
            return Projector.lastModified();
        }, function () {
            var projectiondefault = ProjectionDefault.filter({name: 'users'})[0];
            if (projectiondefault) {
                $scope.defaultProjectorId = projectiondefault.projector_id;
            }
        });

        // open edit dialog
        $scope.openDialog = function (user) {
            ngDialog.open(UserForm.getDialog(user));
        };
    }
])

.controller('UserCreateCtrl', [
    '$scope',
    '$state',
    'User',
    'UserForm',
    'ErrorMessage',
    function($scope, $state, User, UserForm, ErrorMessage) {
        $scope.alert = {};
        // get all form fields
        $scope.formFields = UserForm.getFormFields(true);

        // save user
        $scope.save = function (user) {
            if (!user.groups_id) {
                user.groups_id = [];
            }
            User.create(user).then(
                function (success) {
                    $scope.closeThisDialog();
                },
                function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('UserUpdateCtrl', [
    '$scope',
    '$state',
    'User',
    'UserForm',
    'userId',
    'ErrorMessage',
    function($scope, $state, User, UserForm, userId, ErrorMessage) {
        $scope.alert = {};
        // set initial values for form model by create deep copy of user object
        // so list/detail view is not updated while editing
        $scope.model = angular.copy(User.get(userId));

        // get all form fields
        $scope.formFields = UserForm.getFormFields();

        // save user
        $scope.save = function (user) {
            if (!user.groups_id) {
                user.groups_id = [];
            }
            // inject the changed user (copy) object back into DS store
            User.inject(user);
            // save change user object on server
            User.save(user).then(
                function (success) {
                    $scope.closeThisDialog();
                },
                function (error) {
                    // save error: revert all changes by restore
                    // (refresh) original user object from server
                    User.refresh(user);
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('UserProfileCtrl', [
    '$scope',
    'Editor',
    'User',
    'operator',
    'UserProfileForm',
    'gettext',
    'ErrorMessage',
    function($scope, Editor, User, operator, UserProfileForm, gettext, ErrorMessage) {
        $scope.model = angular.copy(operator.user);
        $scope.title = gettext('Edit profile');
        $scope.formFields = UserProfileForm.getFormFields();
        $scope.save = function (user) {
            User.inject(user);
            User.save(user).then(
                function(success) {
                    $scope.closeThisDialog();
                },
                function(error) {
                    // save error: revert all changes by restore
                    // (refresh) original user object from server
                    User.refresh(user);
                    $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.controller('UserChangePasswordCtrl', [
    '$scope',
    '$state',
    '$http',
    'User',
    'userId',
    'gettextCatalog',
    'PasswordGenerator',
    'ErrorMessage',
    function($scope, $state, $http, User, userId, gettextCatalog, PasswordGenerator, ErrorMessage) {
        User.bindOne(userId, $scope, 'user');
        $scope.alert = {};
        $scope.generatePassword = function () {
            $scope.new_password = PasswordGenerator.generate();
        };
        $scope.save = function (user) {
            if ($scope.new_password !== '') {
                $http.post(
                    '/rest/users/user/' + user.id + '/reset_password/',
                    {'password': $scope.new_password}
                ).then(
                    function (success) {
                        $scope.alert = {type: 'success', msg: success.data.detail, show: true};
                        $scope.new_password = '';
                    },
                    function (error) {
                        $scope.alert = ErrorMessage.forAlert(error);
                    }
                );
            }
        };
    }
])

.directive("showPassword", function() {
    return function linkFn(scope, elem, attrs) {
        scope.$watch(attrs.showPassword, function(value) {
            if (value) {
                elem.attr("type", "text");
            } else {
                elem.attr("type", "password");
            }
        });
    };
})

.controller('UserPasswordCtrl', [
    '$scope',
    '$state',
    '$http',
    'gettext',
    'UserPasswordForm',
    'ErrorMessage',
    function($scope, $state, $http, gettext, UserPasswordForm, ErrorMessage) {
        $scope.title = 'Change password';
        $scope.alert = {};
        $scope.model = {};
        $scope.formFields = UserPasswordForm.getFormFields();
        $scope.save = function (data) {
            if (data.newPassword != data.newPassword2) {
                data.newPassword = data.newPassword2 = '';
                $scope.alert = {
                    type: 'danger',
                    msg: gettext('Password confirmation does not match.'),
                    show: true,
                };
            } else {
                $http.post(
                    '/users/setpassword/',
                    {'old_password': data.oldPassword, 'new_password': data.newPassword}
                ).then(
                    function (success) {
                        $scope.closeThisDialog();
                    },
                    function (error) {
                        // Error, e. g. wrong old password.
                        $scope.model = {};
                        $scope.alert = ErrorMessage.forAlert(error);
                    }
                );
            }
        };
    }
])

.controller('UserPresenceCtrl', [
    '$scope',
    'User',
    'gettextCatalog',
    'ErrorMessage',
    function ($scope, User, gettextCatalog, ErrorMessage) {
        $scope.alert = {};
        $('#userNumber').focus();

        $scope.changeState = function () {
            if (!$scope.number) {
                return;
            }
            var enteredNumber = $scope.number.trim();
            var user = _.find(User.getAll(), function (user) {
                return user.number === enteredNumber;
            });
            if (user) {
                user.is_present = !user.is_present;
                User.save(user).then(function (success) {
                    var messageText = user.full_name + ' ' + gettextCatalog.getString('is now') + ' ';
                    messageText += gettextCatalog.getString(user.is_present ? 'present' : 'not present') + '.';
                    $scope.alert = {
                        msg: messageText,
                        show: true,
                        type: 'success',
                    };
                    $scope.number = '';
                }, function (error) {
                    $scope.alert = ErrorMessage.forAlert(error);
                });
            } else {
                $scope.alert = {
                    msg: gettextCatalog.getString('Cannot find the participant with the participant number') + ' "' + enteredNumber + '".',
                    show: true,
                    type: 'danger',
                };
            }
            $('#userNumber').focus();
        };
    }
])

.controller('UserImportCtrl', [
    '$scope',
    '$http',
    '$q',
    'gettext',
    'gettextCatalog',
    'User',
    'Group',
    'UserCsvExport',
    'osTablePagination',
    'ErrorMessage',
    function($scope, $http, $q, gettext, gettextCatalog, User, Group, UserCsvExport,
        osTablePagination, ErrorMessage) {
        // import from textarea
        $scope.importByLine = function () {
            var usernames = $scope.userlist[0].split("\n");
            var users = _.map(usernames, function (name) {
                // Split each full name in first and last name.
                // The last word is set as last name, rest is the first name(s).
                // (e.g.: "Max Martin Mustermann" -> last_name = "Mustermann")
                var names = name.split(" ");
                var last_name = names.slice(-1)[0];
                var first_name = names.slice(0, -1).join(" ");
                return {
                    first_name: first_name,
                    last_name: last_name,
                    groups_id: [],
                };
            });
            $http.post('/rest/users/user/mass_import/', {
                users: users
            }).then(function (success) {
                $scope.alert = {
                    show: true,
                    type: 'success',
                    msg: success.data.detail,
                };
            }, function (error) {
                $scope.alert = ErrorMessage.forAlert(error);
            });
        };

        // pagination
        $scope.pagination = osTablePagination.createInstance('UserImportTablePagination', 100);

        // Duplicates
        $scope.duplicateActions = [
            gettext('keep original'),
            gettext('override new'),
            gettext('create duplicate')
        ];

        // *** csv import ***
        $scope.csvConfig = {
            accept: '.csv, .txt',
            encodingOptions: ['UTF-8', 'ISO-8859-1'],
            parseConfig: {
                skipEmptyLines: true,
            },
        };

        var FIELDS = ['title', 'first_name', 'last_name', 'structure_level', 'number',
        'groups', 'comment', 'is_active', 'is_present', 'is_committee', 'default_password', 'email'];
        $scope.users = [];
        $scope.onCsvChange = function (csv) {
            $scope.csvImporting = false;
            // All user objects are already loaded via the resolve statement from ui-router.
            var users = User.getAll();
            $scope.users = [];

            var csvUsers = [];
            _.forEach(csv.data, function (row) {
                if (row.length >= 2) {
                    var filledRow = _.zipObject(FIELDS, row);
                    csvUsers.push(filledRow);
                }
            });
            $scope.duplicates = 0;
            _.forEach(csvUsers, function (user, index) {
                user.importTrackId = index;
                user.selected = true;
                if (!user.first_name && !user.last_name) {
                    user.importerror = true;
                    user.name_error = gettext('Error: Given name or surname is required.');
                }
                // number
                if (!user.number) {
                    user.number = "";
                }
                // groups
                user.groups_id = []; // will be overwritten if there are groups
                if (user.groups) {
                    user.groups = user.groups.split(',');
                    user.groups = _.map(user.groups, function (group) {
                        return _.trim(group); // remove whitespaces on start or end
                    });

                    // All group objects are already loaded via the resolve statement from ui-router.
                    var allGroups = Group.getAll();
                    // in allGroupsNames ar all original group names and translated names if a
                    // translation exists (e.g. for default group Delegates)
                    var allGroupsNames = [];
                    _.forEach(allGroups, function (group) {
                        var groupTranslation = gettextCatalog.getString(group.name);
                        if (group.name !== groupTranslation) {
                            allGroupsNames.push(groupTranslation);
                        }
                        allGroupsNames.push(group.name);
                    });
                    user.groupsToCreate = _.difference(user.groups, allGroupsNames);

                    // for template:
                    user.groupsNotToCreate = _.difference(user.groups, user.groupsToCreate);
                } else {
                    user.groups = [];
                }
                user.is_active = (user.is_active !== undefined && user.is_active === '1');
                user.is_present = (user.is_present !== undefined && user.is_present === '1');
                user.is_committee = (user.is_committee !== undefined && user.is_committee === '1');

                // Check for duplicates
                user.duplicate = false;
                users.forEach(function(user_) {
                    user_.fullname = [
                        user_.title,
                        user_.first_name,
                        user_.last_name,
                        user_.structure_level].join(' ').trim();
                    user.fullname = [
                        user.title,
                        user.first_name,
                        user.last_name,
                        user.structure_level].join(' ').trim();
                    if (user_.fullname === user.fullname) {
                        if (user.duplicate) {
                            // there are multiple duplicates!
                            user.duplicate_info += '\n' + gettextCatalog.getString('There are more than one duplicates of this user!');
                        } else {
                            user.duplicate = true;
                            user.duplicateAction = $scope.duplicateActions[1];
                            user.duplicate_info = '';
                            if (user_.title)
                                user.duplicate_info += user_.title + ' ';
                            if (user_.first_name)
                                user.duplicate_info += user_.first_name;
                            if (user_.first_name && user_.last_name)
                                user.duplicate_info += ' ';
                            if (user_.last_name)
                                user.duplicate_info += user_.last_name;
                            user.duplicate_info += ' (';
                            if (user_.number)
                                user.duplicate_info += gettextCatalog.getString('Number') + ': ' + user_.number + ', ';
                            if (user_.structure_level)
                                user.duplicate_info += gettextCatalog.getString('Structure level') + ': ' + user_.structure_level + ', ';
                            user.duplicate_info += gettextCatalog.getString('Username') + ': ' + user_.username + ') '+
                                gettextCatalog.getString('already exists.');

                            $scope.duplicates++;
                        }
                    }
                });
                $scope.users.push(user);
            });
            $scope.calcStats();
        };

        // Stats
        $scope.calcStats = function() {
            // not imported: if importerror or duplicate->keep original
            $scope.usersWillNotBeImported = 0;
            // imported: all others
            $scope.usersWillBeImported = 0;

            $scope.users.forEach(function(user) {
                if (!user.selected || user.importerror || (user.duplicate && user.duplicateAction == $scope.duplicateActions[0])) {
                    $scope.usersWillNotBeImported++;
                } else {
                    $scope.usersWillBeImported++;
                }
            });
        };

        $scope.setGlobalAction = function (action) {
            $scope.users.forEach(function (user) {
                if (user.duplicate)
                    user.duplicateAction = action;
            });
            $scope.calcStats();
        };

        // import from csv file
        $scope.import = function () {
            $scope.csvImporting = true;

            // collect all needed groups and create non existing groups
            var groupsToCreate = [];
            _.forEach($scope.users, function (user) {
                if (user.selected && !user.importerror && user.groups.length) {
                    _.forEach(user.groupsToCreate, function (group) { // Just append groups, that are not listed yet.
                        if (_.indexOf(groupsToCreate, group) == -1) {
                            groupsToCreate.push(group);
                        }
                    });
                }
            });
            var createPromises = [];
            $scope.groupsCreated = 0;
            _.forEach(groupsToCreate, function (groupname) {
                var group = {
                    name: groupname,
                    permissions: []
                };
                createPromises.push(Group.create(group).then( function (success) {
                    $scope.groupsCreated++;
                }));
            });

            $q.all(createPromises).then(function () {
                // reload allGroups, now all new groups are created
                var allGroups = Group.getAll();
                var existingUsers = User.getAll();

                // For option 'delete existing user' on duplicates
                var deletePromises = [];
                // Array of users for mass import
                var usersToBeImported = [];

                _.forEach($scope.users, function (user) {
                    if (user.selected && !user.importerror) {
                        // Assign all groups
                        _.forEach(user.groups, function(csvGroup) {
                            allGroups.forEach(function (allGroup) {
                                // check with and without translation
                                if (csvGroup === allGroup.name ||
                                    csvGroup === gettextCatalog.getString(allGroup.name)) {
                                    user.groups_id.push(allGroup.id);
                                }
                            });
                        });

                        // Do nothing on duplicateAction==duplicateActions[0] (keep original)
                        if (user.duplicate && (user.duplicateAction == $scope.duplicateActions[1])) {
                            // delete existing user
                            existingUsers.forEach(function(user_) {
                                user_.fullname = [
                                    user_.title,
                                    user_.first_name,
                                    user_.last_name,
                                    user_.structure_level].join(' ').trim();
                                user.fullname = [
                                    user.title,
                                    user.first_name,
                                    user.last_name,
                                    user.structure_level].join(' ').trim();
                                if (user_.fullname === user.fullname) {
                                    deletePromises.push(User.destroy(user_.id));
                                }
                            });
                            usersToBeImported.push(user);
                        } else if (!user.duplicate ||
                                   (user.duplicateAction == $scope.duplicateActions[2])) {
                            // create user
                            usersToBeImported.push(user);
                        }
                    }
                });
                $q.all(deletePromises).then(function () {
                    $http.post('/rest/users/user/mass_import/', {
                        users: usersToBeImported
                    }).then(function (success) {
                        _.forEach(success.data.importedTrackIds, function (trackId) {
                            _.find($scope.users, function (user) {
                                return user.importTrackId === trackId;
                            }).imported = true;
                        });
                        $scope.csvimported = true;
                    }, function (error) {
                        $scope.alert = ErrorMessage.forAlert(error);
                    });
                });
            });
        };
        $scope.clear = function () {
            $scope.users = null;
        };
        $scope.excludeImportedUsers = function () {
            $scope.users = _.filter($scope.users, function (user) {
                return !user.imported;
            });
            $scope.csvImporting = false;
            $scope.calcStats();
        };
        $scope.someImportedUsers = function () {
            return _.some($scope.users, function (user) {
                return user.imported;
            });
        };
        // download CSV example file
        $scope.downloadCSVExample = function () {
            UserCsvExport.downloadExample();
        };
    }
])

.controller('GroupListCtrl', [
    '$scope',
    '$http',
    '$filter',
    'operator',
    'Group',
    'permissions',
    'gettext',
    'Agenda',
    'Assignment',
    'Mediafile',
    'Motion',
    'User',
    'ngDialog',
    'OpenSlidesPlugins',
    function($scope, $http, $filter, operator, Group, permissions, gettext, Agenda,
        Assignment, Mediafile, Motion, User, ngDialog, OpenSlidesPlugins) {
        $scope.permissions = permissions;

        $scope.$watch(function() {
            return Group.lastModified();
        }, function() {
            $scope.groups = $filter('orderBy')(Group.getAll(), 'id');

            // find all groups with the 2 dangerous permissions
            var groups_danger = [];
            $scope.groups.forEach(function (group) {
                if ((_.indexOf(group.permissions, 'users.can_see_name') > -1) &&
                    (_.indexOf(group.permissions, 'users.can_manage') > -1)){
                    if (operator.isInGroup(group)){
                        groups_danger.push(group);
                    }
                }
            });
            // if there is only one dangerous group, block it.
            $scope.group_danger = groups_danger.length == 1 ? groups_danger[0] : null;
        });

        // Dict to map plugin name -> display_name
        var pluginTranslation = {};
        _.forEach(OpenSlidesPlugins.getAll(), function (plugin) {
            pluginTranslation[plugin.name] = plugin.display_name;
        });
        $scope.apps = [];
        // Create the main clustering with appname->permissions
        angular.forEach(permissions, function(perm) {
            var permissionApp = perm.value.split('.')[0]; // get appname

            // To insert perm in the right spot in $scope.apps
            var insert = function (id, perm, verboseName) {
                if (!$scope.apps[id]) {
                    $scope.apps[id] = {
                        app_name: verboseName,
                        app_visible: true,
                        permissions: []
                    };
                }
                $scope.apps[id].permissions.push(perm);
            };

            switch(permissionApp) {
                case 'core': // id 0 (projector) and id 6 (general)
                    if (perm.value.indexOf('projector') > -1) {
                        insert(0, perm, gettext('Projector'));
                    } else {
                        insert(6, perm, gettext('General'));
                    }
                    break;
                case 'agenda': // id 1
                    insert(1, perm, Agenda.verboseName);
                    break;
                case 'motions': // id 2
                    insert(2, perm, Motion.verboseNamePlural);
                    break;
                case 'assignments': // id 3
                    insert(3, perm, Assignment.verboseNamePlural);
                    break;
                case 'mediafiles': // id 4
                    insert(4, perm, Mediafile.verboseNamePlural);
                    break;
                case 'users': // id 5
                    insert(5, perm, User.verboseNamePlural);
                    break;
                default: // plugins: id>5
                    var display_name = pluginTranslation[permissionApp] || permissionApp.charAt(0).toUpperCase() +
                        permissionApp.slice(1);
                    // does the app exists?
                    var result = -1;
                    angular.forEach($scope.apps, function (app, index) {
                        if (app.app_name === display_name)
                            result = index;
                    });
                    var id = result == -1 ? $scope.apps.length : result;
                    insert(id, perm, display_name);
                    break;
            }
        });

        // sort each app: first all permission with 'see', then 'manage', then the rest
        // save the permissions in different lists an concat them in the right order together
        // Special Users: the two "see"-permissions are normally swapped. To create the right
        // order, we could simply reverse the whole permissions.
        angular.forEach($scope.apps, function (app, index) {
            if(index == 5) { // users
                app.permissions.reverse();
            } else { // rest
                var see = [];
                var manage = [];
                var others = [];
                angular.forEach(app.permissions, function (perm) {
                    if (perm.value.indexOf('see') > -1) {
                        see.push(perm);
                    } else if (perm.value.indexOf('manage') > -1) {
                        manage.push(perm);
                    } else {
                        others.push(perm);
                    }
                });
                app.permissions = see.concat(manage.concat(others));
            }
        });

        // check if the given group has the given permission
        $scope.hasPerm = function (group, permission) {
            return _.indexOf(group.permissions, permission.value) > -1;
        };

        // The current user is not allowed to lock himself out of the configuration:
        // - if the permission is 'users.can_manage' or 'users.can_see'
        // - if the user is in only one group with these permissions (group_danger is set)
        $scope.danger = function (group, permission){
            if ($scope.group_danger){
                if (permission.value == 'users.can_see_name' ||
                    permission.value == 'users.can_manage'){
                    return $scope.group_danger == group;
                }
            }
            return false;
        };

        // delete selected group
        $scope.delete = function (group) {
            Group.destroy(group.id);
        };

        // save changed permission
        $scope.changePermission = function (group, perm) {
            if (!$scope.danger(group, perm)) {
                if (!$scope.hasPerm(group, perm)) { // activate perm
                    group.permissions.push(perm.value);
                } else {
                    // delete perm in group.permissions
                    group.permissions = _.filter(group.permissions, function(value) {
                        return value != perm.value; // remove perm
                    });
                }
                Group.save(group);
            }
        };

        $scope.openDialog = function (group) {
            ngDialog.open({
                template: 'static/templates/users/group-edit.html',
                controller: group ? 'GroupRenameCtrl' : 'GroupCreateCtrl',
                className: 'ngdialog-theme-default wide-form',
                closeByEscape: false,
                closeByDocument: false,
                resolve: {
                    group: function () {return group;},
                }
            });
        };
    }
])

.controller('GroupRenameCtrl', [
    '$scope',
    'Group',
    'group',
    'gettextCatalog',
    'ErrorMessage',
    function($scope, Group, group, gettextCatalog, ErrorMessage) {
        $scope.group = group;
        $scope.new_name = gettextCatalog.getString(group.name);

        $scope.alert = {};
        $scope.save = function() {
            var old_name = gettextCatalog.getString($scope.group.name);
            $scope.group.name = $scope.new_name;
            Group.save($scope.group).then(
                function (success) {
                    $scope.closeThisDialog();
                },
                function (error) {
                   $scope.alert = ErrorMessage.forAlert(error);
                   $scope.group.name = old_name;
                }
            );
        };
    }
])

.controller('GroupCreateCtrl', [
    '$scope',
    'Group',
    'ErrorMessage',
    function($scope, Group, ErrorMessage) {
        $scope.new_name = '';
        $scope.alert = {};

        $scope.save = function() {
            var group = {
                name: $scope.new_name,
                permissions: []
            };

            Group.create(group).then(
                function (success) {
                    $scope.closeThisDialog();
                },
                function (error) {
                   $scope.alert = ErrorMessage.forAlert(error);
                }
            );
        };
    }
])

.factory('UserMenu', [
    '$http',
    'OpenSlides',
    'ngDialog',
    'UserProfileForm',
    'UserPasswordForm',
    function ($http, OpenSlides, ngDialog, UserProfileForm, UserPasswordForm) {
        return {
            logout: function () {
                $http.post('/users/logout/').then(function (response) {
                    // Success: User logged out, so reboot OpenSlides.
                    OpenSlides.reboot();
                });
            },
            editProfile: function () {
                ngDialog.open(UserProfileForm.getDialog());
            },
            changePassword: function () {
                ngDialog.open(UserPasswordForm.getDialog());
            },
        };
    }
])

.controller('userMenu', [
    '$scope',
    'UserMenu',
    function($scope, UserMenu) {
        $scope.logout = UserMenu.logout;
        $scope.editProfile = UserMenu.editProfile;
        $scope.changePassword = UserMenu.changePassword;

    }
])

.controller('LoginFormCtrl', [
    '$rootScope',
    '$scope',
    '$http',
    '$state',
    '$stateParams',
    '$q',
    'operator',
    'gettext',
    'autoupdate',
    'mainMenu',
    'DS',
    'ngDialog',
    function ($rootScope, $scope, $http, $state, $stateParams, $q, operator, gettext,
        autoupdate, mainMenu, DS, ngDialog) {
        $scope.alerts = [];

        if ($stateParams.msg) {
            $scope.alerts.push({
                type: 'danger',
                msg: $stateParams.msg,
            });
        }

        // check if guest login is allowed
        $scope.guestAllowed = $rootScope.guest_enabled;

        // get login info-text from server
        $http.get('/users/login/').then(function (success) {
            if(success.data.info_text) {
                $scope.alerts.push({
                    type: 'success',
                    msg: success.data.info_text
                });
            }
        });
        // check if cookies are enabled
        if (!navigator.cookieEnabled) {
            $scope.alerts.push({
                type: 'danger',
                msg: gettext('You have to enable cookies to use OpenSlides.'),
            });
        }

        // close alert function
        $scope.closeAlert = function(index) {
            $scope.alerts.splice(index, 1);
        };
        // login
        $scope.login = function () {
            $scope.closeThisDialog();
            $scope.alerts = [];
            var data = { 'username': $scope.username, 'password': $scope.password };
            if (!navigator.cookieEnabled) {
                data.cookies = false;
            }
            $http.post('/users/login/', data).then(
                function (response) {
                    // Success: User logged in.
                    // Clear store and reset deferred first message, if guests was enabled before.
                    DS.clear();
                    autoupdate.firstMessageDeferred = $q.defer();
                    // The next lines are partly the same lines as in core/start.js
                    autoupdate.newConnect();
                    autoupdate.firstMessageDeferred.promise.then(function () {
                        operator.setUser(response.data.user_id, response.data.user);
                        $rootScope.operator = operator;
                        mainMenu.updateMainMenu();
                        $state.go('home');
                        $rootScope.openslidesBootstrapDone = true;
                    });
                },
                function (error) {
                    // Error: Username or password is not correct.
                    $state.transitionTo($state.current, {msg: error.data.detail}, {
                          reload: true, inherit: false, notify: true
                    });
                }
            );
        };
        // guest login
        $scope.guestLogin = function () {
            $scope.closeThisDialog();
            $state.go('home');
        };
        // quick fix, that we cannot change the state to the main privacy
        // policy view. Display it in a dialog..
        $scope.openPrivacyPolicyDialog = function () {
            ngDialog.open({
                template: 'static/templates/privacypolicydialog.html',
                className: 'ngdialog-theme-default wide-form',
                controller: 'PrivacyPolicyDialogCtrl',
                showClose: true,
                closeByEscape: true,
                closeByDocument: true,
            });
        };
    }
])

.controller('PrivacyPolicyDialogCtrl', [
    '$scope',
    'PrivacyPolicy',
    function ($scope, PrivacyPolicy) {
        $scope.privacyPolicy = PrivacyPolicy;
    }
])

// Mark all users strings for translation in JavaScript.
.config([
    'gettext',
    function (gettext) {
        // permission strings (see models.py of each Django app)
        // agenda
        gettext('Can see agenda');
        gettext('Can manage agenda');
        gettext('Can manage list of speakers');
        gettext('Can see internal items and time scheduling of agenda');
        gettext('Can put oneself on the list of speakers');
        // assignments
        gettext('Can see elections');
        gettext('Can nominate another participant');
        gettext('Can nominate oneself');
        gettext('Can manage elections');
        // core
        gettext('Can see the projector');
        gettext('Can manage the projector');
        gettext('Can see the front page');
        gettext('Can manage tags');
        gettext('Can manage configuration');
        gettext('Can use the chat');
        gettext('Can manage the chat');
        gettext('Can manage logos and fonts');
        // mediafiles
        gettext('Can see the list of files');
        gettext('Can upload files');
        gettext('Can manage files');
        gettext('Can see hidden files');
        // motions
        gettext('Can see motions');
        gettext('Can create motions');
        gettext('Can support motions');
        gettext('Can manage motions');
        gettext('Can see comments');
        gettext('Can manage comments');
        // users
        gettext('Can see names of users');
        gettext('Can see extra data of users (e.g. present and comment)');
        gettext('Can manage users');

        // config strings in users/config_variables.py
        gettext('General');
        gettext('Sort name of participants by');
        gettext('Enable participant presence view');
        gettext('Participants');
        gettext('Given name');
        gettext('Surname');
        gettext('PDF');
        gettext('Welcome to OpenSlides');
        gettext('Title for access data and welcome PDF');
        gettext('[Place for your welcome and help text.]');
        gettext('Help text for access data and welcome PDF');
        gettext('System URL');
        gettext('Used for QRCode in PDF of access data.');
        gettext('WLAN name (SSID)');
        gettext('Used for WLAN QRCode in PDF of access data.');
        gettext('WLAN password');
        gettext('Used for WLAN QRCode in PDF of access data.');
        gettext('WLAN encryption');
        gettext('Used for WLAN QRCode in PDF of access data.');
        gettext('WEP');
        gettext('WPA/WPA2');
        gettext('No encryption');
        gettext('Email');
        gettext('Email sender');
        gettext('Email subject');
        gettext('Your login for {event_name}');
        gettext('You can use {event_name} as a placeholder.');
        gettext('Email body');
        gettext('Dear {name},\n\nthis is your OpenSlides login for the event {event_name}:\n\n    {url}\n    username: {username}\n    password: {password}\n\nThis email was generated automatically.');
        gettext('Use these placeholders: {name}, {event_name}, {url}, {username}, {password}. The url referrs to the system url.');
    }
]);


// this is code from angular.js. Find a way to call this function from this file
function getBlockNodes(nodes) {
  // TODO(perf): just check if all items in `nodes` are siblings and if they are return the original
  //             collection, otherwise update the original collection.
  var node = nodes[0];
  var endNode = nodes[nodes.length - 1];
  var blockNodes = [node];

  do {
    node = node.nextSibling;
    if (!node) break;
    blockNodes.push(node);
  } while (node !== endNode);

  return $(blockNodes);
}

}());

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFnZW5kYS9zdGF0aWMvanMvYWdlbmRhL2Jhc2UuanMiLCJhZ2VuZGEvc3RhdGljL2pzL2FnZW5kYS9jc3YuanMiLCJhZ2VuZGEvc3RhdGljL2pzL2FnZW5kYS9kb2N4LmpzIiwiYWdlbmRhL3N0YXRpYy9qcy9hZ2VuZGEvcGRmLmpzIiwiYWdlbmRhL3N0YXRpYy9qcy9hZ2VuZGEvcHJvamVjdG9yLmpzIiwiYWdlbmRhL3N0YXRpYy9qcy9hZ2VuZGEvc2l0ZS5qcyIsImFzc2lnbm1lbnRzL3N0YXRpYy9qcy9hc3NpZ25tZW50cy9iYXNlLmpzIiwiYXNzaWdubWVudHMvc3RhdGljL2pzL2Fzc2lnbm1lbnRzL3BkZi5qcyIsImFzc2lnbm1lbnRzL3N0YXRpYy9qcy9hc3NpZ25tZW50cy9wcm9qZWN0b3IuanMiLCJhc3NpZ25tZW50cy9zdGF0aWMvanMvYXNzaWdubWVudHMvc2l0ZS5qcyIsImNvcmUvc3RhdGljL2pzL2NvcmUvYmFzZS5qcyIsImNvcmUvc3RhdGljL2pzL2NvcmUvY3N2LmpzIiwiY29yZS9zdGF0aWMvanMvY29yZS9kb2N4LmpzIiwiY29yZS9zdGF0aWMvanMvY29yZS9wZGYuanMiLCJjb3JlL3N0YXRpYy9qcy9jb3JlL3Byb2plY3Rvci5qcyIsImNvcmUvc3RhdGljL2pzL2NvcmUvcmVtb3ZlLWZvcm1hdC1wbHVnaW4uanMiLCJjb3JlL3N0YXRpYy9qcy9jb3JlL3NpdGUuanMiLCJjb3JlL3N0YXRpYy9qcy9jb3JlL3N0YXJ0LmpzIiwibWVkaWFmaWxlcy9zdGF0aWMvanMvbWVkaWFmaWxlcy9mb3Jtcy5qcyIsIm1lZGlhZmlsZXMvc3RhdGljL2pzL21lZGlhZmlsZXMvaW1hZ2UtcGx1Z2luLmpzIiwibWVkaWFmaWxlcy9zdGF0aWMvanMvbWVkaWFmaWxlcy9saXN0LmpzIiwibWVkaWFmaWxlcy9zdGF0aWMvanMvbWVkaWFmaWxlcy9wcm9qZWN0b3IuanMiLCJtZWRpYWZpbGVzL3N0YXRpYy9qcy9tZWRpYWZpbGVzL3Jlc291cmNlcy5qcyIsIm1lZGlhZmlsZXMvc3RhdGljL2pzL21lZGlhZmlsZXMvc2l0ZS5qcyIsIm1lZGlhZmlsZXMvc3RhdGljL2pzL21lZGlhZmlsZXMvc3RhdGVzLmpzIiwibWVkaWFmaWxlcy9zdGF0aWMvanMvbWVkaWFmaWxlcy91cGRhdGUuanMiLCJtZWRpYWZpbGVzL3N0YXRpYy9qcy9tZWRpYWZpbGVzL3VwbG9hZC5qcyIsIm1vdGlvbnMvc3RhdGljL2pzL21vdGlvbnMvYmFzZS5qcyIsIm1vdGlvbnMvc3RhdGljL2pzL21vdGlvbnMvY3N2LmpzIiwibW90aW9ucy9zdGF0aWMvanMvbW90aW9ucy9kaWZmLmpzIiwibW90aW9ucy9zdGF0aWMvanMvbW90aW9ucy9kb2N4LmpzIiwibW90aW9ucy9zdGF0aWMvanMvbW90aW9ucy9saW5lbnVtYmVyaW5nLmpzIiwibW90aW9ucy9zdGF0aWMvanMvbW90aW9ucy9tb3Rpb24tYmxvY2stcHJvamVjdG9yLmpzIiwibW90aW9ucy9zdGF0aWMvanMvbW90aW9ucy9tb3Rpb24tYmxvY2suanMiLCJtb3Rpb25zL3N0YXRpYy9qcy9tb3Rpb25zL21vdGlvbi1zZXJ2aWNlcy5qcyIsIm1vdGlvbnMvc3RhdGljL2pzL21vdGlvbnMvcGRmLmpzIiwibW90aW9ucy9zdGF0aWMvanMvbW90aW9ucy9wcm9qZWN0b3IuanMiLCJtb3Rpb25zL3N0YXRpYy9qcy9tb3Rpb25zL3NpdGUuanMiLCJtb3Rpb25zL3N0YXRpYy9qcy9tb3Rpb25zL3dvcmtmbG93LmpzIiwicG9sbC9zdGF0aWMvanMvcG9sbC9tYWpvcml0eS5qcyIsInRvcGljcy9zdGF0aWMvanMvdG9waWNzL2Jhc2UuanMiLCJ0b3BpY3Mvc3RhdGljL2pzL3RvcGljcy9jc3YuanMiLCJ0b3BpY3Mvc3RhdGljL2pzL3RvcGljcy9wcm9qZWN0b3IuanMiLCJ0b3BpY3Mvc3RhdGljL2pzL3RvcGljcy9zaXRlLmpzIiwidXNlcnMvc3RhdGljL2pzL3VzZXJzL2Jhc2UuanMiLCJ1c2Vycy9zdGF0aWMvanMvdXNlcnMvY3N2LmpzIiwidXNlcnMvc3RhdGljL2pzL3VzZXJzL3BkZi5qcyIsInVzZXJzL3N0YXRpYy9qcy91c2Vycy9wcm9qZWN0b3IuanMiLCJ1c2Vycy9zdGF0aWMvanMvdXNlcnMvc2l0ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzEzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMXBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzc2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDM3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0NENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDclNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzltREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcmpEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3B3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdjZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDOXZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoib3BlbnNsaWRlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAuYWdlbmRhJywgWydPcGVuU2xpZGVzQXBwLnVzZXJzJ10pXG5cbi5mYWN0b3J5KCdTcGVha2VyJywgW1xuICAgICdEUycsXG4gICAgZnVuY3Rpb24oRFMpIHtcbiAgICAgICAgcmV0dXJuIERTLmRlZmluZVJlc291cmNlKHtcbiAgICAgICAgICAgIG5hbWU6ICdhZ2VuZGEvc3BlYWtlcicsXG4gICAgICAgICAgICByZWxhdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBiZWxvbmdzVG86IHtcbiAgICAgICAgICAgICAgICAgICAgJ3VzZXJzL3VzZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEtleTogJ3VzZXJfaWQnLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnQWdlbmRhJywgW1xuICAgICckaHR0cCcsXG4gICAgJ0RTJyxcbiAgICAnU3BlYWtlcicsXG4gICAgJ2pzRGF0YU1vZGVsJyxcbiAgICAnUHJvamVjdG9yJyxcbiAgICAnUHJvamVjdEhlbHBlcicsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgJ0NhbWVsQ2FzZScsXG4gICAgJ0VkaXRGb3JtJyxcbiAgICBmdW5jdGlvbigkaHR0cCwgRFMsIFNwZWFrZXIsIGpzRGF0YU1vZGVsLCBQcm9qZWN0b3IsIFByb2plY3RIZWxwZXIsIGdldHRleHRDYXRhbG9nLFxuICAgICAgICBnZXR0ZXh0LCBDYW1lbENhc2UsIEVkaXRGb3JtKSB7XG4gICAgICAgIHZhciBuYW1lID0gJ2FnZW5kYS9pdGVtJztcbiAgICAgICAgcmV0dXJuIERTLmRlZmluZVJlc291cmNlKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB1c2VDbGFzczoganNEYXRhTW9kZWwsXG4gICAgICAgICAgICB2ZXJib3NlTmFtZTogZ2V0dGV4dCgnQWdlbmRhJyksXG4gICAgICAgICAgICBjb21wdXRlZDoge1xuICAgICAgICAgICAgICAgIGlzX3B1YmxpYzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuaXNfaW50ZXJuYWwgJiYgIXRoaXMuaXNfaGlkZGVuO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWV0aG9kczoge1xuICAgICAgICAgICAgICAgIGdldFJlc291cmNlTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldENvbnRlbnRPYmplY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERTLmdldCh0aGlzLmNvbnRlbnRfb2JqZWN0LmNvbGxlY3Rpb24sIHRoaXMuY29udGVudF9vYmplY3QuaWQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0Q29udGVudE9iamVjdERldGFpbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDYW1lbENhc2UodGhpcy5jb250ZW50X29iamVjdC5jb2xsZWN0aW9uKS5yZXBsYWNlKCcvJywgJy4nKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnLmRldGFpbCh7aWQ6ICcgKyB0aGlzLmNvbnRlbnRfb2JqZWN0LmlkICsgJ30pJztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldENvbnRlbnRPYmplY3RGb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFZGl0Rm9ybS5mcm9tQ29sbGVjdGlvblN0cmluZyh0aGlzLmNvbnRlbnRfb2JqZWN0LmNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0Q29udGVudFJlc291cmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEUy5kZWZpbml0aW9uc1t0aGlzLmNvbnRlbnRfb2JqZWN0LmNvbGxlY3Rpb25dO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0VGl0bGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpdGxlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSAgdGhpcy5nZXRDb250ZW50T2JqZWN0KCkuZ2V0QWdlbmRhVGl0bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgY29udGVudCBvYmplY3QgaXMgbm90IGluIHRoZSBEUyBzdG9yZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gdGhpcy50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtX251bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSB0aGlzLml0ZW1fbnVtYmVyICsgJyDCtyAnICsgdGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpdGxlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0TGlzdE9mU3BlYWtlcnNUaXRsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9ICB0aGlzLmdldENvbnRlbnRPYmplY3QoKS5nZXRMaXN0T2ZTcGVha2Vyc1RpdGxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtX251bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gdGhpcy5pdGVtX251bWJlciArICcgwrcgJyArIHRpdGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHRoaXMuZ2V0VGl0bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGl0bGU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRBZ2VuZGFUaXRsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aXRsZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldENTVkV4cG9ydFRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gIHRoaXMuZ2V0Q29udGVudE9iamVjdCgpLmdldENTVkV4cG9ydFRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgY29udGVudCBvYmplY3QgaXMgbm90IGluIHRoZSBEUyBzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgJ2dldENTVkV4cG9ydFRleHQnIGlzIG5vdCBkZWZpbmVkIHJldHVybiBub3RoaW5nLlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gbGluayBuYW1lIHdoaWNoIGlzIHNob3duIGluIHNlYXJjaCByZXN1bHRcbiAgICAgICAgICAgICAgICBnZXRTZWFyY2hSZXN1bHROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFnZW5kYVRpdGxlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdHJ1ZSBpZiBhIHNwZWNpZmljIHJlbGF0aW9uIG1hdGNoZXMgZm9yIGdpdmVuIHNlYXJjaHF1ZXJ5XG4gICAgICAgICAgICAgICAgLy8gKGhlcmU6IHNwZWFrZXJzKVxuICAgICAgICAgICAgICAgIGhhc1NlYXJjaFJlc3VsdDogZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWFyY2ggZm9yIHNwZWFrZXJzIChjaGVjayBpZiBhbnkgdXNlci5pZCBmcm9tIGFscmVhZHkgZm91bmQgdXNlcnMgbWF0Y2hlcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uc29tZShyZXN1bHRzLCBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZ2V0UmVzb3VyY2VOYW1lKCkgPT09IFwidXNlcnMvdXNlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8uc29tZShpdGVtLnNwZWFrZXJzLCB7J3VzZXJfaWQnOiByZXN1bHQuaWR9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0UHJvamVjdG9yVGl0bGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbnRlbnRPYmplY3QoKS5nZXRBZ2VuZGFMaXN0Vmlld1RpdGxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGNvbnRlbnQgb2JqZWN0IGlzIG5vdCBpbiB0aGUgRFMgc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Rfdmlld190aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0TGlzdFZpZXdUaXRsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmdldFByb2plY3RvclRpdGxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1fbnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHRoaXMuaXRlbV9udW1iZXIgKyAnIMK3ICcgKyB0aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGl0bGU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRJdGVtTnVtYmVyV2l0aEFuY2VzdG9yczogZnVuY3Rpb24gKGFnZW5kYUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWdlbmRhSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZW5kYUlkID0gdGhpcy5pZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYWdlbmRhSXRlbSA9IERTLmdldChuYW1lLCBhZ2VuZGFJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWdlbmRhSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFnZW5kYUl0ZW0uaXRlbV9udW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZ2VuZGFJdGVtLml0ZW1fbnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFnZW5kYUl0ZW0ucGFyZW50X2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtTnVtYmVyV2l0aEFuY2VzdG9ycyhhZ2VuZGFJdGVtLnBhcmVudF9pZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIG92ZXJyaWRlIHByb2plY3QgZnVuY3Rpb24gb2YganNEYXRhTW9kZWwgZmFjdG9yeVxuICAgICAgICAgICAgICAgIHByb2plY3Q6IGZ1bmN0aW9uIChwcm9qZWN0b3JJZCwgdHJlZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzUHJvamVjdGVkSWRzID0gdGhpcy5pc1Byb2plY3RlZCh0cmVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9pZHM6IGlzUHJvamVjdGVkSWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjdGl2YXRlLCBpZiB0aGUgcHJvamVjdG9yX2lkIGlzIGEgbmV3IHByb2plY3Rvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLmluZGV4T2YoaXNQcm9qZWN0ZWRJZHMsIHByb2plY3RvcklkKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhLnBydW5lID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcHJvamVjdG9ySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhZ2VuZGEvaXRlbS1saXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb2plY3RIZWxwZXIucHJvamVjdChyZXF1ZXN0RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAvLyBQcm9qZWN0IHRoZSBjb250ZW50IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRPYmplY3QgPSBEUy5nZXQodGhpcy5jb250ZW50X29iamVjdC5jb2xsZWN0aW9uLCB0aGlzLmNvbnRlbnRfb2JqZWN0LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50T2JqZWN0LnByb2plY3QocHJvamVjdG9ySWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBpc1Byb2plY3RlZCBmdW5jdGlvbiBvZiBqc0RhdGFNb2RlbCBmYWN0b3J5XG4gICAgICAgICAgICAgICAgaXNQcm9qZWN0ZWQ6IGZ1bmN0aW9uICh0cmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybnMgYWxsIGlkcyBvZiBhbGwgcHJvamVjdG9ycyB3aXRoIGFuIGFnZW5kYS1pdGVtIGVsZW1lbnQuIE90aGVyd2lzZSBhbiBlbXB0eSBsaXN0LlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyZWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZGljYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXRlbSB0cmVlIHNsaWRlIGZvciBzdWIgdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZWxlbWVudC5uYW1lID09ICdhZ2VuZGEvaXRlbS1saXN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZWxlbWVudC5pZCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pZCA9PSBzZWxmLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWxlYXRlZCBpdGVtIGRldGFpbCBzbGlkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZWxlbWVudC5uYW1lID09IHNlbGYuY29udGVudF9vYmplY3QuY29sbGVjdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZWxlbWVudC5pZCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pZCA9PSBzZWxmLmNvbnRlbnRfb2JqZWN0LmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNQcm9qZWN0ZWRJZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgUHJvamVjdG9yLmdldEFsbCgpLmZvckVhY2goZnVuY3Rpb24gKHByb2plY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfLmZpbmRLZXkocHJvamVjdG9yLmVsZW1lbnRzLCBwcmVkaWNhdGUpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJvamVjdGVkSWRzLnB1c2gocHJvamVjdG9yLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1Byb2plY3RlZElkcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzUmVsYXRlZFByb2plY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWxhdGVkIG9iamVjdHMgZm9yIGFnZW5kYSBpdGVtczogbGlzdCBvZiBzcGVha2VycyBzbGlkZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNMaXN0T2ZTcGVha2Vyc1Byb2plY3RlZCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gcHJvamVjdCBsaXN0IG9mIHNwZWFrZXJzXG4gICAgICAgICAgICAgICAgcHJvamVjdExpc3RPZlNwZWFrZXJzOiBmdW5jdGlvbihwcm9qZWN0b3JJZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNQcm9qZWN0ZWRJZHMgPSB0aGlzLmlzTGlzdE9mU3BlYWtlcnNQcm9qZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3REYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfaWRzOiBpc1Byb2plY3RlZElkcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uaW5kZXhPZihpc1Byb2plY3RlZElkcywgcHJvamVjdG9ySWQpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YS5wcnVuZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcHJvamVjdG9ySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWdlbmRhL2xpc3Qtb2Ytc3BlYWtlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvamVjdEhlbHBlci5wcm9qZWN0KHJlcXVlc3REYXRhKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGxpc3Qgb2Ygc3BlYWtlcnMgaXMgcHJvamVjdGVkXG4gICAgICAgICAgICAgICAgaXNMaXN0T2ZTcGVha2Vyc1Byb2plY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIGFsbCBpZHMgb2YgYWxsIHByb2plY3RvcnMgd2l0aCBhbiBlbGVtZW50IHdpdGggdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIG5hbWUgJ2FnZW5kYS9saXN0LW9mLXNwZWFrZXJzJyBhbmQgdGhlIHNhbWUgaWQuIEVsc2UgcmV0dXJucyBhbiBlbXB0eSBsaXN0LlxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVkaWNhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQubmFtZSA9PSAnYWdlbmRhL2xpc3Qtb2Ytc3BlYWtlcnMnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGVsZW1lbnQuaWQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pZCA9PSBzZWxmLmlkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNQcm9qZWN0ZWRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIFByb2plY3Rvci5nZXRBbGwoKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgXy5maW5kS2V5KHByb2plY3Rvci5lbGVtZW50cywgcHJlZGljYXRlKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1Byb2plY3RlZHMucHVzaChwcm9qZWN0b3IuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJvamVjdGVkcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhc1N1Yml0ZW1zOiBmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNDaGlsZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGl0ZW0gaGFzIGF0IGxlYXN0IG9uZSBjaGlsZCBpdGVtLlxuICAgICAgICAgICAgICAgICAgICBfLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnRfaWQgPT0gc2VsZi5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNDaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVsYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgaGFzTWFueToge1xuICAgICAgICAgICAgICAgICAgICAnY29yZS90YWcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAndGFncycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEtleXM6ICd0YWdzX2lkJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2FnZW5kYS9zcGVha2VyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGaWVsZDogJ3NwZWFrZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmVpZ25LZXk6ICdpdGVtX2lkJyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiZWZvcmVJbmplY3Q6IGZ1bmN0aW9uIChyZXNvdXJjZSwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBTcGVha2VyLmVqZWN0QWxsKHt3aGVyZToge2l0ZW1faWQ6IHsnPT0nOiBpbnN0YW5jZS5pZH19fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdBZ2VuZGFUcmVlJywgW1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldFRyZWU6IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgICAgICAgICAgIC8vIFNvcnQgaXRlbXMgYWZ0ZXIgdGhlcmUgd2VpZ2h0XG4gICAgICAgICAgICAgICAgaXRlbXMuc29ydChmdW5jdGlvbihpdGVtQSwgaXRlbUIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1BLndlaWdodCAtIGl0ZW1CLndlaWdodDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIGEgZGljdCB3aXRoIGFsbCBjaGlsZHJlbiAoZGljdC12YWx1ZSkgdG8gYSBzcGVjaWZpY1xuICAgICAgICAgICAgICAgIC8vIGl0ZW0gaWQgKGRpY3Qta2V5KS5cbiAgICAgICAgICAgICAgICB2YXIgaXRlbUNoaWxkcmVuID0ge307XG5cbiAgICAgICAgICAgICAgICBfLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnBhcmVudF9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGl0ZW0gdG8gaGlzIHBhcmVudC4gSWYgaXQgaXMgdGhlIGZpcnN0IGNoaWxkLCB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNoaWxkcmVuW2l0ZW0ucGFyZW50X2lkXS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQ2hpbGRyZW5baXRlbS5wYXJlbnRfaWRdID0gW2l0ZW1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhIG5lc3RlZCBsaXN0IHdpdGggYWxsXG4gICAgICAgICAgICAgICAgLy8gaXRlbXMgd2l0aCB0aGVyZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldENoaWxkcmVuKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5JdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBfLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5JdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBnZXRDaGlsZHJlbihpdGVtQ2hpbGRyZW5baXRlbS5pZF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuSXRlbXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBsaXN0IG9mIHJvb3QgaXRlbXMgKHdpdGggbm8gcGFyZW50cylcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SXRlbXMgPSBpdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpdGVtLnBhcmVudF9pZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4ocGFyZW50SXRlbXMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gUmV0dXJucyBhIGxpc3Qgb2YgYWxsIGl0ZW1zIGFzIGEgZmxhdCB0cmVlXG4gICAgICAgICAgICBnZXRGbGF0VHJlZTogZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJlZSA9IHRoaXMuZ2V0VHJlZShpdGVtcyk7XG4gICAgICAgICAgICAgICAgdmFyIGZsYXRJdGVtcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVGbGF0VHJlZSh0cmVlLCBwYXJlbnRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBfLmVhY2godHJlZSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaXRlbS5jaGlsZHJlbkNvdW50ID0gaXRlbS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLml0ZW0ucGFyZW50Q291bnQgPSBwYXJlbnRDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYXRJdGVtcy5wdXNoKGl0ZW0uaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZsYXRUcmVlKGl0ZW0uY2hpbGRyZW4sIHBhcmVudENvdW50ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUZsYXRUcmVlKHRyZWUsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbGF0SXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ0N1cnJlbnRMaXN0T2ZTcGVha2Vyc0l0ZW0nLCBbXG4gICAgJ1Byb2plY3RvcicsXG4gICAgJ0FnZW5kYScsXG4gICAgZnVuY3Rpb24gKFByb2plY3RvciwgQWdlbmRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXRJdGVtOiBmdW5jdGlvbiAocHJvamVjdG9ySWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvamVjdG9yID0gUHJvamVjdG9yLmdldChwcm9qZWN0b3JJZCksIGl0ZW07XG4gICAgICAgICAgICAgICAgaWYgKHByb2plY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2gocHJvamVjdG9yLmVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5hZ2VuZGFfaXRlbV9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBBZ2VuZGEuZ2V0KGVsZW1lbnQuYWdlbmRhX2l0ZW1faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ0N1cnJlbnRMaXN0T2ZTcGVha2Vyc1NsaWRlJywgW1xuICAgICckaHR0cCcsXG4gICAgJ1Byb2plY3RvcicsXG4gICAgZnVuY3Rpb24oJGh0dHAsIFByb2plY3Rvcikge1xuICAgICAgICB2YXIgbmFtZSA9ICdhZ2VuZGEvY3VycmVudC1saXN0LW9mLXNwZWFrZXJzJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb2plY3Q6IGZ1bmN0aW9uIChwcm9qZWN0b3JJZCwgb3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIHZhciBpc1Byb2plY3RlZCA9IHRoaXMuaXNQcm9qZWN0ZWRXaXRoT3ZlcmxheVN0YXR1cygpO1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChpc1Byb2plY3RlZCwgZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgJGh0dHAucG9zdCgnL3Jlc3QvY29yZS9wcm9qZWN0b3IvJyArIG1hcHBpbmcucHJvamVjdG9ySWQgKyAnL2RlYWN0aXZhdGVfZWxlbWVudHMvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFttYXBwaW5nLnV1aWRdXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgc2xpZGUgd2FzIHByb2plY3RlZCwgaWYgdGhlIGlkIG1hdGNoZXMuIElmIHRoZSBvdmVybGF5IGlzIGdpdmVuLCBhbHNvXG4gICAgICAgICAgICAgICAgLy8gdGhlIG92ZXJsYXkgaXMgY2hlY2tlZFxuICAgICAgICAgICAgICAgIHZhciB3YXNQcm9qZWN0ZWRCZWZvcmUgPSBfLnNvbWUoaXNQcm9qZWN0ZWQsIGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IChtYXBwaW5nLnByb2plY3RvcklkID09PSBwcm9qZWN0b3JJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgJiYgKG1hcHBpbmcub3ZlcmxheSA9PT0gb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBvdmVybGF5IHx8IGZhbHNlOyAvLyBzZXQgb3ZlcmxheSBpZiBpdCB3YXNuJ3QgZGVmaW5lZFxuXG4gICAgICAgICAgICAgICAgaWYgKCF3YXNQcm9qZWN0ZWRCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRodHRwLnBvc3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9yZXN0L2NvcmUvcHJvamVjdG9yLycgKyBwcm9qZWN0b3JJZCArICcvYWN0aXZhdGVfZWxlbWVudHMvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3tuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWJsZTogb3ZlcmxheSwgLy8gaWYgdGhpcyBpcyBhbiBvdmVybGF5LCBpdCBzaG91bGQgbm90IGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmVkIGJ5IGNoYW5naW5nIHRoZSBtYWluIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5OiBvdmVybGF5fV1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgYWxsIGVsZW1lbnRzIG9uIHRoaXMgcHJvamVjdG9yLCBiZWNhdXNlIHdlIGFyZSBfbm90XyB1c2luZyB0aGUgb3ZlcmxheS5cbiAgICAgICAgICAgICAgICAgICAgICAgICRodHRwLnBvc3QoJy9yZXN0L2NvcmUvcHJvamVjdG9yLycgKyBwcm9qZWN0b3JJZCArICcvY2xlYXJfZWxlbWVudHMvJykudGhlbihhY3RpdmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzUHJvamVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyB0aGUgaWRzIG9mIGFsbCBwcm9qZWN0b3JzIHdpdGggYW4gYWdlbmRhLWl0ZW0gZWxlbWVudC4gRWxzZSByZXR1cm4gYW4gZW1wdHkgbGlzdC5cbiAgICAgICAgICAgICAgICB2YXIgcHJlZGljYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQubmFtZSA9PT0gbmFtZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBpc1Byb2plY3RlZElkcyA9IFtdO1xuICAgICAgICAgICAgICAgIFByb2plY3Rvci5nZXRBbGwoKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfLmZpbmRLZXkocHJvamVjdG9yLmVsZW1lbnRzLCBwcmVkaWNhdGUpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcm9qZWN0ZWRJZHMucHVzaChwcm9qZWN0b3IuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJvamVjdGVkSWRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFJldHVybnMgYSBsaXN0IG9mIG1hcHBpbmdzIGJldHdlZW4gcG9qZWN0b3IgaWQsIG92ZXJsYXkgYW5kIHV1aWQuXG4gICAgICAgICAgICBpc1Byb2plY3RlZFdpdGhPdmVybGF5U3RhdHVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcHBpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goUHJvamVjdG9yLmdldEFsbCgpLCBmdW5jdGlvbiAocHJvamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChwcm9qZWN0b3IuZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtZW50LCB1dWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdG9ySWQ6IHByb2plY3Rvci5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXVpZDogdXVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheTogZWxlbWVudC5vdmVybGF5IHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwcGluZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuXG5cbi8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBBZ2VuZGEgcmVzb3VyY2UgaXMgbG9hZGVkLlxuLnJ1bihbJ0FnZW5kYScsIGZ1bmN0aW9uKEFnZW5kYSkge31dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAuYWdlbmRhLmNzdicsIFtdKVxuXG4uZmFjdG9yeSgnQWdlbmRhQ3N2RXhwb3J0JywgW1xuICAgICdIdW1hblRpbWVDb252ZXJ0ZXInLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0NzdkRvd25sb2FkJyxcbiAgICBmdW5jdGlvbiAoSHVtYW5UaW1lQ29udmVydGVyLCBnZXR0ZXh0Q2F0YWxvZywgQ3N2RG93bmxvYWQpIHtcbiAgICAgICAgdmFyIG1ha2VIZWFkZXJsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhlYWRlcmxpbmUgPSBbJ1RpdGxlJywgJ1RleHQnLCAnRHVyYXRpb24nLCAnQ29tbWVudCcsICdJbnRlcm5hbCBpdGVtJ107XG4gICAgICAgICAgICByZXR1cm4gXy5tYXAoaGVhZGVybGluZSwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldHRleHRDYXRhbG9nLmdldFN0cmluZyhlbnRyeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cG9ydDogZnVuY3Rpb24gKGFnZW5kYSkge1xuICAgICAgICAgICAgICAgIHZhciBjc3ZSb3dzID0gW1xuICAgICAgICAgICAgICAgICAgICBtYWtlSGVhZGVybGluZSgpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goYWdlbmRhLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGl0ZW0uZHVyYXRpb24gPyBIdW1hblRpbWVDb252ZXJ0ZXIuc2Vjb25kc1RvSHVtYW5UaW1lKGl0ZW0uZHVyYXRpb24qNjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzZWNvbmRzOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyczogJ2VuYWJsZWQnIH0pIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCdcIicgKyAoaXRlbS50aXRsZSB8fCAnJykgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goJ1wiJyArIChpdGVtLmdldENTVkV4cG9ydFRleHQoKSB8fCAnJykgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goJ1wiJyArIGR1cmF0aW9uICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCdcIicgKyAoaXRlbS5jb21tZW50IHx8ICcnKSArICdcIicpO1xuICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgnXCInICsgKGl0ZW0uaXNfaGlkZGVuID8gJzEnIDogJycpICArICdcIicpO1xuICAgICAgICAgICAgICAgICAgICBjc3ZSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBDc3ZEb3dubG9hZChjc3ZSb3dzLCBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0FnZW5kYScpICsgJy5jc3YnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmFuZ3VsYXIubW9kdWxlKCdPcGVuU2xpZGVzQXBwLmFnZW5kYS5kb2N4JywgWydPcGVuU2xpZGVzQXBwLmNvcmUuZG9jeCddKVxuXG4uZmFjdG9yeSgnQWdlbmRhRG9jeEV4cG9ydCcsIFtcbiAgICAnJGh0dHAnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0ZpbGVTYXZlcicsXG4gICAgJ0FnZW5kYScsXG4gICAgJ0FnZW5kYVRyZWUnLFxuICAgICdDb25maWcnLFxuICAgIGZ1bmN0aW9uICgkaHR0cCwgZ2V0dGV4dENhdGFsb2csIEZpbGVTYXZlciwgQWdlbmRhLCBBZ2VuZGFUcmVlLCBDb25maWcpIHtcblxuICAgICAgICB2YXIgZ2V0RGF0YSA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgICAgICAgLy8gSXRlbSBzdHJ1Y3R1cmU6IFRoZSB0b3AgbGF5ZXIgaGFzIHN1Yml0ZW1zLCB0aGF0IGFyZSBmbGF0LlxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGxheWVyIGlzIGJvbGQgYW5kIGFsbCBzdWJsYXllcnMgbm90LiBUaGUgZG9jeFxuICAgICAgICAgICAgLy8gdGVtcGxhdGVyIGNhbm5vdCByZW5kZXIgaXRlbXMgcmVjdXJzaXZlbHksIHNvIHRoZSBzZWNvbmRcbiAgICAgICAgICAgIC8vIGxheWVyIGFyZSBhbGwgc3ViaXRlbXMgZmxhdGVkIG91dC4gU3BhY2luZyBpcyBkb25lIHdpdGggdGFicy5cbiAgICAgICAgICAgIHZhciB0cmVlID0gQWdlbmRhVHJlZS5nZXRUcmVlKGl0ZW1zKTtcbiAgICAgICAgICAgIHZhciBzdWJpdGVtcyA9IFtdOyAvLyBUaGlzIHdpbGwgYmUgdXNlZCBhcyBhIHRlbXBvcmFyeSB2YXJpYWJsZS5cbiAgICAgICAgICAgIHZhciBmbGF0U3ViaXRlbXMgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIHBhcmVudENvdW50KSB7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcHMgPSBfLnJlcGVhdCgnXFx0JywgcGFyZW50Q291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgc3ViaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtX251bWJlcjogdGFwcyArIGNoaWxkLml0ZW0uaXRlbV9udW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtX3RpdGxlOiBjaGlsZC5pdGVtLmxpc3Rfdmlld190aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZsYXRTdWJpdGVtcyhjaGlsZC5jaGlsZHJlbiwgcGFyZW50Q291bnQgKyAxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdHdvTGF5ZXJUcmVlID0gXy5tYXAodHJlZSwgZnVuY3Rpb24gKG1haW5JdGVtKSB7XG4gICAgICAgICAgICAgICAgc3ViaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmbGF0U3ViaXRlbXMobWFpbkl0ZW0uY2hpbGRyZW4sIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1fbnVtYmVyOiBtYWluSXRlbS5pdGVtLml0ZW1fbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBpdGVtX3RpdGxlOiBtYWluSXRlbS5pdGVtLmxpc3Rfdmlld190aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgc3ViaXRlbXM6IHN1Yml0ZW1zLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gaGVhZGVyXG4gICAgICAgICAgICB2YXIgaGVhZGVybGluZTEgPSBbXG4gICAgICAgICAgICAgICAgQ29uZmlnLnRyYW5zbGF0ZShDb25maWcuZ2V0KCdnZW5lcmFsX2V2ZW50X25hbWUnKS52YWx1ZSksXG4gICAgICAgICAgICAgICAgQ29uZmlnLnRyYW5zbGF0ZShDb25maWcuZ2V0KCdnZW5lcmFsX2V2ZW50X2Rlc2NyaXB0aW9uJykudmFsdWUpXG4gICAgICAgICAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKCcg4oCTICcpO1xuICAgICAgICAgICAgdmFyIGhlYWRlcmxpbmUyID0gW1xuICAgICAgICAgICAgICAgIENvbmZpZy5nZXQoJ2dlbmVyYWxfZXZlbnRfbG9jYXRpb24nKS52YWx1ZSxcbiAgICAgICAgICAgICAgICBDb25maWcuZ2V0KCdnZW5lcmFsX2V2ZW50X2RhdGUnKS52YWx1ZVxuICAgICAgICAgICAgXS5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKTtcblxuICAgICAgICAgICAgLy8gRGF0YSBzdHJ1Y3R1cmUgZm9yIHRoZSBkb2N4IHRlbXBsYXRlci5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGVhZGVyOiBbaGVhZGVybGluZTEsIGhlYWRlcmxpbmUyXS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICBhZ2VuZGFfdHJhbnNsYXRpb246IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQWdlbmRhJyksXG4gICAgICAgICAgICAgICAgdG9wX2xpc3Q6IHR3b0xheWVyVHJlZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cG9ydDogZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdXNlIGZpbHRlcmVkIGl0ZW1zLlxuICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQWdlbmRhJykgKyAnLmRvY3gnO1xuICAgICAgICAgICAgICAgICRodHRwLmdldCgnL2FnZW5kYS9kb2N4dGVtcGxhdGUvJykudGhlbihmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IHdpbmRvdy5hdG9iKHN1Y2Nlc3MuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSBuZXcgRG9jeGdlbihjb250ZW50KTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGdldERhdGEoaXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICBkb2Muc2V0RGF0YShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jLnJlbmRlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB6aXAgPSBkb2MuZ2V0WmlwKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vemlwID0gY29udmVydGVyLnVwZGF0ZVppcEZpbGUoemlwKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gemlwLmdlbmVyYXRlKHt0eXBlOiAnYmxvYid9KTtcbiAgICAgICAgICAgICAgICAgICAgRmlsZVNhdmVyLnNhdmVBcyhvdXQsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmFuZ3VsYXIubW9kdWxlKCdPcGVuU2xpZGVzQXBwLmFnZW5kYS5wZGYnLCBbJ09wZW5TbGlkZXNBcHAuY29yZS5wZGYnXSlcblxuLmZhY3RvcnkoJ0FnZW5kYUNvbnRlbnRQcm92aWRlcicsIFtcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdQREZMYXlvdXQnLFxuICAgIGZ1bmN0aW9uKGdldHRleHRDYXRhbG9nLCBQREZMYXlvdXQpIHtcblxuICAgIHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cbiAgICAgICAgLy8gcGFnZSB0aXRsZVxuICAgICAgICB2YXIgdGl0bGUgPSBQREZMYXlvdXQuY3JlYXRlVGl0bGUoZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKFwiQWdlbmRhXCIpKTtcblxuICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgaXRlbSBsaXN0IHdpdGggYWxsIHN1Yml0ZW1zXG4gICAgICAgIHZhciBjcmVhdGVJdGVtTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFnZW5kYV9pdGVtcyA9IFtdO1xuICAgICAgICAgICAgXy5mb3JFYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmlzX3B1YmxpYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUluZGVudCA9IGl0ZW0ucGFyZW50Q291bnQgKiAxNTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbVN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVN0eWxlID0gJ2xpc3RQYXJlbnQnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVN0eWxlID0gJ2xpc3RDaGlsZCc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgYWdlbmRhSnNvblN0cmluZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBpdGVtU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaXRlbUluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDYwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBpdGVtLml0ZW1fbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGl0ZW0udGl0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgYWdlbmRhX2l0ZW1zLnB1c2goYWdlbmRhSnNvblN0cmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWdlbmRhX2l0ZW1zO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRDb250ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUl0ZW1MaXN0KClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldENvbnRlbnQ6IGdldENvbnRlbnRcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlSW5zdGFuY2U6IGNyZWF0ZUluc3RhbmNlXG4gICAgfTtcblxufV0pXG5cbi5mYWN0b3J5KCdBZ2VuZGFQZGZFeHBvcnQnLCBbXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnQWdlbmRhQ29udGVudFByb3ZpZGVyJyxcbiAgICAnUGRmTWFrZURvY3VtZW50UHJvdmlkZXInLFxuICAgICdQZGZDcmVhdGUnLFxuICAgICdNZXNzYWdpbmcnLFxuICAgIGZ1bmN0aW9uIChnZXR0ZXh0Q2F0YWxvZywgQWdlbmRhQ29udGVudFByb3ZpZGVyLCBQZGZNYWtlRG9jdW1lbnRQcm92aWRlciwgUGRmQ3JlYXRlLCBNZXNzYWdpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cG9ydDogZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdBZ2VuZGEnKSArICcucGRmJztcbiAgICAgICAgICAgICAgICB2YXIgYWdlbmRhQ29udGVudFByb3ZpZGVyID0gQWdlbmRhQ29udGVudFByb3ZpZGVyLmNyZWF0ZUluc3RhbmNlKGl0ZW1zKTtcbiAgICAgICAgICAgICAgICBQZGZNYWtlRG9jdW1lbnRQcm92aWRlci5jcmVhdGVJbnN0YW5jZShhZ2VuZGFDb250ZW50UHJvdmlkZXIpLnRoZW4oZnVuY3Rpb24gKGRvY3VtZW50UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgUGRmQ3JlYXRlLmRvd25sb2FkKGRvY3VtZW50UHJvdmlkZXIsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnaW5nLmFkZE1lc3NhZ2UoZXJyb3IubXNnLCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmFuZ3VsYXIubW9kdWxlKCdPcGVuU2xpZGVzQXBwLmFnZW5kYS5wcm9qZWN0b3InLCBbJ09wZW5TbGlkZXNBcHAuYWdlbmRhJ10pXG5cbi5jb25maWcoW1xuICAgICdzbGlkZXNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oc2xpZGVzUHJvdmlkZXIpIHtcbiAgICAgICAgc2xpZGVzUHJvdmlkZXIucmVnaXN0ZXJTbGlkZSgnYWdlbmRhL2xpc3Qtb2Ytc3BlYWtlcnMnLCB7XG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ3N0YXRpYy90ZW1wbGF0ZXMvYWdlbmRhL3NsaWRlLWxpc3Qtb2Ytc3BlYWtlcnMuaHRtbCcsXG4gICAgICAgIH0pO1xuICAgICAgICBzbGlkZXNQcm92aWRlci5yZWdpc3RlclNsaWRlKCdhZ2VuZGEvaXRlbS1saXN0Jywge1xuICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL2FnZW5kYS9zbGlkZS1pdGVtLWxpc3QuaHRtbCcsXG4gICAgICAgIH0pO1xuICAgICAgICBzbGlkZXNQcm92aWRlci5yZWdpc3RlclNsaWRlKCdhZ2VuZGEvY3VycmVudC1saXN0LW9mLXNwZWFrZXJzJywge1xuICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL2FnZW5kYS9zbGlkZS1jdXJyZW50LWxpc3Qtb2Ytc3BlYWtlcnMuaHRtbCcsXG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdTbGlkZUN1cnJlbnRMaXN0T2ZTcGVha2Vyc0N0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ0FnZW5kYScsXG4gICAgJ0N1cnJlbnRMaXN0T2ZTcGVha2Vyc0l0ZW0nLFxuICAgICdDb25maWcnLFxuICAgICdQcm9qZWN0b3InLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsIEFnZW5kYSwgQ3VycmVudExpc3RPZlNwZWFrZXJzSXRlbSwgQ29uZmlnLCBQcm9qZWN0b3IpIHtcbiAgICAgICAgJHNjb3BlLm92ZXJsYXkgPSAkc2NvcGUuZWxlbWVudC5vdmVybGF5O1xuICAgICAgICAvLyBXYXRjaCBmb3IgY2hhbmdlcyBpbiB0aGUgY3VycmVudCBsaXN0IG9mIHNwZWFrZXJzIHJlZmVyZW5jZVxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBDb25maWcubGFzdE1vZGlmaWVkKCdwcm9qZWN0b3JfY3VycmVudExpc3RPZlNwZWFrZXJzX3JlZmVyZW5jZScpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUuY3VycmVudExpc3RPZlNwZWFrZXJzUmVmZXJlbmNlID0gJHNjb3BlLmNvbmZpZygncHJvamVjdG9yX2N1cnJlbnRMaXN0T2ZTcGVha2Vyc19yZWZlcmVuY2UnKTtcbiAgICAgICAgICAgICRzY29wZS51cGRhdGVDdXJyZW50TGlzdE9mU3BlYWtlcnMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdhdGNoIGZvciBjaGFuZ2VzIGluIHRoZSByZWZlcmVuY2VkIHByb2plY3RvclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9qZWN0b3IubGFzdE1vZGlmaWVkKCRzY29wZS5jdXJyZW50TGlzdE9mU3BlYWtlcnNSZWZlcmVuY2UpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUudXBkYXRlQ3VycmVudExpc3RPZlNwZWFrZXJzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXYXRjaCBmb3IgY2hhbmdlcyBpbiB0aGUgY3VycmVudCBpdGVtLlxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBBZ2VuZGEubGFzdE1vZGlmaWVkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS51cGRhdGVDdXJyZW50TGlzdE9mU3BlYWtlcnMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS51cGRhdGVDdXJyZW50TGlzdE9mU3BlYWtlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUuYWdlbmRhSXRlbSA9IEN1cnJlbnRMaXN0T2ZTcGVha2Vyc0l0ZW0uZ2V0SXRlbSgkc2NvcGUuY3VycmVudExpc3RPZlNwZWFrZXJzUmVmZXJlbmNlKTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignU2xpZGVMaXN0T2ZTcGVha2Vyc0N0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ0FnZW5kYScsXG4gICAgJ1VzZXInLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsIEFnZW5kYSwgVXNlcikge1xuICAgICAgICAvLyBBdHRlbnRpb24hIEVhY2ggb2JqZWN0IHRoYXQgaXMgdXNlZCBoZXJlIGhhcyB0byBiZSBkZWFsdCBvbiBzZXJ2ZXIgc2lkZS5cbiAgICAgICAgLy8gQWRkIGl0IHRvIHRoZSBjb3Jlc3BvbmRpbmcgZ2V0X3JlcXVpcmVtZW50cyBtZXRob2Qgb2YgdGhlIFByb2plY3RvckVsZW1lbnRcbiAgICAgICAgLy8gY2xhc3MuXG4gICAgICAgIHZhciBpZCA9ICRzY29wZS5lbGVtZW50LmlkO1xuICAgICAgICBBZ2VuZGEuYmluZE9uZShpZCwgJHNjb3BlLCAnaXRlbScpO1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdTbGlkZUl0ZW1MaXN0Q3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJGh0dHAnLFxuICAgICckZmlsdGVyJyxcbiAgICAnQWdlbmRhJyxcbiAgICAnQWdlbmRhVHJlZScsXG4gICAgJ0NvbmZpZycsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgJGh0dHAsICRmaWx0ZXIsIEFnZW5kYSwgQWdlbmRhVHJlZSwgQ29uZmlnKSB7XG4gICAgICAgIC8vIEF0dGVudGlvbiEgRWFjaCBvYmplY3QgdGhhdCBpcyB1c2VkIGhlcmUgaGFzIHRvIGJlIGRlYWx0IG9uIHNlcnZlciBzaWRlLlxuICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGNvcmVzcG9uZGluZyBnZXRfcmVxdWlyZW1lbnRzIG1ldGhvZCBvZiB0aGUgUHJvamVjdG9yRWxlbWVudFxuICAgICAgICAvLyBjbGFzcy5cblxuICAgICAgICAvLyBCaW5kIGFnZW5kYSB0cmVlIHRvIHRoZSBzY29wZVxuICAgICAgICB2YXIgaXRlbXM7XG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEFnZW5kYS5sYXN0TW9kaWZpZWQoKSArXG4gICAgICAgICAgICAgICAgQ29uZmlnLmxhc3RNb2RpZmllZCgnYWdlbmRhX2hpZGVfaW50ZXJuYWxfaXRlbXNfb25fcHJvamVjdG9yJyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICgkc2NvcGUuZWxlbWVudC5pZCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBoaWRkZW4gaXRlbXNcbiAgICAgICAgICAgICAgICBpdGVtcyA9IF8uZmlsdGVyKEFnZW5kYS5nZXRBbGwoKSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpdGVtLmlzX2hpZGRlbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoQ29uZmlnLmdldCgnYWdlbmRhX2hpZGVfaW50ZXJuYWxfaXRlbXNfb25fcHJvamVjdG9yJykudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBfLmZpbHRlcihpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmlzX3B1YmxpYztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0cmVlID0gQWdlbmRhVHJlZS5nZXRUcmVlKGl0ZW1zKTtcblxuICAgICAgICAgICAgICAgIHZhciBnZXRSb290Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlkID09ICRzY29wZS5lbGVtZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBnZXRSb290Tm9kZShub2RlLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaCh0cmVlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0Um9vdE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5yb290SXRlbSA9IHJlc3VsdC5pdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnRyZWUgPSByZXN1bHQuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHNjb3BlLmVsZW1lbnQudHJlZSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zID0gXy5maWx0ZXIoQWdlbmRhLmdldEFsbCgpLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5pc19wdWJsaWM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRyZWUgPSBBZ2VuZGFUcmVlLmdldFRyZWUoaXRlbXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IEFnZW5kYS5maWx0ZXIoe1xuICAgICAgICAgICAgICAgICAgICB3aGVyZTogeyBwYXJlbnRfaWQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJCeTogJ3dlaWdodCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IF8uZmlsdGVyKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5pc19wdWJsaWM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRyZWUgPSBBZ2VuZGFUcmVlLmdldFRyZWUoaXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAuYWdlbmRhLnNpdGUnLCBbXG4gICAgJ09wZW5TbGlkZXNBcHAuYWdlbmRhJyxcbiAgICAnT3BlblNsaWRlc0FwcC5jb3JlLnBkZicsXG4gICAgJ09wZW5TbGlkZXNBcHAuYWdlbmRhLnBkZicsXG4gICAgJ09wZW5TbGlkZXNBcHAuYWdlbmRhLmNzdicsXG4gICAgJ09wZW5TbGlkZXNBcHAuYWdlbmRhLmRvY3gnLFxuXSlcblxuLmNvbmZpZyhbXG4gICAgJ21haW5NZW51UHJvdmlkZXInLFxuICAgICdnZXR0ZXh0JyxcbiAgICBmdW5jdGlvbiAobWFpbk1lbnVQcm92aWRlciwgZ2V0dGV4dCkge1xuICAgICAgICBtYWluTWVudVByb3ZpZGVyLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICd1aV9zcmVmJzogJ2FnZW5kYS5pdGVtLmxpc3QnLFxuICAgICAgICAgICAgJ2ltZ19jbGFzcyc6ICdjYWxlbmRhci1vJyxcbiAgICAgICAgICAgICd0aXRsZSc6IGdldHRleHQoJ0FnZW5kYScpLFxuICAgICAgICAgICAgJ3dlaWdodCc6IDIwMCxcbiAgICAgICAgICAgICdwZXJtJzogJ2FnZW5kYS5jYW5fc2VlJyxcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLmNvbmZpZyhbXG4gICAgJ1NlYXJjaFByb3ZpZGVyJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgZnVuY3Rpb24gKFNlYXJjaFByb3ZpZGVyLCBnZXR0ZXh0KSB7XG4gICAgICAgIFNlYXJjaFByb3ZpZGVyLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICd2ZXJib3NlTmFtZSc6IGdldHRleHQoJ0FnZW5kYScpLFxuICAgICAgICAgICAgJ2NvbGxlY3Rpb25OYW1lJzogJ2FnZW5kYS9pdGVtJyxcbiAgICAgICAgICAgICd1cmxEZXRhaWxTdGF0ZSc6ICdhZ2VuZGEuaXRlbS5kZXRhaWwnLFxuICAgICAgICAgICAgJ3dlaWdodCc6IDIwMCxcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLmNvbmZpZyhbXG4gICAgJyRzdGF0ZVByb3ZpZGVyJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgZnVuY3Rpb24gKCRzdGF0ZVByb3ZpZGVyLCBnZXR0ZXh0KSB7XG4gICAgICAgICRzdGF0ZVByb3ZpZGVyXG4gICAgICAgICAgICAuc3RhdGUoJ2FnZW5kYScsIHtcbiAgICAgICAgICAgICAgICB1cmw6ICcvYWdlbmRhJyxcbiAgICAgICAgICAgICAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8dWktdmlldy8+XCIsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogZ2V0dGV4dCgnQWdlbmRhJyksXG4gICAgICAgICAgICAgICAgICAgIGJhc2VQZXJtOiAnYWdlbmRhLmNhbl9zZWUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXRlKCdhZ2VuZGEuaXRlbScsIHtcbiAgICAgICAgICAgICAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8dWktdmlldy8+XCIsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXRlKCdhZ2VuZGEuaXRlbS5saXN0Jywge30pXG4gICAgICAgICAgICAuc3RhdGUoJ2FnZW5kYS5pdGVtLmRldGFpbCcsIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogWyckc3RhdGVQYXJhbXMnLCBmdW5jdGlvbigkc3RhdGVQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkc3RhdGVQYXJhbXMuaWQ7XG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3RhdGUoJ2FnZW5kYS5pdGVtLnNvcnQnLCB7XG4gICAgICAgICAgICAgICAgdXJsOiAnL3NvcnQnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdBZ2VuZGFTb3J0Q3RybCcsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXRlKCdhZ2VuZGEuY3VycmVudC1saXN0LW9mLXNwZWFrZXJzJywge1xuICAgICAgICAgICAgICAgIHVybDogJy9zcGVha2VycycsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ0N1cnJlbnRMaXN0T2ZTcGVha2Vyc1ZpZXdDdHJsJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXR0ZXh0KCdDdXJyZW50IGxpc3Qgb2Ygc3BlYWtlcnMnKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLy8gU2V0IHRoZSBzZW5zaXRpdml0eSBvZiBtb3Zpbmcgbm9kZXMgaG9yaXpvbnRhbCBmb3IgdGhlIHVpLXRyZWUuXG4uY29uZmlnKFtcbiAgICAndHJlZUNvbmZpZycsXG4gICAgZnVuY3Rpb24gKHRyZWVDb25maWcpIHtcbiAgICAgICAgdHJlZUNvbmZpZy5kcmFnTW92ZVNlbnNpdGl2aXR5ID0gMjA7XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ1Nob3dBc0FnZW5kYUl0ZW1GaWVsZCcsIFtcbiAgICAnb3BlcmF0b3InLFxuICAgICdnZXR0ZXh0JyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgIGZ1bmN0aW9uIChvcGVyYXRvciwgZ2V0dGV4dCwgZ2V0dGV4dENhdGFsb2cpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtYW5hZ2VQZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtleTogJ2FnZW5kYV90eXBlJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnc2VsZWN0LXNpbmdsZScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0FnZW5kYSB2aXNpYmlsaXR5JyksXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOiAxLCBkaXNwbGF5TmFtZTogZ2V0dGV4dCgnUHVibGljIGl0ZW0nKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTogMiwgZGlzcGxheU5hbWU6IGdldHRleHQoJ0ludGVybmFsIGl0ZW0nKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTogMywgZGlzcGxheU5hbWU6IGdldHRleHQoJ0hpZGRlbiBpdGVtJyl9XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG5nT3B0aW9uczogJ3R5cGUudHlwZSBhcyAodHlwZS5kaXNwbGF5TmFtZSB8IHRyYW5zbGF0ZSkgZm9yIHR5cGUgaW4gdG8ub3B0aW9ucycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoaWRlOiAhKG9wZXJhdG9yLmhhc1Blcm1zKG1hbmFnZVBlcm1pc3Npb24pICYmIG9wZXJhdG9yLmhhc1Blcm1zKCdhZ2VuZGEuY2FuX21hbmFnZScpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignSXRlbUxpc3RDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckZmlsdGVyJyxcbiAgICAnJGh0dHAnLFxuICAgICckc3RhdGUnLFxuICAgICdEUycsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnbmdEaWFsb2cnLFxuICAgICdBZ2VuZGEnLFxuICAgICdUb3BpY0Zvcm0nLCAvLyBUT0RPOiBSZW1vdmUgdGhpcyBkZXBlbmRlbmN5LiBVc2UgdGVtcGxhdGUgaG9vayBmb3IgXCJOZXdcIiBhbmQgXCJJbXBvcnRcIiBidXR0b25zLlxuICAgICdBZ2VuZGFUcmVlJyxcbiAgICAnUHJvamVjdG9yJyxcbiAgICAnUHJvamVjdGlvbkRlZmF1bHQnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ2dldHRleHQnLFxuICAgICdvc1RhYmxlRmlsdGVyJyxcbiAgICAnb3NUYWJsZVBhZ2luYXRpb24nLFxuICAgICdBZ2VuZGFDc3ZFeHBvcnQnLFxuICAgICdBZ2VuZGFQZGZFeHBvcnQnLFxuICAgICdBZ2VuZGFEb2N4RXhwb3J0JyxcbiAgICAnRXJyb3JNZXNzYWdlJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsICRmaWx0ZXIsICRodHRwLCAkc3RhdGUsIERTLCBvcGVyYXRvciwgbmdEaWFsb2csIEFnZW5kYSwgVG9waWNGb3JtLFxuICAgICAgICBBZ2VuZGFUcmVlLCBQcm9qZWN0b3IsIFByb2plY3Rpb25EZWZhdWx0LCBnZXR0ZXh0Q2F0YWxvZywgZ2V0dGV4dCwgb3NUYWJsZUZpbHRlcixcbiAgICAgICAgb3NUYWJsZVBhZ2luYXRpb24sIEFnZW5kYUNzdkV4cG9ydCwgQWdlbmRhUGRmRXhwb3J0LCBBZ2VuZGFEb2N4RXhwb3J0LCBFcnJvck1lc3NhZ2UpIHtcblxuICAgICAgICAkc2NvcGUuQUdFTkRBX0lURU0gPSAxO1xuICAgICAgICAkc2NvcGUuSU5URVJOQUxfSVRFTSA9IDI7XG4gICAgICAgICRzY29wZS5ISURERU5fSVRFTSA9IDM7XG5cbiAgICAgICAgLy8gQmluZCBhZ2VuZGEgdHJlZSB0byB0aGUgc2NvcGVcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQWdlbmRhLmxhc3RNb2RpZmllZCgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGl0ZW1zIHRoYXQgZG9lc24ndCBoYXZlIHRoZSBsaXN0X2l0ZW1fdGl0bGUuIFRoaXMgaGFwcGVucywgaWYgdGhlXG4gICAgICAgICAgICAvLyBpdGVtIGlzIGEgaGlkZGVuIGl0ZW0gYnV0IHByb3ZpZGVzIHRoZSBsaXN0IG9mIHNwZWFrZXJzLCBidXQgc2hvdWxkIG5vdCBiZVxuICAgICAgICAgICAgLy8gdmlzaWJsZSBpbiB0aGUgbGlzdCB2aWV3LlxuICAgICAgICAgICAgdmFyIGFsbG93ZWRJdGVtcyA9IF8uZmlsdGVyKEFnZW5kYS5nZXRBbGwoKSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5saXN0X3ZpZXdfdGl0bGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzY29wZS5pdGVtcyA9IEFnZW5kYVRyZWUuZ2V0RmxhdFRyZWUoYWxsb3dlZEl0ZW1zKTtcbiAgICAgICAgICAgICRzY29wZS5hZ2VuZGFIYXNTdWJpdGVtcyA9ICRmaWx0ZXIoJ2ZpbHRlcicpKCRzY29wZS5pdGVtcywgeydwYXJlbnRfaWQnOiAnJ30pLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIFByb2plY3Rvci5iaW5kQWxsKHt9LCAkc2NvcGUsICdwcm9qZWN0b3JzJyk7XG4gICAgICAgICRzY29wZS5tYWluTGlzdFRyZWUgPSB0cnVlO1xuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9qZWN0b3IubGFzdE1vZGlmaWVkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwcm9qZWN0aW9uZGVmYXVsdCA9ICBQcm9qZWN0aW9uRGVmYXVsdC5maWx0ZXIoe25hbWU6ICdhZ2VuZGFfYWxsX2l0ZW1zJ30pWzBdO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rpb25kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlZmF1bHRQcm9qZWN0b3JJZF9hbGxfaXRlbXMgPSBwcm9qZWN0aW9uZGVmYXVsdC5wcm9qZWN0b3JfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUucHJvamVjdGlvbkRlZmF1bHRzID0gUHJvamVjdGlvbkRlZmF1bHQuZ2V0QWxsKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcblxuXG4gICAgICAgIC8vIEZpbHRlcmluZ1xuICAgICAgICAkc2NvcGUuZmlsdGVyID0gb3NUYWJsZUZpbHRlci5jcmVhdGVJbnN0YW5jZSgnQWdlbmRhVGFibGVGaWx0ZXInKTtcblxuICAgICAgICBpZiAoISRzY29wZS5maWx0ZXIuZXhpc3RzU3RvcmFnZUVudHJ5KCkpIHtcbiAgICAgICAgICAgICRzY29wZS5maWx0ZXIuYm9vbGVhbkZpbHRlcnMgPSB7XG4gICAgICAgICAgICAgICAgY2xvc2VkOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogZ2V0dGV4dCgnQ2xvc2VkIGl0ZW1zJyksXG4gICAgICAgICAgICAgICAgICAgIGNob2ljZVllczogZ2V0dGV4dCgnQ2xvc2VkIGl0ZW1zJyksXG4gICAgICAgICAgICAgICAgICAgIGNob2ljZU5vOiBnZXR0ZXh0KCdPcGVuIGl0ZW1zJyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBmaWx0ZXJzIGFyZSBqdXN0IG9uLW9mZiwgc28gbm8gdW5kZWZpbmVkIHRoZXJlXG4gICAgICAgICAgICAgICAgaXNfcHVibGljOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNob2ljZVllczogZ2V0dGV4dCgnUHVibGljIGl0ZW1zJyksXG4gICAgICAgICAgICAgICAgICAgIGNob2ljZU5vOiBnZXR0ZXh0KCdObyBwdWJsaWMgaXRlbXMnKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzX2ludGVybmFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNob2ljZVllczogZ2V0dGV4dCgnSW50ZXJuYWwgaXRlbXMnKSxcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlTm86IGdldHRleHQoJ05vIGludGVybmFsIGl0ZW1zJyksXG4gICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb246ICdhZ2VuZGEuY2FuX3NlZV9pbnRlcm5hbF9pdGVtcycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc19oaWRkZW46IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjaG9pY2VZZXM6IGdldHRleHQoJ0hpZGRlbiBpdGVtcycpLFxuICAgICAgICAgICAgICAgICAgICBjaG9pY2VObzogZ2V0dGV4dCgnTm8gaGlkZGVuIGl0ZW1zJyksXG4gICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb246ICdhZ2VuZGEuY2FuX21hbmFnZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgJHNjb3BlLmZpbHRlci5wcm9wZXJ0eUxpc3QgPSBbJ2l0ZW1fbnVtYmVyJywgJ3RpdGxlJywgJ3RpdGxlX2xpc3RfdmlldycsICdjb21tZW50JywgJ2R1cmF0aW9uJ107XG4gICAgICAgICRzY29wZS5maWx0ZXIucHJvcGVydHlGdW5jdGlvbkxpc3QgPSBbXG4gICAgICAgICAgICBmdW5jdGlvbiAoaXRlbSkge3JldHVybiBpdGVtLmdldExpc3RWaWV3VGl0bGUoKTt9LFxuICAgICAgICBdO1xuICAgICAgICAkc2NvcGUuYXJlRmlsdGVyc1NldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoJHNjb3BlLmFyZVZpc2liaWxpdHlGaWx0ZXJzU2V0KCkgfHxcbiAgICAgICAgICAgICAgICAkc2NvcGUuZmlsdGVyLmJvb2xlYW5GaWx0ZXJzLmNsb3NlZC52YWx1ZSAhPT0gJHNjb3BlLmZpbHRlci5ib29sZWFuRmlsdGVycy5jbG9zZWQuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmFyZVZpc2liaWxpdHlGaWx0ZXJzU2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICgkc2NvcGUuZmlsdGVyLmJvb2xlYW5GaWx0ZXJzLmlzX3B1YmxpYy52YWx1ZSAhPT0gJHNjb3BlLmZpbHRlci5ib29sZWFuRmlsdGVycy5pc19wdWJsaWMuZGVmYXVsdFZhbHVlIHx8XG4gICAgICAgICAgICAgICAgJHNjb3BlLmZpbHRlci5ib29sZWFuRmlsdGVycy5pc19pbnRlcm5hbC52YWx1ZSAhPT0gJHNjb3BlLmZpbHRlci5ib29sZWFuRmlsdGVycy5pc19pbnRlcm5hbC5kZWZhdWx0VmFsdWUgfHxcbiAgICAgICAgICAgICAgICAkc2NvcGUuZmlsdGVyLmJvb2xlYW5GaWx0ZXJzLmlzX2hpZGRlbi52YWx1ZSAhPT0gJHNjb3BlLmZpbHRlci5ib29sZWFuRmlsdGVycy5pc19oaWRkZW4uZGVmYXVsdFZhbHVlKTtcblxuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUucmVzZXRGaWx0ZXJzID0gZnVuY3Rpb24gKGlzU2VsZWN0TW9kZSkge1xuICAgICAgICAgICAgaWYgKCFpc1NlbGVjdE1vZGUpIHtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goJHNjb3BlLmZpbHRlci5ib29sZWFuRmlsdGVycywgZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIudmFsdWUgPSBmaWx0ZXIuZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICRzY29wZS5maWx0ZXIuc2F2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEV4cGFuZCBhbGwgaXRlbXMgZHVyaW5nIHNlYXJjaGluZy5cbiAgICAgICAgJHNjb3BlLmZpbHRlci5jaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLmNvbGxhcHNlU3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgJHNjb3BlLnRvZ2dsZUNvbGxhcHNlU3RhdGUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwYWdpbmF0aW9uXG4gICAgICAgICRzY29wZS5wYWdpbmF0aW9uID0gb3NUYWJsZVBhZ2luYXRpb24uY3JlYXRlSW5zdGFuY2UoJ0FnZW5kYVRhYmxlUGFnaW5hdGlvbicsIDUwKTtcblxuICAgICAgICAvLyBwYXJzZSBkdXJhdGlvbiBmb3IgaW5saW5lIGVkaXRpbmdcbiAgICAgICAgJHNjb3BlLmdlbmVyYXRlRHVyYXRpb25UZXh0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIC8vY29udmVydCBkYXRhIGZyb20gbW9kZWwgZm9ybWF0IChtKSB0byB2aWV3IGZvcm1hdCAoaGg6bW0pXG4gICAgICAgICAgICBpZiAoaXRlbS5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lID0gXCJcIixcbiAgICAgICAgICAgICAgICAgICAgdG90YWxtaW51dGVzID0gaXRlbS5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAodG90YWxtaW51dGVzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lID0gXCItXCI7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsbWludXRlcyA9IC10b3RhbG1pbnV0ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBoaCA9IE1hdGguZmxvb3IodG90YWxtaW51dGVzIC8gNjApO1xuICAgICAgICAgICAgICAgIHZhciBtbSA9IE1hdGguZmxvb3IodG90YWxtaW51dGVzICUgNjApO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBsZWFkaW5nIFwiMFwiIGZvciBkb3VibGUgZGlnaXQgdmFsdWVzXG4gICAgICAgICAgICAgICAgbW0gPSAoXCIwXCIrbW0pLnNsaWNlKC0yKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IGhoICsgXCI6XCIgKyBtbTtcbiAgICAgICAgICAgICAgICBpdGVtLmR1cmF0aW9uVGV4dCA9IHRpbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uZHVyYXRpb25UZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLnNldER1cmF0aW9uVGV4dCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAvL2NvbnZlcnQgZGF0YSBmcm9tIHZpZXcgZm9ybWF0IChoaDptbSkgdG8gbW9kZWwgZm9ybWF0IChtKVxuICAgICAgICAgICAgdmFyIHRpbWUgPSBpdGVtLmR1cmF0aW9uVGV4dC5yZXBsYWNlKCdoJywgJycpLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICAgIGlmICh0aW1lLmxlbmd0aCA+IDEgJiYgIWlzTmFOKHRpbWVbMF0pICYmICFpc05hTih0aW1lWzFdKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSAoK3RpbWVbMF0pICogNjAgKyAoK3RpbWVbMV0pO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gXCItXCIrZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbS5kdXJhdGlvbiA9IHBhcnNlSW50KGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lLmxlbmd0aCA9PSAxICYmICFpc05hTih0aW1lWzBdKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSAoK3RpbWVbMF0pO1xuICAgICAgICAgICAgICAgIGl0ZW0uZHVyYXRpb24gPSBwYXJzZUludChkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUuc2F2ZShpdGVtKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKiogRHVyYXRpb24gY2FsY3VsYXRpb25zICoqL1xuICAgICAgICAkc2NvcGUuc3VtRHVyYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvdGFsRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgJHNjb3BlLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0b3RhbER1cmF0aW9uICs9IGl0ZW0uZHVyYXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdG90YWxEdXJhdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmNhbGN1bGF0ZUVuZFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG90YWxEdXJhdGlvbiA9ICRzY29wZS5zdW1EdXJhdGlvbnMoKTtcbiAgICAgICAgICAgIHZhciBzdGFydFRpbWVzdGFtcCA9ICRzY29wZS5jb25maWcoJ2FnZW5kYV9zdGFydF9ldmVudF9kYXRlX3RpbWUnKTtcbiAgICAgICAgICAgIGlmIChzdGFydFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHZhciBlbmRUaW1lc3RhbXAgPSBzdGFydFRpbWVzdGFtcCArIHRvdGFsRHVyYXRpb24gKiA2MCAqIDEwMDA7XG4gICAgICAgICAgICAgICAgdmFyIGVuZERhdGUgPSBuZXcgRGF0ZShlbmRUaW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIHZhciBtbSA9IChcIjBcIiArIGVuZERhdGUuZ2V0TWludXRlcygpKS5zbGljZSgtMik7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGVTdHIgPSBlbmREYXRlLmdldEhvdXJzKCkgKyAnOicgKyBtbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZVN0cjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFnZW5kYSBjb2xsYXBzZSBmdW5jdGlvblxuICAgICAgICAkc2NvcGUudG9nZ2xlQ29sbGFwc2VTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5jb2xsYXBzZVN0YXRlID0gISRzY29wZS5jb2xsYXBzZVN0YXRlO1xuICAgICAgICAgICAgXy5mb3JFYWNoKCRzY29wZS5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLmhpZGVDaGlsZHJlbiA9ICRzY29wZS5jb2xsYXBzZVN0YXRlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hlY2ssIGlmIGFuIGl0ZW0gaGFzIGNoaWxkcyBpbiBhbGwgZmlsdGVyZWQgaXRlbXNcbiAgICAgICAgJHNjb3BlLmhhc0NoaWxkcmVuID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBfLnNvbWUoJHNjb3BlLml0ZW1zRmlsdGVyZWQsIGZ1bmN0aW9uIChfaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfaXRlbS5wYXJlbnRfaWQgPT0gaXRlbS5pZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJldHVybnMgdHJ1ZSwgaWYgdGhlIGFnZW5kYSBoYXMgYXQgbGVhc3QgdHdvIGxheWVyc1xuICAgICAgICAkc2NvcGUuYWdlbmRhSGFzTXVsdGlwbGVMYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5zb21lKCRzY29wZS5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5wYXJlbnRfaWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKiogQWdlbmRhIGl0ZW0gZnVuY3Rpb25zICoqL1xuICAgICAgICAvLyBvcGVuIGRpYWxvZyBmb3IgbmV3IHRvcGljcyAvLyBUT0RPIFJlbW92ZSB0aGlzLiBEb24ndCBmb3JnZXQgaW1wb3J0IGJ1dHRvbiBpbiB0ZW1wbGF0ZS5cbiAgICAgICAgJHNjb3BlLm5ld0RpYWxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG5nRGlhbG9nLm9wZW4oVG9waWNGb3JtLmdldERpYWxvZygpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2F2ZSBjaGFuZ2VkIGl0ZW1cbiAgICAgICAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgQWdlbmRhLnNhdmUoaXRlbSkudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQuc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IEVycm9yTWVzc2FnZS5mb3JBbGVydChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRlbGV0ZSByZWxhdGVkIGl0ZW1cbiAgICAgICAgJHNjb3BlLmRlbGV0ZVJlbGF0ZWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIERTLmRlc3Ryb3koaXRlbS5jb250ZW50X29iamVjdC5jb2xsZWN0aW9uLCBpdGVtLmNvbnRlbnRfb2JqZWN0LmlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYXV0byBudW1iZXJpbmcgb2YgYWdlbmRhIGl0ZW1zXG4gICAgICAgICRzY29wZS5hdXRvTnVtYmVyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkaHR0cC5wb3N0KCcvcmVzdC9hZ2VuZGEvaXRlbS9udW1iZXJpbmcvJywge30pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBjaGVjayBvcGVuIHBlcm1pc3Npb25cbiAgICAgICAgLy8gVE9ETzogVXNlIGdlbmVyaWMgc29sdXRpb24gaGVyZS5cbiAgICAgICAgJHNjb3BlLmlzQWxsb3dlZFRvU2VlT3BlbkxpbmsgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBpdGVtLmNvbnRlbnRfb2JqZWN0LmNvbGxlY3Rpb247XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0b3BpY3MvdG9waWMnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IuaGFzUGVybXMoJ2FnZW5kYS5jYW5fc2VlJyk7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW90aW9ucy9tb3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IuaGFzUGVybXMoJ21vdGlvbnMuY2FuX3NlZScpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vdGlvbnMvbW90aW9uLWJsb2NrJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yLmhhc1Blcm1zKCdtb3Rpb25zLmNhbl9zZWUnKTtcbiAgICAgICAgICAgICAgICBjYXNlICdhc3NpZ25tZW50cy9hc3NpZ25tZW50JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yLmhhc1Blcm1zKCdhc3NpZ25tZW50cy5jYW5fc2VlJyk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuZWRpdCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKGl0ZW0uZ2V0Q29udGVudE9iamVjdEZvcm0oKS5nZXREaWFsb2coe2lkOiBpdGVtLmNvbnRlbnRfb2JqZWN0LmlkfSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGV4cG9ydFxuICAgICAgICAkc2NvcGUucGRmRXhwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQWdlbmRhUGRmRXhwb3J0LmV4cG9ydCgkc2NvcGUuaXRlbXNGaWx0ZXJlZCk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5jc3ZFeHBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBBZ2VuZGFDc3ZFeHBvcnQuZXhwb3J0KCRzY29wZS5pdGVtc0ZpbHRlcmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmRvY3hFeHBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBBZ2VuZGFEb2N4RXhwb3J0LmV4cG9ydCgkc2NvcGUuaXRlbXNGaWx0ZXJlZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqIHNlbGVjdCBtb2RlIGZ1bmN0aW9ucyAqKi9cbiAgICAgICAgJHNjb3BlLmlzU2VsZWN0TW9kZSA9IGZhbHNlO1xuICAgICAgICAvLyBjaGVjayBhbGwgY2hlY2tib3hlc1xuICAgICAgICAkc2NvcGUuY2hlY2tBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUuc2VsZWN0ZWRBbGwgPSAhJHNjb3BlLnNlbGVjdGVkQWxsO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gJHNjb3BlLnNlbGVjdGVkQWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHVuY2hlY2sgYWxsIGNoZWNrYm94ZXMgaWYgaXNEZWxldGVNb2RlIGlzIGNsb3NlZFxuICAgICAgICAkc2NvcGUudW5jaGVja0FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghJHNjb3BlLmlzU2VsZWN0TW9kZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5zZWxlY3RlZEFsbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2V0IHR5cGUgZm9yIHNlbGVjdGVkIGl0ZW1zXG4gICAgICAgICRzY29wZS5zZXRUeXBlTXVsdGlwbGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgXy5mb3JFYWNoKCRzY29wZS5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2F2ZShpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzY29wZS5pc1NlbGVjdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICRzY29wZS51bmNoZWNrQWxsKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHNldCBjbG9zZWQgZm9yIHNlbGVjdGVkIGl0ZW1zXG4gICAgICAgICRzY29wZS5zZXRTdGF0ZU11bHRpcGxlID0gZnVuY3Rpb24gKGNsb3NlZCkge1xuICAgICAgICAgICAgXy5mb3JFYWNoKCRzY29wZS5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNsb3NlZCA9IGNsb3NlZDtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNhdmUoaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2NvcGUuaXNTZWxlY3RNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAkc2NvcGUudW5jaGVja0FsbCgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBkZWxldGUgc2VsZWN0ZWQgaXRlbXNcbiAgICAgICAgJHNjb3BlLmRlbGV0ZU11bHRpcGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgXy5mb3JFYWNoKCRzY29wZS5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBEUy5kZXN0cm95KGl0ZW0uY29udGVudF9vYmplY3QuY29sbGVjdGlvbiwgaXRlbS5jb250ZW50X29iamVjdC5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2NvcGUuaXNTZWxlY3RNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAkc2NvcGUudW5jaGVja0FsbCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKiBQcm9qZWN0IGZ1bmN0aW9ucyAqKi9cbiAgICAgICAgLy8gZ2V0IFByb2plY3Rpb25EZWZhdWx0IGZvciBpdGVtXG4gICAgICAgICRzY29wZS5nZXRQcm9qZWN0aW9uRGVmYXVsdCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS50cmVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRzY29wZS5kZWZhdWx0UHJvamVjdG9ySWRfYWxsX2l0ZW1zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBwX25hbWUgPSBpdGVtLmNvbnRlbnRfb2JqZWN0LmNvbGxlY3Rpb24uc3BsaXQoJy8nKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSAxO1xuICAgICAgICAgICAgICAgICRzY29wZS5wcm9qZWN0aW9uRGVmYXVsdHMuZm9yRWFjaChmdW5jdGlvbiAocHJvamVjdGlvbkRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2plY3Rpb25EZWZhdWx0Lm5hbWUgPT0gYXBwX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gcHJvamVjdGlvbkRlZmF1bHQucHJvamVjdG9yX2lkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBwcm9qZWN0IGFnZW5kYVxuICAgICAgICAkc2NvcGUucHJvamVjdEFnZW5kYSA9IGZ1bmN0aW9uIChwcm9qZWN0b3JJZCwgdHJlZSwgaWQpIHtcbiAgICAgICAgICAgIHZhciBpc0FnZW5kYVByb2plY3RlZElkcyA9ICRzY29wZS5pc0FnZW5kYVByb2plY3RlZCgkc2NvcGUubWFpbkxpc3RUcmVlKTtcbiAgICAgICAgICAgIF8uZm9yRWFjaChpc0FnZW5kYVByb2plY3RlZElkcywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgJGh0dHAucG9zdCgnL3Jlc3QvY29yZS9wcm9qZWN0b3IvJyArIGlkICsgJy9jbGVhcl9lbGVtZW50cy8nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKF8uaW5kZXhPZihpc0FnZW5kYVByb2plY3RlZElkcywgcHJvamVjdG9ySWQpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgJGh0dHAucG9zdCgnL3Jlc3QvY29yZS9wcm9qZWN0b3IvJyArIHByb2plY3RvcklkICsgJy9wcnVuZV9lbGVtZW50cy8nLFxuICAgICAgICAgICAgICAgICAgICBbe25hbWU6ICdhZ2VuZGEvaXRlbS1saXN0JywgdHJlZTogdHJlZSwgaWQ6IGlkfV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBjaGFuZ2Ugd2hldGhlciBhbGwgaXRlbXMgb3Igb25seSBtYWluIGl0ZW1zIHNob3VsZCBiZSBwcm9qZWN0ZWRcbiAgICAgICAgJHNjb3BlLmNoYW5nZU1haW5MaXN0VHJlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpc0FnZW5kYVByb2plY3RlZElkID0gJHNjb3BlLmlzQWdlbmRhUHJvamVjdGVkKCRzY29wZS5tYWluTGlzdFRyZWUpO1xuICAgICAgICAgICAgJHNjb3BlLm1haW5MaXN0VHJlZSA9ICEkc2NvcGUubWFpbkxpc3RUcmVlO1xuICAgICAgICAgICAgaWYgKGlzQWdlbmRhUHJvamVjdGVkSWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnByb2plY3RBZ2VuZGEoaXNBZ2VuZGFQcm9qZWN0ZWRJZCwgJHNjb3BlLm1haW5MaXN0VHJlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNoYW5nZSB3aGV0aGVyIG9uZSBpdGVtIG9yIGFsbCBzdWJpdGVtcyBzaG91bGQgYmUgcHJvamVjdGVkXG4gICAgICAgICRzY29wZS5jaGFuZ2VJdGVtVHJlZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgdHJlZSA9IGl0ZW0udHJlZTtcbiAgICAgICAgICAgIGl0ZW0udHJlZSA9ICFpdGVtLnRyZWU7XG4gICAgICAgICAgICB2YXIgaXNQcm9qZWN0ZWQgPSBpdGVtLmlzUHJvamVjdGVkKHRyZWUpO1xuICAgICAgICAgICAgXy5mb3JFYWNoKGlzUHJvamVjdGVkLCBmdW5jdGlvbiAocHJvamVjdG9ySWQpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWFjdGl2YXRlIGFuZCByZWFjdGl2YXRlXG4gICAgICAgICAgICAgICAgaXRlbS5wcm9qZWN0KHByb2plY3RvcklkLCB0cmVlKS50aGVuKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucHJvamVjdChwcm9qZWN0b3JJZCwgIXRyZWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNoZWNrIGlmIGFnZW5kYSBpcyBwcm9qZWN0ZWRcbiAgICAgICAgJHNjb3BlLmlzQWdlbmRhUHJvamVjdGVkID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgdGhlIGlkcyBvZiBhbGwgcHJvamVjdG9ycyB3aXRoIGFuIGVsZW1lbnQgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIG5hbWUgJ2FnZW5kYS9pdGVtLWxpc3QnLiBFbHNlIHJldHVybnMgYW4gZW1wdHkgbGlzdC5cbiAgICAgICAgICAgIHZhciBwcmVkaWNhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHJlZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cmVlIHdpdGggYWxsIGFnZW5kYSBpdGVtc1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVsZW1lbnQubmFtZSA9PSAnYWdlbmRhL2l0ZW0tbGlzdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBlbGVtZW50LmlkID09PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC50cmVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgbWFpbiBhZ2VuZGEgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlbGVtZW50Lm5hbWUgPT0gJ2FnZW5kYS9pdGVtLWxpc3QnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZWxlbWVudC5pZCA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFlbGVtZW50LnRyZWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcHJvamVjdG9ySWRzID0gW107XG4gICAgICAgICAgICAkc2NvcGUucHJvamVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF8uZmluZEtleShwcm9qZWN0b3IuZWxlbWVudHMsIHByZWRpY2F0ZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3Rvcklkcy5wdXNoKHByb2plY3Rvci5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdG9ySWRzO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi8vIEZpbHRlciBmb3IgdGhlIGl0ZW0gdHlwZSB0aGF0IGZpbHRlcnMgdGhlIHNlbGVjdGVkIGl0ZW1zIGJ5IHR5cGUuIGZpbHRlcnNcbi8vIGFyZSB0aGUgYm9vbGVhbiBmaWx0ZXJzIGZyb20gdGhlIHVpLlxuLmZpbHRlcignaXRlbVR5cGVGaWx0ZXInLCBbXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZW1zLCBmaWx0ZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5maWx0ZXIoaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpdGVtLmlzX3B1YmxpYyAmJiBmaWx0ZXJzLmlzX3B1YmxpYy52YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGl0ZW0uaXNfaW50ZXJuYWwgJiYgZmlsdGVycy5pc19pbnRlcm5hbC52YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGl0ZW0uaXNfaGlkZGVuICYmIGZpbHRlcnMuaXNfaGlkZGVuLnZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi8vIGZpbHRlciB0byBoaWRlIGNvbGxhcHNlZCBpdGVtcy4gSXRlbXMgaGFzIHRvIGJlIGEgZmxhdCB0cmVlLlxuLmZpbHRlcignY29sbGFwc2VkSXRlbUZpbHRlcicsIFtcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfLmZpbHRlcihpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfLmZpbmRJbmRleChpdGVtcywgaXRlbSk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudElkID0gaXRlbS5wYXJlbnRfaWQ7XG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoIGZvciBwYXJlbnRzLCBpZiBvbmUgaGFzIHRoZSBoaWRlQ2hpbGRyZW4gYXR0cmlidXRlIHNldC4gQWxsIHBhcmVudHNcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgaGlnaGVyIGluZGV4IGFzIHRoaXMgaXRlbSwgYmVjYXVzZSBpdGVtcyBpcyBhIGZsYXQgdHJlZS5cbiAgICAgICAgICAgICAgICAvLyBJZiBhIHBhcmVudCBoYXMgdGhpcyBhdHRyaWJ1dGUsIHdlIHNob3VsZCByZW1vdmUgdGhpcyBpdGVtLiBFbHNlIGlmIHdlIGhpdFxuICAgICAgICAgICAgICAgIC8vIHRoZSB0b3Agb3IgYW4gaXRlbSBvbiB0aGUgZmlyc3QgbGF5ZXIsIHRoZSBpdGVtIGlzIG5vdCBjb2xsYXBzZWQuXG4gICAgICAgICAgICAgICAgZm9yICgtLWluZGV4OyBpbmRleCA+PSAwICYmIHBhcmVudElkICE9PSBudWxsOyBpbmRleC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gaXRlbXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocC5pZCA9PT0gcGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLmhpZGVDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQgPSBwLnBhcmVudF9pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdJdGVtRGV0YWlsQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJGZpbHRlcicsXG4gICAgJ0FnZW5kYScsXG4gICAgJ2l0ZW1JZCcsXG4gICAgJ1Byb2plY3RvcicsXG4gICAgJ1Byb2plY3Rpb25EZWZhdWx0JyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdXZWJwYWdlVGl0bGUnLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsICRmaWx0ZXIsIEFnZW5kYSwgaXRlbUlkLCBQcm9qZWN0b3IsIFByb2plY3Rpb25EZWZhdWx0LCBnZXR0ZXh0Q2F0YWxvZywgV2VicGFnZVRpdGxlLFxuICAgICAgICBFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge307XG5cbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQWdlbmRhLmxhc3RNb2RpZmllZChpdGVtSWQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUuaXRlbSA9IEFnZW5kYS5nZXQoaXRlbUlkKTtcbiAgICAgICAgICAgIFdlYnBhZ2VUaXRsZS51cGRhdGVUaXRsZShnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0xpc3Qgb2Ygc3BlYWtlcnMnKSArICcgJyArXG4gICAgICAgICAgICAgICAgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdvZicpICsgJyAnICsgJHNjb3BlLml0ZW0uZ2V0VGl0bGUoKSk7XG4gICAgICAgICAgICAvLyBhbGwgc3BlYWtlcnNcbiAgICAgICAgICAgICRzY29wZS5zcGVha2VycyA9ICRmaWx0ZXIoJ29yZGVyQnknKSgkc2NvcGUuaXRlbS5zcGVha2VycywgJ3dlaWdodCcpO1xuICAgICAgICAgICAgLy8gbmV4dCBzcGVha2Vyc1xuICAgICAgICAgICAgJHNjb3BlLm5leHRTcGVha2VycyA9ICRmaWx0ZXIoJ2ZpbHRlcicpKCRzY29wZS5zcGVha2VycywgeydiZWdpbl90aW1lJzogbnVsbH0pO1xuICAgICAgICAgICAgLy8gY3VycmVudCBzcGVha2VyXG4gICAgICAgICAgICAkc2NvcGUuY3VycmVudFNwZWFrZXIgPSAkZmlsdGVyKCdmaWx0ZXInKSgkc2NvcGUuc3BlYWtlcnMsIHsnYmVnaW5fdGltZSc6ICchIScsICdlbmRfdGltZSc6IG51bGx9KTtcbiAgICAgICAgICAgIC8vIGxhc3Qgc3BlYWtlcnNcbiAgICAgICAgICAgICRzY29wZS5sYXN0U3BlYWtlcnMgPSAkZmlsdGVyKCdmaWx0ZXInKSgkc2NvcGUuc3BlYWtlcnMsIHsnZW5kX3RpbWUnOiAnISEnfSk7XG4gICAgICAgICAgICAkc2NvcGUubGFzdFNwZWFrZXJzID0gJGZpbHRlcignb3JkZXJCeScpKCRzY29wZS5sYXN0U3BlYWtlcnMsICdiZWdpbl90aW1lJyk7XG4gICAgICAgIH0pO1xuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9qZWN0b3IubGFzdE1vZGlmaWVkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtX2FwcF9uYW1lID0gJHNjb3BlLml0ZW0uY29udGVudF9vYmplY3QuY29sbGVjdGlvbi5zcGxpdCgnLycpWzBdO1xuICAgICAgICAgICAgdmFyIHByb2plY3Rpb25kZWZhdWx0SXRlbSA9IFByb2plY3Rpb25EZWZhdWx0LmZpbHRlcih7bmFtZTogaXRlbV9hcHBfbmFtZX0pWzBdO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rpb25kZWZhdWx0SXRlbSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5kZWZhdWx0UHJvamVjdG9ySXRlbUlkID0gcHJvamVjdGlvbmRlZmF1bHRJdGVtLnByb2plY3Rvcl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm9qZWN0aW9uZGVmYXVsdExpc3RPZlNwZWFrZXJzID0gUHJvamVjdGlvbkRlZmF1bHQuZmlsdGVyKHtuYW1lOiAnYWdlbmRhX2xpc3Rfb2Zfc3BlYWtlcnMnfSlbMF07XG4gICAgICAgICAgICBpZiAocHJvamVjdGlvbmRlZmF1bHRMaXN0T2ZTcGVha2Vycykge1xuICAgICAgICAgICAgICAgICRzY29wZS5kZWZhdWx0UHJvamVjdG9yTGlzdE9mU3BlYWtlcnNJZCA9IHByb2plY3Rpb25kZWZhdWx0TGlzdE9mU3BlYWtlcnMucHJvamVjdG9yX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4vKiBUaGlzIGlzIHRoZSBjb250cm9sbGVyIGZvciB0aGUgbGlzdCBvZiBzcGVha2VycyBwYXJ0aWFsIG1hbmFnZW1lbnQgdGVtcGxhdGUuXG4gKiBUaGUgcGFyZW50IGNvbnRyb2xsZXIgbmVlZHMgdG8gcHJvdmlkZSBhICRzY29wZS5pdGVtLCAkc2NvcGUuc3BlYWtlcnMsICRzY29wZS5uZXh0U3BlYWtlcnMsXG4gKiAkc2NvcGUuY3VycmVudFNwZWFrZXJzLCAkc2NvcGUubGFzdFNwZWFrZXJzLiBTZWUgKGFzIGV4YW1wbGUpIEl0ZW1EZXRhaWxDdHJsLiAqL1xuLmNvbnRyb2xsZXIoJ0xpc3RPZlNwZWFrZXJzTWFuYWdlbWVudEN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRodHRwJyxcbiAgICAnJGZpbHRlcicsXG4gICAgJ0FnZW5kYScsXG4gICAgJ1VzZXInLFxuICAgICdvcGVyYXRvcicsXG4gICAgJ0Vycm9yTWVzc2FnZScsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgJGh0dHAsICRmaWx0ZXIsIEFnZW5kYSwgVXNlciwgb3BlcmF0b3IsIEVycm9yTWVzc2FnZSkge1xuICAgICAgICBVc2VyLmJpbmRBbGwoe30sICRzY29wZSwgJ3VzZXJzJyk7XG4gICAgICAgICRzY29wZS5zcGVha2VyU2VsZWN0Qm94ID0ge307XG5cbiAgICAgICAgLy8gY2xvc2Uvb3BlbiBsaXN0IG9mIHNwZWFrZXJzIG9mIGN1cnJlbnQgaXRlbVxuICAgICAgICAkc2NvcGUuY2xvc2VMaXN0ID0gZnVuY3Rpb24gKGxpc3RDbG9zZWQpIHtcbiAgICAgICAgICAgICRzY29wZS5pdGVtLnNwZWFrZXJfbGlzdF9jbG9zZWQgPSBsaXN0Q2xvc2VkO1xuICAgICAgICAgICAgQWdlbmRhLnNhdmUoJHNjb3BlLml0ZW0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZCB1c2VyIHRvIGxpc3Qgb2Ygc3BlYWtlcnNcbiAgICAgICAgJHNjb3BlLmFkZFNwZWFrZXIgPSBmdW5jdGlvbiAodXNlcklkKSB7XG4gICAgICAgICAgICAkaHR0cC5wb3N0KCcvcmVzdC9hZ2VuZGEvaXRlbS8nICsgJHNjb3BlLml0ZW0uaWQgKyAnL21hbmFnZV9zcGVha2VyLycsIHsndXNlcic6IHVzZXJJZH0pLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0LnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNwZWFrZXJTZWxlY3RCb3ggPSB7fTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNwZWFrZXJTZWxlY3RCb3ggPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRlbGV0ZSBzcGVha2VyKCEpIGZyb20gbGlzdCBvZiBzcGVha2Vyc1xuICAgICAgICAkc2NvcGUucmVtb3ZlU3BlYWtlciA9IGZ1bmN0aW9uIChzcGVha2VySWQpIHtcbiAgICAgICAgICAgICRodHRwLmRlbGV0ZShcbiAgICAgICAgICAgICAgICAnL3Jlc3QvYWdlbmRhL2l0ZW0vJyArICRzY29wZS5pdGVtLmlkICsgJy9tYW5hZ2Vfc3BlYWtlci8nLFxuICAgICAgICAgICAgICAgIHtoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ30sXG4gICAgICAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHtzcGVha2VyOiBzcGVha2VySWR9KX1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9kZWxldGUgYWxsIHNwZWFrZXJzIGZyb20gbGlzdCBvZiBzcGVha2Vyc1xuICAgICAgICAkc2NvcGUucmVtb3ZlQWxsU3BlYWtlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3BlYWtlcnNPbkxpc3QgPSBbXTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUuaXRlbS5zcGVha2VycywgZnVuY3Rpb24gKHNwZWFrZXIpIHtcbiAgICAgICAgICAgICAgICBzcGVha2Vyc09uTGlzdC5wdXNoKHNwZWFrZXIuaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkaHR0cC5kZWxldGUoXG4gICAgICAgICAgICAgICAgJy9yZXN0L2FnZW5kYS9pdGVtLycgKyAkc2NvcGUuaXRlbS5pZCArICcvbWFuYWdlX3NwZWFrZXIvJyxcbiAgICAgICAgICAgICAgICB7aGVhZGVyczogeydDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbid9LFxuICAgICAgICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSh7c3BlYWtlcjogc3BlYWtlcnNPbkxpc3R9KX1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIHJlcXVlc3RlZCB1c2VyIGlzIGFsbG93ZWQgdG8gZG8gYSBzcGVjaWZpYyBhY3Rpb25cbiAgICAgICAgLy8gYW5kIHNlZSB0aGUgY29ycmVzcG9uZGluZyBidXR0b24gKGUuZy4gJ2FkZCBtZScgb3IgJ3JlbW92ZSBtZScpLlxuICAgICAgICAkc2NvcGUuaXNBbGxvd2VkID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgdmFyIG5leHRVc2VycyA9IFtdO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5uZXh0U3BlYWtlcnMsIGZ1bmN0aW9uIChzcGVha2VyKSB7XG4gICAgICAgICAgICAgICAgbmV4dFVzZXJzLnB1c2goc3BlYWtlci51c2VyX2lkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG9wZXJhdG9yLmhhc1Blcm1zKCdhZ2VuZGEuY2FuX2JlX3NwZWFrZXInKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEkc2NvcGUuaXRlbS5zcGVha2VyX2xpc3RfY2xvc2VkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5pbkFycmF5KG9wZXJhdG9yLnVzZXIuaWQsIG5leHRVc2VycykgPT0gLTEpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvci51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCQuaW5BcnJheShvcGVyYXRvci51c2VyLmlkLCBuZXh0VXNlcnMpICE9IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVtb3ZlQWxsJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChvcGVyYXRvci5oYXNQZXJtcygnYWdlbmRhLmNhbl9tYW5hZ2VfbGlzdF9vZl9zcGVha2VycycpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNwZWFrZXJzLmxlbmd0aCA+IDApO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Nob3dMYXN0U3BlYWtlcnMnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHNjb3BlLmxhc3RTcGVha2Vycy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGJlZ2luIHNwZWVjaCBvZiBzZWxlY3RlZC9uZXh0IHNwZWFrZXJcbiAgICAgICAgJHNjb3BlLmJlZ2luU3BlZWNoID0gZnVuY3Rpb24gKHNwZWFrZXJJZCkge1xuICAgICAgICAgICAgJGh0dHAucHV0KCcvcmVzdC9hZ2VuZGEvaXRlbS8nICsgJHNjb3BlLml0ZW0uaWQgKyAnL3NwZWFrLycsIHsnc3BlYWtlcic6IHNwZWFrZXJJZH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICRzY29wZS5hbGVydC5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZW5kIHNwZWVjaCBvZiBjdXJyZW50IHNwZWFrZXJcbiAgICAgICAgJHNjb3BlLmVuZFNwZWVjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRodHRwLmRlbGV0ZShcbiAgICAgICAgICAgICAgICAnL3Jlc3QvYWdlbmRhL2l0ZW0vJyArICRzY29wZS5pdGVtLmlkICsgJy9zcGVhay8nLFxuICAgICAgICAgICAgICAgIHtoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ30sIGRhdGE6IHt9fVxuICAgICAgICAgICAgKS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzKSB7fSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICAvLyBnZXRzIHNwZWVjaCBkdXJhdGlvbiBvZiBzZWxlY3RlZCBzcGVha2VyIGluIHNlY29uZHNcbiAgICAgICAgJHNjb3BlLmdldER1cmF0aW9uID0gZnVuY3Rpb24gKHNwZWFrZXIpIHtcbiAgICAgICAgICAgIHZhciBiZWdpblRpbWVzdGFtcCA9IG5ldyBEYXRlKHNwZWFrZXIuYmVnaW5fdGltZSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdmFyIGVuZFRpbWVzdGFtcCA9IG5ldyBEYXRlKHNwZWFrZXIuZW5kX3RpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoZW5kVGltZXN0YW1wIC0gYmVnaW5UaW1lc3RhbXApIC8gMTAwMCk7XG5cbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2F2ZSByZW9yZGVyZWQgbGlzdCBvZiBzcGVha2Vyc1xuICAgICAgICAkc2NvcGUudHJlZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkcm9wcGVkOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc29ydGVkU3BlYWtlcnMgPSBfLm1hcCgkc2NvcGUubmV4dFNwZWFrZXJzLCBmdW5jdGlvbiAoc3BlYWtlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BlYWtlci5pZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkaHR0cC5wb3N0KCcvcmVzdC9hZ2VuZGEvaXRlbS8nICsgJHNjb3BlLml0ZW0uaWQgKyAnL3NvcnRfc3BlYWtlcnMvJyxcbiAgICAgICAgICAgICAgICAgICAge3NwZWFrZXJzOiBzb3J0ZWRTcGVha2Vyc31cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIE1hcmtpbmcgYSBzcGVha2VyXG4gICAgICAgICRzY29wZS50b2dnbGVNYXJrZWQgPSBmdW5jdGlvbiAoc3BlYWtlcikge1xuICAgICAgICAgICAgJGh0dHAucGF0Y2goJy9yZXN0L2FnZW5kYS9pdGVtLycgKyAkc2NvcGUuaXRlbS5pZCArICcvbWFuYWdlX3NwZWFrZXIvJywge1xuICAgICAgICAgICAgICAgIHVzZXI6IHNwZWFrZXIudXNlci5pZCxcbiAgICAgICAgICAgICAgICBtYXJrZWQ6ICFzcGVha2VyLm1hcmtlZCxcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQuc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdBZ2VuZGFTb3J0Q3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJGh0dHAnLFxuICAgICdBZ2VuZGEnLFxuICAgICdBZ2VuZGFUcmVlJyxcbiAgICAnRXJyb3JNZXNzYWdlJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsICRodHRwLCBBZ2VuZGEsIEFnZW5kYVRyZWUsIEVycm9yTWVzc2FnZSkge1xuICAgICAgICAvLyBCaW5kIGFnZW5kYSB0cmVlIHRvIHRoZSBzY29wZVxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBBZ2VuZGEubGFzdE1vZGlmaWVkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5pdGVtcyA9IEFnZW5kYVRyZWUuZ2V0VHJlZShBZ2VuZGEuZ2V0QWxsKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgJHNjb3BlLnNob3dJbnRlcm5hbEl0ZW1zID0gdHJ1ZTtcbiAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge307XG5cbiAgICAgICAgLy8gc2F2ZSBwYXJlbnQgYW5kIHdlaWdodCBvZiBtb3ZlZCBhZ2VuZGEgaXRlbSAoYW5kIGFsbCBpdGVtcyBvbiBzYW1lIGxldmVsKVxuICAgICAgICAkc2NvcGUudHJlZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkcm9wcGVkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJRCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGRyb3BwZWRJdGVtSUQgPSBldmVudC5zb3VyY2Uubm9kZVNjb3BlLiRtb2RlbFZhbHVlLmlkO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kZXN0Lm5vZGVzU2NvcGUuaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJRCA9IGV2ZW50LmRlc3Qubm9kZXNTY29wZS5pdGVtLmlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkaHR0cC5wb3N0KCcvcmVzdC9hZ2VuZGEvaXRlbS9zb3J0LycsIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXM6IGV2ZW50LmRlc3Qubm9kZXNTY29wZS4kbW9kZWxWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50X2lkOiBwYXJlbnRJRH1cbiAgICAgICAgICAgICAgICApLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHN1Y2Nlc3MpIHt9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvcil7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignQ3VycmVudExpc3RPZlNwZWFrZXJzVmlld0N0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRodHRwJyxcbiAgICAnJGZpbHRlcicsXG4gICAgJ1Byb2plY3RvcicsXG4gICAgJ1Byb2plY3Rpb25EZWZhdWx0JyxcbiAgICAnQWdlbmRhJyxcbiAgICAnQ29uZmlnJyxcbiAgICAnQ3VycmVudExpc3RPZlNwZWFrZXJzSXRlbScsXG4gICAgJ0N1cnJlbnRMaXN0T2ZTcGVha2Vyc1NsaWRlJyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdXZWJwYWdlVGl0bGUnLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgJGh0dHAsICRmaWx0ZXIsIFByb2plY3RvciwgUHJvamVjdGlvbkRlZmF1bHQsIEFnZW5kYSwgQ29uZmlnLFxuICAgICAgICBDdXJyZW50TGlzdE9mU3BlYWtlcnNJdGVtLCBDdXJyZW50TGlzdE9mU3BlYWtlcnNTbGlkZSwgZ2V0dGV4dENhdGFsb2csIFdlYnBhZ2VUaXRsZSkge1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcbiAgICAgICAgJHNjb3BlLmN1cnJlbnRMaXN0T2ZTcGVha2VycyA9IEN1cnJlbnRMaXN0T2ZTcGVha2Vyc1NsaWRlO1xuXG4gICAgICAgIC8vIFdhdGNoIGZvciBjaGFuZ2VzIGluIHRoZSBjdXJyZW50IGxpc3Qgb2Ygc3BlYWtlcnMgcmVmZXJlbmNlXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIENvbmZpZy5sYXN0TW9kaWZpZWQoJ3Byb2plY3Rvcl9jdXJyZW50TGlzdE9mU3BlYWtlcnNfcmVmZXJlbmNlJyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5jdXJyZW50TGlzdE9mU3BlYWtlcnNSZWZlcmVuY2UgPSAkc2NvcGUuY29uZmlnKCdwcm9qZWN0b3JfY3VycmVudExpc3RPZlNwZWFrZXJzX3JlZmVyZW5jZScpO1xuICAgICAgICAgICAgJHNjb3BlLnVwZGF0ZUN1cnJlbnRMaXN0T2ZTcGVha2Vyc0l0ZW0oKTtcbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb2plY3Rvci5sYXN0TW9kaWZpZWQoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUucHJvamVjdG9ycyA9IFByb2plY3Rvci5nZXRBbGwoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGp1c3Qgb25lIHByb2plY3RvciB3ZSBwcm92aWRlIGp1c3QgdGhlIG92ZXJsYXkuXG4gICAgICAgICAgICBpZiAoJHNjb3BlLnByb2plY3RvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmN1cnJlbnRMaXN0T2ZTcGVha2Vyc0FzT3ZlcmxheSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUudXBkYXRlQ3VycmVudExpc3RPZlNwZWFrZXJzSXRlbSgpO1xuXG4gICAgICAgICAgICAkc2NvcGUubGlzdE9mU3BlYWtlcnNEZWZhdWx0UHJvamVjdG9ySWQgPSBQcm9qZWN0aW9uRGVmYXVsdC5maWx0ZXIoe25hbWU6ICdhZ2VuZGFfY3VycmVudF9saXN0X29mX3NwZWFrZXJzJ30pWzBdLnByb2plY3Rvcl9pZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJHNjb3BlLml0ZW0gPyBBZ2VuZGEubGFzdE1vZGlmaWVkKCRzY29wZS5pdGVtLmlkKSA6IHZvaWQgMDtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLnVwZGF0ZUN1cnJlbnRMaXN0T2ZTcGVha2Vyc0l0ZW0oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHNjb3BlLnVwZGF0ZUN1cnJlbnRMaXN0T2ZTcGVha2Vyc0l0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUuaXRlbSA9IEN1cnJlbnRMaXN0T2ZTcGVha2Vyc0l0ZW0uZ2V0SXRlbSgkc2NvcGUuY3VycmVudExpc3RPZlNwZWFrZXJzUmVmZXJlbmNlKTtcbiAgICAgICAgICAgIGlmICgkc2NvcGUuaXRlbSkge1xuICAgICAgICAgICAgICAgIC8vIGFsbCBzcGVha2Vyc1xuICAgICAgICAgICAgICAgICRzY29wZS5zcGVha2VycyA9ICRmaWx0ZXIoJ29yZGVyQnknKSgkc2NvcGUuaXRlbS5zcGVha2VycywgJ3dlaWdodCcpO1xuICAgICAgICAgICAgICAgIC8vIG5leHQgc3BlYWtlcnNcbiAgICAgICAgICAgICAgICAkc2NvcGUubmV4dFNwZWFrZXJzID0gJGZpbHRlcignZmlsdGVyJykoJHNjb3BlLnNwZWFrZXJzLCB7J2JlZ2luX3RpbWUnOiBudWxsfSk7XG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBzcGVha2VyXG4gICAgICAgICAgICAgICAgJHNjb3BlLmN1cnJlbnRTcGVha2VyID0gJGZpbHRlcignZmlsdGVyJykoJHNjb3BlLnNwZWFrZXJzLCB7J2JlZ2luX3RpbWUnOiAnISEnLCAnZW5kX3RpbWUnOiBudWxsfSk7XG4gICAgICAgICAgICAgICAgLy8gbGFzdCBzcGVha2Vyc1xuICAgICAgICAgICAgICAgICRzY29wZS5sYXN0U3BlYWtlcnMgPSAkZmlsdGVyKCdmaWx0ZXInKSgkc2NvcGUuc3BlYWtlcnMsIHsnZW5kX3RpbWUnOiAnISEnfSk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmxhc3RTcGVha2VycyA9ICRmaWx0ZXIoJ29yZGVyQnknKSgkc2NvcGUubGFzdFNwZWFrZXJzLCAnYmVnaW5fdGltZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3BlYWtlcnMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm5leHRTcGVha2VycyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAkc2NvcGUuY3VycmVudFNwZWFrZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmxhc3RTcGVha2VycyA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkc2NvcGUuaXRlbSkge1xuICAgICAgICAgICAgICAgIFdlYnBhZ2VUaXRsZS51cGRhdGVUaXRsZShnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0N1cnJlbnQgbGlzdCBvZiBzcGVha2VycycpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdvZicpICsgJyAnICsgJHNjb3BlLml0ZW0uZ2V0VGl0bGUoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFdlYnBhZ2VUaXRsZS51cGRhdGVUaXRsZShnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0N1cnJlbnQgbGlzdCBvZiBzcGVha2VycycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgb3ZlcmxheSBzdGF0dXNcbiAgICAgICAgaWYgKCRzY29wZS5jdXJyZW50TGlzdE9mU3BlYWtlcnMuaXNQcm9qZWN0ZWQoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBpc1Byb2plY3RlZCA9ICRzY29wZS5jdXJyZW50TGlzdE9mU3BlYWtlcnMuaXNQcm9qZWN0ZWRXaXRoT3ZlcmxheVN0YXR1cygpO1xuICAgICAgICAgICAgJHNjb3BlLmN1cnJlbnRMaXN0T2ZTcGVha2Vyc0FzT3ZlcmxheSA9IGlzUHJvamVjdGVkWzBdLm92ZXJsYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2NvcGUuY3VycmVudExpc3RPZlNwZWFrZXJzQXNPdmVybGF5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgJHNjb3BlLnNldE92ZXJsYXkgPSBmdW5jdGlvbiAob3ZlcmxheSkge1xuICAgICAgICAgICAgJHNjb3BlLmN1cnJlbnRMaXN0T2ZTcGVha2Vyc0FzT3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgICAgICB2YXIgaXNQcm9qZWN0ZWQgPSAkc2NvcGUuY3VycmVudExpc3RPZlNwZWFrZXJzLmlzUHJvamVjdGVkV2l0aE92ZXJsYXlTdGF0dXMoKTtcbiAgICAgICAgICAgIGlmIChpc1Byb2plY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goaXNQcm9qZWN0ZWQsIGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBwaW5nLm92ZXJsYXkgIT0gb3ZlcmxheSkgeyAvLyBjaGFuZ2UgdGhlIG92ZXJsYXkgaWYgaXQgaXMgZGlmZmVyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY3VycmVudExpc3RPZlNwZWFrZXJzLnByb2plY3QobWFwcGluZy5wcm9qZWN0b3JJZCwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4vL21hcmsgYWxsIGFnZW5kYSBjb25maWcgc3RyaW5ncyBmb3IgdHJhbnNsYXRpb24gd2l0aCBKYXZhc2NyaXB0XG4uY29uZmlnKFtcbiAgICAnZ2V0dGV4dCcsXG4gICAgZnVuY3Rpb24gKGdldHRleHQpIHtcbiAgICAgICAgZ2V0dGV4dCgnRW5hYmxlIG51bWJlcmluZyBmb3IgYWdlbmRhIGl0ZW1zJyk7XG4gICAgICAgIGdldHRleHQoJ051bWJlcmluZyBwcmVmaXggZm9yIGFnZW5kYSBpdGVtcycpO1xuICAgICAgICBnZXR0ZXh0KCdUaGlzIHByZWZpeCB3aWxsIGJlIHNldCBpZiB5b3UgcnVuIHRoZSBhdXRvbWF0aWMgYWdlbmRhIG51bWJlcmluZy4nKTtcbiAgICAgICAgZ2V0dGV4dCgnQWdlbmRhJyk7XG4gICAgICAgIGdldHRleHQoJ0ludmFsaWQgaW5wdXQuJyk7XG4gICAgICAgIGdldHRleHQoJ051bWVyYWwgc3lzdGVtIGZvciBhZ2VuZGEgaXRlbXMnKTtcbiAgICAgICAgZ2V0dGV4dCgnQXJhYmljJyk7XG4gICAgICAgIGdldHRleHQoJ1JvbWFuJyk7XG4gICAgICAgIGdldHRleHQoJ0JlZ2luIG9mIGV2ZW50Jyk7XG4gICAgICAgIGdldHRleHQoJ0lucHV0IGZvcm1hdDogREQuTU0uWVlZWSBISDpNTScpO1xuICAgICAgICBnZXR0ZXh0KCdIaWRlIGludGVybmFsIGl0ZW1zIHdoZW4gcHJvamVjdGluZyBzdWJpdGVtcycpO1xuICAgICAgICBnZXR0ZXh0KCdOdW1iZXIgb2YgbGFzdCBzcGVha2VycyB0byBiZSBzaG93biBvbiB0aGUgcHJvamVjdG9yJyk7XG4gICAgICAgIGdldHRleHQoJ0xpc3Qgb2Ygc3BlYWtlcnMnKTtcbiAgICAgICAgZ2V0dGV4dCgnU2hvdyBvcmFuZ2UgY291bnRkb3duIGluIHRoZSBsYXN0IHggc2Vjb25kcyBvZiBzcGVha2luZyB0aW1lJyk7XG4gICAgICAgIGdldHRleHQoJ0VudGVyIGR1cmF0aW9uIGluIHNlY29uZHMuIENob29zZSAwIHRvIGRpc2FibGUgd2FybmluZyBjb2xvci4nKTtcbiAgICAgICAgZ2V0dGV4dCgnQ291cGxlIGNvdW50ZG93biB3aXRoIHRoZSBsaXN0IG9mIHNwZWFrZXJzJyk7XG4gICAgICAgIGdldHRleHQoJ1tCZWdpbiBzcGVlY2hdIHN0YXJ0cyB0aGUgY291bnRkb3duLCBbRW5kIHNwZWVjaF0gc3RvcHMgdGhlICcgK1xuICAgICAgICAgICAgICAgICdjb3VudGRvd24uJyk7XG4gICAgICAgIGdldHRleHQoJ0FnZW5kYSB2aXNpYmlsaXR5Jyk7XG4gICAgICAgIGdldHRleHQoJ0RlZmF1bHQgdmlzaWJpbGl0eSBmb3IgbmV3IGFnZW5kYSBpdGVtcyAoZXhjZXB0IHRvcGljcyknKTtcbiAgICB9XG4gXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmFuZ3VsYXIubW9kdWxlKCdPcGVuU2xpZGVzQXBwLmFzc2lnbm1lbnRzJywgW10pXG5cbi5mYWN0b3J5KCdBc3NpZ25tZW50UG9sbE9wdGlvbicsIFtcbiAgICAnRFMnLFxuICAgICdqc0RhdGFNb2RlbCcsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnQ29uZmlnJyxcbiAgICAnTWFqb3JpdHlNZXRob2RzJyxcbiAgICBmdW5jdGlvbiAoRFMsIGpzRGF0YU1vZGVsLCBnZXR0ZXh0Q2F0YWxvZywgQ29uZmlnLCBNYWpvcml0eU1ldGhvZHMpIHtcbiAgICAgICAgcmV0dXJuIERTLmRlZmluZVJlc291cmNlKHtcbiAgICAgICAgICAgIG5hbWU6ICdhc3NpZ25tZW50cy9wb2xsb3B0aW9uJyxcbiAgICAgICAgICAgIHVzZUNsYXNzOiBqc0RhdGFNb2RlbCxcbiAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgc3RyaW5naWZpZWQgbnVtYmVycyB0byBmbG9hdHMuXG4gICAgICAgICAgICBiZWZvcmVJbmplY3Q6IGZ1bmN0aW9uIChyZXNvdXJjZSwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goaW5zdGFuY2Uudm90ZXMsIGZ1bmN0aW9uICh2b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZvdGUud2VpZ2h0ID0gcGFyc2VGbG9hdCh2b3RlLndlaWdodCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWV0aG9kczoge1xuICAgICAgICAgICAgICAgIGdldFZvdGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wb2xsLmhhc192b3Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBpZiB0aGlzIHBvbGwgaGFzIG5vIHZvdGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXMgZm9yIHRoZSBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZvdGVzID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBDb25maWcuZ2V0KCdhc3NpZ25tZW50c19wb2xsXzEwMF9wZXJjZW50X2Jhc2UnKS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IHRoaXMucG9sbC5nZXRQZXJjZW50QmFzZShjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJhc2UgPT09ICdvYmplY3QnICYmIGJhc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMucG9sbC5wb2xsbWV0aG9kID09PSAneW5hJ1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2VbdGhpcy5pZF07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2godGhpcy52b3RlcywgZnVuY3Rpb24gKHZvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzIGZvciB0aGUgdm90ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yZGVyID0gJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50U3RyID0gJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudE51bWJlcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHNwZWNpYWwgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodm90ZS53ZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnbWFqb3JpdHknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAtMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ3VuZG9jdW1lbnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm90ZS53ZWlnaHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2b3RlLndlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gMDsgIC8vIFZvdGUgd2FzIG5vdCBkZWZpbmVkLiBTZXQgdmFsdWUgdG8gMC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2b3RlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlllc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlciA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJOb1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlciA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBYnN0YWluXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2Ugd2hlcmUgdG8gc2tpcCBwZXJjZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNraXBQZXJjZW50cyA9IGNvbmZpZyA9PT0gJ1lFU19OTycgJiYgdm90ZS52YWx1ZSA9PT0gJ0Fic3RhaW4nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZSAmJiAhc2tpcFBlcmNlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudE51bWJlciA9IE1hdGgucm91bmQodm90ZS53ZWlnaHQgKiAxMDAgLyBiYXNlICogMTAwKSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVyY2VudE51bWJlciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnRTdHIgPSAnKCcgKyBwZXJjZW50TnVtYmVyICsgJyAlKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdm90ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyJzogb3JkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2xhYmVsJzogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKHZvdGUudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwZXJjZW50U3RyJzogcGVyY2VudFN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGVyY2VudE51bWJlcic6IHBlcmNlbnROdW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uc29ydEJ5KHZvdGVzLCAnb3JkZXInKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyAwIG9yIHBvc2l0aXZlIGludGVnZXIgaWYgcXVvcnVtIGlzIHJlYWNoZWQgb3Igc3VycGFzc2VkLlxuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgbmVnYXRpdiBpbnRlZ2VyIGlmIHF1b3J1bSBpcyBub3QgcmVhY2hlZC5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIHVuZGVmaW5lZCBpZiB3ZSBjYW4gbm90IGNhbGN1bGF0ZSB0aGUgcXVvcnVtLlxuICAgICAgICAgICAgICAgIGlzUmVhY2hlZDogZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucG9sbC5oYXNfdm90ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgaWYgdGhpcyBwb2xsIGhhcyBubyB2b3Rlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSZWFjaGVkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gQ29uZmlnLmdldCgnYXNzaWdubWVudHNfcG9sbF8xMDBfcGVyY2VudF9iYXNlJykudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy5wb2xsLmdldFBlcmNlbnRCYXNlKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gJ29iamVjdCcgJiYgYmFzZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5wb2xsLnBvbGxtZXRob2QgPT09ICd5bmEnXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZVt0aGlzLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvdmlkZSByZXN1bHQgb25seSBpZiBiYXNlIGlzIG5vdCB1bmRlZmluZWQgYW5kIG5vdCAwLlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZWFjaGVkID0gTWFqb3JpdHlNZXRob2RzW21ldGhvZF0odGhpcy5nZXRWb3RlWWVzKCksIGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1JlYWNoZWQ7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgdGhlIHdlaWdodCBmb3IgdGhlIHZvdGUgb3IgdGhlIHZvdGUgJ3llcycgaW4gY2FzZSBvZiBZTkEgcG9sbCBtZXRob2QuXG4gICAgICAgICAgICAgICAgZ2V0Vm90ZVllczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdm90ZVllcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvbGwucG9sbG1ldGhvZCA9PT0gJ3luYScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2b3RlT2JqID0gXy5maW5kKHRoaXMudm90ZXMsIGZ1bmN0aW9uICh2b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvdGUudmFsdWUgPT09ICdZZXMnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodm90ZU9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvdGVZZXMgPSB2b3RlT2JqLndlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvbGxtZXRob2QgPT09ICd2b3RlcydcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvdGVZZXMgPSB0aGlzLnZvdGVzWzBdLndlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm90ZVllcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVsYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgYmVsb25nc1RvOiB7XG4gICAgICAgICAgICAgICAgICAgICdhc3NpZ25tZW50cy9wb2xsJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGaWVsZDogJ3BvbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxLZXk6ICdwb2xsX2lkJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3VzZXJzL3VzZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAnY2FuZGlkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsS2V5OiAnY2FuZGlkYXRlX2lkJyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdBc3NpZ25tZW50UG9sbCcsIFtcbiAgICAnJGh0dHAnLFxuICAgICdEUycsXG4gICAgJ2pzRGF0YU1vZGVsJyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdBc3NpZ25tZW50UG9sbE9wdGlvbicsXG4gICAgJ0NvbmZpZycsXG4gICAgZnVuY3Rpb24gKCRodHRwLCBEUywganNEYXRhTW9kZWwsIGdldHRleHRDYXRhbG9nLCBBc3NpZ25tZW50UG9sbE9wdGlvbiwgQ29uZmlnKSB7XG4gICAgICAgIHZhciBuYW1lID0gJ2Fzc2lnbm1lbnRzL3BvbGwnO1xuICAgICAgICByZXR1cm4gRFMuZGVmaW5lUmVzb3VyY2Uoe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHVzZUNsYXNzOiBqc0RhdGFNb2RlbCxcbiAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgc3RyaW5naWZpZWQgbnVtYmVycyB0byBmbG9hdHMuXG4gICAgICAgICAgICBiZWZvcmVJbmplY3Q6IGZ1bmN0aW9uIChyZXNvdXJjZSwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBbJ3ZvdGVzY2FzdCcsICd2b3Rlc2ludmFsaWQnLCAndm90ZXN2YWxpZCcsICd2b3Rlc2Fic3RhaW4nLCAndm90ZXNubyddO1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChhdHRycywgZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlW2F0dHJdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVthdHRyXSA9IHBhcnNlRmxvYXQoaW5zdGFuY2VbYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWV0aG9kczoge1xuICAgICAgICAgICAgICAgIGdldFJlc291cmNlTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyBwZXJjZW50IGJhc2UuIFJldHVybnMgdW5kZWZpbmVkIGlmIGNhbGN1bGF0aW9uIGlzIG5vdCBwb3NzaWJsZSBpbiBnZW5lcmFsLlxuICAgICAgICAgICAgICAgIGdldFBlcmNlbnRCYXNlOiBmdW5jdGlvbiAoY29uZmlnLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQ0FTVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudm90ZXNjYXN0IDw9IDAgfHwgdGhpcy52b3Rlc2ludmFsaWQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0IHdvdWxkIGJlIE9LIHRvIGNoZWNrIG9ubHkgdGhpcy52b3Rlc2Nhc3QgPCAwIGJlY2F1c2UgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBjaGVja2VkIGFnYWluIGxhdGVyIGJ1dCB0aGlzIGlzIGEgbGl0dGxlIGJpdCBmYXN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gdGhpcy52b3Rlc2Nhc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVkFMSUQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZvdGVzdmFsaWQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJhc2UgPT09ICd1bmRlZmluZWQnICYmIHR5cGUgIT09ICd2b3Rlc2Nhc3QnICYmIHR5cGUgIT09ICd2b3Rlc2ludmFsaWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSB0aGlzLnZvdGVzdmFsaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lFU19OT19BQlNUQUlOJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lFU19OTyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucG9sbG1ldGhvZCA9PT0gJ3luYScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSAndW5kZWZpbmVkJyAmJiB0eXBlICE9PSAndm90ZXNjYXN0JyAmJiB0eXBlICE9PSAndm90ZXNpbnZhbGlkJyAmJiB0eXBlICE9PSAndm90ZXN2YWxpZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaCh0aGlzLm9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsVm90ZXMgPSBvcHRpb24udm90ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZyA9PT0gJ1lFU19OTycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVm90ZXMgPSBfLmZpbHRlcihhbGxWb3RlcywgZnVuY3Rpb24gKHZvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgYWJzdGFpbiB2b3RlcyBpbiBjYXNlIG9mIFlFU19OTyBwZXJjZW50IGJhc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgZXh0cmFjdCBhYnN0YWluIHZvdGUgaWYgaXQgaXMgc2V0IHRvIG1ham9yaXR5IHNvIHRoZSBwcmVkaWNhdGUgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhaWxzIGFuZCB0aGVyZWZvciB3ZSBnZXQgYW4gdW5kZWZpbmVkIGJhc2UuIFJlYXNvbjogSXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gc2V0IGFic3RhaW4gdG8gbWFqb3JpdHkgYW5kIG5ldmVydGhlbGVzcyBjYWxjdWxhdGUgcGVyY2VudHMgb2YgeWVzIGFuZCBuby5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2b3RlLnZhbHVlICE9PSAnQWJzdGFpbicgfHwgdm90ZS53ZWlnaHQgPT09IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZWRpY2F0ZSA9IGZ1bmN0aW9uICh2b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2b3RlLndlaWdodCA8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5maW5kSW5kZXgoYWxsVm90ZXMsIHByZWRpY2F0ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2Vbb3B0aW9uLmlkXSA9IF8ucmVkdWNlKGFsbFZvdGVzLCBmdW5jdGlvbiAoc3VtLCB2b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtICsgdm90ZS53ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5wb2xsbWV0aG9kID09PSAndm90ZXMnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmVkaWNhdGUgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uLnZvdGVzWzBdLndlaWdodCA8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLmZpbmRJbmRleCh0aGlzLm9wdGlvbnMsIHByZWRpY2F0ZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSAndW5kZWZpbmVkJyAmJiB0eXBlICE9PSAndm90ZXNhYnN0YWluJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgIT09ICd2b3Rlc25vJyAmJiB0eXBlICE9PSAndm90ZXNjYXN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgIT09ICd2b3Rlc2ludmFsaWQnICYmIHR5cGUgIT09ICd2b3Rlc3ZhbGlkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSBfLnJlZHVjZSh0aGlzLm9wdGlvbnMsIGZ1bmN0aW9uIChzdW0sIG9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtICsgb3B0aW9uLnZvdGVzWzBdLndlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyBvYmplY3Qgd2l0aCB2YWx1ZSBhbmQgcGVyY2VudCBmb3IgdGhpcyBwb2xsIChmb3Igdm90ZXMgdmFsaWQvaW52YWxpZC9jYXN0IG9ubHkpLlxuICAgICAgICAgICAgICAgIGdldFZvdGU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNfdm90ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgaWYgdGhpcyBwb2xsIGhhcyBubyB2b3Rlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudFN0ciA9ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudE51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBDb25maWcuZ2V0KCdhc3NpZ25tZW50c19wb2xsXzEwMF9wZXJjZW50X2Jhc2UnKS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ZvdGVzYWJzdGFpbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm90ZSA9IHRoaXMudm90ZXNhYnN0YWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndm90ZXNubyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm90ZSA9IHRoaXMudm90ZXNubztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ZvdGVzaW52YWxpZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm90ZSA9IHRoaXMudm90ZXNpbnZhbGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndm90ZXN2YWxpZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm90ZSA9IHRoaXMudm90ZXN2YWxpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ZvdGVzY2FzdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm90ZSA9IHRoaXMudm90ZXNjYXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgc3BlY2lhbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdtYWpvcml0eScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAtMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygndW5kb2N1bWVudGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b3RlID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2b3RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gMDsgLy8gdmFsdWUgd2FzIG5vdCBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBlcmNlbnQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2UgPSB0aGlzLmdldFBlcmNlbnRCYXNlKGNvbmZpZywgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50TnVtYmVyID0gTWF0aC5yb3VuZCh2b3RlICogMTAwIC8gKGJhc2UpICogMTApIC8gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50U3RyID0gJygnICsgcGVyY2VudE51bWJlciArICcgJSknO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwZXJjZW50U3RyJzogcGVyY2VudFN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgICdwZXJjZW50TnVtYmVyJzogcGVyY2VudE51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXNwbGF5JzogdmFsdWUgKyAnICcgKyBwZXJjZW50U3RyXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbGF0aW9uczoge1xuICAgICAgICAgICAgICAgIGJlbG9uZ3NUbzoge1xuICAgICAgICAgICAgICAgICAgICAnYXNzaWdubWVudHMvYXNzaWdubWVudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRmllbGQ6ICdhc3NpZ25tZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsS2V5OiAnYXNzaWdubWVudF9pZCcsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhc01hbnk6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2Fzc2lnbm1lbnRzL3BvbGxvcHRpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAnb3B0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JlaWduS2V5OiAncG9sbF9pZCcsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4ucHJvdmlkZXIoJ0Fzc2lnbm1lbnRQb2xsRGVjaW1hbFBsYWNlcycsIFtcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGdldCA9IFsnJHEnLCBmdW5jdGlvbiAoJHEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2V0UGxhY2VzOiBmdW5jdGlvbiAocG9sbCwgZmluZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfV07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ0Fzc2lnbm1lbnRSZWxhdGVkVXNlcicsIFtcbiAgICAnRFMnLFxuICAgIGZ1bmN0aW9uIChEUykge1xuICAgICAgICByZXR1cm4gRFMuZGVmaW5lUmVzb3VyY2Uoe1xuICAgICAgICAgICAgbmFtZTogJ2Fzc2lnbm1lbnRzL3JlbGF0ZWR1c2VyJyxcbiAgICAgICAgICAgIHJlbGF0aW9uczoge1xuICAgICAgICAgICAgICAgIGJlbG9uZ3NUbzoge1xuICAgICAgICAgICAgICAgICAgICAndXNlcnMvdXNlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRmllbGQ6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsS2V5OiAndXNlcl9pZCcsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdBc3NpZ25tZW50JywgW1xuICAgICckaHR0cCcsXG4gICAgJ0RTJyxcbiAgICAnUHJvamVjdG9yJyxcbiAgICAnUHJvamVjdEhlbHBlcicsXG4gICAgJ0Fzc2lnbm1lbnRSZWxhdGVkVXNlcicsXG4gICAgJ0Fzc2lnbm1lbnRQb2xsJyxcbiAgICAnanNEYXRhTW9kZWwnLFxuICAgICdnZXR0ZXh0JyxcbiAgICBmdW5jdGlvbiAoJGh0dHAsIERTLCBQcm9qZWN0b3IsIFByb2plY3RIZWxwZXIsIEFzc2lnbm1lbnRSZWxhdGVkVXNlciwgQXNzaWdubWVudFBvbGwsXG4gICAgICAgIGpzRGF0YU1vZGVsLCBnZXR0ZXh0KSB7XG4gICAgICAgIHZhciBuYW1lID0gJ2Fzc2lnbm1lbnRzL2Fzc2lnbm1lbnQnO1xuICAgICAgICByZXR1cm4gRFMuZGVmaW5lUmVzb3VyY2Uoe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHVzZUNsYXNzOiBqc0RhdGFNb2RlbCxcbiAgICAgICAgICAgIHZlcmJvc2VOYW1lOiBnZXR0ZXh0KCdFbGVjdGlvbicpLFxuICAgICAgICAgICAgdmVyYm9zZU5hbWVQbHVyYWw6IGdldHRleHQoJ0VsZWN0aW9ucycpLFxuICAgICAgICAgICAgbWV0aG9kczoge1xuICAgICAgICAgICAgICAgIGdldFJlc291cmNlTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFRpdGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0QWdlbmRhVGl0bGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIGxpbmsgbmFtZSB3aGljaCBpcyBzaG93biBpbiBzZWFyY2ggcmVzdWx0XG4gICAgICAgICAgICAgICAgZ2V0U2VhcmNoUmVzdWx0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBZ2VuZGFUaXRsZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRydWUgaWYgYSBzcGVjaWZpYyByZWxhdGlvbiBtYXRjaGVzIGZvciBnaXZlbiBzZWFyY2hxdWVyeVxuICAgICAgICAgICAgICAgIC8vIChoZXJlOiByZWxhdGVkX3VzZXJzL2NhbmRpZGF0ZXMpXG4gICAgICAgICAgICAgICAgaGFzU2VhcmNoUmVzdWx0OiBmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXNzaWdubWVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBmb3IgcmVsYXRlZCB1c2VycyAoY2hlY2sgaWYgYW55IHVzZXIuaWQgZnJvbSBhbHJlYWR5IGZvdW5kIHVzZXJzIG1hdGNoZXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnNvbWUocmVzdWx0cywgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmdldFJlc291cmNlTmFtZSgpID09PSBcInVzZXJzL3VzZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLnNvbWUoYXNzaWdubWVudC5hc3NpZ25tZW50X3JlbGF0ZWRfdXNlcnMsIHsndXNlcl9pZCc6IHJlc3VsdC5pZH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBwcm9qZWN0IGZ1bmN0aW9uIG9mIGpzRGF0YU1vZGVsIGZhY3RvcnlcbiAgICAgICAgICAgICAgICBwcm9qZWN0OiBmdW5jdGlvbiAocHJvamVjdG9ySWQsIHBvbGxJZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNQcm9qZWN0ZWRJZHMgPSB0aGlzLmlzUHJvamVjdGVkKHBvbGxJZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2lkczogaXNQcm9qZWN0ZWRJZHMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmluZGV4T2YoaXNQcm9qZWN0ZWRJZHMsIHByb2plY3RvcklkKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERhdGEucHJ1bmUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHByb2plY3RvcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Fzc2lnbm1lbnRzL2Fzc2lnbm1lbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9sbDogcG9sbElkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb2plY3RIZWxwZXIucHJvamVjdChyZXF1ZXN0RGF0YSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBpc1Byb2plY3RlZCBmdW5jdGlvbiBvZiBqc0RhdGFNb2RlbCBmYWN0b3J5XG4gICAgICAgICAgICAgICAgaXNQcm9qZWN0ZWQ6IGZ1bmN0aW9uIChwb2xsX2lkLCBhbnlQb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybnMgdGhlIGlkcyBvZiBhbGwgcHJvamVjdG9ycyB3aXRoIGFuIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgbmFtZSAnYXNzaWdubWVudHMvYXNzaWdubWVudCcuIEVsc2UgcmV0dXJucyBhbiBlbXB0eSBsaXN0LlxuICAgICAgICAgICAgICAgICAgICAvLyBQcm92aWRlIGEgcG9sbF9pZCB0byBxdWVyeSBhIHNwZWNpZmljIHBvbGwgb3Igc2V0IGFueVBvbGwgdG8gdHJ1ZSwgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gcXVlcnkgd2hldGhlciBhbnkgcG9sbCAoYnV0IG5vdCB0aGUgYXNzaWdubWVudCBpdHNlbGYpIGlzIHByb2plY3RlZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZGljYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9sbF9pZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ25tZW50IGRldGFpbCBzbGlkZSB3aXRob3V0IHBvbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVsZW1lbnQubmFtZSA9PSAnYXNzaWdubWVudHMvYXNzaWdubWVudCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGVsZW1lbnQuaWQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaWQgPT0gc2VsZi5pZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZWxlbWVudC5wb2xsID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYW55UG9sbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbm1lbnQgZGV0YWlsIHNsaWRlIHdpdGggYW55IHBvbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVsZW1lbnQubmFtZSA9PSAnYXNzaWdubWVudHMvYXNzaWdubWVudCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGVsZW1lbnQuaWQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaWQgPT0gc2VsZi5pZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZWxlbWVudC5wb2xsICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWdubWVudCBkZXRhaWwgc2xpZGUgd2l0aCBzcGVjaWZpYyBwb2xsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlbGVtZW50Lm5hbWUgPT0gJ2Fzc2lnbm1lbnRzL2Fzc2lnbm1lbnQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBlbGVtZW50LmlkICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmlkID09IHNlbGYuaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGVsZW1lbnQucG9sbCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wb2xsID09IHBvbGxfaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1Byb2plY3RlZElkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBQcm9qZWN0b3IuZ2V0QWxsKCkuZm9yRWFjaChmdW5jdGlvbiAocHJvamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF8uZmluZEtleShwcm9qZWN0b3IuZWxlbWVudHMsIHByZWRpY2F0ZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQcm9qZWN0ZWRJZHMucHVzaChwcm9qZWN0b3IuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJvamVjdGVkSWRzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNSZWxhdGVkUHJvamVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0T2ZTcGVha2VycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hZ2VuZGFfaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdE9mU3BlYWtlcnMgPSB0aGlzLmFnZW5kYV9pdGVtLmlzTGlzdE9mU3BlYWtlcnNQcm9qZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdE9mU3BlYWtlcnMuY29uY2F0KHRoaXMuaXNQcm9qZWN0ZWQobnVsbCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVsYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgYmVsb25nc1RvOiB7XG4gICAgICAgICAgICAgICAgICAgICdhZ2VuZGEvaXRlbSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsS2V5OiAnYWdlbmRhX2l0ZW1faWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGaWVsZDogJ2FnZW5kYV9pdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGFzTWFueToge1xuICAgICAgICAgICAgICAgICAgICAnY29yZS90YWcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAndGFncycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEtleXM6ICd0YWdzX2lkJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2Fzc2lnbm1lbnRzL3JlbGF0ZWR1c2VyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGaWVsZDogJ2Fzc2lnbm1lbnRfcmVsYXRlZF91c2VycycsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JlaWduS2V5OiAnYXNzaWdubWVudF9pZCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdhc3NpZ25tZW50cy9wb2xsJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGaWVsZDogJ3BvbGxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmVpZ25LZXk6ICdhc3NpZ25tZW50X2lkJyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiZWZvcmVJbmplY3Q6IGZ1bmN0aW9uIChyZXNvdXJjZSwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBBc3NpZ25tZW50UmVsYXRlZFVzZXIuZWplY3RBbGwoe3doZXJlOiB7YXNzaWdubWVudF9pZDogeyc9PSc6IGluc3RhbmNlLmlkfX19KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLnJ1bihbJ0Fzc2lnbm1lbnQnLCBmdW5jdGlvbihBc3NpZ25tZW50KSB7fV0pO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5hc3NpZ25tZW50cy5wZGYnLCBbJ09wZW5TbGlkZXNBcHAuY29yZS5wZGYnXSlcblxuLmZhY3RvcnkoJ0Fzc2lnbm1lbnRDb250ZW50UHJvdmlkZXInLCBbXG4gICAgJyRmaWx0ZXInLFxuICAgICdIVE1MVmFsaWRpemVyJyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdQREZMYXlvdXQnLFxuICAgICdBc3NpZ25tZW50UG9sbERlY2ltYWxQbGFjZXMnLFxuICAgIGZ1bmN0aW9uKCRmaWx0ZXIsIEhUTUxWYWxpZGl6ZXIsIGdldHRleHRDYXRhbG9nLCBQREZMYXlvdXQsIEFzc2lnbm1lbnRQb2xsRGVjaW1hbFBsYWNlcykge1xuXG4gICAgICAgIHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uKGFzc2lnbm1lbnQpIHtcblxuICAgICAgICAgICAgLy8gcGFnZSB0aXRsZVxuICAgICAgICAgICAgdmFyIHRpdGxlID0gUERGTGF5b3V0LmNyZWF0ZVRpdGxlKGFzc2lnbm1lbnQudGl0bGUpO1xuICAgICAgICAgICAgdmFyIGlzRWxlY3RlZFNlbWFwaG9yZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBvcGVuIHBvc3RzXG4gICAgICAgICAgICB2YXIgY3JlYXRlUHJlYW1ibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJlYW1ibGVUZXh0ID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKFwiTnVtYmVyIG9mIHBlcnNvbnMgdG8gYmUgZWxlY3RlZFwiKSArIFwiOiBcIjtcbiAgICAgICAgICAgICAgICB2YXIgbWVtYmVyTnVtYmVyID0gXCJcIithc3NpZ25tZW50Lm9wZW5fcG9zdHM7XG4gICAgICAgICAgICAgICAgdmFyIHByZWFtYmxlID0ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcHJlYW1ibGVUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICd0ZXh0SXRlbSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbWVtYmVyTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndGV4dEl0ZW0nXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVhbWJsZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICB2YXIgY3JlYXRlRGVzY3JpcHRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXNzaWdubWVudC5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IEhUTUxWYWxpZGl6ZXIudmFsaWRpemUoYXNzaWdubWVudC5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdGlvblRleHQgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoXCJEZXNjcmlwdGlvblwiKSArIFwiOlwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRpb24gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZGVzY3JpcHRpb25UZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICd0ZXh0SXRlbSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJChodG1sKS50ZXh0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICd0ZXh0SXRlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMTAsIDAsIDAsIDBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBzaG93IGNhbmRpZGF0ZSBsaXN0IChpZiBhc3NpZ25tZW50IHBoYXNlIGlzIG5vdCAnZmluaXNoZWQnKVxuICAgICAgICAgICAgdmFyIGNyZWF0ZUNhbmRpZGF0ZUxpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXNzaWdubWVudC5waGFzZSAhPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVzID0gJGZpbHRlcignb3JkZXJCeScpKGFzc2lnbm1lbnQuYXNzaWdubWVudF9yZWxhdGVkX3VzZXJzLCAnd2VpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVzVGV4dCA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZyhcIkNhbmRpZGF0ZXNcIikgKyBcIjogXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1c2VyTGlzdCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChjYW5kaWRhdGVzLCBmdW5jdGlvbihhc3NpZ25tZW50c1JlbGF0ZWRVc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogYXNzaWdubWVudHNSZWxhdGVkVXNlci51c2VyLmdldF9mdWxsX25hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMCwgMCwgMCwgMTBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWRpZGF0ZUxpc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjYW5kaWRhdGVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9sZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IFwiMjUlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndGV4dEl0ZW0nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVsOiB1c2VyTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICd0ZXh0SXRlbSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWRpZGF0ZUxpc3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlcyB0aGUgY2FzZSBpZiBhIGNhbmRpZGF0ZSBpcyBlbGVjdGVkIG9yIG5vdFxuICAgICAgICAgICAgdmFyIGVsZWN0ZWRDYW5kaWRhdGVMaW5lID0gZnVuY3Rpb24oY2FuZGlkYXRlTmFtZSwgcG9sbE9wdGlvbiwgcG9sbFRhYmxlQm9keSkge1xuICAgICAgICAgICAgICAgIGlmIChwb2xsT3B0aW9uLmlzX2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNFbGVjdGVkU2VtYXBob3JlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNhbmRpZGF0ZU5hbWUgKyBcIipcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogUERGTGF5b3V0LmZsaXBUYWJsZVJvd1N0eWxlKHBvbGxUYWJsZUJvZHkubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjYW5kaWRhdGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFBERkxheW91dC5mbGlwVGFibGVSb3dTdHlsZShwb2xsVGFibGVCb2R5Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvL2NyZWF0ZXMgdGhlIHZvdGluZyBzdHJpbmcgZm9yIHRoZSByZXN1bHQgdGFibGUgYW5kIGRpZmZlcmVudGlhdGVzIGJldHdlZW4gc3BlY2lhbCB2YWx1ZXNcbiAgICAgICAgICAgIHZhciBwYXJzZVZvdGVWYWx1ZSA9IGZ1bmN0aW9uKHZvdGVPYmplY3QsIHByaW50TGFiZWwsIHByZWNpc2lvbikge1xuICAgICAgICAgICAgICAgIHZhciB2b3RlVmFsID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKHZvdGVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByaW50TGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvdGVWYWwgKz0gdm90ZU9iamVjdC5sYWJlbCArICc6ICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdm90ZVZhbCArPSAkZmlsdGVyKCdudW1iZXInKSh2b3RlT2JqZWN0LnZhbHVlLCBwcmVjaXNpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2b3RlT2JqZWN0LnBlcmNlbnRTdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvdGVWYWwgKz0gJyAnICsgdm90ZU9iamVjdC5wZXJjZW50U3RyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZvdGVWYWwgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvdGVWYWw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBjcmVhdGVzIHRoZSBlbGVjdGlvbiByZXN1bHQgdGFibGVcbiAgICAgICAgICAgIHZhciBjcmVhdGVQb2xsUmVzdWx0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0Qm9keSA9IFtdO1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChhc3NpZ25tZW50LnBvbGxzLCBmdW5jdGlvbihwb2xsLCBwb2xsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbGwucHVibGlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9sbFRhYmxlQm9keSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZWNpc2lvbiA9IEFzc2lnbm1lbnRQb2xsRGVjaW1hbFBsYWNlcy5nZXRQbGFjZXMocG9sbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEJvZHkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdCYWxsb3QnKSArICcgJyArIChwb2xsSW5kZXgrMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9sZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3RleHRJdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFswLCAxNSwgMCwgMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2xsVGFibGVCb2R5LnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdDYW5kaWRhdGVzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndGFibGVIZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1ZvdGVzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndGFibGVIZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2gocG9sbC5vcHRpb25zLCBmdW5jdGlvbihwb2xsT3B0aW9uLCBvcHRpb25JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVOYW1lID0gcG9sbE9wdGlvbi5jYW5kaWRhdGUuZ2V0X2Z1bGxfbmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2b3RlcyA9IHBvbGxPcHRpb24uZ2V0Vm90ZXMoKTsgLy8gMCA9IHllcywgMSA9IG5vLCAyID0gYWJzdGFpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZUxpbmUgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlTGluZS5wdXNoKGVsZWN0ZWRDYW5kaWRhdGVMaW5lKGNhbmRpZGF0ZU5hbWUsIHBvbGxPcHRpb24sIHBvbGxUYWJsZUJvZHkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9sbC5wb2xsbWV0aG9kID09ICd2b3RlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVMaW5lLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcGFyc2VWb3RlVmFsdWUodm90ZXNbMF0sIGZhbHNlLCBwcmVjaXNpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBQREZMYXlvdXQuZmxpcFRhYmxlUm93U3R5bGUocG9sbFRhYmxlQm9keS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdEJsb2NrID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaCh2b3RlcywgZnVuY3Rpb24odm90ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0QmxvY2sucHVzaChwYXJzZVZvdGVWYWx1ZSh2b3RlLCB0cnVlLCBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlTGluZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiByZXN1bHRCbG9jayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogUERGTGF5b3V0LmZsaXBUYWJsZVJvd1N0eWxlKHBvbGxUYWJsZUJvZHkubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2xsVGFibGVCb2R5LnB1c2godGFibGVMaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHVzaENvbmNsdWRlUm93ID0gZnVuY3Rpb24gKHRpdGxlLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9sbFtmaWVsZE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbGxUYWJsZUJvZHkucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKHRpdGxlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3RhYmxlQ29uY2x1ZGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcnNlVm90ZVZhbHVlKHBvbGwuZ2V0Vm90ZShmaWVsZE5hbWUpLCBmYWxzZSwgcHJlY2lzaW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3RhYmxlQ29uY2x1ZGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQ29uY2x1ZGVSb3coJ0Fic3RhaW4nLCAndm90ZXNhYnN0YWluJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQ29uY2x1ZGVSb3coJ05vJywgJ3ZvdGVzbm8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hDb25jbHVkZVJvdygnVmFsaWQgYmFsbG90cycsICd2b3Rlc3ZhbGlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQ29uY2x1ZGVSb3coJ0ludmFsaWQgYmFsbG90cycsICd2b3Rlc2ludmFsaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hDb25jbHVkZVJvdygnQ2FzdGVkIGJhbGxvdHMnLCAndm90ZXNjYXN0Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRUYWJsZUpzb25TdGluZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aHM6IFsnNjQlJywnMzMlJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlclJvd3M6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHBvbGxUYWJsZUJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6ICdoZWFkZXJMaW5lT25seScsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRCb2R5LnB1c2gocmVzdWx0VGFibGVKc29uU3RpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGxlZ2VuZCB0byB0aGUgcmVzdWx0IGJvZHlcbiAgICAgICAgICAgICAgICBpZiAoYXNzaWdubWVudC5wb2xscy5sZW5ndGggPiAwICYmIGlzRWxlY3RlZFNlbWFwaG9yZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRCb2R5LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJyogPSAnICsgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdpcyBlbGVjdGVkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFswLCA1LCAwLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdEJvZHk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZ2V0Q29udGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVQcmVhbWJsZSgpLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVEZXNjcmlwdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVDYW5kaWRhdGVMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVBvbGxSZXN1bHRUYWJsZSgpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2V0Q29udGVudDogZ2V0Q29udGVudCxcbiAgICAgICAgICAgICAgICB0aXRsZTogYXNzaWdubWVudC50aXRsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlSW5zdGFuY2U6IGNyZWF0ZUluc3RhbmNlXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ0JhbGxvdENvbnRlbnRQcm92aWRlcicsIFtcbiAgICAnJHEnLFxuICAgICckZmlsdGVyJyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdQREZMYXlvdXQnLFxuICAgICdDb25maWcnLFxuICAgICdVc2VyJyxcbiAgICAnSW1hZ2VDb252ZXJ0ZXInLFxuICAgIGZ1bmN0aW9uKCRxLCAkZmlsdGVyLCBnZXR0ZXh0Q2F0YWxvZywgUERGTGF5b3V0LCBDb25maWcsIFVzZXIsIEltYWdlQ29udmVydGVyKSB7XG4gICAgICAgIHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uKGFzc2lnbm1lbnQsIHBvbGwsIHBvbGxOdW1iZXIpIHtcblxuICAgICAgICAgICAgdmFyIGxvZ29CYWxsb3RQYXBlclVybCA9IENvbmZpZy5nZXQoJ2xvZ29fcGRmX2JhbGxvdF9wYXBlcicpLnZhbHVlLnBhdGg7XG4gICAgICAgICAgICB2YXIgaW1hZ2VNYXAgPSB7fTtcblxuICAgICAgICAgICAgLy8gUERGIGhlYWRlclxuICAgICAgICAgICAgdmFyIGhlYWRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyBsb2dvXG4gICAgICAgICAgICAgICAgaWYgKGxvZ29CYWxsb3RQYXBlclVybCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGxvZ29CYWxsb3RQYXBlclVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpdDogWzkwLDIwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMjAlJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBDb25maWcuZ2V0KCdnZW5lcmFsX2V2ZW50X25hbWUnKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogOCxcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50OiAncmlnaHQnLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjNTU1JyxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMzAsIDEwLCAxMCwgLTEwXSwgLy8gW2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbV1cbiAgICAgICAgICAgICAgICAgICAgY29sdW1uczogY29sdW1ucyxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uR2FwOiAxMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBwYWdlIHRpdGxlXG4gICAgICAgICAgICB2YXIgY3JlYXRlVGl0bGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBhc3NpZ25tZW50LnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3RpdGxlJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gcG9sbCBkZXNjcmlwdGlvblxuICAgICAgICAgICAgdmFyIGNyZWF0ZVBvbGxIaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gcG9sbC5kZXNjcmlwdGlvbiA/ICc6ICcgKyBwb2xsLmRlc2NyaXB0aW9uIDogJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKFwiQmFsbG90XCIpICsgXCIgXCIgKyBwb2xsTnVtYmVyICsgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnZGVzY3JpcHRpb24nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBlbGVjdGlvbiBlbnRyaWVzXG4gICAgICAgICAgICB2YXIgY3JlYXRlWU5CYWxsb3RFbnRyeSA9IGZ1bmN0aW9uKGRlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIFlOQ29sdW1uID0gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBERkxheW91dC5jcmVhdGVCYWxsb3RFbnRyeShnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoXCJZZXNcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUERGTGF5b3V0LmNyZWF0ZUJhbGxvdEVudHJ5KGdldHRleHRDYXRhbG9nLmdldFN0cmluZyhcIk5vXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBpZiAocG9sbC5wb2xsbWV0aG9kID09ICd5bmEnKSB7XG4gICAgICAgICAgICAgICAgICAgIFlOQ29sdW1uLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQREZMYXlvdXQuY3JlYXRlQmFsbG90RW50cnkoZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKFwiQWJzdGFpblwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZGVjaXNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFs0MCwgMTAsIDAsIDBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiBZTkNvbHVtblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjcmVhdGVTZWxlY3Rpb25GaWVsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVzID0gJGZpbHRlcignb3JkZXJCeScpKHBvbGwub3B0aW9ucywgJ3dlaWdodCcpO1xuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVCYWxsb3RMaXN0ID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAocG9sbC5wb2xsbWV0aG9kID09ICd2b3RlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNhbmRpZGF0ZXMsIGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IG9wdGlvbi5jYW5kaWRhdGUuZ2V0X2Z1bGxfbmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlQmFsbG90TGlzdC5wdXNoKFBERkxheW91dC5jcmVhdGVCYWxsb3RFbnRyeShjYW5kaWRhdGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCAnbm8nIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICB2YXIgbm8gPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ05vJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYWxsb3RFbnRyeSA9IFBERkxheW91dC5jcmVhdGVCYWxsb3RFbnRyeShubyk7XG4gICAgICAgICAgICAgICAgICAgIGJhbGxvdEVudHJ5Lm1hcmdpblsxXSA9IDI1OyAvLyB0b3AgbWFyZ2luXG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZUJhbGxvdExpc3QucHVzaChiYWxsb3RFbnRyeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNhbmRpZGF0ZXMsIGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb24uY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gb3B0aW9uLmNhbmRpZGF0ZS5nZXRfZnVsbF9uYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVCYWxsb3RMaXN0LnB1c2goY3JlYXRlWU5CYWxsb3RFbnRyeShjYW5kaWRhdGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVCYWxsb3RMaXN0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNyZWF0ZVNlY3Rpb24gPSBmdW5jdGlvbihtYXJnaW5Ub3ApIHtcblxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBnaXZlIGEgY29sdW1uIGEgZml4ZWQgaGVpZ2h0LCB3ZSBkcmF3IGFuIFwiZW1wdHlcIiBjb2x1bW5cbiAgICAgICAgICAgICAgICAvLyB3aXRoIGEgb25lIHB4IHdpZHRoIGFuZCBhIGZpeGVkIHRvcC1tYXJnaW5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMCwgbWFyZ2luVG9wXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcqJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlVGl0bGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUG9sbEhpbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2VsZWN0aW9uRmllbGQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY3JlYXRlVGFibGVCb2R5ID0gZnVuY3Rpb24obnVtYmVyT2ZSb3dzLCBzaGVldGVuZCwgbWF4YmFsbG90cykge1xuICAgICAgICAgICAgICAgIHZhciBiYWxsb3RzdG9wcmludCA9IG51bWJlck9mUm93cyAqIDI7XG4gICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobWF4YmFsbG90cykgJiYgbWF4YmFsbG90cyA+IDAgJiYgbWF4YmFsbG90cyA8IGJhbGxvdHN0b3ByaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGJhbGxvdHN0b3ByaW50ID0gbWF4YmFsbG90cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlQm9keSA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChiYWxsb3RzdG9wcmludCA+IDEpe1xuICAgICAgICAgICAgICAgICAgICB0YWJsZUJvZHkucHVzaChbY3JlYXRlU2VjdGlvbihzaGVldGVuZCksIGNyZWF0ZVNlY3Rpb24oc2hlZXRlbmQpXSk7XG4gICAgICAgICAgICAgICAgICAgIGJhbGxvdHN0b3ByaW50IC09IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiYWxsb3RzdG9wcmludCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQm9keS5wdXNoKFtjcmVhdGVTZWN0aW9uKHNoZWV0ZW5kKSwgJyddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlQm9keTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjcmVhdGVDb250ZW50VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCwgZGV0ZXJtaW5lIGhvdyBtYW55IGJhbGxvdHMgd2UgbmVlZFxuICAgICAgICAgICAgICAgIHZhciBhbW91bnQ7XG4gICAgICAgICAgICAgICAgdmFyIGFtb3VudF9tZXRob2QgPSBDb25maWcuZ2V0KCdhc3NpZ25tZW50c19wZGZfYmFsbG90X3BhcGVyc19zZWxlY3Rpb24nKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGFtb3VudF9tZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTlVNQkVSX09GX0FMTF9QQVJUSUNJUEFOVFMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50ID0gVXNlci5nZXRBbGwoKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTlVNQkVSX09GX0RFTEVHQVRFUyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE86IGFzc3VtcHRpb24gdGhhdCBERUxFR0FURVMgaXMgYWx3YXlzIGdyb3VwIGlkIDIuIFRoaXMgbWF5IG5vdCBiZSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBfaWQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50ID0gVXNlci5maWx0ZXIoe3doZXJlOiB7J2dyb3Vwc19pZCc6IHtjb250YWluczpncm91cF9pZH0gfX0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdDVVNUT01fTlVNQkVSJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudCA9IENvbmZpZy5nZXQoJ2Fzc2lnbm1lbnRzX3BkZl9iYWxsb3RfcGFwZXJzX251bWJlcicpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgbm90IGhhcHBlbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0YWJsZWRDb250ZW50ID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHJvd3NwZXJwYWdlO1xuICAgICAgICAgICAgICAgIHZhciBzaGVldGVuZDtcbiAgICAgICAgICAgICAgICBpZiAocG9sbC5wb2xsbWV0aG9kID09ICd2b3RlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbGwub3B0aW9ucy5sZW5ndGggPD0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hlZXRlbmQgPSAxMDU7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzcGVycGFnZSA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9sbC5vcHRpb25zLmxlbmd0aCA8PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGVldGVuZCA9IDE0MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3NwZXJwYWdlID0gMztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb2xsLm9wdGlvbnMubGVuZ3RoIDw9IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGVldGVuZCA9IDIxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3NwZXJwYWdlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy93b3JrcyB1bnRpbGwgfjMwIHBlb3BsZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2hlZXRlbmQgPSA0MTg7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzcGVycGFnZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9sbC5vcHRpb25zLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGVldGVuZCA9IDEwNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3NwZXJwYWdlID0gNDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb2xsLm9wdGlvbnMubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoZWV0ZW5kID0gMTQwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93c3BlcnBhZ2UgPSAzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvbGwub3B0aW9ucy5sZW5ndGggPD0gNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hlZXRlbmQgPSAyMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzcGVycGFnZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGVldGVuZCA9IDQxODtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3NwZXJwYWdlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcGFnZV9lbnRyaWVzID0gcm93c3BlcnBhZ2UgKiAyO1xuICAgICAgICAgICAgICAgIHZhciBmdWxscGFnZXMgPSBNYXRoLmZsb29yKGFtb3VudCAvIHBhZ2VfZW50cmllcyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgZnVsbHBhZ2VzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGVkQ29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyUm93czogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aHM6IFsnNTAlJywgJzUwJSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGNyZWF0ZVRhYmxlQm9keShyb3dzcGVycGFnZSwgc2hlZXRlbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VCcmVhazogJ2FmdGVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0OiBQREZMYXlvdXQuZ2V0QmFsbG90TGF5b3V0TGluZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzcGVycGFnZTogcm93c3BlcnBhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmaWxsIHRoZSBsYXN0IHBhZ2Ugb25seSBwYXJ0aWFsbHlcbiAgICAgICAgICAgICAgICB2YXIgbGFzdHBhZ2VfYmFsbG90cyA9IGFtb3VudCAtIChmdWxscGFnZXMgKiBwYWdlX2VudHJpZXMpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0cGFnZV9iYWxsb3RzIDwgcGFnZV9lbnRyaWVzICYmIGxhc3RwYWdlX2JhbGxvdHMgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxwYWdlID0gY3JlYXRlVGFibGVCb2R5KHJvd3NwZXJwYWdlLCBzaGVldGVuZCwgbGFzdHBhZ2VfYmFsbG90cyk7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlZENvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlclJvd3M6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhzOiBbJzUwJScsICc1MCUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBwYXJ0aWFscGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dDogUERGTGF5b3V0LmdldEJhbGxvdExheW91dExpbmVzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzcGVycGFnZTogcm93c3BlcnBhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZWRDb250ZW50O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldENvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29udGVudFRhYmxlKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZ2V0SW1hZ2VNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltYWdlTWFwO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuICRxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VTb3VyY2VzID0gW1xuICAgICAgICAgICAgICAgICAgICBsb2dvQmFsbG90UGFwZXJVcmwsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBJbWFnZUNvbnZlcnRlci50b0Jhc2U2NChpbWFnZVNvdXJjZXMpLnRoZW4oZnVuY3Rpb24gKF9pbWFnZU1hcCkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZU1hcCA9IF9pbWFnZU1hcDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb250ZW50OiBnZXRDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SW1hZ2VNYXA6IGdldEltYWdlTWFwLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZUluc3RhbmNlOiBjcmVhdGVJbnN0YW5jZVxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdBc3NpZ25tZW50Q2F0YWxvZ0NvbnRlbnRQcm92aWRlcicsIFtcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdQREZMYXlvdXQnLFxuICAgICdDb25maWcnLFxuICAgIGZ1bmN0aW9uKGdldHRleHRDYXRhbG9nLCBQREZMYXlvdXQsIENvbmZpZykge1xuXG4gICAgICAgIHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uKGFsbEFzc2lnbm1lbnRzKSB7XG5cbiAgICAgICAgICAgIHZhciB0aXRsZSA9IFBERkxheW91dC5jcmVhdGVUaXRsZShcbiAgICAgICAgICAgICAgICAgICAgQ29uZmlnLnRyYW5zbGF0ZShDb25maWcuZ2V0KCdhc3NpZ25tZW50c19wZGZfdGl0bGUnKS52YWx1ZSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBjcmVhdGVQcmVhbWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmVhbWJsZVRleHQgPSBDb25maWcuZ2V0KCdhc3NpZ25tZW50c19wZGZfcHJlYW1ibGUnKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJlYW1ibGVUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBwcmVhbWJsZVRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogXCJwcmVhbWJsZVwiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNyZWF0ZVRPQ29udGVudCA9IGZ1bmN0aW9uKGFzc2lnbm1lbnRUaXRsZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGluZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKFwiVGFibGUgb2YgY29udGVudHNcIiksXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImhlYWRpbmcyXCIsXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciB0b2MgPSBbXTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goYXNzaWdubWVudFRpdGxlcywgZnVuY3Rpb24odGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9jLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogXCJ0YWJsZW9mY29udGVudFwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGluZyxcbiAgICAgICAgICAgICAgICAgICAgdG9jLFxuICAgICAgICAgICAgICAgICAgICBQREZMYXlvdXQuYWRkUGFnZUJyZWFrKClcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldENvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhc3NpZ25tZW50Q29udGVudCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhc3NpZ25tZW50VGl0bGVzID0gW107XG5cbiAgICAgICAgICAgICAgICBfLmZvckVhY2goYWxsQXNzaWdubWVudHMsIGZ1bmN0aW9uKGFzc2lnbm1lbnQsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50VGl0bGVzLnB1c2goYXNzaWdubWVudC50aXRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRDb250ZW50LnB1c2goYXNzaWdubWVudC5nZXRDb250ZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IDwgYWxsQXNzaWdubWVudHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWdubWVudENvbnRlbnQucHVzaChQREZMYXlvdXQuYWRkUGFnZUJyZWFrKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2godGl0bGUpO1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChjcmVhdGVQcmVhbWJsZSgpKTtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goY3JlYXRlVE9Db250ZW50KGFzc2lnbm1lbnRUaXRsZXMpKTtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goYXNzaWdubWVudENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBnZXRDb250ZW50OiBnZXRDb250ZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVJbnN0YW5jZTogY3JlYXRlSW5zdGFuY2VcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnQXNzaWdubWVudFBkZkV4cG9ydCcsIFtcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdBc3NpZ25tZW50Q29udGVudFByb3ZpZGVyJyxcbiAgICAnQXNzaWdubWVudENhdGFsb2dDb250ZW50UHJvdmlkZXInLFxuICAgICdQZGZNYWtlRG9jdW1lbnRQcm92aWRlcicsXG4gICAgJ0JhbGxvdENvbnRlbnRQcm92aWRlcicsXG4gICAgJ1BkZk1ha2VCYWxsb3RQYXBlclByb3ZpZGVyJyxcbiAgICAnUGRmQ3JlYXRlJyxcbiAgICAnTWVzc2FnaW5nJyxcbiAgICBmdW5jdGlvbiAoZ2V0dGV4dENhdGFsb2csIEFzc2lnbm1lbnRDb250ZW50UHJvdmlkZXIsIEFzc2lnbm1lbnRDYXRhbG9nQ29udGVudFByb3ZpZGVyLFxuICAgICAgICBQZGZNYWtlRG9jdW1lbnRQcm92aWRlciwgQmFsbG90Q29udGVudFByb3ZpZGVyLCBQZGZNYWtlQmFsbG90UGFwZXJQcm92aWRlciwgUGRmQ3JlYXRlLFxuICAgICAgICBNZXNzYWdpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cG9ydDogZnVuY3Rpb24gKGFzc2lnbm1lbnRzLCBzaW5nbGVBc3NpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gc2luZ2xlQXNzaWdubWVudCA/XG4gICAgICAgICAgICAgICAgICAgIGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnRWxlY3Rpb24nKSArICdfJyArIGFzc2lnbm1lbnRzLnRpdGxlIDpcbiAgICAgICAgICAgICAgICAgICAgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdFbGVjdGlvbnMnKTtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSArPSAnLnBkZic7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWdubWVudHMgPSBbYXNzaWdubWVudHNdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGFzc2lnbm1lbnRzIHRvIGNvbnRlbnQgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgdmFyIGFzc2lnbm1lbnRDb250ZW50UHJvdmlkZXJBcnJheSA9IF8ubWFwKGFzc2lnbm1lbnRzLCBmdW5jdGlvbiAoYXNzaWdubWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXNzaWdubWVudENvbnRlbnRQcm92aWRlci5jcmVhdGVJbnN0YW5jZShhc3NpZ25tZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBkb2N1bWVudFByb3ZpZGVyUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlQXNzaWdubWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudFByb3ZpZGVyUHJvbWlzZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBQZGZNYWtlRG9jdW1lbnRQcm92aWRlci5jcmVhdGVJbnN0YW5jZShhc3NpZ25tZW50Q29udGVudFByb3ZpZGVyQXJyYXlbMF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhc3NpZ25tZW50Q2F0YWxvZ0NvbnRlbnRQcm92aWRlciA9XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NpZ25tZW50Q2F0YWxvZ0NvbnRlbnRQcm92aWRlci5jcmVhdGVJbnN0YW5jZShhc3NpZ25tZW50Q29udGVudFByb3ZpZGVyQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudFByb3ZpZGVyUHJvbWlzZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBQZGZNYWtlRG9jdW1lbnRQcm92aWRlci5jcmVhdGVJbnN0YW5jZShhc3NpZ25tZW50Q2F0YWxvZ0NvbnRlbnRQcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvY3VtZW50UHJvdmlkZXJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRvY3VtZW50UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgUGRmQ3JlYXRlLmRvd25sb2FkKGRvY3VtZW50UHJvdmlkZXIsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnaW5nLmFkZE1lc3NhZ2UoZXJyb3IubXNnLCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVhdGVCYWxsb3RQZGY6IGZ1bmN0aW9uIChhc3NpZ25tZW50LCBwb2xsSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhlUG9sbDtcbiAgICAgICAgICAgICAgICB2YXIgcG9sbE51bWJlcjtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goYXNzaWdubWVudC5wb2xscywgZnVuY3Rpb24ocG9sbCwgcG9sbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2xsLmlkID09IHBvbGxJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhlUG9sbCA9IHBvbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2xsTnVtYmVyID0gcG9sbEluZGV4KzE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0JhbGxvdCcpICsgJ18nICsgcG9sbE51bWJlciArICdfJyArIGFzc2lnbm1lbnQudGl0bGUgKyAnLnBkZic7XG4gICAgICAgICAgICAgICAgQmFsbG90Q29udGVudFByb3ZpZGVyLmNyZWF0ZUluc3RhbmNlKGFzc2lnbm1lbnQsIHRoZVBvbGwsIHBvbGxOdW1iZXIpLnRoZW4oZnVuY3Rpb24gKGJhbGxvdENvbnRlbnRQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnRQcm92aWRlciA9IFBkZk1ha2VCYWxsb3RQYXBlclByb3ZpZGVyLmNyZWF0ZUluc3RhbmNlKGJhbGxvdENvbnRlbnRQcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgIFBkZkNyZWF0ZS5kb3dubG9hZChkb2N1bWVudFByb3ZpZGVyLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2luZy5hZGRNZXNzYWdlKGVycm9yLm1zZywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5hc3NpZ25tZW50cy5wcm9qZWN0b3InLCBbJ09wZW5TbGlkZXNBcHAuYXNzaWdubWVudHMnXSlcblxuLmNvbmZpZyhbXG4gICAgJ3NsaWRlc1Byb3ZpZGVyJyxcbiAgICBmdW5jdGlvbihzbGlkZXNQcm92aWRlcikge1xuICAgICAgICBzbGlkZXNQcm92aWRlci5yZWdpc3RlclNsaWRlKCdhc3NpZ25tZW50cy9hc3NpZ25tZW50Jywge1xuICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL2Fzc2lnbm1lbnRzL3NsaWRlX2Fzc2lnbm1lbnQuaHRtbCcsXG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdTbGlkZUFzc2lnbm1lbnRDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICdBc3NpZ25tZW50JyxcbiAgICAnQXNzaWdubWVudFBvbGwnLFxuICAgICdBc3NpZ25tZW50UGhhc2VzJyxcbiAgICAnQXNzaWdubWVudFBvbGxEZWNpbWFsUGxhY2VzJyxcbiAgICAnVXNlcicsXG4gICAgZnVuY3Rpb24oJHNjb3BlLCBBc3NpZ25tZW50LCBBc3NpZ25tZW50UG9sbCwgQXNzaWdubWVudFBoYXNlcywgQXNzaWdubWVudFBvbGxEZWNpbWFsUGxhY2VzLCBVc2VyKSB7XG4gICAgICAgIC8vIEF0dGVudGlvbiEgRWFjaCBvYmplY3QgdGhhdCBpcyB1c2VkIGhlcmUgaGFzIHRvIGJlIGRlYWx0IG9uIHNlcnZlciBzaWRlLlxuICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGNvcmVzcG9uZGluZyBnZXRfcmVxdWlyZW1lbnRzIG1ldGhvZCBvZiB0aGUgUHJvamVjdG9yRWxlbWVudFxuICAgICAgICAvLyBjbGFzcy5cbiAgICAgICAgdmFyIGlkID0gJHNjb3BlLmVsZW1lbnQuaWQ7XG4gICAgICAgICRzY29wZS5zaG93UmVzdWx0ID0gJHNjb3BlLmVsZW1lbnQucG9sbDtcblxuICAgICAgICBpZiAoJHNjb3BlLnNob3dSZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBwb2xsID0gQXNzaWdubWVudFBvbGwuZ2V0KCRzY29wZS5zaG93UmVzdWx0KTtcbiAgICAgICAgICAgICRzY29wZS52b3Rlc1ByZWNpc2lvbiA9IDA7XG4gICAgICAgICAgICBpZiAocG9sbCkge1xuICAgICAgICAgICAgICAgIEFzc2lnbm1lbnRQb2xsRGVjaW1hbFBsYWNlcy5nZXRQbGFjZXMocG9sbCwgdHJ1ZSkudGhlbihmdW5jdGlvbiAoZGVjaW1hbFBsYWNlcykge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudm90ZXNQcmVjaXNpb24gPSBkZWNpbWFsUGxhY2VzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgQXNzaWdubWVudC5iaW5kT25lKGlkLCAkc2NvcGUsICdhc3NpZ25tZW50Jyk7XG4gICAgICAgICRzY29wZS5waGFzZXMgPSBBc3NpZ25tZW50UGhhc2VzO1xuICAgICAgICBVc2VyLmJpbmRBbGwoe30sICRzY29wZSwgJ3VzZXJzJyk7XG4gICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmFuZ3VsYXIubW9kdWxlKCdPcGVuU2xpZGVzQXBwLmFzc2lnbm1lbnRzLnNpdGUnLCBbXG4gICAgJ09wZW5TbGlkZXNBcHAuYXNzaWdubWVudHMnLFxuICAgICdPcGVuU2xpZGVzQXBwLmNvcmUucGRmJyxcbiAgICAnT3BlblNsaWRlc0FwcC5hc3NpZ25tZW50cy5wZGYnLFxuICAgICdPcGVuU2xpZGVzQXBwLnBvbGwubWFqb3JpdHknXG5dKVxuXG4uY29uZmlnKFtcbiAgICAnbWFpbk1lbnVQcm92aWRlcicsXG4gICAgJ2dldHRleHQnLFxuICAgIGZ1bmN0aW9uIChtYWluTWVudVByb3ZpZGVyLCBnZXR0ZXh0KSB7XG4gICAgICAgIG1haW5NZW51UHJvdmlkZXIucmVnaXN0ZXIoe1xuICAgICAgICAgICAgJ3VpX3NyZWYnOiAnYXNzaWdubWVudHMuYXNzaWdubWVudC5saXN0JyxcbiAgICAgICAgICAgICdpbWdfY2xhc3MnOiAncGllLWNoYXJ0JyxcbiAgICAgICAgICAgICd0aXRsZSc6IGdldHRleHQoJ0VsZWN0aW9ucycpLFxuICAgICAgICAgICAgJ3dlaWdodCc6IDQwMCxcbiAgICAgICAgICAgICdwZXJtJzogJ2Fzc2lnbm1lbnRzLmNhbl9zZWUnXG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5jb25maWcoW1xuICAgICdTZWFyY2hQcm92aWRlcicsXG4gICAgJ2dldHRleHQnLFxuICAgIGZ1bmN0aW9uIChTZWFyY2hQcm92aWRlciwgZ2V0dGV4dCkge1xuICAgICAgICBTZWFyY2hQcm92aWRlci5yZWdpc3Rlcih7XG4gICAgICAgICAgICAndmVyYm9zZU5hbWUnOiBnZXR0ZXh0KCdFbGVjdGlvbnMnKSxcbiAgICAgICAgICAgICdjb2xsZWN0aW9uTmFtZSc6ICdhc3NpZ25tZW50cy9hc3NpZ25tZW50JyxcbiAgICAgICAgICAgICd1cmxEZXRhaWxTdGF0ZSc6ICdhc3NpZ25tZW50cy5hc3NpZ25tZW50LmRldGFpbCcsXG4gICAgICAgICAgICAnd2VpZ2h0JzogNDAwLFxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4uY29uZmlnKFtcbiAgICAnJHN0YXRlUHJvdmlkZXInLFxuICAgICdnZXR0ZXh0JyxcbiAgICBmdW5jdGlvbigkc3RhdGVQcm92aWRlciwgZ2V0dGV4dCkge1xuICAgICAgICAkc3RhdGVQcm92aWRlclxuICAgICAgICAgICAgLnN0YXRlKCdhc3NpZ25tZW50cycsIHtcbiAgICAgICAgICAgICAgICB1cmw6ICcvYXNzaWdubWVudHMnLFxuICAgICAgICAgICAgICAgIGFic3RyYWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjx1aS12aWV3Lz5cIixcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXR0ZXh0KCdFbGVjdGlvbnMnKSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVBlcm06ICdhc3NpZ25tZW50cy5jYW5fc2VlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdGF0ZSgnYXNzaWdubWVudHMuYXNzaWdubWVudCcsIHtcbiAgICAgICAgICAgICAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8dWktdmlldy8+XCIsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXRlKCdhc3NpZ25tZW50cy5hc3NpZ25tZW50Lmxpc3QnLCB7fSlcbiAgICAgICAgICAgIC5zdGF0ZSgnYXNzaWdubWVudHMuYXNzaWdubWVudC5kZXRhaWwnLCB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ0Fzc2lnbm1lbnREZXRhaWxDdHJsJyxcbiAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRJZDogWyckc3RhdGVQYXJhbXMnLCBmdW5jdGlvbigkc3RhdGVQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkc3RhdGVQYXJhbXMuaWQ7XG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvLyByZWRpcmVjdHMgdG8gYXNzaWdubWVudCBkZXRhaWwgYW5kIG9wZW5zIGFzc2lnbm1lbnQgZWRpdCBmb3JtIGRpYWxvZywgdXNlcyBlZGl0IHVybCxcbiAgICAgICAgICAgIC8vIHVzZWQgYnkgdWktc3JlZiBsaW5rcyBmcm9tIGFnZW5kYSBvbmx5XG4gICAgICAgICAgICAvLyAoZnJvbSBhc3NpZ25tZW50IGNvbnRyb2xsZXIgdXNlIEFzc2lnbm1lbnRGb3JtIGZhY3RvcnkgaW5zdGVhZCB0byBvcGVuIGRpYWxvZyBpbiBmcm9udFxuICAgICAgICAgICAgLy8gb2YgY3VycmVudCB2aWV3IHdpdGhvdXQgcmVkaXJlY3QpXG4gICAgICAgICAgICAuc3RhdGUoJ2Fzc2lnbm1lbnRzLmFzc2lnbm1lbnQuZGV0YWlsLnVwZGF0ZScsIHtcbiAgICAgICAgICAgICAgICBvbkVudGVyOiBbJyRzdGF0ZVBhcmFtcycsICckc3RhdGUnLCAnbmdEaWFsb2cnLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigkc3RhdGVQYXJhbXMsICRzdGF0ZSwgbmdEaWFsb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5nRGlhbG9nLm9wZW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnc3RhdGljL3RlbXBsYXRlcy9hc3NpZ25tZW50cy9hc3NpZ25tZW50LWZvcm0uaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ0Fzc2lnbm1lbnRVcGRhdGVDdHJsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICduZ2RpYWxvZy10aGVtZS1kZWZhdWx0IHdpZGUtZm9ybScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VCeUVzY2FwZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VCeURvY3VtZW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRJZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHN0YXRlUGFyYW1zLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlQ2xvc2VDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnYXNzaWdubWVudHMuYXNzaWdubWVudC5kZXRhaWwnLCB7YXNzaWdubWVudDogJHN0YXRlUGFyYW1zLmlkfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLy8gU2VydmljZSBmb3IgZ2VuZXJpYyBhc3NpZ25tZW50IGZvcm0gKGNyZWF0ZSBhbmQgdXBkYXRlKVxuLmZhY3RvcnkoJ0Fzc2lnbm1lbnRGb3JtJywgW1xuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnRWRpdG9yJyxcbiAgICAnTWVkaWFmaWxlJyxcbiAgICAnVGFnJyxcbiAgICAnQXNzaWdubWVudCcsXG4gICAgJ0FnZW5kYScsXG4gICAgJ0FnZW5kYVRyZWUnLFxuICAgICdTaG93QXNBZ2VuZGFJdGVtRmllbGQnLFxuICAgIGZ1bmN0aW9uIChnZXR0ZXh0Q2F0YWxvZywgb3BlcmF0b3IsIEVkaXRvciwgTWVkaWFmaWxlLCBUYWcsIEFzc2lnbm1lbnQsIEFnZW5kYSwgQWdlbmRhVHJlZSwgU2hvd0FzQWdlbmRhSXRlbUZpZWxkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBuZ0RpYWxvZyBmb3IgYXNzaWdubWVudCBmb3JtXG4gICAgICAgICAgICBnZXREaWFsb2c6IGZ1bmN0aW9uIChhc3NpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL2Fzc2lnbm1lbnRzL2Fzc2lnbm1lbnQtZm9ybS5odG1sJyxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogKGFzc2lnbm1lbnQpID8gJ0Fzc2lnbm1lbnRVcGRhdGVDdHJsJyA6ICdBc3NpZ25tZW50Q3JlYXRlQ3RybCcsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ25nZGlhbG9nLXRoZW1lLWRlZmF1bHQgd2lkZS1mb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VCeUVzY2FwZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlEb2N1bWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRJZDogZnVuY3Rpb24gKCkge3JldHVybiBhc3NpZ25tZW50ID8gYXNzaWdubWVudC5pZCA6IHZvaWQgMDt9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBhbmd1bGFyLWZvcm1seSBmaWVsZHMgZm9yIGFzc2lnbm1lbnQgZm9ybVxuICAgICAgICAgICAgZ2V0Rm9ybUZpZWxkczogZnVuY3Rpb24gKGlzQ3JlYXRlRm9ybSkge1xuICAgICAgICAgICAgICAgIHZhciBpbWFnZXMgPSBNZWRpYWZpbGUuZ2V0QWxsSW1hZ2VzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1GaWVsZHMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICd0aXRsZScsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnVGl0bGUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnZGVzY3JpcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZWRpdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdEZXNjcmlwdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNrZWRpdG9yT3B0aW9uczogRWRpdG9yLmdldE9wdGlvbnMoaW1hZ2VzKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ29wZW5fcG9zdHMnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ051bWJlciBvZiBwZXJzb25zIHRvIGJlIGVsZWN0ZWQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdwb2xsX2Rlc2NyaXB0aW9uX2RlZmF1bHQnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0RlZmF1bHQgY29tbWVudCBvbiB0aGUgYmFsbG90IHBhcGVyJylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICAgICAgLy8gc2hvdyBhcyBhZ2VuZGEgaXRlbSArIHBhcmVudCBpdGVtXG4gICAgICAgICAgICAgICAgaWYgKGlzQ3JlYXRlRm9ybSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtRmllbGRzLnB1c2goU2hvd0FzQWdlbmRhSXRlbUZpZWxkKCdhc3NpZ25tZW50cy5jYW5fbWFuYWdlJykpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtRmllbGRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnYWdlbmRhX3BhcmVudF9pZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2VsZWN0LXNpbmdsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdQYXJlbnQgaXRlbScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IEFnZW5kYVRyZWUuZ2V0RmxhdFRyZWUoQWdlbmRhLmdldEFsbCgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZ09wdGlvbnM6ICdpdGVtLmlkIGFzIGl0ZW0uZ2V0TGlzdFZpZXdUaXRsZSgpIGZvciBpdGVtIGluIHRvLm9wdGlvbnMgfCBub3RzZWxmIDogbW9kZWwuYWdlbmRhX2l0ZW1faWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1NlbGVjdCBhIHBhcmVudCBpdGVtIC4uLicpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTogIW9wZXJhdG9yLmhhc1Blcm1zKCdhZ2VuZGEuY2FuX21hbmFnZScpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtb3JlICh3aXRoIHRhZ3MgZmllbGQpXG4gICAgICAgICAgICAgICAgaWYgKFRhZy5nZXRBbGwoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1GaWVsZHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtb3JlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTaG93IGV4dGVuZGVkIGZpZWxkcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlOiAhb3BlcmF0b3IuaGFzUGVybXMoJ2Fzc2lnbm1lbnRzLmNhbl9tYW5hZ2UnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxociBjbGFzcz1cInNtYWxsaHJcIj4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVFeHByZXNzaW9uOiAnIW1vZGVsLm1vcmUnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ3RhZ3NfaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzZWxlY3QtbXVsdGlwbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdUYWdzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IFRhZy5nZXRBbGwoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmdPcHRpb25zOiAnb3B0aW9uLmlkIGFzIG9wdGlvbi5uYW1lIGZvciBvcHRpb24gaW4gdG8ub3B0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1NlbGVjdCBvciBzZWFyY2ggYSB0YWcgLi4uJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVFeHByZXNzaW9uOiAnIW1vZGVsLm1vcmUnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1GaWVsZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLy8gQ2FjaGUgZm9yIEFzc2lnbm1lbnRQb2xsRGV0YWlsQ3RybCBzbyB0aGF0IHVzZXJzIGNob2ljZXMgYXJlIGtlZXBlZCBkdXJpbmcgdXNlciBhY3Rpb25zIChlLiBnLiBzYXZlIHBvbGwgZm9ybSkuXG4udmFsdWUoJ0Fzc2lnbm1lbnRQb2xsRGV0YWlsQ3RybENhY2hlJywge30pXG5cbi8vIENoaWxkIGNvbnRyb2xsZXIgb2YgQXNzaWdubWVudERldGFpbEN0cmwgZm9yIGVhY2ggc2luZ2xlIHBvbGwuXG4uY29udHJvbGxlcignQXNzaWdubWVudFBvbGxEZXRhaWxDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICdNYWpvcml0eU1ldGhvZENob2ljZXMnLFxuICAgICdDb25maWcnLFxuICAgICdBc3NpZ25tZW50UG9sbERldGFpbEN0cmxDYWNoZScsXG4gICAgJ0Fzc2lnbm1lbnRQb2xsJyxcbiAgICAnQXNzaWdubWVudFBvbGxEZWNpbWFsUGxhY2VzJyxcbiAgICBmdW5jdGlvbiAoJHNjb3BlLCBNYWpvcml0eU1ldGhvZENob2ljZXMsIENvbmZpZywgQXNzaWdubWVudFBvbGxEZXRhaWxDdHJsQ2FjaGUsXG4gICAgICAgIEFzc2lnbm1lbnRQb2xsLCBBc3NpZ25tZW50UG9sbERlY2ltYWxQbGFjZXMpIHtcbiAgICAgICAgLy8gRGVmaW5lIGNob2ljZXMuXG4gICAgICAgICRzY29wZS5tZXRob2RDaG9pY2VzID0gTWFqb3JpdHlNZXRob2RDaG9pY2VzO1xuICAgICAgICAvLyBUT0RPOiBHZXQgJHNjb3BlLmJhc2VDaG9pY2VzIGZyb20gY29uZmlnX3ZhcmlhYmxlcy5weSB3aXRob3V0IGNvcHlpbmcgdGhlbS5cblxuICAgICAgICAkc2NvcGUudm90ZXNQcmVjaXNpb24gPSBBc3NpZ25tZW50UG9sbERlY2ltYWxQbGFjZXMuZ2V0UGxhY2VzKCRzY29wZS5wb2xsKTtcblxuICAgICAgICAvLyBTZXR1cCBlbXB0eSBjYWNoZSB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICBpZiAodHlwZW9mIEFzc2lnbm1lbnRQb2xsRGV0YWlsQ3RybENhY2hlWyRzY29wZS5wb2xsLmlkXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIEFzc2lnbm1lbnRQb2xsRGV0YWlsQ3RybENhY2hlWyRzY29wZS5wb2xsLmlkXSA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICRzY29wZS5jb25maWcoJ2Fzc2lnbm1lbnRzX3BvbGxfZGVmYXVsdF9tYWpvcml0eV9tZXRob2QnKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGZXRjaCB1c2VycyBjaG9pY2VzIGZyb20gY2FjaGUuXG4gICAgICAgICRzY29wZS5tZXRob2QgPSBBc3NpZ25tZW50UG9sbERldGFpbEN0cmxDYWNoZVskc2NvcGUucG9sbC5pZF0ubWV0aG9kO1xuXG4gICAgICAgICRzY29wZS5yZWNhbGN1bGF0ZU1ham9yaXRpZXMgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICAkc2NvcGUubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICAgICAgXy5mb3JFYWNoKCRzY29wZS5wb2xsLm9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICBvcHRpb24ubWFqb3JpdHlSZWFjaGVkID0gb3B0aW9uLmlzUmVhY2hlZChtZXRob2QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5yZWNhbGN1bGF0ZU1ham9yaXRpZXMoJHNjb3BlLm1ldGhvZCk7XG5cbiAgICAgICAgJHNjb3BlLnNhdmVEZXNjcmlwdGlvbkNoYW5nZSA9IGZ1bmN0aW9uIChwb2xsKSB7XG4gICAgICAgICAgICBBc3NpZ25tZW50UG9sbC5zYXZlKHBvbGwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNhdmUgY3VycmVudCB2YWx1ZXMgdG8gY2FjaGUgb24gZGVzdHJveSBvZiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBBc3NpZ25tZW50UG9sbERldGFpbEN0cmxDYWNoZVskc2NvcGUucG9sbC5pZF0gPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAkc2NvcGUubWV0aG9kLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ0Fzc2lnbm1lbnRMaXN0Q3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnbmdEaWFsb2cnLFxuICAgICdBc3NpZ25tZW50Rm9ybScsXG4gICAgJ0Fzc2lnbm1lbnQnLFxuICAgICdUYWcnLFxuICAgICdBZ2VuZGEnLFxuICAgICdQcm9qZWN0b3InLFxuICAgICdQcm9qZWN0aW9uRGVmYXVsdCcsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnVXNlcicsXG4gICAgJ29zVGFibGVGaWx0ZXInLFxuICAgICdvc1RhYmxlU29ydCcsXG4gICAgJ29zVGFibGVQYWdpbmF0aW9uJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgJ0Fzc2lnbm1lbnRQaGFzZXMnLFxuICAgICdBc3NpZ25tZW50UGRmRXhwb3J0JyxcbiAgICBmdW5jdGlvbigkc2NvcGUsIG5nRGlhbG9nLCBBc3NpZ25tZW50Rm9ybSwgQXNzaWdubWVudCwgVGFnLCBBZ2VuZGEsIFByb2plY3RvcixcbiAgICAgICAgUHJvamVjdGlvbkRlZmF1bHQsIGdldHRleHRDYXRhbG9nLCBVc2VyLCBvc1RhYmxlRmlsdGVyLCBvc1RhYmxlU29ydCwgb3NUYWJsZVBhZ2luYXRpb24sXG4gICAgICAgIGdldHRleHQsIEFzc2lnbm1lbnRQaGFzZXMsIEFzc2lnbm1lbnRQZGZFeHBvcnQpIHtcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQXNzaWdubWVudC5sYXN0TW9kaWZpZWQoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLmFzc2lnbm1lbnRzID0gXy5vcmRlckJ5KEFzc2lnbm1lbnQuZ2V0QWxsKCksIFsndGl0bGUnXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBUYWcuYmluZEFsbCh7fSwgJHNjb3BlLCAndGFncycpO1xuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9qZWN0b3IubGFzdE1vZGlmaWVkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwcm9qZWN0aW9uZGVmYXVsdCA9IFByb2plY3Rpb25EZWZhdWx0LmZpbHRlcih7bmFtZTogJ2Fzc2lnbm1lbnRzJ30pWzBdO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rpb25kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlZmF1bHRQcm9qZWN0b3JJZCA9IHByb2plY3Rpb25kZWZhdWx0LnByb2plY3Rvcl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS5waGFzZXMgPSBBc3NpZ25tZW50UGhhc2VzO1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcblxuICAgICAgICAvLyBGaWx0ZXJpbmdcbiAgICAgICAgJHNjb3BlLmZpbHRlciA9IG9zVGFibGVGaWx0ZXIuY3JlYXRlSW5zdGFuY2UoJ0Fzc2lnbm1lbnRUYWJsZUZpbHRlcicpO1xuXG4gICAgICAgIGlmICghJHNjb3BlLmZpbHRlci5leGlzdHNTdG9yYWdlRW50cnkoKSkge1xuICAgICAgICAgICAgJHNjb3BlLmZpbHRlci5tdWx0aXNlbGVjdEZpbHRlcnMgPSB7XG4gICAgICAgICAgICAgICAgdGFnOiBbXSxcbiAgICAgICAgICAgICAgICBwaGFzZTogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgICRzY29wZS5maWx0ZXIucHJvcGVydHlMaXN0ID0gWyd0aXRsZScsICdkZXNjcmlwdGlvbiddO1xuICAgICAgICAkc2NvcGUuZmlsdGVyLnByb3BlcnR5RnVuY3Rpb25MaXN0ID0gW1xuICAgICAgICAgICAgZnVuY3Rpb24gKGFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCRzY29wZS5waGFzZXNbYXNzaWdubWVudC5waGFzZV0uZGlzcGxheV9uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgICRzY29wZS5maWx0ZXIucHJvcGVydHlEaWN0ID0ge1xuICAgICAgICAgICAgJ2Fzc2lnbm1lbnRfcmVsYXRlZF91c2Vycyc6IGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlLnVzZXIuZ2V0X3Nob3J0X25hbWUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndGFncyc6IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnLm5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuZ2V0SXRlbUlkID0ge1xuICAgICAgICAgICAgdGFnOiBmdW5jdGlvbiAoYXNzaWdubWVudCkge3JldHVybiBhc3NpZ25tZW50LnRhZ3NfaWQ7fSxcbiAgICAgICAgICAgIHBoYXNlOiBmdW5jdGlvbiAoYXNzaWdubWVudCkge3JldHVybiBhc3NpZ25tZW50LnBoYXNlO30sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU29ydGluZ1xuICAgICAgICAkc2NvcGUuc29ydCA9IG9zVGFibGVTb3J0LmNyZWF0ZUluc3RhbmNlKCdBc3NpZ25tZW50VGFibGVTb3J0Jyk7XG4gICAgICAgIGlmICghJHNjb3BlLnNvcnQuY29sdW1uKSB7XG4gICAgICAgICAgICAkc2NvcGUuc29ydC5jb2x1bW4gPSAndGl0bGUnO1xuICAgICAgICB9XG4gICAgICAgICRzY29wZS5zb3J0T3B0aW9ucyA9IFtcbiAgICAgICAgICAgIHtuYW1lOiAnYWdlbmRhX2l0ZW0uZ2V0SXRlbU51bWJlcldpdGhBbmNlc3RvcnMoKScsXG4gICAgICAgICAgICAgZGlzcGxheV9uYW1lOiBnZXR0ZXh0KCdJdGVtJyl9LFxuICAgICAgICAgICAge25hbWU6ICd0aXRsZScsXG4gICAgICAgICAgICAgZGlzcGxheV9uYW1lOiBnZXR0ZXh0KCdUaXRsZScpfSxcbiAgICAgICAgICAgIHtuYW1lOiAncGhhc2UnLFxuICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogZ2V0dGV4dCgnUGhhc2UnKX0sXG4gICAgICAgICAgICB7bmFtZTogJ2Fzc2lnbm1lbnRfcmVsYXRlZF91c2Vycy5sZW5ndGgnLFxuICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogZ2V0dGV4dCgnTnVtYmVyIG9mIGNhbmRpZGF0ZXMnKX0sXG4gICAgICAgIF07XG4gICAgICAgICRzY29wZS5oYXNUYWcgPSBmdW5jdGlvbiAoYXNzaWdubWVudCwgdGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5pbmRleE9mKGFzc2lnbm1lbnQudGFnc19pZCwgdGFnLmlkKSA+IC0xO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUudG9nZ2xlVGFnID0gZnVuY3Rpb24gKGFzc2lnbm1lbnQsIHRhZykge1xuICAgICAgICAgICAgaWYgKCRzY29wZS5oYXNUYWcoYXNzaWdubWVudCwgdGFnKSkge1xuICAgICAgICAgICAgICAgIGFzc2lnbm1lbnQudGFnc19pZCA9IF8uZmlsdGVyKGFzc2lnbm1lbnQudGFnc19pZCwgZnVuY3Rpb24gKHRhZ19pZCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWdfaWQgIT0gdGFnLmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NpZ25tZW50LnRhZ3NfaWQucHVzaCh0YWcuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQXNzaWdubWVudC5zYXZlKGFzc2lnbm1lbnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhZ2luYXRpb25cbiAgICAgICAgJHNjb3BlLnBhZ2luYXRpb24gPSBvc1RhYmxlUGFnaW5hdGlvbi5jcmVhdGVJbnN0YW5jZSgnQXNzaWdubWVudFRhYmxlUGFnaW5hdGlvbicpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwaGFzZVxuICAgICAgICAkc2NvcGUudXBkYXRlUGhhc2UgPSBmdW5jdGlvbiAoYXNzaWdubWVudCwgcGhhc2VfaWQpIHtcbiAgICAgICAgICAgIGFzc2lnbm1lbnQucGhhc2UgPSBwaGFzZV9pZDtcbiAgICAgICAgICAgIEFzc2lnbm1lbnQuc2F2ZShhc3NpZ25tZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gb3BlbiBuZXcvZWRpdCBkaWFsb2dcbiAgICAgICAgJHNjb3BlLm9wZW5EaWFsb2cgPSBmdW5jdGlvbiAoYXNzaWdubWVudCkge1xuICAgICAgICAgICAgbmdEaWFsb2cub3BlbihBc3NpZ25tZW50Rm9ybS5nZXREaWFsb2coYXNzaWdubWVudCkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyAqKiogc2VsZWN0IG1vZGUgZnVuY3Rpb25zICoqKlxuICAgICAgICAkc2NvcGUuaXNTZWxlY3RNb2RlID0gZmFsc2U7XG4gICAgICAgIC8vIGNoZWNrIGFsbCBjaGVja2JveGVzXG4gICAgICAgICRzY29wZS5jaGVja0FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5zZWxlY3RlZEFsbCA9ICEkc2NvcGUuc2VsZWN0ZWRBbGw7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlLmFzc2lnbm1lbnRzLCBmdW5jdGlvbiAoYXNzaWdubWVudCkge1xuICAgICAgICAgICAgICAgIGFzc2lnbm1lbnQuc2VsZWN0ZWQgPSAkc2NvcGUuc2VsZWN0ZWRBbGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdW5jaGVjayBhbGwgY2hlY2tib3hlcyBpZiBpc1NlbGVjdE1vZGUgaXMgY2xvc2VkXG4gICAgICAgICRzY29wZS51bmNoZWNrQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuaXNTZWxlY3RNb2RlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdGVkQWxsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5hc3NpZ25tZW50cywgZnVuY3Rpb24gKGFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWdubWVudC5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBkZWxldGUgYWxsIHNlbGVjdGVkIGFzc2lnbm1lbnRzXG4gICAgICAgICRzY29wZS5kZWxldGVNdWx0aXBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUuYXNzaWdubWVudHMsIGZ1bmN0aW9uIChhc3NpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFzc2lnbm1lbnQuc2VsZWN0ZWQpXG4gICAgICAgICAgICAgICAgICAgIEFzc2lnbm1lbnQuZGVzdHJveShhc3NpZ25tZW50LmlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHNjb3BlLmlzU2VsZWN0TW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgJHNjb3BlLnVuY2hlY2tBbGwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZGVsZXRlIHNpbmdsZSBhc3NpZ25tZW50XG4gICAgICAgICRzY29wZS5kZWxldGUgPSBmdW5jdGlvbiAoYXNzaWdubWVudCkge1xuICAgICAgICAgICAgQXNzaWdubWVudC5kZXN0cm95KGFzc2lnbm1lbnQuaWQpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBjcmVhdGUgdGhlIFBERiBMaXN0XG4gICAgICAgICRzY29wZS5wZGZFeHBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBBc3NpZ25tZW50UGRmRXhwb3J0LmV4cG9ydCgkc2NvcGUuYXNzaWdubWVudHNGaWx0ZXJlZCk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ0Fzc2lnbm1lbnREZXRhaWxDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckaHR0cCcsXG4gICAgJyRmaWx0ZXInLFxuICAgICckdGltZW91dCcsXG4gICAgJ2ZpbHRlckZpbHRlcicsXG4gICAgJ2dldHRleHQnLFxuICAgICduZ0RpYWxvZycsXG4gICAgJ0Fzc2lnbm1lbnRGb3JtJyxcbiAgICAnb3BlcmF0b3InLFxuICAgICdBc3NpZ25tZW50JyxcbiAgICAnVXNlcicsXG4gICAgJ2Fzc2lnbm1lbnRJZCcsXG4gICAgJ1Byb2plY3RvcicsXG4gICAgJ1Byb2plY3Rpb25EZWZhdWx0JyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdBc3NpZ25tZW50UGhhc2VzJyxcbiAgICAnQXNzaWdubWVudFBkZkV4cG9ydCcsXG4gICAgJ1dlYnBhZ2VUaXRsZScsXG4gICAgJ0Vycm9yTWVzc2FnZScsXG4gICAgZnVuY3Rpb24oJHNjb3BlLCAkaHR0cCwgJGZpbHRlciwgJHRpbWVvdXQsIGZpbHRlckZpbHRlciwgZ2V0dGV4dCwgbmdEaWFsb2csIEFzc2lnbm1lbnRGb3JtLCBvcGVyYXRvcixcbiAgICAgICAgQXNzaWdubWVudCwgVXNlciwgYXNzaWdubWVudElkLCBQcm9qZWN0b3IsIFByb2plY3Rpb25EZWZhdWx0LCBnZXR0ZXh0Q2F0YWxvZywgQXNzaWdubWVudFBoYXNlcyxcbiAgICAgICAgQXNzaWdubWVudFBkZkV4cG9ydCwgV2VicGFnZVRpdGxlLCBFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgVXNlci5iaW5kQWxsKHt9LCAkc2NvcGUsICd1c2VycycpO1xuICAgICAgICB2YXIgYXNzaWdubWVudCA9IEFzc2lnbm1lbnQuZ2V0KGFzc2lnbm1lbnRJZCk7XG4gICAgICAgIEFzc2lnbm1lbnQubG9hZFJlbGF0aW9ucyhhc3NpZ25tZW50LCAnYWdlbmRhX2l0ZW0nKTtcbiAgICAgICAgLy8gVGhpcyBmbGFnIGlzIGZvciBzZXR0aW5nICdhY3RpdmVUYWInIHRvIHJlY2VudGx5IGFkZGVkIChsYXN0KSBiYWxsb3QgdGFiLlxuICAgICAgICAvLyBTZXQgdGhpcyBmbGFnLCBpZiBiYWxsb3RzIGFyZSBhZGRlZC9yZW1vdmVkLiBXaGVuIHRoZSBuZXh0IGF1dG91cGRhdGUgY29tZXNcbiAgICAgICAgLy8gaW4sIHRoZSB0YWJzZXQgd2lsbCBiZSB1cGRhdGVkLlxuICAgICAgICB2YXIgdXBkYXRlQmFsbG90VGFic0ZsYWcgPSB0cnVlO1xuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9qZWN0b3IubGFzdE1vZGlmaWVkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwcm9qZWN0aW9uZGVmYXVsdCA9IFByb2plY3Rpb25EZWZhdWx0LmZpbHRlcih7bmFtZTogJ2Fzc2lnbm1lbnRzJ30pWzBdO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rpb25kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlZmF1bHRQcm9qZWN0b3JJZCA9IHByb2plY3Rpb25kZWZhdWx0LnByb2plY3Rvcl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEFzc2lnbm1lbnQubGFzdE1vZGlmaWVkKGFzc2lnbm1lbnRJZCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHNldHVwIHNvcnRpbmcgb2YgY2FuZGlkYXRlc1xuICAgICAgICAgICAgJHNjb3BlLnJlbGF0ZWRVc2Vyc1NvcnRlZCA9ICRmaWx0ZXIoJ29yZGVyQnknKShhc3NpZ25tZW50LmFzc2lnbm1lbnRfcmVsYXRlZF91c2VycywgJ3dlaWdodCcpO1xuICAgICAgICAgICAgJHNjb3BlLmFzc2lnbm1lbnQgPSBBc3NpZ25tZW50LmdldChhc3NpZ25tZW50LmlkKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVCYWxsb3RUYWJzRmxhZykge1xuICAgICAgICAgICAgICAgICRzY29wZS5hY3RpdmVUYWIgPSAkc2NvcGUuYXNzaWdubWVudC5wb2xscy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUJhbGxvdFRhYnNGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBXZWJwYWdlVGl0bGUudXBkYXRlVGl0bGUoZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdFbGVjdGlvbicpICsgJyAnICsgJHNjb3BlLmFzc2lnbm1lbnQudGl0bGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgJHNjb3BlLmNhbmRpZGF0ZVNlbGVjdEJveCA9IHt9O1xuICAgICAgICAkc2NvcGUucGhhc2VzID0gQXNzaWdubWVudFBoYXNlcztcbiAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge307XG5cbiAgICAgICAgLy8gb3BlbiBlZGl0IGRpYWxvZ1xuICAgICAgICAkc2NvcGUub3BlbkRpYWxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG5nRGlhbG9nLm9wZW4oQXNzaWdubWVudEZvcm0uZ2V0RGlhbG9nKCRzY29wZS5hc3NpZ25tZW50KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGFkZCAobm9taW5hdGUpIGNhbmRpZGF0ZVxuICAgICAgICAkc2NvcGUuYWRkQ2FuZGlkYXRlID0gZnVuY3Rpb24gKHVzZXJJZCkge1xuICAgICAgICAgICAgJGh0dHAucG9zdCgnL3Jlc3QvYXNzaWdubWVudHMvYXNzaWdubWVudC8nICsgYXNzaWdubWVudElkICsgJy9jYW5kaWRhdHVyZV9vdGhlci8nLCB7J3VzZXInOiB1c2VySWR9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKXtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0LnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNhbmRpZGF0ZVNlbGVjdEJveCA9IHt9O1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcil7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IEVycm9yTWVzc2FnZS5mb3JBbGVydChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jYW5kaWRhdGVTZWxlY3RCb3ggPSB7fTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVtb3ZlIGNhbmRpZGF0ZVxuICAgICAgICAkc2NvcGUucmVtb3ZlQ2FuZGlkYXRlID0gZnVuY3Rpb24gKHVzZXJJZCkge1xuICAgICAgICAgICAgJGh0dHAuZGVsZXRlKCcvcmVzdC9hc3NpZ25tZW50cy9hc3NpZ25tZW50LycgKyBhc3NpZ25tZW50SWQgKyAnL2NhbmRpZGF0dXJlX290aGVyLycsXG4gICAgICAgICAgICAgICAgICAgIHtoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ30sXG4gICAgICAgICAgICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSh7dXNlcjogdXNlcklkfSl9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYWRkIG1lIChub21pbmF0ZSBzZWxmIGFzIGNhbmRpZGF0ZSlcbiAgICAgICAgJHNjb3BlLmFkZE1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJGh0dHAucG9zdCgnL3Jlc3QvYXNzaWdubWVudHMvYXNzaWdubWVudC8nICsgYXNzaWdubWVudElkICsgJy9jYW5kaWRhdHVyZV9zZWxmLycsIHt9KS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydC5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IEVycm9yTWVzc2FnZS5mb3JBbGVydChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVtb3ZlIG1lICh3aXRoZHJhdyBvd24gY2FuZGlkYXR1cmUpXG4gICAgICAgICRzY29wZS5yZW1vdmVNZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRodHRwLmRlbGV0ZSgnL3Jlc3QvYXNzaWdubWVudHMvYXNzaWdubWVudC8nICsgYXNzaWdubWVudElkICsgJy9jYW5kaWRhdHVyZV9zZWxmLycpLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0LnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICAvLyBjaGVjayBpZiBjdXJyZW50IHVzZXIgaXMgYWxyZWFkeSBhIGNhbmRpZGF0ZSAoZWxlY3RlZD09ZmFsc2UpXG4gICAgICAgICRzY29wZS5pc0NhbmRpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGVjayA9ICRzY29wZS5hc3NpZ25tZW50LmFzc2lnbm1lbnRfcmVsYXRlZF91c2Vycy5tYXAoZnVuY3Rpb24oY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGUuZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuaW5kZXhPZihvcGVyYXRvci51c2VyLmlkKTtcbiAgICAgICAgICAgIGlmIChjaGVjayA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gU29ydCBhbGwgY2FuZGlkYXRlc1xuICAgICAgICAkc2NvcGUudHJlZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkcm9wcGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvcnRlZENhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goJHNjb3BlLnJlbGF0ZWRVc2Vyc1NvcnRlZCwgZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkQ2FuZGlkYXRlcy5wdXNoKHVzZXIuaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICRodHRwLnBvc3QoJy9yZXN0L2Fzc2lnbm1lbnRzL2Fzc2lnbm1lbnQvJyArIGFzc2lnbm1lbnRJZCArICcvc29ydF9yZWxhdGVkX3VzZXJzLycsXG4gICAgICAgICAgICAgICAgICAgIHtyZWxhdGVkX3VzZXJzOiBzb3J0ZWRDYW5kaWRhdGVzfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHVwZGF0ZSBwaGFzZVxuICAgICAgICAkc2NvcGUudXBkYXRlUGhhc2UgPSBmdW5jdGlvbiAocGhhc2VfaWQpIHtcbiAgICAgICAgICAgICRzY29wZS5hc3NpZ25tZW50LnBoYXNlID0gcGhhc2VfaWQ7XG4gICAgICAgICAgICBBc3NpZ25tZW50LnNhdmUoJHNjb3BlLmFzc2lnbm1lbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBjcmVhdGUgbmV3IGJhbGxvdFxuICAgICAgICAkc2NvcGUuY3JlYXRlQmFsbG90ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJGh0dHAucG9zdCgnL3Jlc3QvYXNzaWdubWVudHMvYXNzaWdubWVudC8nICsgYXNzaWdubWVudElkICsgJy9jcmVhdGVfcG9sbC8nKS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydC5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc3NpZ25tZW50LnBoYXNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUudXBkYXRlUGhhc2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQmFsbG90VGFic0ZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRlbGV0ZSBiYWxsb3RcbiAgICAgICAgJHNjb3BlLmRlbGV0ZUJhbGxvdCA9IGZ1bmN0aW9uIChwb2xsKSB7XG4gICAgICAgICAgICBwb2xsLkRTRGVzdHJveSgpLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFjdGl2ZVRhYiA9ICRzY29wZS5hY3RpdmVUYWIgLSAxO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCYWxsb3RUYWJzRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZWRpdCBwb2xsIGRpYWxvZ1xuICAgICAgICAkc2NvcGUuZWRpdFBvbGxEaWFsb2cgPSBmdW5jdGlvbiAocG9sbCwgYmFsbG90KSB7XG4gICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJ3N0YXRpYy90ZW1wbGF0ZXMvYXNzaWdubWVudHMvYXNzaWdubWVudHBvbGwtZm9ybS5odG1sJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnQXNzaWdubWVudFBvbGxVcGRhdGVDdHJsJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICduZ2RpYWxvZy10aGVtZS1kZWZhdWx0JyxcbiAgICAgICAgICAgICAgICBjbG9zZUJ5RXNjYXBlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjbG9zZUJ5RG9jdW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWdubWVudHBvbGxJZDogZnVuY3Rpb24gKCkge3JldHVybiBwb2xsLmlkO30sXG4gICAgICAgICAgICAgICAgICAgIGJhbGxvdDogZnVuY3Rpb24gKCkge3JldHVybiBiYWxsb3Q7fSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcHVibGlzaCBiYWxsb3RcbiAgICAgICAgJHNjb3BlLnRvZ2dsZVB1Ymxpc2hCYWxsb3QgPSBmdW5jdGlvbiAocG9sbCkge1xuICAgICAgICAgICAgcG9sbC5EU1VwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRfaWQ6IGFzc2lnbm1lbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaGVkOiAhcG9sbC5wdWJsaXNoZWQsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQuc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1hcmsgY2FuZGlkYXRlIGFzIChub3QpIGVsZWN0ZWRcbiAgICAgICAgJHNjb3BlLm1hcmtFbGVjdGVkID0gZnVuY3Rpb24gKHVzZXIsIHJldmVyc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgJGh0dHAuZGVsZXRlKFxuICAgICAgICAgICAgICAgICAgICAnL3Jlc3QvYXNzaWdubWVudHMvYXNzaWdubWVudC8nICsgYXNzaWdubWVudElkICsgJy9tYXJrX2VsZWN0ZWQvJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSh7dXNlcjogdXNlcn0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRodHRwLnBvc3QoJy9yZXN0L2Fzc2lnbm1lbnRzL2Fzc2lnbm1lbnQvJyArIGFzc2lnbm1lbnRJZCArICcvbWFya19lbGVjdGVkLycsIHsndXNlcic6IHVzZXJ9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENyZWF0ZXMgdGhlIGRvY3VtZW50IGFzIHBkZlxuICAgICAgICAkc2NvcGUucGRmRXhwb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBBc3NpZ25tZW50UGRmRXhwb3J0LmV4cG9ydCgkc2NvcGUuYXNzaWdubWVudCwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENyZWF0ZXMgdGhlIGJhbGxvdHBhcGVyIGFzIHBkZlxuICAgICAgICAkc2NvcGUuYmFsbG90cGFwZXJFeHBvcnQgPSBmdW5jdGlvbihwb2xsSWQpIHtcbiAgICAgICAgICAgIEFzc2lnbm1lbnRQZGZFeHBvcnQuY3JlYXRlQmFsbG90UGRmKCRzY29wZS5hc3NpZ25tZW50LCBwb2xsSWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEp1c3QgbWFyayBzb21lIHZvdGUgdmFsdWUgc3RyaW5ncyBmb3IgdHJhbnNsYXRpb24uXG4gICAgICAgIGdldHRleHQoJ1llcycpO1xuICAgICAgICBnZXR0ZXh0KCdObycpO1xuICAgICAgICBnZXR0ZXh0KCdBYnN0YWluJyk7XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ0Fzc2lnbm1lbnRDcmVhdGVDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckc3RhdGUnLFxuICAgICdBc3NpZ25tZW50JyxcbiAgICAnQXNzaWdubWVudEZvcm0nLFxuICAgICdBZ2VuZGEnLFxuICAgICdDb25maWcnLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlLCBBc3NpZ25tZW50LCBBc3NpZ25tZW50Rm9ybSwgQWdlbmRhLCBDb25maWcsIEVycm9yTWVzc2FnZSkge1xuICAgICAgICAkc2NvcGUubW9kZWwgPSB7XG4gICAgICAgICAgICBhZ2VuZGFfdHlwZTogcGFyc2VJbnQoQ29uZmlnLmdldCgnYWdlbmRhX25ld19pdGVtc19kZWZhdWx0X3Zpc2liaWxpdHknKS52YWx1ZSksXG4gICAgICAgIH07XG4gICAgICAgIC8vIHNldCBkZWZhdWx0IHZhbHVlIGZvciBvcGVuIHBvc3RzIGZvcm0gZmllbGRcbiAgICAgICAgJHNjb3BlLm1vZGVsLm9wZW5fcG9zdHMgPSAxO1xuICAgICAgICAvLyBnZXQgYWxsIGZvcm0gZmllbGRzXG4gICAgICAgICRzY29wZS5mb3JtRmllbGRzID0gQXNzaWdubWVudEZvcm0uZ2V0Rm9ybUZpZWxkcyh0cnVlKTtcbiAgICAgICAgLy8gc2F2ZSBhc3NpZ25tZW50XG4gICAgICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24oYXNzaWdubWVudCwgZ290b0RldGFpbFZpZXcpIHtcbiAgICAgICAgICAgIEFzc2lnbm1lbnQuY3JlYXRlKGFzc2lnbm1lbnQpLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdvdG9EZXRhaWxWaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ2Fzc2lnbm1lbnRzLmFzc2lnbm1lbnQuZGV0YWlsJywge2lkOiBzdWNjZXNzLmlkfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlVGhpc0RpYWxvZygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IEVycm9yTWVzc2FnZS5mb3JBbGVydChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignQXNzaWdubWVudFVwZGF0ZUN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRzdGF0ZScsXG4gICAgJ0Fzc2lnbm1lbnQnLFxuICAgICdBc3NpZ25tZW50Rm9ybScsXG4gICAgJ0FnZW5kYScsXG4gICAgJ2Fzc2lnbm1lbnRJZCcsXG4gICAgJ0Vycm9yTWVzc2FnZScsXG4gICAgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGUsIEFzc2lnbm1lbnQsIEFzc2lnbm1lbnRGb3JtLCBBZ2VuZGEsIGFzc2lnbm1lbnRJZCwgRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHZhciBhc3NpZ25tZW50ID0gQXNzaWdubWVudC5nZXQoYXNzaWdubWVudElkKTtcbiAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge307XG4gICAgICAgIC8vIHNldCBpbml0aWFsIHZhbHVlcyBmb3IgZm9ybSBtb2RlbCBieSBjcmVhdGUgZGVlcCBjb3B5IG9mIGFzc2lnbm1lbnQgb2JqZWN0XG4gICAgICAgIC8vIHNvIGxpc3QvZGV0YWlsIHZpZXcgaXMgbm90IHVwZGF0ZWQgd2hpbGUgZWRpdGluZ1xuICAgICAgICAkc2NvcGUubW9kZWwgPSBhbmd1bGFyLmNvcHkoYXNzaWdubWVudCk7XG4gICAgICAgIC8vIGdldCBhbGwgZm9ybSBmaWVsZHNcbiAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHMgPSBBc3NpZ25tZW50Rm9ybS5nZXRGb3JtRmllbGRzKCk7XG5cbiAgICAgICAgLy8gc2F2ZSBhc3NpZ25tZW50XG4gICAgICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24gKGFzc2lnbm1lbnQsIGdvdG9EZXRhaWxWaWV3KSB7XG4gICAgICAgICAgICAvLyBpbmplY3QgdGhlIGNoYW5nZWQgYXNzaWdubWVudCAoY29weSkgb2JqZWN0IGJhY2sgaW50byBEUyBzdG9yZVxuICAgICAgICAgICAgQXNzaWdubWVudC5pbmplY3QoYXNzaWdubWVudCk7XG4gICAgICAgICAgICAvLyBzYXZlIGNoYW5nZWQgYXNzaWdubWVudCBvYmplY3Qgb24gc2VydmVyXG4gICAgICAgICAgICBBc3NpZ25tZW50LnNhdmUoYXNzaWdubWVudCkudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnb3RvRGV0YWlsVmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdhc3NpZ25tZW50cy5hc3NpZ25tZW50LmRldGFpbCcsIHtpZDogc3VjY2Vzcy5pZH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZVRoaXNEaWFsb2coKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGVycm9yOiByZXZlcnQgYWxsIGNoYW5nZXMgYnkgcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICAvLyAocmVmcmVzaCkgb3JpZ2luYWwgYXNzaWdubWVudCBvYmplY3QgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgQXNzaWdubWVudC5yZWZyZXNoKGFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ0Fzc2lnbm1lbnRQb2xsVXBkYXRlQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJGZpbHRlcicsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnQXNzaWdubWVudFBvbGwnLFxuICAgICdhc3NpZ25tZW50cG9sbElkJyxcbiAgICAnQXNzaWdubWVudFBvbGxEZWNpbWFsUGxhY2VzJyxcbiAgICAnYmFsbG90JyxcbiAgICAnRXJyb3JNZXNzYWdlJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsICRmaWx0ZXIsIGdldHRleHRDYXRhbG9nLCBBc3NpZ25tZW50UG9sbCwgYXNzaWdubWVudHBvbGxJZCxcbiAgICAgICAgQXNzaWdubWVudFBvbGxEZWNpbWFsUGxhY2VzLCBiYWxsb3QsIEVycm9yTWVzc2FnZSkge1xuICAgICAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZXMgZm9yIGZvcm0gbW9kZWwgYnkgY3JlYXRlIGRlZXAgY29weSBvZiBhc3NpZ25tZW50cG9sbCBvYmplY3RcbiAgICAgICAgLy8gc28gZGV0YWlsIHZpZXcgaXMgbm90IHVwZGF0ZWQgd2hpbGUgZWRpdGluZyBwb2xsXG4gICAgICAgIHZhciBhc3NpZ25tZW50cG9sbCA9IGFuZ3VsYXIuY29weShBc3NpZ25tZW50UG9sbC5nZXQoYXNzaWdubWVudHBvbGxJZCkpO1xuICAgICAgICAkc2NvcGUubW9kZWwgPSBhc3NpZ25tZW50cG9sbDtcbiAgICAgICAgJHNjb3BlLmJhbGxvdCA9IGJhbGxvdDtcbiAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHMgPSBbXTtcbiAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge307XG5cbiAgICAgICAgLy8gRm9yIG51bWJlciBpbnB1dHNcbiAgICAgICAgdmFyIHN0ZXAgPSBNYXRoLnBvdygxMCwgLUFzc2lnbm1lbnRQb2xsRGVjaW1hbFBsYWNlcy5nZXRQbGFjZXMoYXNzaWdubWVudHBvbGwpKTtcblxuICAgICAgICAvLyBhZGQgZHluYW1pYyBmb3JtIGZpZWxkc1xuICAgICAgICB2YXIgb3B0aW9ucyA9ICRmaWx0ZXIoJ29yZGVyQnknKShhc3NpZ25tZW50cG9sbC5vcHRpb25zLCAnd2VpZ2h0Jyk7XG4gICAgICAgIF8uZm9yRWFjaChvcHRpb25zLCBmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICBpZiAoYXNzaWdubWVudHBvbGwucG9sbG1ldGhvZCA9PSAneW5hJyB8fCBhc3NpZ25tZW50cG9sbC5wb2xsbWV0aG9kID09ICd5bicpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSB7fTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2gob3B0aW9uLnZvdGVzLCBmdW5jdGlvbiAodm90ZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVbdm90ZS52YWx1ZS50b0xvd2VyQ2FzZSgpXSA9IHZvdGUud2VpZ2h0O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbkNsYXNzID0gKGFzc2lnbm1lbnRwb2xsLnBvbGxtZXRob2QgPT09ICd5bmEnKSA/ICdjb2wteHMtNCcgOiAnY29sLXhzLTYnO1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICd5ZXNfJyArIG9wdGlvbi5jYW5kaWRhdGVfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjb2x1bW5DbGFzcyArICcgbm8tcGFkZGluZy1sZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1llcycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogLTIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLnllc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdub18nICsgb3B0aW9uLmNhbmRpZGF0ZV9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNvbHVtbkNsYXNzICsgJyBuby1wYWRkaW5nLWxlZnQnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYXNzaWdubWVudHBvbGwucG9sbG1ldGhvZCA9PT0gJ3luJyA/ICcgbm8tcGFkZGluZy1yaWdodCcgOiAnJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdObycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogLTIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLm5vXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGlmIChhc3NpZ25tZW50cG9sbC5wb2xsbWV0aG9kID09ICd5bmEnKXtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTonYWJzdGFpbl8nICsgb3B0aW9uLmNhbmRpZGF0ZV9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNvbHVtbkNsYXNzICsgJyBuby1wYWRkaW5nLWxlZnQgbm8tcGFkZGluZy1yaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdBYnN0YWluJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluOiAtMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUuYWJzdGFpblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5vRm9ybUNvbnRyb2w6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPHN0cm9uZz4nICsgb3B0aW9uLmNhbmRpZGF0ZS5nZXRfZnVsbF9uYW1lKCkgKyAnPC9zdHJvbmc+J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdyb3cnLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZEdyb3VwOiBjb2x1bW5zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gdm90ZXMgbWV0aG9kXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbi52b3Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gb3B0aW9uLnZvdGVzWzBdLndlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ3ZvdGVfJyArIG9wdGlvbi5jYW5kaWRhdGVfaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG9wdGlvbi5jYW5kaWRhdGUuZ2V0X2Z1bGxfbmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW46IC0yLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFzc2lnbm1lbnRwb2xsLnBvbGxtZXRob2QgPT0gJ3ZvdGVzJyl7XG4gICAgICAgICAgICAkc2NvcGUuZm9ybUZpZWxkcy5wdXNoKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAndm90ZXNhYnN0YWluJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdBYnN0YWluJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW46IC0yLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ3ZvdGVzbm8nLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ05vJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW46IC0yLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgZ2VuZXJhbCBmb3JtIGZpZWxkc1xuICAgICAgICAkc2NvcGUuZm9ybUZpZWxkcy5wdXNoKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPGhyIGNsYXNzPVwic21hbGxoclwiPicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtleTogJ3ZvdGVzdmFsaWQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1ZhbGlkIGJhbGxvdHMnKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgICAgICAgICAgICAgIG1pbjogLTIsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBrZXk6ICd2b3Rlc2ludmFsaWQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0ludmFsaWQgYmFsbG90cycpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgbWluOiAtMixcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtleTogJ3ZvdGVzY2FzdCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQ2FzdGVkIGJhbGxvdHMnKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgICAgICAgICAgICAgIG1pbjogLTIsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNhdmUgYXNzaWdubWVudHBvbGxcbiAgICAgICAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbiAocG9sbCkge1xuICAgICAgICAgICAgdmFyIHZvdGVzID0gW107XG4gICAgICAgICAgICBpZiAoYXNzaWdubWVudHBvbGwucG9sbG1ldGhvZCA9PSAneW5hJykge1xuICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRwb2xsLm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdm90ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnWWVzJzogcG9sbFsneWVzXycgKyBvcHRpb24uY2FuZGlkYXRlX2lkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdObyc6IHBvbGxbJ25vXycgKyBvcHRpb24uY2FuZGlkYXRlX2lkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBYnN0YWluJzogcG9sbFsnYWJzdGFpbl8nICsgb3B0aW9uLmNhbmRpZGF0ZV9pZF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFzc2lnbm1lbnRwb2xsLnBvbGxtZXRob2QgPT0gJ3luJykge1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50cG9sbC5vcHRpb25zLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2b3Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWWVzJzogcG9sbFsneWVzXycgKyBvcHRpb24uY2FuZGlkYXRlX2lkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTm8nOiBwb2xsWydub18nICsgb3B0aW9uLmNhbmRpZGF0ZV9pZF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NpZ25tZW50cG9sbC5vcHRpb25zLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZvdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1ZvdGVzJzogcG9sbFsndm90ZV8nICsgb3B0aW9uLmNhbmRpZGF0ZV9pZF0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2F2ZSBjaGFuZ2UgcG9sbCBvYmplY3Qgb24gc2VydmVyXG4gICAgICAgICAgICBwb2xsLkRTVXBkYXRlKHtcbiAgICAgICAgICAgICAgICBhc3NpZ25tZW50X2lkOiBwb2xsLmFzc2lnbm1lbnRfaWQsXG4gICAgICAgICAgICAgICAgdm90ZXM6IHZvdGVzLFxuICAgICAgICAgICAgICAgIHZvdGVzYWJzdGFpbjogcG9sbC52b3Rlc2Fic3RhaW4sXG4gICAgICAgICAgICAgICAgdm90ZXNubzogcG9sbC52b3Rlc25vLFxuICAgICAgICAgICAgICAgIHZvdGVzdmFsaWQ6IHBvbGwudm90ZXN2YWxpZCxcbiAgICAgICAgICAgICAgICB2b3Rlc2ludmFsaWQ6IHBvbGwudm90ZXNpbnZhbGlkLFxuICAgICAgICAgICAgICAgIHZvdGVzY2FzdDogcG9sbC52b3Rlc2Nhc3QsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICRzY29wZS5hbGVydC5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlVGhpc0RpYWxvZygpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi8vbWFyayBhbGwgYXNzaWdubWVudCBjb25maWcgc3RyaW5ncyBmb3IgdHJhbnNsYXRpb24gd2l0aCBKYXZhc2NyaXB0XG4uY29uZmlnKFtcbiAgICAnZ2V0dGV4dCcsXG4gICAgZnVuY3Rpb24gKGdldHRleHQpIHtcbiAgICAgICAgZ2V0dGV4dCgnRWxlY3Rpb24gbWV0aG9kJyk7XG4gICAgICAgIGdldHRleHQoJ0F1dG9tYXRpYyBhc3NpZ24gb2YgbWV0aG9kJyk7XG4gICAgICAgIGdldHRleHQoJ0Fsd2F5cyBvbmUgb3B0aW9uIHBlciBjYW5kaWRhdGUnKTtcbiAgICAgICAgZ2V0dGV4dCgnQWx3YXlzIFllcy1Oby1BYnN0YWluIHBlciBjYW5kaWRhdGUnKTtcbiAgICAgICAgZ2V0dGV4dCgnQWx3YXlzIFllcy9ObyBwZXIgY2FuZGlkYXRlJyk7XG4gICAgICAgIGdldHRleHQoJ0VsZWN0aW9ucycpO1xuICAgICAgICBnZXR0ZXh0KCdCYWxsb3QgYW5kIGJhbGxvdCBwYXBlcnMnKTtcbiAgICAgICAgZ2V0dGV4dCgnVGhlIDEwMC0lLWJhc2Ugb2YgYW4gZWxlY3Rpb24gcmVzdWx0IGNvbnNpc3RzIG9mJyk7XG4gICAgICAgIGdldHRleHQoJ0ZvciBZZXMvTm8vQWJzdGFpbiBwZXIgY2FuZGlkYXRlIGFuZCBZZXMvTm8gcGVyIGNhbmRpZGF0ZSB0aGUgMTAwLSUtYmFzZSAnICtcbiAgICAgICAgICAgICAgICAnZGVwZW5kcyBvbiB0aGUgZWxlY3Rpb24gbWV0aG9kOiBJZiB0aGVyZSBpcyBvbmx5IG9uZSBvcHRpb24gcGVyIGNhbmRpZGF0ZSwgJyArXG4gICAgICAgICAgICAgICAgJ3RoZSBzdW0gb2YgYWxsIHZvdGVzIG9mIGFsbCBjYW5kaWRhdGVzIGlzIDEwMCAlLiBPdGhlcndpc2UgZm9yIGVhY2ggJyArXG4gICAgICAgICAgICAgICAgJ2NhbmRpZGF0ZSB0aGUgc3VtIG9mIGFsbCB2b3RlcyBpcyAxMDAgJS4nKTtcbiAgICAgICAgZ2V0dGV4dCgnWWVzL05vL0Fic3RhaW4gcGVyIGNhbmRpZGF0ZScpO1xuICAgICAgICBnZXR0ZXh0KCdZZXMvTm8gcGVyIGNhbmRpZGF0ZScpO1xuICAgICAgICBnZXR0ZXh0KCdBbGwgdmFsaWQgYmFsbG90cycpO1xuICAgICAgICBnZXR0ZXh0KCdBbGwgY2FzdGVkIGJhbGxvdHMnKTtcbiAgICAgICAgZ2V0dGV4dCgnRGlzYWJsZWQgKG5vIHBlcmNlbnRzKScpO1xuICAgICAgICBnZXR0ZXh0KCdOdW1iZXIgb2YgYmFsbG90IHBhcGVycyAoc2VsZWN0aW9uKScpO1xuICAgICAgICBnZXR0ZXh0KCdOdW1iZXIgb2YgYWxsIGRlbGVnYXRlcycpO1xuICAgICAgICBnZXR0ZXh0KCdOdW1iZXIgb2YgYWxsIHBhcnRpY2lwYW50cycpO1xuICAgICAgICBnZXR0ZXh0KCdVc2UgdGhlIGZvbGxvd2luZyBjdXN0b20gbnVtYmVyJyk7XG4gICAgICAgIGdldHRleHQoJ0N1c3RvbSBudW1iZXIgb2YgYmFsbG90IHBhcGVycycpO1xuICAgICAgICBnZXR0ZXh0KCdSZXF1aXJlZCBtYWpvcml0eScpO1xuICAgICAgICBnZXR0ZXh0KCdEZWZhdWx0IG1ldGhvZCB0byBjaGVjayB3aGV0aGVyIGEgY2FuZGlkYXRlIGhhcyByZWFjaGVkIHRoZSByZXF1aXJlZCBtYWpvcml0eS4nKTtcbiAgICAgICAgZ2V0dGV4dCgnU2ltcGxlIG1ham9yaXR5Jyk7XG4gICAgICAgIGdldHRleHQoJ1R3by10aGlyZHMgbWFqb3JpdHknKTtcbiAgICAgICAgZ2V0dGV4dCgnVGhyZWUtcXVhcnRlcnMgbWFqb3JpdHknKTtcbiAgICAgICAgZ2V0dGV4dCgnRGlzYWJsZWQnKTtcbiAgICAgICAgZ2V0dGV4dCgnUHV0IGFsbCBjYW5kaWRhdGVzIG9uIHRoZSBsaXN0IG9mIHNwZWFrZXJzJyk7XG4gICAgICAgIGdldHRleHQoJ1RpdGxlIGZvciBQREYgZG9jdW1lbnQgKGFsbCBlbGVjdGlvbnMpJyk7XG4gICAgICAgIGdldHRleHQoJ1ByZWFtYmxlIHRleHQgZm9yIFBERiBkb2N1bWVudCAoYWxsIGVsZWN0aW9ucyknKTtcbiAgICAgICAgLy9vdGhlciB0cmFuc2xhdGlvbnNcbiAgICAgICAgZ2V0dGV4dCgnU2VhcmNoaW5nIGZvciBjYW5kaWRhdGVzJyk7XG4gICAgICAgIGdldHRleHQoJ1ZvdGluZycpO1xuICAgICAgICBnZXR0ZXh0KCdGaW5pc2hlZCcpO1xuICAgIH1cbl0pO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgY29yZSBtb2R1bGUgdXNlZCBmb3IgdGhlIE9wZW5TbGlkZXMgc2l0ZSBhbmQgdGhlIHByb2plY3RvclxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAuY29yZScsIFtcbiAgICAnanMtZGF0YScsXG4gICAgJ2dldHRleHQnLFxuICAgICduZ0FuaW1hdGUnLFxuICAgICduZ0Jvb3Rib3gnLFxuICAgICduZ1Nhbml0aXplJywgIC8vIFRPRE86IG9ubHkgdXNlIHRoaXMgaW4gZnVuY3Rpb25zIHRoYXQgbmVlZCBpdC5cbiAgICAnbmdTdG9yYWdlJyxcbiAgICAndWkuYm9vdHN0cmFwJyxcbiAgICAndWkuYm9vdHN0cmFwLmRhdGV0aW1lcGlja2VyJyxcbiAgICAndWkudHJlZScsXG4gICAgJ3BkZicsXG4gICAgJ09wZW5TbGlkZXNBcHAtdGVtcGxhdGVzJyxcbl0pXG5cbi5jb25maWcoW1xuICAgICdEU1Byb3ZpZGVyJyxcbiAgICAnRFNIdHRwQWRhcHRlclByb3ZpZGVyJyxcbiAgICBmdW5jdGlvbihEU1Byb3ZpZGVyLCBEU0h0dHBBZGFwdGVyUHJvdmlkZXIpIHtcbiAgICAgICAgRFNQcm92aWRlci5kZWZhdWx0cy5yZWFwQWN0aW9uID0gJ25vbmUnO1xuICAgICAgICBEU1Byb3ZpZGVyLmRlZmF1bHRzLmJhc2VQYXRoID0gJy9yZXN0JztcbiAgICAgICAgRFNQcm92aWRlci5kZWZhdWx0cy5hZnRlclJlYXAgPSBmdW5jdGlvbihtb2RlbCwgaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiA1KSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuZmluZEFsbCh7fSwge2J5cGFzc0NhY2hlOiB0cnVlfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwucmVmcmVzaChpdGVtW21vZGVsLmlkQXR0cmlidXRlXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERTSHR0cEFkYXB0ZXJQcm92aWRlci5kZWZhdWx0cy5mb3JjZVRyYWlsaW5nU2xhc2ggPSB0cnVlO1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdQcm9qZWN0b3JJRCcsIFtcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gL3Byb2plY3RvclxcLyhcXGQrKVxcLy8uZXhlYyhsb2NhdGlvbi5wYXRobmFtZSlbMV07XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbmZpZyhbXG4gICAgJyRzZXNzaW9uU3RvcmFnZVByb3ZpZGVyJyxcbiAgICBmdW5jdGlvbiAoJHNlc3Npb25TdG9yYWdlUHJvdmlkZXIpIHtcbiAgICAgICAgJHNlc3Npb25TdG9yYWdlUHJvdmlkZXIuc2V0S2V5UHJlZml4KCdPcGVuU2xpZGVzJyk7XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ2F1dG91cGRhdGUnLCBbXG4gICAgJ0RTJyxcbiAgICAnUkVBTE0nLFxuICAgICdQcm9qZWN0b3JJRCcsXG4gICAgJyRxJyxcbiAgICAnJHRpbWVvdXQnLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uIChEUywgUkVBTE0sIFByb2plY3RvcklELCAkcSwgJHRpbWVvdXQsIEVycm9yTWVzc2FnZSkge1xuICAgICAgICB2YXIgc29ja2V0ID0gbnVsbDtcbiAgICAgICAgdmFyIHJldHJ5Q29ubmVjdENhbGxiYWNrcyA9IFtdO1xuXG4gICAgICAgIHZhciB3ZWJzb2NrZXRQcm90b2NvbDtcbiAgICAgICAgaWYgKGxvY2F0aW9uLnByb3RvY29sID09ICdodHRwczonKSB7XG4gICAgICAgICAgICB3ZWJzb2NrZXRQcm90b2NvbCA9ICd3c3M6JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlYnNvY2tldFByb3RvY29sID0gJ3dzOic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2Vic29ja2V0UGF0aDtcbiAgICAgICAgaWYgKFJFQUxNID09PSAnc2l0ZScpIHtcbiAgICAgICAgICB3ZWJzb2NrZXRQYXRoID0gJy93cy9zaXRlLyc7XG4gICAgICAgIH0gZWxzZSBpZiAoUkVBTE0gPT09ICdwcm9qZWN0b3InKSB7XG4gICAgICAgICAgd2Vic29ja2V0UGF0aCA9ICcvd3MvcHJvamVjdG9yLycgKyBQcm9qZWN0b3JJRCgpICsgJy8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSBjb25zdGFudCBSRUFMTSBpcyBub3Qgc2V0IHByb3Blcmx5LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGEgcmFuZG9tIHJldHJ5IHRpbWVvdXQgYmV0d2VlbiAyMDAwIGFuZCA1MDAwIG1zLlxuICAgICAgICB2YXIgZ2V0VGltZW91dFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMzAwMCArIDIwMDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qIFRoZSBjYWxsYmFja3MgYXJlIGludm9rZWQgaWYgdGhlIHdzIGNvbm5lY3Rpb24gY2xvc2VkIGFuZCB0aGlzIGZhY3RvcnkgdHJpZXMgdG9cbiAgICAgICAgICogcmVjb25uZWN0IGFmdGVyIDEgc2Vjb25kLiBUaGUgY2FsbGJhY2tzIHNob3VsZCByZXR1cm4gYSBwcm9taXNlLiBJZiB0aGUgcHJvbWlzZVxuICAgICAgICAgKiByZXNvbHZlcywgdGhlIHJldHJ5LXByb2Nlc3MgaXMgc3RvcHBlZCwgc28gdGhlIGNhbGxiYWNrIGNhbiBpbmRpY2F0ZSB3aGV0aGVyIGl0XG4gICAgICAgICAqIGhhcyBtYW5hZ2VkIHRoZSByZWNvbm5lY3RpbmcgZGlmZmVyZW50LiovXG4gICAgICAgIHZhciBydW5SZXRyeUNvbm5lY3RDYWxsYmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tQcm9taXNlcyA9IF8ubWFwKHJldHJ5Q29ubmVjdENhbGxiYWNrcywgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRxLmFsbChjYWxsYmFja1Byb21pc2VzKS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgRXJyb3JNZXNzYWdlLmNsZWFyQ29ubmVjdGlvbkVycm9yKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkdGltZW91dChydW5SZXRyeUNvbm5lY3RDYWxsYmFja3MsIGdldFRpbWVvdXRUaW1lKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIEF1dG91cGRhdGUgPSB7fTtcbiAgICAgICAgQXV0b3VwZGF0ZS5tZXNzYWdlUmVjZWl2ZXJzID0gW107XG4gICAgICAgIC8vIFdlIHVzZSBsYXRlciBhIHByb21pc2UgdG8gZGVmZXIgdGhlIGZpcnN0IG1lc3NhZ2Ugb2YgdGhlIGVzdGFibGlzaGVkIHdzIGNvbm5lY3Rpb24uXG4gICAgICAgIEF1dG91cGRhdGUuZmlyc3RNZXNzYWdlRGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICBBdXRvdXBkYXRlLm9uTWVzc2FnZSA9IGZ1bmN0aW9uIChyZWNlaXZlcikge1xuICAgICAgICAgICAgQXV0b3VwZGF0ZS5tZXNzYWdlUmVjZWl2ZXJzLnB1c2gocmVjZWl2ZXIpO1xuICAgICAgICB9O1xuICAgICAgICBBdXRvdXBkYXRlLm5ld0Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHdlYnNvY2tldFByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QgKyB3ZWJzb2NrZXRQYXRoKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc2h1cmUgdGhlIHNlcnZlcnMgc3RhdGUgaGFzbid0IGNoYW5nZWQ6IFNlbmQgYSB3aG9hbWkgcmVxdWVzdC4gSWYgbm8gdXNlcnMgaXMgbG9nZ2VkIGFuZFxuICAgICAgICAgICAgLy8gYW5vbnltb3VzIGFyZSBkZWFjdGl2YXRlZCwgcmVib290IHRoZSBjbGllbnQgaW4gZmFjdCB0aGF0IHRoZSBzZXJ2ZXIgaGFzIGxvc3QgYWxsIGxvZ2luIGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgc29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jb2RlICE9PSAxMDAwKSB7IC8vIDEwMDAgaXMgYSBub3JtYWwgY2xvc2UsIGxpa2UgdGhlIGNsb3NlIG9uIGxvZ291dFxuICAgICAgICAgICAgICAgICAgICBFcnJvck1lc3NhZ2Uuc2V0Q29ubmVjdGlvbkVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR0aW1lb3V0KHJ1blJldHJ5Q29ubmVjdENhbGxiYWNrcywgZ2V0VGltZW91dFRpbWUoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFMaXN0ID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKEF1dG91cGRhdGUubWVzc2FnZVJlY2VpdmVycywgZnVuY3Rpb24gKHJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlcihkYXRhTGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHByb21pc2UgaXMgbm90IHJlc29sdmVkIHlldC5cbiAgICAgICAgICAgICAgICBpZiAoQXV0b3VwZGF0ZS5maXJzdE1lc3NhZ2VEZWZlcnJlZC5wcm9taXNlLiQkc3RhdGUuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIEF1dG91cGRhdGUuZmlyc3RNZXNzYWdlRGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBFcnJvck1lc3NhZ2UuY2xlYXJDb25uZWN0aW9uRXJyb3IoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIEF1dG91cGRhdGUuc2VuZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBdXRvdXBkYXRlLmNsb3NlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEF1dG91cGRhdGUuZmlyc3RNZXNzYWdlRGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICB9O1xuICAgICAgICBBdXRvdXBkYXRlLnJlZ2lzdGVyUmV0cnlDb25uZWN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHJ5Q29ubmVjdENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEF1dG91cGRhdGU7XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ29wZXJhdG9yJywgW1xuICAgICdVc2VyJyxcbiAgICAnR3JvdXAnLFxuICAgIGZ1bmN0aW9uIChVc2VyLCBHcm91cCkge1xuICAgICAgICB2YXIgc2V0VXNlckNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB7XG4gICAgICAgICAgICB1c2VyOiBudWxsLFxuICAgICAgICAgICAgcGVybXM6IFtdLFxuICAgICAgICAgICAgaXNBdXRoZW50aWNhdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdGhpcy51c2VyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFVzZXI6IGZ1bmN0aW9uKHVzZXJfaWQsIHVzZXJfZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICh1c2VyX2lkICYmIHVzZXJfZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvci51c2VyID0gVXNlci5pbmplY3QodXNlcl9kYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvci51c2VyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3BlcmF0b3IucmVsb2FkUGVybXMoKTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goc2V0VXNlckNhbGxiYWNrcywgZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKG9wZXJhdG9yLnVzZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgb3BlcmF0b3IgaGFzIGF0IGxlYXN0IG9uZSBwZXJtIG9mIHRoZSBwZXJtcy1saXN0LlxuICAgICAgICAgICAgaGFzUGVybXM6IGZ1bmN0aW9uKHBlcm1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwZXJtcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVybXMgPSBwZXJtcy5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXy5pbnRlcnNlY3Rpb24ocGVybXMsIG9wZXJhdG9yLnBlcm1zKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbG9hZFBlcm1zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IucGVybXMgPSBvcGVyYXRvci51c2VyLmdldFBlcm1zKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRHcm91cCA9IEdyb3VwLmdldCgxKTtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IucGVybXMgPSBkZWZhdWx0R3JvdXAgPyBkZWZhdWx0R3JvdXAucGVybWlzc2lvbnMgOiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBvcGVyYXRvciBpcyBhIG1lbWJlciBvZiBncm91cC5cbiAgICAgICAgICAgIGlzSW5Hcm91cDogZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBzID0gb3BlcmF0b3IudXNlci5ncm91cHNfaWQ7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3Vwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzID0gWzFdOyAvLyBTZXQgdGhlIGRlZmF1bHQgZ3JvdXAsIGlmIG5vIG90aGVyIGdyb3VwcyBhcmUgc2V0LlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXy5pbmRleE9mKGdyb3VwcywgZ3JvdXAuaWQpID4gLTE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVnaXN0ZXJTZXRVc2VyQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHNldFVzZXJDYWxsYmFja3MucHVzaChjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3BlcmF0b3I7XG4gICAgfVxuXSlcblxuLy8gZ2V0cyBhbGwgaW4gT3BlblNsaWRlcyBhdmFpbGFibGUgbGFuZ3VhZ2VzXG4uZmFjdG9yeSgnTGFuZ3VhZ2VzJywgW1xuICAgICckc2Vzc2lvblN0b3JhZ2UnLFxuICAgICckbmdCb290Ym94JyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnT3BlblNsaWRlc1BsdWdpbnMnLFxuICAgIGZ1bmN0aW9uICgkc2Vzc2lvblN0b3JhZ2UsICRuZ0Jvb3Rib3gsIGdldHRleHQsIGdldHRleHRDYXRhbG9nLCBPcGVuU2xpZGVzUGx1Z2lucykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gZ2V0IGFsbCBhdmFpbGFibGUgbGFuZ3VhZ2VzXG4gICAgICAgICAgICBnZXRMYW5ndWFnZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9ICRzZXNzaW9uU3RvcmFnZS5sYW5ndWFnZTtcbiAgICAgICAgICAgICAgICAvLyBEZWZpbmUgaGVyZSBuZXcgbGFuZ3VhZ2VzLi4uXG4gICAgICAgICAgICAgICAgdmFyIGxhbmd1YWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgeyBjb2RlOiAnZW4nLCBuYW1lOiAnRW5nbGlzaCcgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBjb2RlOiAnZGUnLCBuYW1lOiAnRGV1dHNjaCcgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBjb2RlOiAnZnInLCBuYW1lOiAnRnJhbsOnYWlzJyB9LFxuICAgICAgICAgICAgICAgICAgICB7IGNvZGU6ICdlcycsIG5hbWU6ICdFc3Bhw7FvbCcgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBjb2RlOiAncHQnLCBuYW1lOiAnUG9ydHVndcOqcycgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBjb2RlOiAnY3MnLCBuYW1lOiAnxIxlxaF0aW5hJ30sXG4gICAgICAgICAgICAgICAgICAgIHsgY29kZTogJ3J1JywgbmFtZTogJ9GA0YPRgdGB0LrQuNC5J30sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gobGFuZ3VhZ2VzLCBmdW5jdGlvbiAobGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlLmNvZGUgPT0gY3VycmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGdldCBkZXRlY3RlZCBicm93c2VyIGxhbmd1YWdlIGNvZGVcbiAgICAgICAgICAgIGdldEJyb3dzZXJMYW5ndWFnZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBsYW5nID0gbmF2aWdhdG9yLmxhbmd1YWdlIHx8IG5hdmlnYXRvci51c2VyTGFuZ3VhZ2U7XG4gICAgICAgICAgICAgICAgaWYgKCFuYXZpZ2F0b3IubGFuZ3VhZ2UgJiYgIW5hdmlnYXRvci51c2VyTGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZyA9ICdlbic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmcuaW5kZXhPZignLScpICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmcgPSBsYW5nLnNwbGl0KCctJylbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5nLmluZGV4T2YoJ18nKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5nID0gbGFuZy5zcGxpdCgnXycpWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBzZXQgY3VycmVudCBsYW5ndWFnZSBhbmQgcmV0dXJuIHVwZGF0ZWQgbGFuZ3VhZ2VzIG9iamVjdCBhcnJheVxuICAgICAgICAgICAgc2V0Q3VycmVudExhbmd1YWdlOiBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICAgICAgICAgIHZhciBsYW5ndWFnZXMgPSB0aGlzLmdldExhbmd1YWdlcygpO1xuICAgICAgICAgICAgICAgIHZhciBwbHVnaW5zID0gT3BlblNsaWRlc1BsdWdpbnMuZ2V0QWxsKCk7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGxhbmd1YWdlcywgZnVuY3Rpb24gKGxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZS5jb2RlID09IGxhbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzZXNzaW9uU3RvcmFnZS5sYW5ndWFnZSA9IGxhbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXh0Q2F0YWxvZy5zZXRDdXJyZW50TGFuZ3VhZ2UobGFuZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQbHVnaW5zXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFuZyAhPSAnZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGV4dENhdGFsb2cubG9hZFJlbW90ZShcInN0YXRpYy9pMThuL1wiICsgbGFuZyArIFwiLmpzb25cIikudGhlbihmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2xhdGUgbmctYm9vdGJveCBkaXJlY3RpdmVzIHdoZW4gdGhlIHRyYW5zbGF0aW9ucyBhcmUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbmdCb290Ym94LmFkZExvY2FsZShsYW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPSzogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdPSycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0FOQ0VMOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0NhbmNlbCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09ORklSTTogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdPSycpLCAvLyBZZXMsICdPSycgaXMgdGhlIG9yaWdpbmFsIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRuZ0Jvb3Rib3guc2V0TG9jYWxlKGxhbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvYWQgbGFuZ3VhZ2UgZmlsZXMgZnJvbSBwbHVnaW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHBsdWdpbnMsIGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5sYW5ndWFnZXMuaW5kZXhPZihsYW5nKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGV4dENhdGFsb2cubG9hZFJlbW90ZShcInN0YXRpYy9pMThuL1wiICsgcGx1Z2luLm5hbWUgKyAnLycgKyBsYW5nICsgXCIuanNvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4vLyBIb29rIGludG8gZ2V0dGV4dENhdGFsb2cgdG8gaW5jbHVkZSBjdXN0b20gdHJhbnNsYXRpb25zIGJ5IHdyYXBwaW5nXG4vLyB0aGUgZ2V0U3RyaW5nIG1ldGhvZC4gVGhlIHRyYW5zbGF0aW9ucyBhcmUgc3RvcmVkIGluIHRoZSBjb25maWcuXG4uZGVjb3JhdG9yKCdnZXR0ZXh0Q2F0YWxvZycsIFtcbiAgICAnJGRlbGVnYXRlJyxcbiAgICAnJHJvb3RTY29wZScsXG4gICAgZnVuY3Rpb24gKCRkZWxlZ2F0ZSwgJHJvb3RTY29wZSkge1xuICAgICAgICB2YXIgb2xkR2V0U3RyaW5nID0gJGRlbGVnYXRlLmdldFN0cmluZztcbiAgICAgICAgdmFyIGN1c3RvbVRyYW5zbGF0aW9ucyA9IHt9O1xuXG4gICAgICAgICRkZWxlZ2F0ZS5nZXRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRlZCA9IG9sZEdldFN0cmluZy5hcHBseSgkZGVsZWdhdGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoY3VzdG9tVHJhbnNsYXRpb25zW3RyYW5zbGF0ZWRdKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZCA9IGN1c3RvbVRyYW5zbGF0aW9uc1t0cmFuc2xhdGVkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVkO1xuICAgICAgICB9O1xuICAgICAgICAkZGVsZWdhdGUuc2V0Q3VzdG9tVHJhbnNsYXRpb25zID0gZnVuY3Rpb24gKHRyYW5zbGF0aW9ucykge1xuICAgICAgICAgICAgY3VzdG9tVHJhbnNsYXRpb25zID0gdHJhbnNsYXRpb25zO1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdnZXR0ZXh0TGFuZ3VhZ2VDaGFuZ2VkJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICRkZWxlZ2F0ZTtcbiAgICB9XG5dKVxuXG4ucnVuKFtcbiAgICAnJHJvb3RTY29wZScsXG4gICAgJ0NvbmZpZycsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICBmdW5jdGlvbiAoJHJvb3RTY29wZSwgQ29uZmlnLCBnZXR0ZXh0Q2F0YWxvZykge1xuICAgICAgICAkcm9vdFNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29uZmlnLmxhc3RNb2RpZmllZCgndHJhbnNsYXRpb25zJyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGlvbnMgPSBDb25maWcuZ2V0KCd0cmFuc2xhdGlvbnMnKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VzdG9tVHJhbnNsYXRpb25zID0ge307XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKHRyYW5zbGF0aW9ucy52YWx1ZSwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVRyYW5zbGF0aW9uc1tlbnRyeS5vcmlnaW5hbF0gPSBlbnRyeS50cmFuc2xhdGlvbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYWxsIHRyYW5zbGF0ZSBkaXJlY3RpdmVzXG4gICAgICAgICAgICAgICAgZ2V0dGV4dENhdGFsb2cuc2V0Q3VzdG9tVHJhbnNsYXRpb25zKGN1c3RvbVRyYW5zbGF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi8vIHNldCBicm93c2VyIGxhbmd1YWdlIGFzIGRlZmF1bHQgbGFuZ3VhZ2UgZm9yIE9wZW5TbGlkZXNcbi5ydW4oW1xuICAgICckc2Vzc2lvblN0b3JhZ2UnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0xhbmd1YWdlcycsXG4gICAgZnVuY3Rpb24oJHNlc3Npb25TdG9yYWdlLCBnZXR0ZXh0Q2F0YWxvZywgTGFuZ3VhZ2VzKSB7XG4gICAgICAgIC8vIHNldCBkZXRlY3RlZCBicm93c2VyIGxhbmd1YWdlIGFzIGRlZmF1bHQgbGFuZ3VhZ2UgKGZhbGxiYWNrOiAnZW4nKVxuICAgICAgICBpZiAoJHNlc3Npb25TdG9yYWdlLmxhbmd1YWdlKSB7XG4gICAgICAgICAgICBMYW5ndWFnZXMuc2V0Q3VycmVudExhbmd1YWdlKCRzZXNzaW9uU3RvcmFnZS5sYW5ndWFnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBMYW5ndWFnZXMuc2V0Q3VycmVudExhbmd1YWdlKExhbmd1YWdlcy5nZXRCcm93c2VyTGFuZ3VhZ2UoKSk7XG4gICAgICAgIH0gICBcbiAgICAgICAgLy8gU2V0IHRoaXMgdG8gdHJ1ZSBmb3IgZGVidWcuIEhlbHBzIHRvIGZpbmQgdW50cmFuc2xhdGVkIHN0cmluZ3MgYnlcbiAgICAgICAgLy8gYWRkaW5nIFwiW01JU1NJTkddOlwiLlxuICAgICAgICBnZXR0ZXh0Q2F0YWxvZy5kZWJ1ZyA9IGZhbHNlO1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdkc0VqZWN0JywgW1xuICAgICdEUycsXG4gICAgZnVuY3Rpb24gKERTKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBSZXNvdXJjZSA9IERTLmRlZmluaXRpb25zW2NvbGxlY3Rpb25dO1xuICAgICAgICAgICAgaWYgKFJlc291cmNlLnJlbGF0aW9uTGlzdCkge1xuICAgICAgICAgICAgICAgIFJlc291cmNlLnJlbGF0aW9uTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGlvbkRlZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVsYXRpb25EZWYuZm9yZWlnbktleSAmJiAhcmVsYXRpb25EZWYub3NQcm90ZWN0ZWRSZWxhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVtyZWxhdGlvbkRlZi5mb3JlaWduS2V5XSA9IGluc3RhbmNlW1Jlc291cmNlLmlkQXR0cmlidXRlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlc291cmNlLmdldFJlc291cmNlKHJlbGF0aW9uRGVmLnJlbGF0aW9uKS5lamVjdEFsbChxdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4ucnVuKFtcbiAgICAnRFMnLFxuICAgICdhdXRvdXBkYXRlJyxcbiAgICAnZHNFamVjdCcsXG4gICAgZnVuY3Rpb24gKERTLCBhdXRvdXBkYXRlLCBkc0VqZWN0KSB7XG4gICAgICAgIC8vIEhhbmRsZXIgZm9yIG5vcm1hbCBhdXRvdXBkYXRlIG1lc3NhZ2VzLlxuICAgICAgICBhdXRvdXBkYXRlLm9uTWVzc2FnZShmdW5jdGlvbihkYXRhTGlzdCkge1xuICAgICAgICAgICAgdmFyIGRhdGFMaXN0QnlDb2xsZWN0aW9uID0gXy5ncm91cEJ5KGRhdGFMaXN0LCAnY29sbGVjdGlvbicpO1xuICAgICAgICAgICAgXy5mb3JFYWNoKGRhdGFMaXN0QnlDb2xsZWN0aW9uLCBmdW5jdGlvbiAobGlzdCwga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZWRFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBkZWxldGVkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvblN0cmluZyA9IGtleTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2gobGlzdCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5jb21tZW50IHRoaXMgbGluZSBmb3IgZGVidWdnaW5nIHRvIGxvZyBhbGwgYXV0b3VwZGF0ZXM6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiUmVjZWl2ZWQgb2JqZWN0OiBcIiArIGRhdGEuY29sbGVjdGlvbiArIFwiLCBcIiArIGRhdGEuaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyBoYW5kbGUgYXV0b3VwZGF0ZSBtZXNzYWdlIGJ1dCBkbyBub3QgaGFuZGxlIG5vdGlmeSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuY29sbGVjdGlvbiAhPT0gJ25vdGlmeScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSAoPWVqZWN0KSBvYmplY3QgZnJvbSBsb2NhbCBEUyBzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gRFMuZ2V0KGRhdGEuY29sbGVjdGlvbiwgZGF0YS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkc0VqZWN0KGRhdGEuY29sbGVjdGlvbiwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgb2JqZWN0IGNoYW5nZWQgb3IgZGVsZXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuYWN0aW9uID09PSAnY2hhbmdlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkRWxlbWVudHMucHVzaChkYXRhLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLmFjdGlvbiA9PT0gJ2RlbGV0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEVsZW1lbnRzLnB1c2goZGF0YS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yOiBVbmRlZmluZWQgYWN0aW9uIGZvciByZWNlaXZlZCBvYmplY3QnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgZGF0YS5jb2xsZWN0aW9uICsgJywgJyArIGRhdGEuaWQgKyAnKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gYWRkICg9aW5qZWN0KSBhbGwgZ2l2ZW4gb2JqZWN0cyBpbnRvIGxvY2FsIERTIHN0b3JlXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIERTLmluamVjdChjb2xsZWN0aW9uU3RyaW5nLCBjaGFuZ2VkRWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgKD1lamVjdCkgYWxsIGdpdmVuIG9iamVjdHMgZnJvbSBsb2NhbCBEUyBzdG9yZVxuICAgICAgICAgICAgICAgIC8vIChub3RlOiBqcy1kYXRhIGRvZXMgbm90IHByb3ZpZGUgJ2J1bGsgZWplY3QnIGFzIGZvciBEUy5pbmplY3QpXG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGRlbGV0ZWRFbGVtZW50cywgZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgRFMuZWplY3QoY29sbGVjdGlvblN0cmluZywgaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdOb3RpZnknLCBbXG4gICAgJ2F1dG91cGRhdGUnLFxuICAgICdvcGVyYXRvcicsXG4gICAgZnVuY3Rpb24gKGF1dG91cGRhdGUsIG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBhbm9ueW1vdXNUcmFja0lkO1xuXG4gICAgICAgIC8vIEhhbmRsZXIgZm9yIG5vdGlmeSBtZXNzYWdlcy5cbiAgICAgICAgYXV0b3VwZGF0ZS5vbk1lc3NhZ2UoZnVuY3Rpb24oZGF0YUxpc3QpIHtcbiAgICAgICAgICAgIHZhciBkYXRhTGlzdEJ5Q29sbGVjdGlvbiA9IF8uZ3JvdXBCeShkYXRhTGlzdCwgJ2NvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgIF8uZm9yRWFjaChkYXRhTGlzdEJ5Q29sbGVjdGlvbi5ub3RpZnksIGZ1bmN0aW9uIChub3RpZnlJdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2ssIGlmIHRoaXMgY3VycmVudCB1c2VyIChvciBhbm9ueW1vdXMgaW5zdGFuY2UpIGhhcyBzZW5kIHRoaXMgbm90aWZ5LlxuICAgICAgICAgICAgICAgIGlmIChub3RpZnlJdGVtLnNlbmRlclVzZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3IudXNlcikgeyAvLyBVc2VyIHNlbmQgdG8gdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZ5SXRlbS5zZW5kQnlTZWxmID0gKG5vdGlmeUl0ZW0uc2VuZGVyVXNlcklkID09PSBvcGVyYXRvci51c2VyLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gVXNlciBzZW5kIHRvIGFub255bW91c1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZ5SXRlbS5zZW5kQnlTZWxmID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3IudXNlcikgeyAvLyBBbm9ueW1vdXMgc2VuZCB0byB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZnlJdGVtLnNlbmRCeVNlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gQW5vbnltb3VzIHNlbmQgdG8gYW5vbnltb3VzXG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZnlJdGVtLnNlbmRCeVNlbGYgPSAobm90aWZ5SXRlbS5hbm9ueW1vdXNUcmFja0lkID09PSBhbm9ueW1vdXNUcmFja0lkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBub3RpZnkgcmVnaXN0ZXJlZCByZWNlaXZlcnMuXG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNhbGxiYWNrUmVjZWl2ZXJzW25vdGlmeUl0ZW0ubmFtZV0sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZm4obm90aWZ5SXRlbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNhbGxiYWNrUmVjZWl2ZXJzID0ge307XG4gICAgICAgIC8qIFN0cnVjdHVyZSBvZiBjYWxsYmFja1JlY2VpdmVyczpcbiAgICAgICAgICogZXZlbnRfbmFtZV9vbmU6IFsge2lkOjAsIGZuOmZufSwge2lkOjMsIGZuOmZufSBdLFxuICAgICAgICAgKiBldmVudF9uYW1lX3R3bzogWyB7aWQ6MiwgZm46Zm59IF0sXG4gICAgICAgICAqICovXG4gICAgICAgIHZhciBpZENvdW50ZXIgPSAwO1xuICAgICAgICB2YXIgZXZlbnROYW1lUmVnZXggPSBuZXcgUmVnRXhwKCdeW2EtekEtWjAtOV8tXSskJyk7XG4gICAgICAgIHZhciBleHRlcm5JZFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXlthLXpBLVowLTlfLV0rXFwvWzAtOV0rJCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVnaXN0ZXJDYWxsYmFjazogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50TmFtZVJlZ2V4LnRlc3QoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnZXZlbnROYW1lIHNob3VsZCBvbmx5IGNvbnNpc3Qgb2YgW2EtekEtWjAtOV8tXSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gaWRDb3VudGVyKys7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFja1JlY2VpdmVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1JlY2VpdmVyc1tldmVudE5hbWVdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tSZWNlaXZlcnNbZXZlbnROYW1lXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuOiBmbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudE5hbWUgKyAnLycgKyBpZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnZm4gc2hvdWxkIGJlIGEgZnVuY3Rpb24uJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVyZWdpc3RlckNhbGxiYWNrOiBmdW5jdGlvbiAoZXh0ZXJuSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZXJuSWRSZWdleC50ZXN0KGV4dGVybklkKSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGxpdCA9IGV4dGVybklkLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBzcGxpdFswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gcGFyc2VJbnQoc3BsaXRbMV0pO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1JlY2VpdmVyc1tldmVudE5hbWVdID0gXy5maWx0ZXIoY2FsbGJhY2tSZWNlaXZlcnNbZXZlbnROYW1lXSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmlkICE9PSBpZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXh0ZXJuSWQgKyAnIGlzIG5vdCBhIHZhbGlkIGlkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gdmFyaWFibGUgbGVuZ3RoIG9mIHBhcmFtZXRlcnMsIGp1c3QgcGFzcyBpZHMuXG4gICAgICAgICAgICBkZXJlZ2lzdGVyQ2FsbGJhY2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGFyZ3VtZW50cywgdGhpcy5kZXJlZ2lzdGVyQ2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vdGlmeTogZnVuY3Rpb24oZXZlbnROYW1lLCBwYXJhbXMsIHVzZXJzLCBjaGFubmVscywgcHJvamVjdG9ycykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWVSZWdleC50ZXN0KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMgfHwgdHlwZW9mIHBhcmFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdGlmeUl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiAnbm90aWZ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcnM6IHVzZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlDaGFubmVsczogY2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0b3JzOiBwcm9qZWN0b3JzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wZXJhdG9yLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYW5vbnltb3VzVHJhY2tJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFub255bW91c1RyYWNrSWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMTAwMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZnlJdGVtLmFub255bW91c1RyYWNrSWQgPSBhbm9ueW1vdXNUcmFja0lkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF1dG91cGRhdGUuc2VuZChbbm90aWZ5SXRlbV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdldmVudE5hbWUgc2hvdWxkIG9ubHkgY29uc2lzdCBvZiBbYS16QS1aMC05Xy1dJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi8vIFNhdmUgdGhlIHNlcnZlciB0aW1lIHRvIHRoZSByb290c2NvcGUuXG4ucnVuKFtcbiAgICAnJGh0dHAnLFxuICAgICckcm9vdFNjb3BlJyxcbiAgICBmdW5jdGlvbiAoJGh0dHAsICRyb290U2NvcGUpIHtcbiAgICAgICAgLy8gTG9hZHMgc2VydmVyIHRpbWUgYW5kIGNhbGN1bGF0ZXMgc2VydmVyIG9mZnNldFxuICAgICAgICAkcm9vdFNjb3BlLnNlcnZlck9mZnNldCA9IDA7XG4gICAgICAgICRodHRwLmdldCgnL2NvcmUvc2VydmVydGltZS8nKVxuICAgICAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNlcnZlck9mZnNldCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDAgLSBkYXRhLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4ucnVuKFtcbiAgICAnQ29uZmlnJyxcbiAgICAnJHJvb3RTY29wZScsXG4gICAgZnVuY3Rpb24gKENvbmZpZywgJHJvb3RTY29wZSkge1xuICAgICAgICAkcm9vdFNjb3BlLmNvbmZpZyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbmZpZy5nZXQoa2V5KS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4vLyBNYWtlIHRoZSBpbmRleE9mIGF2YWlsYWJsZSBpbiBldmVyeSBzY29wZTsgbmVlZGVkIGZvciB0aGUgcHJvamVjdG9yYnV0dG9uc1xuLnJ1bihbXG4gICAgJyRyb290U2NvcGUnLFxuICAgIGZ1bmN0aW9uICgkcm9vdFNjb3BlKSB7XG4gICAgICAgICRyb290U2NvcGUuaW5BcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfLmluZGV4T2YoYXJyYXksIHZhbHVlKSA+IC0xO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi8vIFB1dCB0aGUgTWF0aCBvYmplY3QgaW50byBldmVyeSBzY29wZS5cbi5ydW4oW1xuICAgICckcm9vdFNjb3BlJyxcbiAgICBmdW5jdGlvbiAoJHJvb3RTY29wZSkge1xuICAgICAgICAkcm9vdFNjb3BlLk1hdGggPSB3aW5kb3cuTWF0aDtcbiAgICB9XG5dKVxuXG4vLyBUZW1wbGF0ZSBob29rc1xuLy8gUG9zc2libGUgdXNlczpcbi8vIDEuIHsgaWQ6ICdteUhvb2tJZCcsIHRlbXBsYXRlOiAnPGJ1dHRvbj5jbGljayBtZTwvYnV0dG9uPicgfVxuLy8gMi4geyBpZDogJ215SG9va0lkJywgdGVtcGxhdGVVcmw6ICcvc3RhdGljL3RlbXBsYXRlcy9wbHVnaW5fbmFtZS9teS1ob29rLmh0bWwnIH1cbi8vIDMuIHsgaWQ6ICdteUhvb2tJZCcgfVxuLy9cbi8vIERlcHJlY2F0ZWQ6IEdpdmUgdGhlIGlkIHdpdGggJ0lkJy4gUGxlYXNlIHVzZSAnaWQnLlxuLy9cbi8vIE9wdGlvbiAzIGlzIGZvciBqdXN0IGNoYW5naW5nIHRoZSBzY29wZSAoc2VlIGJlbG93KSwgYnV0IG5vdCB0aGUgb3JpZ2luYWwgY29udGVudC4gVGhpc1xuLy8gaXMgdXNlZnVsbCB0byBhbHRlciBhIEpTIGJlaGF2aW9yLCBlLmcuIG9uIGEgbmctY2xpY2suIEluIHRoaXMgY2FzZSwgb3ZlcnJpZGUgaXMgZmFsc2Vcbi8vIGZvciB0aGlzIHRlbXBsYXRlIGhvb2suXG4vL1xuLy8gSXQgaXMgcG9zc2libGUgdG8gcHJvdmlkZSBhIHNjb3BlLCB0aGF0IGlzIG1lcmdlZCBpbnRvIHRoZSBzdXJyb3VuZGluZyBzY29wZS5cbi8vIFlvdSBjYW4gb3ZlcnJpZGUgZnVuY3Rpb25zIG9yIHZhbHVlcyBvZiB0aGUgc3Vycm91bmRpbmcgc2NvcGUgYnkgcHJvdmlkaW5nIHRoZW06XG4vLyB7IGlkOiAnaG9va0lkJywgdGVtcGxhdGU6ICc8YnV0dG9uIG5nLWNsaWNrPVwiY3VzdG9tT3JPdmVyd3JpdHRlbigpXCI+Y2xpY2sgbWU8L2J1dHRvbj4nLFxuLy8gICBzY29wZToge1xuLy8gICAgIGN1c3RvbU9yT3ZlcndyaXR0ZW46IGZ1bmN0aW9uICgpIHsgLypEbyBzb21ldGhpbmcgKi8gfSxcbi8vICAgfSxcbi8vIH1cbi8vIE9yIHlvdSBwcm92aWRlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMvdmFsdWVzIHRvIG92ZXJ3cml0ZSB0b1xuLy8gZ2V0IGFjY2VzcyB0byB0aGUgc2NvcGUgbWVyZ2VkIGluOlxuLy8geyBpZDogJ2hvb2tJZCcsIHRlbXBsYXRlOiAnPGJ1dHRvbiBuZy1jbGljaz1cImN1c3RvbUZuKClcIj5jbGljayBtZTwvYnV0dG9uPicsXG4vLyAgIHNjb3BlOiBmdW5jdGlvbiAoc2NvcGUpIHtcbi8vICAgICByZXR1cm4ge1xuLy8gICAgICAgY3VzdG9tT3JPdmVyd3JpdHRlbjogZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICBzY29wZS52YWx1ZSA9IC8qIGNoYW5nZSBpdCAqLztcbi8vICAgICAgIH0sXG4vLyAgICAgfTtcbi8vICAgfSxcbi8vIH1cbi8vXG4vLyBBcyBhIGRlZmF1bHQsIHRlbXBsYXRlIGhvb2tzIGluIGZsYXZvdXIgb2Ygb3B0aW9uIDEgYW5kIDIgb3ZlcnJpZGUgdGhlIGNvbnRlbnQgdGhhdCB3YXNcbi8vIG9yaWdpbmFsbHkgdGhlcmUuIFByb3ZpZGUgJ292ZXJyaWRlOiBmYWxzZScsIHRvIHByZXZlbnQgb3ZlcnJpZGluZyB0aGUgb3JpZ2luYWwgY29udGVudC5cbi5mYWN0b3J5KCd0ZW1wbGF0ZUhvb2tzJywgW1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhvb2tzID0ge307XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBob29rczogaG9va3MsXG4gICAgICAgICAgICByZWdpc3Rlckhvb2s6IGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVwcmVjYXRlZDogU2V0IHRoZSBuZXcgc3R5bGUgJ2lkJywgaWYgJ0lkJyBpcyBnaXZlbi5cbiAgICAgICAgICAgICAgICBpZiAoaG9vay5pZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2suaWQgPSBob29rLklkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChob29rc1tob29rLmlkXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzW2hvb2suaWRdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNldCBvdmVycmlkZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgaWYgKGhvb2sub3ZlcnJpZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBob29rLm92ZXJyaWRlID0gISEoaG9vay50ZW1wbGF0ZSB8fCBob29rLnRlbXBsYXRlVXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9va3NbaG9vay5pZF0ucHVzaChob29rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uZGlyZWN0aXZlKCd0ZW1wbGF0ZUhvb2snLCBbXG4gICAgJyRjb21waWxlJyxcbiAgICAnJGh0dHAnLFxuICAgICckcScsXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcbiAgICAnJHRpbWVvdXQnLFxuICAgICd0ZW1wbGF0ZUhvb2tzJyxcbiAgICBmdW5jdGlvbiAoJGNvbXBpbGUsICRodHRwLCAkcSwgJHRlbXBsYXRlQ2FjaGUsICR0aW1lb3V0LCB0ZW1wbGF0ZUhvb2tzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgdGVtcGxhdGU6ICcnLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBpRWxlbWVudCwgaUF0dHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaG9va3MgPSB0ZW1wbGF0ZUhvb2tzLmhvb2tzW2lBdHRyLmhvb2tOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgc2NvcGVzXG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChob29rcywgZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfc2NvcGUgPSBob29rLnNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYSBmdW5jdGlvbiwgZ2V0IHRoZSBzY29wZSBmcm9tIHRoZSBmdW5jdGlvbiBhbmQgcHJvdmlkZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIHNjb3BlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBob29rLnNjb3BlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Njb3BlID0gaG9vay5zY29wZShzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChfc2NvcGUsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrLCBpZiBhdCBsZWFzdCBvbmUgaG9vayBvdmVycmlkZXMgdGhlIG9yaWdpbmFsIGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdmVycmlkZSA9IF8uc29tZShob29rcywgZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBob29rLm92ZXJyaWRlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgaG9va3MsIHRoYXQgZG9lcyBhY3R1YWxseSBoYXZlIGEgdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgaG9va3MgPSBfLmZpbHRlcihob29rcywgZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBob29rLnRlbXBsYXRlIHx8IGhvb2sudGVtcGxhdGVVcmw7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBhbGwgdGVtcGxhdGVzXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZXMgPSBfLm1hcChob29rcywgZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciBhIHRlbXBsYXRlIChodG1sIGdpdmVuIGFzIHN0cmluZykgb3IgYSB0ZW1wbGF0ZVVybCBoYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIGdpdmVuLiBJZiBhIHNjb3BlIGlzIHByb3ZpZGVkLCB0aGUgc2Nob3BlIG9mIHRoaXMgdGVtcGxhdGVIb29rXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBwb3B1bGF0ZWQgd2l0aCB0aGUgZ2l2ZW4gZnVuY3Rpb25zL3ZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob29rLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvb2sudGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGVtcGxhdGVDYWNoZS5nZXQoaG9vay50ZW1wbGF0ZVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBkb20gdG8gYnVpbGQgdXAsIHNvIHdlIGNhbiByZXRyaWV2ZSB0aGUgaW5uZXIgaHRtbCBvZiBpRWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBvdmVycmlkZSA/ICcnIDogaUVsZW1lbnQuaHRtbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9IHRlbXBsYXRlcy5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaUVsZW1lbnQuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlFbGVtZW50LmFwcGVuZCgkY29tcGlsZShodG1sKShzY29wZSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLypcbiAqIFRoaXMgcGxhY2VzIGEgcHJvamVjdG9yIGJ1dHRvbiBpbiB0aGUgZG9jdW1lbnQuXG4gKlxuICogRXhhbXBsZTogPHByb2plY3Rvci1idXR0b24gbW9kZWw9XCJtb3Rpb25cIiBkZWZhdWx0LXByb2plY3Rvci5pZD1cImRlZlBySWRcIlxuICogICAgICAgICAgIGFyZz1cIjJcIiBjb250ZW50PVwie3sgJ3Byb2plY3QnIHwgdHJhbnNsYXRlIH19XCI+PC9wcm9qZWN0b3ItYnV0dG9uPlxuICogVGhpcyBidXR0b24gcmVmZXJlbmNlcyB0byBtb2RlbCAoaW4gdGhpcyBleGFtcGxlICdtb3Rpb24nKS4gQWxzbyBhIGRlZmF1bHRQcm9qZWN0aW9uSWRcbiAqIGhhcyB0byBiZSBnaXZlbi4gSW4gdGhlIGV4YW1wbGUgaXQncyBhIHNjb3BlIHZhcmlhYmxlLiBUaGUgbmV4dCB0d28gcGFyYW1ldGVycyBhcmUgYWRkaXRpb25hbDpcbiAqICAgLSBhcmc6IFRoZW4gdGhlIG1vZGVsLnByb2plY3QgYW5kIG1vZGVsLmlzUHJvamVjdGVkIHdpbGwgYmUgY2FsbGVkIHdpdGhcbiAqICAgICAgICAgIHRoaXMgYXJndW1lbnQgKGUuIGcuOiBtb2RlbC5wcm9qZWN0KDIpKVxuICogICAtIGNvbnRlbnQ6IEEgdGV4dCBwbGFjZWQgYmVoaW5kIHRoZSBwcm9qZWN0b3Igc3ltYm9sLlxuICovXG4uZGlyZWN0aXZlKCdwcm9qZWN0b3JCdXR0b24nLCBbXG4gICAgJ1Byb2plY3RvcicsXG4gICAgZnVuY3Rpb24gKFByb2plY3Rvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3RhdGljL3RlbXBsYXRlcy9wcm9qZWN0b3ItYnV0dG9uLmh0bWwnLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLm1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdBIG1vZGVsIGhhcyB0byBiZSBnaXZlbiEnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXMuZGVmYXVsdFByb2plY3RvcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdBIGRlZmF1bHQtcHJvamVjdG9yLWlkIGhhcyB0byBiZSBnaXZlbiEnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFByb2plY3Rvci5iaW5kQWxsKHt9LCBzY29wZSwgJ3Byb2plY3RvcnMnKTtcblxuICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChhdHRyaWJ1dGVzLm1vZGVsLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChhdHRyaWJ1dGVzLmRlZmF1bHRQcm9qZWN0b3JJZCwgZnVuY3Rpb24gKGRlZmF1bHRQcm9qZWN0b3JJZCkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5kZWZhdWx0UHJvamVjdG9ySWQgPSBkZWZhdWx0UHJvamVjdG9ySWQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5hcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKGF0dHJpYnV0ZXMuYXJnLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5hcmcgPSBhcmc7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjb3BlLmNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuJG9ic2VydmUoJ2NvbnRlbnQnLCBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnanNEYXRhTW9kZWwnLCBbXG4gICAgJyRodHRwJyxcbiAgICAnUHJvamVjdG9yJyxcbiAgICAnUHJvamVjdEhlbHBlcicsXG4gICAgZnVuY3Rpb24oJGh0dHAsIFByb2plY3RvciwgUHJvamVjdEhlbHBlcikge1xuICAgICAgICB2YXIgQmFzZU1vZGVsID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgQmFzZU1vZGVsLnByb3RvdHlwZS5wcm9qZWN0ID0gZnVuY3Rpb24ocHJvamVjdG9ySWQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgb2JqZWN0IGlzIGFscmVhZHkgcHJvamVjdGVkIG9uIHByb2plY3RvcklkLCBkZWxldGUgdGhpcyBlbGVtZW50IGZyb20gdGhpcyBwcm9qZWN0b3JcbiAgICAgICAgICAgIHZhciBpc1Byb2plY3RlZElkcyA9IHRoaXMuaXNQcm9qZWN0ZWQoKTtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBjbGVhcl9pZHM6IGlzUHJvamVjdGVkSWRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFNob3cgdGhlIGVsZW1lbnQsIGlmIGl0IHdhcyBub3QgcHJvamVjdGVkIGJlZm9yZSBvbiB0aGUgZ2l2ZW4gcHJvamVjdG9yXG4gICAgICAgICAgICBpZiAoXy5pbmRleE9mKGlzUHJvamVjdGVkSWRzLCBwcm9qZWN0b3JJZCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YS5wcnVuZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHByb2plY3RvcklkLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB7bmFtZTogdGhpcy5nZXRSZXNvdXJjZU5hbWUoKSwgaWQ6IHRoaXMuaWR9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvamVjdEhlbHBlci5wcm9qZWN0KHJlcXVlc3REYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFzZU1vZGVsLnByb3RvdHlwZS5pc1Byb2plY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUmV0dXJucyB0aGUgaWRzIG9mIGFsbCBwcm9qZWN0b3JzIGlmIHRoZXJlIGlzIGEgcHJvamVjdG9yIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIHdpdGggdGhlIHNhbWUgbmFtZSBhbmQgdGhlIHNhbWUgaWQuIEVsc2UgcmV0dXJucyBhbiBlbXB0eSBsaXN0LlxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHByZWRpY2F0ZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQubmFtZSA9PSBzZWxmLmdldFJlc291cmNlTmFtZSgpICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBlbGVtZW50LmlkICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmlkID09IHNlbGYuaWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGlzUHJvamVjdGVkSWRzID0gW107XG4gICAgICAgICAgICBQcm9qZWN0b3IuZ2V0QWxsKCkuZm9yRWFjaChmdW5jdGlvbiAocHJvamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfLmZpbmRLZXkocHJvamVjdG9yLmVsZW1lbnRzLCBwcmVkaWNhdGUpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpc1Byb2plY3RlZElkcy5wdXNoKHByb2plY3Rvci5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaXNQcm9qZWN0ZWRJZHM7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGdldCBvYmplY3Qgc3BlY2lmaWMgYmVoYXZpb3JcbiAgICAgICAgQmFzZU1vZGVsLnByb3RvdHlwZS5pc1JlbGF0ZWRQcm9qZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IFwibmVlZHMgdG8gYmUgaW1wbGVtZW50ZWQhXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCYXNlTW9kZWw7XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ0Vycm9yTWVzc2FnZScsIFtcbiAgICAnJHRpbWVvdXQnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ01lc3NhZ2luZycsXG4gICAgZnVuY3Rpb24gKCR0aW1lb3V0LCBnZXR0ZXh0Q2F0YWxvZywgTWVzc2FnaW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JBbGVydDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0Vycm9yJykgKyAnOiAnO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKFwiVGhlIHNlcnZlciBkaWRuJ3QgcmVzcG9uZC5cIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5kYXRhLmRldGFpbCkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGVycm9yLmRhdGEuZGV0YWlsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhdHVzID4gNTAwKSB7IC8vIFNvbWUga2luZCBvZiBzZXJ2ZXIgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKFwiQSBzZXJ2ZXIgZXJyb3Igb2NjdXJyZWQgKCUlY29kZSUlKS4gUGxlYXNlIGNoZWNrIHRoZSBzeXN0ZW0gbG9ncy5cIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoJyUlY29kZSUlJywgZXJyb3Iuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlIGluIGVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gZSArICc6ICcgKyBlcnJvci5kYXRhW2VdICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdkYW5nZXInLCBtc2c6IG1lc3NhZ2UsIHNob3c6IHRydWUgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRDb25uZWN0aW9uRXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2luZy5jcmVhdGVPckVkaXRNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Nvbm5lY3Rpb25Mb3N0TWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ09mZmxpbmUgbW9kZTogWW91IGNhbiB1c2UgT3BlblNsaWRlcyBidXQgY2hhbmdlcyBhcmUgbm90IHNhdmVkLicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAge25vQ2xvc2U6IHRydWV9KTtcbiAgICAgICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhckNvbm5lY3Rpb25FcnJvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnaW5nLmRlbGV0ZU1lc3NhZ2UoJ2Nvbm5lY3Rpb25Mb3N0TWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4vKiBNZXNzYWdpbmcgZmFjdG9yeS4gVGhlIHRleHQgaXMgaHRtbC1iaW5kZWQgaW50byB0aGUgZG9jdW1lbnQsIHNvIHlvdSBjYW5cbiAqIHByb3ZpZGUgYWxzbyBodG1sIG1hcmt1cCBmb3IgdGhlIG1lc3NhZ2VzLiBUaGVyZSBhcmUgNCB0eXBlczogJ2luZm8nLFxuICogJ3N1Y2Nlc3MnLCAnd2FybmluZycsICdlcnJvcicuIFRoZSB0aW1lb3V0IGlzIGZvciBhdXRvZGVsZXRpbmcgdGhlIG1lc3NhZ2UuXG4gKiBBcmdzIHRoYXQgY291bGQgYmUgcHJvdmlkZWQ6XG4gKiAtIHRpbWVvdXQ6IE1pbGxpc2Vjb25kcyB1bnRpbCBhdXRvY2xvc2UgdGhlIG1lc3NhZ2UgKGRlZmF1bHQ6IG5vdCBzZXQsIG5vIGF1dG8gY2xvc2UpXG4gKiAtIG5vQ2xvc2U6IFdoZXRoZXIgdG8gc2hvdyB0aGUgY2xvc2UgYnV0dG9uIChkZWZhdWx0OiBmYWxzZSlcbiAqL1xuLmZhY3RvcnkoJ01lc3NhZ2luZycsIFtcbiAgICAnJHRpbWVvdXQnLFxuICAgIGZ1bmN0aW9uKCR0aW1lb3V0KSB7XG4gICAgICAgIHZhciBjYWxsYmFja0xpc3QgPSBbXSxcbiAgICAgICAgICAgIG1lc3NhZ2VzID0ge30sXG4gICAgICAgICAgICBpZENvdW50ZXIgPSAwO1xuXG4gICAgICAgIHZhciBvbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF8uZm9yRWFjaChjYWxsYmFja0xpc3QsIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkTWVzc2FnZTogZnVuY3Rpb24gKHRleHQsIHR5cGUsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBpZENvdW50ZXIrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVPckVkaXRNZXNzYWdlKGlkLCB0ZXh0LCB0eXBlLCBhcmdzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVhdGVPckVkaXRNZXNzYWdlOiBmdW5jdGlvbiAoaWQsIHRleHQsIHR5cGUsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNbaWRdICYmIG1lc3NhZ2VzW2lkXS50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbChtZXNzYWdlc1tpZF0udGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzLnRpbWVvdXQgPT09ICdudW1iZXInICYmIGFyZ3MudGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1tpZF0udGltZW91dCA9ICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGVsZXRlTWVzc2FnZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGFyZ3MudGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlbGV0ZU1lc3NhZ2U6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXNzYWdlc1tpZF07XG4gICAgICAgICAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRNZXNzYWdlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWdpc3Rlck1lc3NhZ2VDaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0xpc3QucHVzaChmbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2ZuIGhhcyB0byBiZSBhIGZ1bmN0aW9uJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdMb2dvcycsIFtcbiAgICAnQ29uZmlnJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgZnVuY3Rpb24gKENvbmZpZywgZ2V0dGV4dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0S2V5czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb25maWcuZ2V0KCdsb2dvc19hdmFpbGFibGUnKS52YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ubWFwKHRoaXMuZ2V0S2V5cygpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBDb25maWcuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcudmFsdWUua2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gQ29uZmlnLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnZhbHVlLnBhdGggPSBwYXRoIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBDb25maWcuc2F2ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ0ZvbnRzJywgW1xuICAgICdDb25maWcnLFxuICAgICdnZXR0ZXh0JyxcbiAgICBmdW5jdGlvbiAoQ29uZmlnLCBnZXR0ZXh0KSB7XG4gICAgICAgIHZhciBleHRlbnNpb25Gb3JtYXRNYXAgPSB7XG4gICAgICAgICAgICAndHRmJzogJ3RydWV0eXBlJyxcbiAgICAgICAgICAgICd3b2ZmJzogJ3dvZmYnLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXRLZXlzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbmZpZy5nZXQoJ2ZvbnRzX2F2YWlsYWJsZScpLnZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5tYXAodGhpcy5nZXRLZXlzKCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IENvbmZpZy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy52YWx1ZS5rZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maWcudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFVybDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBmb250ID0gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoZm9udCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IGZvbnQucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9udC5kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRGb3JDc3M6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gdGhpcy5nZXRVcmwoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHQgPSBfLmxhc3QodXJsLnNwbGl0KCcuJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ1cmwoJ1wiICsgdXJsICsgXCInKSBmb3JtYXQoJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbkZvcm1hdE1hcFtleHRdICsgXCInKVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gQ29uZmlnLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnZhbHVlLnBhdGggPSBwYXRoIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBDb25maWcuc2F2ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ1RhZycsIFtcbiAgICAnRFMnLFxuICAgIGZ1bmN0aW9uKERTKSB7XG4gICAgICAgIHJldHVybiBEUy5kZWZpbmVSZXNvdXJjZSh7XG4gICAgICAgICAgICBuYW1lOiAnY29yZS90YWcnLFxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnQ29uZmlnJywgW1xuICAgICckaHR0cCcsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnRFMnLFxuICAgIGZ1bmN0aW9uKCRodHRwLCBnZXR0ZXh0Q2F0YWxvZywgRFMpIHtcbiAgICAgICAgdmFyIGNvbmZpZ09wdGlvbnM7XG4gICAgICAgIHJldHVybiBEUy5kZWZpbmVSZXNvdXJjZSh7XG4gICAgICAgICAgICBuYW1lOiAnY29yZS9jb25maWcnLFxuICAgICAgICAgICAgaWRBdHRyaWJ1dGU6ICdrZXknLFxuICAgICAgICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ0NoYXRNZXNzYWdlJywgW1xuICAgICdEUycsXG4gICAgZnVuY3Rpb24oRFMpIHtcbiAgICAgICAgcmV0dXJuIERTLmRlZmluZVJlc291cmNlKHtcbiAgICAgICAgICAgIG5hbWU6ICdjb3JlL2NoYXQtbWVzc2FnZScsXG4gICAgICAgICAgICByZWxhdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBiZWxvbmdzVG86IHtcbiAgICAgICAgICAgICAgICAgICAgJ3VzZXJzL3VzZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEtleTogJ3VzZXJfaWQnLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4vKlxuICogUHJvdmlkZXMgYSBmdW5jdGlvbiBmb3IgcGx1Z2lucyB0byByZWdpc3RlciBhcyBuZXcgcGx1Z2luLlxuICpcbiAqIEdldCBhbGwgcmVnaXN0ZXJkIHBsdWdpbnMgdmlhICdPcGVuU2xpZGVzUGx1Z2lucy5nZXRBbGwoKScuXG4gKlxuICogRXhhbXBsZSBjb2RlIGZvciBwbHVnaW5zOlxuICpcbiAqICAuY29uZmlnKFtcbiAqICAgICAgJ09wZW5TbGlkZXNQbHVnaW5zUHJvdmlkZXInLFxuICogICAgICAgZnVuY3Rpb24oT3BlblNsaWRlc1BsdWdpbnNQcm92aWRlcikge1xuICogICAgICAgICAgT3BlblNsaWRlc1BsdWdpbnNQcm92aWRlci5yZWdpc3RlclBsdWdpbih7XG4gKiAgICAgICAgICAgICAgbmFtZTogJ29wZW5zbGlkZXNfdm90ZWNvbGxlY3RvcicsXG4gKiAgICAgICAgICAgICAgZGlzcGxheV9uYW1lOiAnVm90ZUNvbGxlY3RvcicsXG4gKiAgICAgICAgICAgICAgbGFuZ3VhZ2VzOiBbJ2RlJ11cbiAqICAgICAgICAgIH0pO1xuICogICAgICB9XG4gKiAgXSlcbiAqL1xuLnByb3ZpZGVyKCdPcGVuU2xpZGVzUGx1Z2lucycsIFtcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm92aWRlciA9IHRoaXM7XG4gICAgICAgIHByb3ZpZGVyLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgcHJvdmlkZXIucmVnaXN0ZXJQbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgICAgICBwcm92aWRlci5wbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvdmlkZXIuJGdldCA9IFtcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBnZXRBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5wbHVnaW5zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG5dKVxuXG5cbi8vIENvbmZpZ3MgZm9yIENLRWRpdG9yIHdoaWNoIGhhcyB0byBzZXQgd2hpbGUgc3RhcnR1cCBvZiBPcGVuU2xpZGVzXG4uY29uZmlnKFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICBDS0VESVRPUi5kaXNhYmxlQXV0b0lubGluZSA9IHRydWU7XG4gICAgfVxuKVxuXG4vLyBPcHRpb25zIGZvciBDS0VkaXRvciB1c2VkIGluIHZhcmlvdXMgY3JlYXRlIGFuZCBlZGl0IHZpZXdzLlxuLy8gUmVxdWlyZWQgaW4gY29yZS9iYXNlLmpzIGJlY2F1c2UgTW90aW9uQ29tbWVudCBmYWN0b3J5IHdoaWNoIHVzZWQgdGhpc1xuLy8gZmFjdG9yeSBoYXMgdG8gcGxhY2VkIGluIG1vdGlvbnMvYmFzZS5qcy5cbi5mYWN0b3J5KCdFZGl0b3InLCBbXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICBmdW5jdGlvbiAoZ2V0dGV4dENhdGFsb2cpIHtcbiAgICAgICAgdmFyIGV4dHJhUGx1Z2lucyA9IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVnaXN0ZXJEaWFsb2c6IGZ1bmN0aW9uIChuYW1lLCBkaWFsb2cpIHtcbiAgICAgICAgICAgICAgICBDS0VESVRPUi5kaWFsb2cuYWRkKG5hbWUsIGRpYWxvZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uIChuYW1lLCBwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChuYW1lLCBwbHVnaW4pO1xuICAgICAgICAgICAgICAgIGV4dHJhUGx1Z2lucy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qIFByb3ZpZGUgc3BlY2lhbCBrZXl3b3JkIGluIHRoZSBhcmd1bWVudHMgZm9yIGEgc3BlY2lhbCBiZWhhdmlvdXI6XG4gICAgICAgICAgICAgKiBFeGFtcGxlOiBnZXRPcHRpb25zKCdpbmxpbmUnLCAnWU9mZnNldCcpXG4gICAgICAgICAgICAgKiBBdmFpbGFibGUga2V5d29yZHM6XG4gICAgICAgICAgICAgKiAgLSBpbmxpbmU6IHNtYWxsZXIgdG9vbGJhclxuICAgICAgICAgICAgICogIC0gWU9mZnNldDogbW92ZSB0aGUgZWRpdG9yIHRvb2xiYXIgNDBweCB1cFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRPcHRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhUGx1Z2luc1N0cmluZyA9ICdjb2xvcmJ1dHRvbixjb2xvcmRpYWxvZyxmaW5kLHNvdXJjZWRpYWxvZyxqdXN0aWZ5LHNob3dibG9ja3MnO1xuICAgICAgICAgICAgICAgIHZhciByZWdpc3RlcmVkUGx1Z2luc1N0cmluZyA9IGV4dHJhUGx1Z2lucy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lzdGVyZWRQbHVnaW5zU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhUGx1Z2luc1N0cmluZyArPSAnLCcgKyByZWdpc3RlcmVkUGx1Z2luc1N0cmluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGFkZHMgYSBsaXN0ZW5lciB0byBja2VkaXRvciB0byByZW1vdmUgdW53YW50ZWQgYmxhbmsgbGluZXMgb24gaW1wb3J0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsaXBib2FyZCBjb250ZW50IHZhcmllcyBoZWF2aWx5IGluIHN0cnVjdHVyZSBhbmQgaHRtbCBjb2RlLCBkZXBlbmRpbmcgb24gdGhlIFwic2VuZGVyXCIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSBpdCBpcyBmaXJzdCBwYXJzZWQgaW50byBhIHBzZXVkby1ET00gKHR3byBsaW5lcyB0YWtlbiBmcm9tIGEgY2tlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXN0ZSBleGFtcGxlIG9uIHRoZSBja2VkaXRvciBzaXRlKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKCdwYXN0ZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0LmRhdGEudHlwZSA9PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IENLRURJVE9SLmh0bWxQYXJzZXIuZnJhZ21lbnQuZnJvbUh0bWwoZXZ0LmRhdGEuZGF0YVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3cml0ZXIgPSBuZXcgQ0tFRElUT1IuaHRtbFBhcnNlci5iYXNpY1dyaXRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHRtbCBjb250ZW50IHdpbGwgbm93IGJlIGluIGEgZG9tLWxpa2Ugc3RydWN0dXJlIGluc2lkZSAnZnJhZ21lbnQnLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXIuYXBwbHlUbyhmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGZyYWdtZW50IGlzIERPTS1saWtlLCBpdCBtYXkgY29udGFpbiBuZXN0ZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChiZWluZyBodG1sIG5vZGVzKS4gVHJhdmVyc2UgdGhlIGNoaWxkcmVuIGFuZCBjaGVjayBpZiBpdCBpcyBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hpbGQgb25seSBjb250YWluaW5nIGVtcHR5IDxicj4gb3IgPHA+LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ld19jb250ZW50X2NoaWxkcmVuIHdpbGwgZmluYWxseSBjb250YWluIGFsbCBub2RlcyB0aGF0IGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X2NvbnRlbnRfY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goZnJhZ21lbnQuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY2hpbGRyZW4pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNoaWxkLmNoaWxkcmVuLCBmdW5jdGlvbihncmFuZGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyYW5kY2hpbGQubmFtZSAhPSAncCcgJiYgZ3JhbmRjaGlsZC5uYW1lICE9ICdicicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdyYW5kY2hpbGQuaXNFbXB0eSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtcHR5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19jb250ZW50X2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5hbWUgIT0gJ3AnICYmIGNoaWxkLm5hbWUgIT0gJ2JyJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmlzRW1wdHkgIT09IHRydWUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19jb250ZW50X2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuY2hpbGRyZW4gPSBuZXdfY29udGVudF9jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LndyaXRlSHRtbCh3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSByZS1jcmVhdGVkIGZyYWdtZW50IHdpdGhvdXQgdGhlIGVtcHR5IDxwPiBhbmQgPGJyPiBpbnRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWRpdG9yIGltcG9ydCBwcm9jZXNzaW5nIChzYW1lIGFzIGF0IHRoZSBiZWdpbiBvZiB0aGUgZnVuY3Rpb246IGJ5IGNrZWRpdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZ0LmRhdGEuZGF0YVZhbHVlID0gd3JpdGVyLmdldEh0bWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21Db25maWc6ICcnLFxuICAgICAgICAgICAgICAgICAgICBmbG9hdFNwYWNlRG9ja2VkT2Zmc2V0WTogXy5pbmRleE9mKGFyZ3VtZW50cywgJ1lPZmZzZXQnKSA+IC0xID8gMzUgOiAwLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlTmF0aXZlU3BlbGxDaGVja2VyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VfbGlzdDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZyOmZyYW7Dp2FpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXM6ZXNwYcOxb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3B0OnBvcnR1Z3XDqnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2VuOmVuZ2xpc2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlOmRldXRzY2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NzOsSNZcWhdGluYSddLFxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZTogZ2V0dGV4dENhdGFsb2cuZ2V0Q3VycmVudExhbmd1YWdlKCksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRDb250ZW50OlxuICAgICAgICAgICAgICAgICAgICAgICAgJ2gxIGgyIGgzIGIgaSB1IHN0cmlrZSBzdXAgc3ViIHN0cm9uZyBlbTsnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdibG9ja3F1b3RlIHAgcHJlIHRhYmxlJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKHRleHQtYWxpZ24tbGVmdCx0ZXh0LWFsaWduLWNlbnRlcix0ZXh0LWFsaWduLXJpZ2h0LHRleHQtYWxpZ24tanVzdGlmeSxvcy1zcGxpdC1iZWZvcmUsb3Mtc3BsaXQtYWZ0ZXIpe3RleHQtYWxpZ24sIGZsb2F0LCBwYWRkaW5nfTsnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhWyFocmVmXTsnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbWdbIXNyYyxhbHRde3dpZHRoLGhlaWdodCxmbG9hdCwgcGFkZGluZ307JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAndHIgdGggdGQgY2FwdGlvbjsnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaShvcy1zcGxpdC1iZWZvcmUsb3Mtc3BsaXQtYWZ0ZXIpOyBvbChvcy1zcGxpdC1iZWZvcmUsb3Mtc3BsaXQtYWZ0ZXIpW3N0YXJ0XXtsaXN0LXN0eWxlLXR5cGV9OycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3VsKG9zLXNwbGl0LWJlZm9yZSxvcy1zcGxpdC1hZnRlcil7bGlzdC1zdHlsZX07JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3BhblshKl17Y29sb3IsYmFja2dyb3VuZC1jb2xvcn0ob3Mtc3BsaXQtYmVmb3JlLG9zLXNwbGl0LWFmdGVyLG9zLWxpbmUtbnVtYmVyLGxpbmUtbnVtYmVyLSopOycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JyKG9zLWxpbmUtYnJlYWspOycsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgc2VlbXMgdG8gYmUgYW4gZXJyb3IgaW4gQ0tlZGl0b3IgdGhhdCBwYXJzZXMgc3BhY2VzIGluIGV4dHJhUGx1Z2lucyBhcyBwYXJ0IG9mIHRoZSBwbHVnaW4gbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgZXh0cmFQbHVnaW5zOiBleHRyYVBsdWdpbnNTdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVBsdWdpbnM6ICd3c2Msc2NheXQsYTExeWhlbHAsZmlsZWJyb3dzZXIsc291cmNlYXJlYSxsaXN0c3R5bGUsdGFibGV0b29scyx0YWJsZXNlbGVjdGlvbixjb250ZXh0bWVudSxpbWFnZScsXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUJ1dHRvbnM6ICdTY2F5dCxBbmNob3IsU3R5bGVzLEhvcml6b250YWxSdWxlJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChfLmluZGV4T2YoYXJndW1lbnRzLCAnaW5saW5lJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRvb2xiYXJHcm91cHMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdiYXNpY3N0eWxlcycsIGdyb3VwczogWyAnYmFzaWNzdHlsZXMnLCAnY2xlYW51cCcgXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY29sb3JzJywgZ3JvdXBzOiBbICdjb2xvcnMnIF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3BhcmFncmFwaCcsIGdyb3VwczogWyAnbGlzdCddIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsaW5rcycsIGdyb3VwczogWyAnbGlua3MnIF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NsaXBib2FyZCcsIGdyb3VwczogWyAndW5kbycgXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZG9jdW1lbnQnLCBncm91cHM6IFsgJ21vZGUnIF0gfSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZW1vdmVCdXR0b25zID0gJ1VuZGVybGluZSxTdWJzY3JpcHQsU3VwZXJzY3JpcHQsUGFzdGVGcm9tV29yZCxQYXN0ZVRleHQsU2NheXQsTGluayxVbmxpbmssQW5jaG9yLEhvcml6b250YWxSdWxlLFRhYmxlLEltYWdlLE1heGltaXplLFNvdXJjZSxGb3JtYXQsQWJvdXQsUGFzdGUsQ3V0LENvcHknO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudG9vbGJhckdyb3VwcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NsaXBib2FyZCcsIGdyb3VwczogWyAnY2xpcGJvYXJkJywgJ3VuZG8nIF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2VkaXRpbmcnLCBncm91cHM6IFsgJ2ZpbmQnLCAnc2VsZWN0aW9uJywgJ3NwZWxsY2hlY2tlcicsICdlZGl0aW5nJyBdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsaW5rcycsIGdyb3VwczogWyAnbGlua3MnIF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2luc2VydCcsIGdyb3VwczogWyAnaW5zZXJ0JyBdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd0b29scycsIGdyb3VwczogWyAndG9vbHMnIF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2RvY3VtZW50JywgZ3JvdXBzOiBbICdtb2RlJyBdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnLycsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdzdHlsZXMnLCBncm91cHM6IFsgJ3N0eWxlcycgXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnYmFzaWNzdHlsZXMnLCBncm91cHM6IFsgJ2Jhc2ljc3R5bGVzJywgJ2NsZWFudXAnIF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NvbG9ycycsIGdyb3VwczogWyAnY29sb3JzJyBdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdwYXJhZ3JhcGgnLCBncm91cHM6IFsgJ2xpc3QnLCAnaW5kZW50JyBdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdhbGlnbid9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncGFyYWdyYXBoJywgZ3JvdXBzOiBbICdibG9ja3MnIF0gfVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4vKiBNb2RlbCBmb3IgYSBwcm9qZWN0b3IuXG4gKlxuICogQXQgdGhlIG1vbWVudCB3ZSB1c2Ugb25seSBvbmUgcHJvamVjdG9yLCBzbyB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIG9iamVjdFxuICogaW4gdGhpcyBtb2RlbC4gSXQgaGFzIHRoZSBpZCAxLiBGb3IgbGF0ZXIgcmVsZWFzZXMgdGhlcmUgd2lsbCBiZSBtdWx0aXBsZVxuICogcHJvamVjdG9yIG9iamVjdHMuXG4gKlxuICogVGhpcyBtb2RlbCB1c2VzIG9uQ29uZmlsaWN0OiAncmVwbGFjZScgaW5zdGVhZCBvZiAnbWVyZ2UnLiBUaGlzIGlzIG5lY2Vzc2FyeVxuICogYmVjYXVzZSB0aGUga2V5cyBvZiB0aGUgcHJvamVjdG9yIG9iamVjdHMgY2FuIGNoYW5nZSBhbmQgb2xkIGtleXMgaGF2ZSB0b1xuICogYmUgcmVtb3ZlZC4gU2VlIGh0dHA6Ly93d3cuanMtZGF0YS5pby9kb2NzL2RzZGVmYXVsdHMjb25jb25mbGljdCBmb3JcbiAqIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbi5mYWN0b3J5KCdQcm9qZWN0b3InLCBbXG4gICAgJ0RTJyxcbiAgICAnJGh0dHAnLFxuICAgICdFZGl0Rm9ybScsXG4gICAgJ0NvbmZpZycsXG4gICAgZnVuY3Rpb24oRFMsICRodHRwLCBFZGl0Rm9ybSwgQ29uZmlnKSB7XG4gICAgICAgIHJldHVybiBEUy5kZWZpbmVSZXNvdXJjZSh7XG4gICAgICAgICAgICBuYW1lOiAnY29yZS9wcm9qZWN0b3InLFxuICAgICAgICAgICAgb25Db25mbGljdDogJ3JlcGxhY2UnLFxuICAgICAgICAgICAgcmVsYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgaGFzTWFueToge1xuICAgICAgICAgICAgICAgICAgICAnY29yZS9wcm9qZWN0aW9uLWRlZmF1bHQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAncHJvamVjdGlvbmRlZmF1bHRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmVpZ25LZXk6ICdwcm9qZWN0b3JfaWQnLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXRob2RzOiB7XG4gICAgICAgICAgICAgICAgY29udHJvbFByb2plY3RvcjogZnVuY3Rpb24oYWN0aW9uLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgJGh0dHAucG9zdCgnL3Jlc3QvY29yZS9wcm9qZWN0b3IvJyArIHRoaXMuaWQgKyAnL2NvbnRyb2xfdmlldy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcImFjdGlvblwiOiBhY3Rpb24sIFwiZGlyZWN0aW9uXCI6IGRpcmVjdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldEZvcm1PclN0YXRlRm9yQ3VycmVudFNsaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5fZGljdDtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHRoaXMuZWxlbWVudHMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5uYW1lID09ICdhZ2VuZGEvbGlzdC1vZi1zcGVha2VycycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5fZGljdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICdhZ2VuZGEuaXRlbS5kZXRhaWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIGdlbmVyaWMgc29sdXRpb24gZm9yIHdoaXRlbGlzdCBpbiBnZXRGb3JtT3JTdGF0ZUZvckN1cnJlbnRTbGlkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vT3BlblNsaWRlcy9PcGVuU2xpZGVzL2lzc3Vlcy8zMTMwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9PT0gJ3RvcGljcy90b3BpYycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5uYW1lID09PSAnbW90aW9ucy9tb3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9PT0gJ21vdGlvbnMvbW90aW9uLWJsb2NrJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPT09ICdhc3NpZ25tZW50cy9hc3NpZ25tZW50JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPT09ICdtZWRpYWZpbGVzL21lZGlhZmlsZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5uYW1lID09PSAndXNlcnMvdXNlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuX2RpY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtOiBFZGl0Rm9ybS5mcm9tQ29sbGVjdGlvblN0cmluZyh2YWx1ZS5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5fZGljdDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRvZ2dsZUJsYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICRodHRwLnBvc3QoJy9yZXN0L2NvcmUvcHJvamVjdG9yLycgKyB0aGlzLmlkICsgJy9jb250cm9sX2JsYW5rLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5ibGFua1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG9nZ2xlQnJvYWRjYXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICRodHRwLnBvc3QoJy9yZXN0L2NvcmUvcHJvamVjdG9yLycgKyB0aGlzLmlkICsgJy9icm9hZGNhc3QvJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLy8gVGhpcyBmYWN0b3J5IHNlbmRzIGEgcmVxdWVzdCB0byAvcmVzdC9jb3JlL3Byb2plY3RvcnMvcHJvamVjdFxuLy8gd2l0aCB0aGUgZ2l2ZW4gZGF0YS4gQWxzbyBpdCBkb2VzIHRoZSBjaGFuZ2VzIGRvbmUgYnkgdGhlIHNlcnZlclxuLy8gbG9jYWxseSBhbmQgbWF5IHJldmVydHMgdGhlbSwgaWYgc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4uZmFjdG9yeSgnUHJvamVjdEhlbHBlcicsIFtcbiAgICAnJHEnLFxuICAgICckaHR0cCcsXG4gICAgJ1Byb2plY3RvcicsXG4gICAgZnVuY3Rpb24gKCRxLCAkaHR0cCwgUHJvamVjdG9yKSB7XG4gICAgICAgIHZhciB1dWlkNCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHM4KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwMDAwMClcbiAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM4KCkgKyBzOCgpICsgczgoKSArIHM4KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb2plY3Q6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb2plY3RvcjtcbiAgICAgICAgICAgICAgICAvLyBnZXQgYWxsIHByb2plY3RvcnMgdGhhdCB3aWxsIGJlIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgdmFyIHByb2plY3RvcnNDaGFuZ2VkID0gXy5maWx0ZXIoXy5tYXAoZGF0YS5jbGVhcl9pZHMsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvamVjdG9yLmdldChpZCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnBydW5lICYmICFfLmluY2x1ZGVzKGRhdGEuY2xlYXJfaWRzLCBkYXRhLnBydW5lLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0b3IgPSBQcm9qZWN0b3IuZ2V0KGRhdGEucHJ1bmUuaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0b3JzQ2hhbmdlZC5wdXNoKHByb2plY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjb3B5IG9yaWdpbmFsIHByb2plY3RvcnMgaW4gY2FzZSB3ZSBoYXZlIHRvIHJlY29uc3RydWN0IHRob3NlXG4gICAgICAgICAgICAgICAgLy8gXy5jbG9uZURlZXAgYW5kIGFuZ3VsYXIuY2xvbmUgZG9lcyBub3Qgd29yayBoZXJlOyBJJ20gbm90XG4gICAgICAgICAgICAgICAgLy8gZXhhY3RseSBzdXJlIHdoeS4uXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsUHJvamVjdG9ycyA9IF8ubWFwKHByb2plY3RvcnNDaGFuZ2VkLCBmdW5jdGlvbiAocHJvamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2gocHJvamVjdG9yLmVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1trZXldID0gXy5jbG9uZURlZXAoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHByb2plY3Rvci5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbDogcHJvamVjdG9yLnNjcm9sbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlOiBwcm9qZWN0b3Iuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9qZWN0b3IubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsYW5rOiBwcm9qZWN0b3IuYmxhbmssXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvamVjdG9yLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwcm9qZWN0b3IuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdGlvbmRlZmF1bHRzOiBfLmNsb25lRGVlcChwcm9qZWN0b3IucHJvamVjdGlvbmRlZmF1bHRzKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFyIGV2ZXJ5IHByb2plY3RvclxuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChwcm9qZWN0b3JzQ2hhbmdlZCwgZnVuY3Rpb24gKHByb2plY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKHByb2plY3Rvci5lbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNba2V5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0b3IuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcHJ1bmUgZWxlbWVudCBpZiBnaXZlblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnBydW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3RvciA9IF8uZmluZChwcm9qZWN0b3JzQ2hhbmdlZCwgZnVuY3Rpb24gKHByb2plY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2plY3Rvci5pZCA9PT0gZGF0YS5wcnVuZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3Rvci5zY3JvbGwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdG9yLmVsZW1lbnRzW3V1aWQ0KCldID0gZGF0YS5wcnVuZS5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgUHJvamVjdG9yLmluamVjdChwcm9qZWN0b3JzQ2hhbmdlZCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJGh0dHAucG9zdCgnL3Jlc3QvY29yZS9wcm9qZWN0b3IvcHJvamVjdC8nLCBkYXRhKS5jYXRjaChcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXZlcnQgdGhlIGNoYW5nZXMgbWFkZSBlYXJsaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9qZWN0b3IuaW5qZWN0KG9yaWdpbmFsUHJvamVjdG9ycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi8qIE1vZGVsIGZvciBhbGwgcHJvamVjdGlvbiBkZWZhdWx0cyAqL1xuLmZhY3RvcnkoJ1Byb2plY3Rpb25EZWZhdWx0JywgW1xuICAgICdEUycsXG4gICAgZnVuY3Rpb24oRFMpIHtcbiAgICAgICAgcmV0dXJuIERTLmRlZmluZVJlc291cmNlKHtcbiAgICAgICAgICAgIG5hbWU6ICdjb3JlL3Byb2plY3Rpb24tZGVmYXVsdCcsXG4gICAgICAgICAgICByZWxhdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBiZWxvbmdzVG86IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NvcmUvcHJvamVjdG9yJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGaWVsZDogJ3Byb2plY3RvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEtleTogJ3Byb2plY3Rvcl9pZCcsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi8qIE1vZGVsIGZvciBQcm9qZWN0b3JNZXNzYWdlcyAqL1xuLmZhY3RvcnkoJ1Byb2plY3Rvck1lc3NhZ2UnLCBbXG4gICAgJ0RTJyxcbiAgICAnanNEYXRhTW9kZWwnLFxuICAgICdnZXR0ZXh0JyxcbiAgICAnJGh0dHAnLFxuICAgICdQcm9qZWN0b3InLFxuICAgIGZ1bmN0aW9uKERTLCBqc0RhdGFNb2RlbCwgZ2V0dGV4dCwgJGh0dHAsIFByb2plY3Rvcikge1xuICAgICAgICB2YXIgbmFtZSA9ICdjb3JlL3Byb2plY3Rvci1tZXNzYWdlJztcbiAgICAgICAgcmV0dXJuIERTLmRlZmluZVJlc291cmNlKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB1c2VDbGFzczoganNEYXRhTW9kZWwsXG4gICAgICAgICAgICB2ZXJib3NlTmFtZTogZ2V0dGV4dCgnTWVzc2FnZScpLFxuICAgICAgICAgICAgdmVyYm9zZW5hbWVQbHVyYWw6IGdldHRleHQoJ01lc3NhZ2VzJyksXG4gICAgICAgICAgICBtZXRob2RzOiB7XG4gICAgICAgICAgICAgICAgZ2V0UmVzb3VyY2VOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIEJhc2VNb2RlbC5wcm9qZWN0IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcHJvamVjdDogZnVuY3Rpb24ocHJvamVjdG9ySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBvYmplY3QgaXMgYWxyZWFkeSBwcm9qZWN0ZWQgb24gcHJvamVjdG9ySWQsIGRlbGV0ZSB0aGlzIGVsZW1lbnQgZnJvbSB0aGlzIHByb2plY3RvclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNQcm9qZWN0ZWRJZHMgPSB0aGlzLmlzUHJvamVjdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZWRpY2F0ZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5uYW1lID09PSBuYW1lICYmIGVsZW1lbnQuaWQgPT09IHNlbGYuaWQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChpc1Byb2plY3RlZElkcywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXVpZCA9IF8uZmluZEtleShQcm9qZWN0b3IuZ2V0KGlkKS5lbGVtZW50cywgcHJlZGljYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRodHRwLnBvc3QoJy9yZXN0L2NvcmUvcHJvamVjdG9yLycgKyBpZCArICcvZGVhY3RpdmF0ZV9lbGVtZW50cy8nLCBbdXVpZF0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgd2FzIHRoZSBzYW1lIHByb2plY3RvciBiZWZvcmUsIGp1c3QgZGVsZXRlIGl0IGJ1dCBub3Qgc2hvdyBhZ2FpblxuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pbmRleE9mKGlzUHJvamVjdGVkSWRzLCBwcm9qZWN0b3JJZCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdyBjaGVjayB3aGV0aGVyIG90aGVyIG1lc3NhZ2VzIGFyZSBhbHJlYWR5IHByb2plY3RlZCBhbmQgZGVsZXRlIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IFByb2plY3Rvci5nZXQocHJvamVjdG9ySWQpLmVsZW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCwgdXVpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGh0dHAucG9zdCgnL3Jlc3QvY29yZS9wcm9qZWN0b3IvJyArIHByb2plY3RvcklkICsgJy9kZWFjdGl2YXRlX2VsZW1lbnRzLycsIFt1dWlkXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGh0dHAucG9zdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3Jlc3QvY29yZS9wcm9qZWN0b3IvJyArIHByb2plY3RvcklkICsgJy9hY3RpdmF0ZV9lbGVtZW50cy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt7bmFtZTogbmFtZSwgaWQ6IHNlbGYuaWQsIHN0YWJsZTogdHJ1ZX1dXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLyogTW9kZWwgZm9yIENvdW50ZG93bnMgKi9cbi5mYWN0b3J5KCdDb3VudGRvd24nLCBbXG4gICAgJ0RTJyxcbiAgICAnanNEYXRhTW9kZWwnLFxuICAgICdnZXR0ZXh0JyxcbiAgICAnJHJvb3RTY29wZScsXG4gICAgJyRodHRwJyxcbiAgICAnUHJvamVjdG9yJyxcbiAgICBmdW5jdGlvbihEUywganNEYXRhTW9kZWwsIGdldHRleHQsICRyb290U2NvcGUsICRodHRwLCBQcm9qZWN0b3IpIHtcbiAgICAgICAgdmFyIG5hbWUgPSAnY29yZS9jb3VudGRvd24nO1xuICAgICAgICByZXR1cm4gRFMuZGVmaW5lUmVzb3VyY2Uoe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHVzZUNsYXNzOiBqc0RhdGFNb2RlbCxcbiAgICAgICAgICAgIHZlcmJvc2VOYW1lOiBnZXR0ZXh0KCdDb3VudGRvd24nKSxcbiAgICAgICAgICAgIHZlcmJvc2VuYW1lUGx1cmFsOiBnZXR0ZXh0KCdDb3VudGRvd25zJyksXG4gICAgICAgICAgICBtZXRob2RzOiB7XG4gICAgICAgICAgICAgICAgZ2V0UmVzb3VyY2VOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGVuZCBwb2ludCBvZiBjb3VudGRvd24gKGluIHNlY29uZHMhKVxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kVGltZXN0YW1wID0gRGF0ZS5ub3coKSAvIDEwMDAgLSAkcm9vdFNjb3BlLnNlcnZlck9mZnNldCArIHRoaXMuY291bnRkb3duX3RpbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnRkb3duX3RpbWUgPSBlbmRUaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgICAgIERTLnNhdmUobmFtZSwgdGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZXN0IGR1cmF0aW9uIG9mIGNvdW50ZG93biAoaW4gc2Vjb25kcyEpXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdEdXJhdGlvbiA9IE1hdGguZmxvb3IoIHRoaXMuY291bnRkb3duX3RpbWUgLSBEYXRlLm5vdygpIC8gMTAwMCArICRyb290U2NvcGUuc2VydmVyT2Zmc2V0ICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50ZG93bl90aW1lID0gbmV3RHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIERTLnNhdmUobmFtZSwgdGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudGRvd25fdGltZSA9IHRoaXMuZGVmYXVsdF90aW1lO1xuICAgICAgICAgICAgICAgICAgICBEUy5zYXZlKG5hbWUsIHRoaXMuaWQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIEJhc2VNb2RlbC5wcm9qZWN0IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcHJvamVjdDogZnVuY3Rpb24ocHJvamVjdG9ySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBvYmplY3QgaXMgYWxyZWFkeSBwcm9qZWN0ZWQgb24gcHJvamVjdG9ySWQsIGRlbGV0ZSB0aGlzIGVsZW1lbnQgZnJvbSB0aGlzIHByb2plY3RvclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNQcm9qZWN0ZWRJZHMgPSB0aGlzLmlzUHJvamVjdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZWRpY2F0ZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5uYW1lID09IG5hbWUgJiYgZWxlbWVudC5pZCA9PSBzZWxmLmlkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goaXNQcm9qZWN0ZWRJZHMsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHV1aWQgPSBfLmZpbmRLZXkoUHJvamVjdG9yLmdldChpZCkuZWxlbWVudHMsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkaHR0cC5wb3N0KCcvcmVzdC9jb3JlL3Byb2plY3Rvci8nICsgaWQgKyAnL2RlYWN0aXZhdGVfZWxlbWVudHMvJywgW3V1aWRdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IHdhcyB0aGUgc2FtZSBwcm9qZWN0b3IgYmVmb3JlLCBqdXN0IGRlbGV0ZSBpdCBidXQgbm90IHNob3cgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uaW5kZXhPZihpc1Byb2plY3RlZElkcywgcHJvamVjdG9ySWQpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGh0dHAucG9zdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3Jlc3QvY29yZS9wcm9qZWN0b3IvJyArIHByb2plY3RvcklkICsgJy9hY3RpdmF0ZV9lbGVtZW50cy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt7bmFtZTogbmFtZSwgaWQ6IHNlbGYuaWQsIHN0YWJsZTogdHJ1ZX1dXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi8qIFR3byBmdW5jdGlvbnMgdG8gY29udmVydCBiZXR3ZWVuIHRpbWUgZHVyYXRpb24gaW4gc2Vjb25kcyA8LT4gaHVtYW4gcmVhZGFibGUgdGltZSBzcGFuLlxuICogRS5nLiA5MCBzZWMgPC0+IDE6MzAgKG1pbiksIDM2NjEgc2VjIDwtPiAxOjAxOjAxIChoKVxuICpcbiAqIHNlY29uZHNUb0h1bWFuVGltZTogRXhwZWN0cyBzZWNvbmRzIGFuZCBnaXZlIFtoKjpdbW1bOnNzXS4gVGhlIG1pbnV0ZXMgcGFydCBpcyBhbHdheXMgZ2l2ZW4sIHRoZSBob3Vyc1xuICogICAgICBhbmQgbWludXRlcyBjb3VsZCBiZSBjb250cm9sbGVkLiBUaGUgZGVmYXVsdCBhcmUgZm9yY2VkIHNlY29uZHMgYW5kIGhvdXJzIGp1c3QgaWYgaXQgaXMgbm90IDAuXG4gKiAgICAgIC0gc2Vjb25kcyAoJ2VuYWJsZWQnLCAnYXV0bycsICdkaXNhYmxlZCcpOiBXaGV0aGVyIHRvIHNob3cgc2Vjb25kcyAoRGVmYXVsdCAnZW5hYmxlZCcpXG4gKiAgICAgIC0gaG91cnMgKCdlbmFibGVkJywgJ2F1dG8nLCAnZGlzYWJsZWQnKTogV2hldGhlciB0byBzaG93IGhvdXJzIChEZWZhdWx0ICdhdXRvJylcbiAqXG4gKiBodW1hblRpbWVUb1NlY29uZHM6IEV4cGVjdHMgW2gqOl1tKls6cypdIHdpdGggZWFjaCBwYXJ0IGNvdWxkIGhhdmUgYSB2YXJpYWJsZSBsZW5ndGguIFRoZSBwYXJzZWQgdGltZSBpc1xuICogICAgICBpbiBzZWNvbmRzLiBNaW51dGVzIGhhdmUgdG8gYmUgZ2l2ZW4gYW5kIGhvdXJzIGFuZCBzZWNvbmRzIGFyZSBvcHRpb25hbC4gT25lIGhhdmUgdG8gc2V0ICdzZWNvbmRzJyBvclxuICogICAgICAnaG91cnMnIHRvIHRydWUgdG9wYXJzZSB0aGVzZS5cbiAqXG4gKiBwYXJhbXMgY291bGQgYmUgYW4gb2JqZWN0IHdpdGggdGhlIGdpdmVuIHNldHRpbmdzLCBlLmcuIHtpZ25vcmVIb3VyczogdHJ1ZX1cbiAqL1xuLmZhY3RvcnkoJ0h1bWFuVGltZUNvbnZlcnRlcicsIFtcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWNvbmRzVG9IdW1hblRpbWU6IGZ1bmN0aW9uIChzZWNvbmRzLCBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7c2Vjb25kczogJ2VuYWJsZWQnLCBob3VyczogJ2F1dG8nfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMuc2Vjb25kcykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuc2Vjb25kcyA9ICdlbmFibGVkJztcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtcy5ob3Vycykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuaG91cnMgPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0aW1lO1xuICAgICAgICAgICAgICAgIC8vIGZsb29yIHJldHVybnMgdGhlIGxhcmdlc3QgaW50ZWdlciBvZiB0aGUgYWJzb2x1dCB2YWx1ZSBvZiBzZWNvbmRzXG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gTWF0aC5mbG9vcihNYXRoLmFicyhzZWNvbmRzKSk7XG4gICAgICAgICAgICAgICAgdmFyIGggPSBNYXRoLmZsb29yKHRvdGFsIC8gMzYwMCk7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBNYXRoLmZsb29yKHRvdGFsICUgMzYwMCAvIDYwKTtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IE1hdGguZmxvb3IodG90YWwgJSA2MCk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGxlYWRpbmcgXCIwXCIgZm9yIGRvdWJsZSBkaWdpdCB2YWx1ZXNcbiAgICAgICAgICAgICAgICB0aW1lID0gKCcwJyttKS5zbGljZSgtMik7IC8vbWludXRlc1xuICAgICAgICAgICAgICAgIGlmICgocGFyYW1zLnNlY29uZHMgPT0gJ2F1dG8nICYmIHMgPiAwKSB8fCBwYXJhbXMuc2Vjb25kcyA9PSAnZW5hYmxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9ICgnMCcrcykuc2xpY2UoLTIpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lID0gIHRpbWUgKyAnOicgKyBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHBhcmFtcy5ob3VycyA9PSAnYXV0bycgJiYgaCA+IDApIHx8IHBhcmFtcy5ob3VycyA9PSAnZW5hYmxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZSA9IGggKyAnOicgKyB0aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2Vjb25kcyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZSA9ICctJyt0aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGltZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBodW1hblRpbWVUb1NlY29uZHM6IGZ1bmN0aW9uIChkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7c2Vjb25kczogZmFsc2UsIGhvdXJzOiBmYWxzZX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtaW5MZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuc2Vjb25kcykge1xuICAgICAgICAgICAgICAgICAgICBtaW5MZW5ndGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ob3Vycyl7XG4gICAgICAgICAgICAgICAgICAgIG1pbkxlbmd0aCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBuZWdhdGl2ZSA9IGRhdGEuY2hhckF0KDApID09ICctJztcbiAgICAgICAgICAgICAgICB2YXIgdGltZSA9IGRhdGEuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGltZS5sZW5ndGggPj0gbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhKjYwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTigrdGltZVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhICs9ICgrdGltZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMuc2Vjb25kcykgeyAvLyB0aGUgbGFzdCBmaWVsZCB3YXMgbWludXRlcyAoZS5nLiBoOm1tKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSAqPSA2MDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAtZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLyogQ29udmVydHMgYSBzbmFrZS1jYXNlIHN0cmluZyB0byBjYW1lbENhc2UuIEV4YW1wbGU6XG4gKiAnbW90aW9uLWJsb2NrLWNvbmZpZycgLT4gJ21vdGlvbkJsb2NrQ29uZmlnJyAqL1xuLmZhY3RvcnkoJ0NhbWVsQ2FzZScsIFtcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLy0oW2Etel0pL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLyogUmV0dXJuIHRoZSBzcGVjaWZpYyBFZGl0Rm9ybSBmb3IgYSBnaXZlbiBtb2RlbC4gKi9cbi5mYWN0b3J5KCdFZGl0Rm9ybScsIFtcbiAgICAnJGluamVjdG9yJyxcbiAgICAnQ2FtZWxDYXNlJyxcbiAgICBmdW5jdGlvbiAoJGluamVjdG9yLCBDYW1lbENhc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb21Db2xsZWN0aW9uU3RyaW5nOiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBtb2RlbE5hbWUgPSBDYW1lbENhc2UoY29sbGVjdGlvbikuc3BsaXQoJy8nKVsxXTtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IG1vZGVsTW9kZWwgdG8gTW9kZWxNb2RlbEZvcm1cbiAgICAgICAgICAgICAgICB2YXIgZm9ybU5hbWUgPSBtb2RlbE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBtb2RlbE5hbWUuc2xpY2UoMSkgKyAnRm9ybSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRpbmplY3Rvci5nZXQoZm9ybU5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4vKiBDb252ZXJ0cyBudW1iZXIgb2Ygc2Vjb25kcyBpbnRvIHN0cmluZyBcImg6bW06c3NcIiBvciBcIm1tOnNzXCIgKi9cbi5maWx0ZXIoJ29zU2Vjb25kc1RvVGltZScsIFtcbiAgICAnSHVtYW5UaW1lQ29udmVydGVyJyxcbiAgICBmdW5jdGlvbiAoSHVtYW5UaW1lQ29udmVydGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc2Vjb25kcykge1xuICAgICAgICAgICAgcmV0dXJuIEh1bWFuVGltZUNvbnZlcnRlci5zZWNvbmRzVG9IdW1hblRpbWUoc2Vjb25kcyk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLyogQ29udmVydHMgbnVtYmVyIG9mIG1pbnV0ZXMgaW50byBzdHJpbmcgXCJoOm1tXCIgb3IgXCJoaDptbVwiICovXG4uZmlsdGVyKCdvc01pbnV0ZXNUb1RpbWUnLCBbXG4gICAgJ0h1bWFuVGltZUNvbnZlcnRlcicsXG4gICAgZnVuY3Rpb24gKEh1bWFuVGltZUNvbnZlcnRlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1pbnV0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBIdW1hblRpbWVDb252ZXJ0ZXIuc2Vjb25kc1RvSHVtYW5UaW1lKG1pbnV0ZXMqNjAsXG4gICAgICAgICAgICAgICAgeyBzZWNvbmRzOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICBob3VyczogJ2VuYWJsZWQnIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLy8gbWFyayBIVE1MIGFzIFwidHJ1c3RlZFwiXG4uZmlsdGVyKCd0cnVzdGVkJywgW1xuICAgICckc2NlJyxcbiAgICBmdW5jdGlvbiAoJHNjZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuICRzY2UudHJ1c3RBc0h0bWwodGV4dCk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLy8gZmlsdGVycyB0aGUgcmVxdWVzdGluZyBvYmplY3QgKGlkPXNlbGZpZCkgZnJvbSBhIGxpc3Qgb2YgaW5wdXQgb2JqZWN0c1xuLmZpbHRlcignbm90c2VsZicsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGlucHV0LCBzZWxmaWQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHNlbGZpZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5wdXQpe1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmaWQgIT0gb2JqLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSlcblxuLy8gV3JhcHMgdGhlIG9yZGVyQnkgZmlsdGVyLiBCdXQgcHV0cyAoXCJcIiwgbnVsbCwgdW5kZWZpbmVkKSBsYXN0LlxuLmZpbHRlcignb3JkZXJCeUVtcHR5TGFzdCcsIFtcbiAgICAnJGZpbHRlcicsXG4gICAgJyRwYXJzZScsXG4gICAgZnVuY3Rpb24gKCRmaWx0ZXIsICRwYXJzZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFycmF5LCBzb3J0UHJlZGljYXRlLCByZXZlcnNlT3JkZXIsIGNvbXBhcmVGbikge1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9ICRwYXJzZShzb3J0UHJlZGljYXRlKTtcbiAgICAgICAgICAgIHZhciBmYWxzeUl0ZW1zID0gW107XG4gICAgICAgICAgICB2YXIgdHJ1dGh5SXRlbXMgPSBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZmFsc3kgPSBwYXJzZWQoaXRlbSkgPT09IHZvaWQgMCB8fCBwYXJzZWQoaXRlbSkgPT09IG51bGwgfHwgcGFyc2VkKGl0ZW0pID09PSAnJztcbiAgICAgICAgICAgICAgICBpZiAoZmFsc3kpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFsc3lJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gIWZhbHN5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnV0aHlJdGVtcyA9ICRmaWx0ZXIoJ29yZGVyQnknKSh0cnV0aHlJdGVtcywgc29ydFByZWRpY2F0ZSwgcmV2ZXJzZU9yZGVyLCBjb21wYXJlRm4pO1xuICAgICAgICAgICAgcmV0dXJuIF8uY29uY2F0KHRydXRoeUl0ZW1zLCBmYWxzeUl0ZW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4vLyBNYWtlIHN1cmUgdGhhdCB0aGUgRFMgZmFjdG9yaWVzIGFyZSBsb2FkZWQgYnkgbWFraW5nIHRoZW0gYSBkZXBlbmRlbmN5XG4ucnVuKFtcbiAgICAnQ2hhdE1lc3NhZ2UnLFxuICAgICdDb25maWcnLFxuICAgICdDb3VudGRvd24nLFxuICAgICdQcm9qZWN0b3JNZXNzYWdlJyxcbiAgICAnUHJvamVjdG9yJyxcbiAgICAnUHJvamVjdGlvbkRlZmF1bHQnLFxuICAgICdUYWcnLFxuICAgICdOb3RpZnknLCAvLyBGb3Igc2V0dGluZyB1cCB0aGUgYXV0b3VwZGF0ZSBjYWxsYmFja1xuICAgIGZ1bmN0aW9uIChDaGF0TWVzc2FnZSwgQ29uZmlnLCBDb3VudGRvd24sIFByb2plY3Rvck1lc3NhZ2UsIFByb2plY3RvciwgUHJvamVjdGlvbkRlZmF1bHQsIFRhZywgTm90aWZ5KSB7fVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmFuZ3VsYXIubW9kdWxlKCdPcGVuU2xpZGVzQXBwLmNvcmUuY3N2JywgW10pXG5cbi5mYWN0b3J5KCdDc3ZEb3dubG9hZCcsIFtcbiAgICAnQ29uZmlnJyxcbiAgICAnRmlsZVNhdmVyJyxcbiAgICBmdW5jdGlvbiAoQ29uZmlnLCBGaWxlU2F2ZXIpIHtcbiAgICAgICAgdmFyIHV0ZjhfQk9NID0gZGVjb2RlVVJJQ29tcG9uZW50KCclRUYlQkIlQkYnKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZW50Um93cywgZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSBDb25maWcuZ2V0KCdnZW5lcmFsX2Nzdl9zZXBhcmF0b3InKS52YWx1ZTtcbiAgICAgICAgICAgIHZhciByb3dzID0gXy5tYXAoY29udGVudFJvd3MsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93LmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbdXRmOF9CT00gKyByb3dzLmpvaW4oJ1xcbicpXSk7XG4gICAgICAgICAgICBGaWxlU2F2ZXIuc2F2ZUFzKGJsb2IsIGZpbGVuYW1lKTtcbiAgICAgICAgfTtcbiAgICB9XG5dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAuY29yZS5kb2N4JywgW10pXG5cbi5mYWN0b3J5KCdIdG1sMkRvY3hDb252ZXJ0ZXInLCBbXG4gICAgJyRxJyxcbiAgICAnSW1hZ2VDb252ZXJ0ZXInLFxuICAgIGZ1bmN0aW9uICgkcSwgSW1hZ2VDb252ZXJ0ZXIpIHtcbiAgICAgICAgdmFyIFBBR0VCUkVBSyA9ICc8dzpwPjx3OnI+PHc6YnIgdzp0eXBlPVwicGFnZVwiIC8+PC93OnI+PC93OnA+JztcblxuICAgICAgICB2YXIgY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udmVydGVyID0ge1xuICAgICAgICAgICAgICAgIGltYWdlTWFwOiB7fSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudEltYWdlczogW10sXG4gICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwczogW10sXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVzOiBbXSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBodG1sMmRvY3ggPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgICAgIHZhciBkb2N4ID0gJyc7XG4gICAgICAgICAgICAgICAgdmFyIHRhZ1N0YWNrID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyBXaXRoIHRoaXMgdmFyaWFibGUsIHdlIGtlZXAgdHJhY2ssIGlmIHdlIGFyZSBjdXJyZW50bHkgaW5zaWRlIG9yIG91dHNpZGUgb2YgYSBwYXJhZ3JhcGguXG4gICAgICAgICAgICAgICAgdmFyIGluUGFyYWdyYXBoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgdGV4dCBtYXkgbm90IGJlZ2luIHdpdGggYSBwYXJhZ3JhcGguIElmIHNvLCBhcHBlbmQgb25lIGJlY2F1c2Ugd29yZCBuZWVkcyBpdC5cbiAgICAgICAgICAgICAgICB2YXIgc2tpcEZpcnN0UGFyYWdyYXBoQ2xvc2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnLmNoYXJBdCgwKSA9PSBcIi9cIikgeyAgLy8gQSBjbG9zaW5nIHRhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ1N0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsOiBlbmQgcGFyYWdyYXBoc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZy5pbmRleE9mKCcvcCcpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jeCArPSAnPC93OnA+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblBhcmFncmFwaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBub3cgYWxsIG90aGVyIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWduYW1lID0gdGFnLnNwbGl0KCcgJylbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOYW1lZFRhZyh0YWduYW1lLCB0YWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N4O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZU5hbWVkVGFnID0gZnVuY3Rpb24gKHRhZ25hbWUsIGZ1bGxUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogdGFnbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWduYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5QYXJhZ3JhcGggJiYgIXNraXBGaXJzdFBhcmFncmFwaENsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIHRoZSBwYXJhZ3JhcHRoLCBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jeCArPSAnPC93OnA+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEZpcnN0UGFyYWdyYXBoQ2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3ggKz0gJzx3OnA+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblBhcmFncmFwaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzcGFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVSZWdleCA9IC8oPzpcXFwifFxcO1xccz8pKFthLXpBLXpcXC1dKylcXDpcXHM/KFthLXpBLVowLTlcXC1cXCNdKykvZywgbWF0Y2hTcGFuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgobWF0Y2hTcGFuID0gc3R5bGVSZWdleC5leGVjKGZ1bGxUYWcpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1hdGNoU3BhblsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcuYXR0cnMuY29sb3IgPSBtYXRjaFNwYW5bMl0uc2xpY2UoMSk7IC8vIGN1dCBvZmYgdGhlICNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JhY2tncm91bmQtY29sb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcuYXR0cnMuYmFja2dyb3VuZENvbG9yID0gbWF0Y2hTcGFuWzJdLnNsaWNlKDEpOyAvLyBjdXQgb2ZmIHRoZSAjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0LWRlY29yYXRpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFNwYW5bMl0gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5hdHRycy51bmRlcmxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hTcGFuWzJdID09PSAnbGluZS10aHJvdWdoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcuYXR0cnMuc3RyaWtlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaHJlZlJlZ2V4ID0gL2hyZWY9XCIoW15cIl0rKVwiL2c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBocmVmUmVnZXguZXhlYyhmdWxsVGFnKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcuaHJlZiA9IGhyZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbWcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVGFnKHRhZywgZnVsbFRhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ25hbWUgIT09ICdpbWcnICYmIHRhZ25hbWUgIT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnU3RhY2sucHVzaCh0YWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VUYWcgPSBmdW5jdGlvbiAodGFnLCBmdWxsVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGltYWdlcyBoYXMgdG8gYmUgcGxhY2VkIGluc3RhbnRseSwgc28gdGhlcmUgaXMgbm8gdXNlIG9mICd0YWcnLlxuICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZVJlZ2V4ID0gLyhcXHcrKT1cXFwiKFteXFxcIl0qKVxcXCIvZywgYXR0cmlidXRlTWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoYXR0cmlidXRlTWF0Y2ggPSBhdHRyaWJ1dGVSZWdleC5leGVjKGZ1bGxUYWcpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VbYXR0cmlidXRlTWF0Y2hbMV1dID0gYXR0cmlidXRlTWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlLnNyYyAmJiBjb252ZXJ0ZXIuaW1hZ2VNYXBbaW1hZ2Uuc3JjXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uud2lkdGggPSBjb252ZXJ0ZXIuaW1hZ2VNYXBbaW1hZ2Uuc3JjXS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLmhlaWdodCA9IGNvbnZlcnRlci5pbWFnZU1hcFtpbWFnZS5zcmNdLmhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJySWQgPSBjb252ZXJ0ZXIucmVsYXRpb25zaGlwcy5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlSWQgPSBjb252ZXJ0ZXIuZG9jdW1lbnRJbWFnZXMubGVuZ3RoICsgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IG5hbWUgKCdwaWMuanBnJyksIHRpdGxlLCBleHQgKCdqcGcnKSwgbWltZSAoJ2ltYWdlL2pwZWcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UubmFtZSA9IF8ubGFzdChpbWFnZS5zcmMuc3BsaXQoJy8nKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBpbWFnZS5uYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5leHQgPSB0bXAuc3BsaWNlKC0xKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IG5hbWUgd2l0aG91dCBleHRlbnNpb24gYXMgdGl0bGUgaWYgdGhlcmUgaXNuJ3QgYSB0aXRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWFnZS50aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnRpdGxlID0gdG1wLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UubWltZSA9ICdpbWFnZS8nICsgaW1hZ2UuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlLmV4dCA9PSAnanBlJyB8fCBpbWFnZS5leHQgPT0gJ2pwZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5taW1lID0gJ2ltYWdlL2pwZWcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB4IGFuZCB5IGZvciB0aGUgY29udGFpbmVyIGFuZCBwaWN0dXJlIHNpemUgaW4gRU1VIChhc3N1bWluZyA5NmRwaSkhXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGltYWdlLndpZHRoICogOTE0NDAwIC8gOTY7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGltYWdlLmhlaWdodCAqIDkxNDQwMCAvIDk2O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaW1hZ2UgZG9lcyBub3QgYmVsb25nIGludG8gYSBwYXJhZ3JhcGggaW4gb294bWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpblBhcmFncmFwaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3ggKz0gJzwvdzpwPic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N4ICs9ICc8dzpwPjx3OnI+PHc6ZHJhd2luZz48d3A6aW5saW5lIGRpc3RUPVwiMFwiIGRpc3RCPVwiMFwiIGRpc3RMPVwiMFwiIGRpc3RSPVwiMFwiPjx3cDpleHRlbmQgY3g9XCInICsgeCArJ1wiIGN5PVwiJyArIHkgKyAnXCIvPjx3cDplZmZlY3RFeHRlbnQgbD1cIjBcIiB0PVwiMFwiIHI9XCIwXCIgYj1cIjBcIi8+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx3cDpkb2NQciBpZD1cIicgKyBpbWFnZUlkICsgJ1wiIG5hbWU9XCInICsgaW1hZ2UubmFtZSArICdcIiB0aXRsZT1cIicgKyBpbWFnZS50aXRsZSArICdcIiBkZXNjcj1cIicgKyBpbWFnZS50aXRsZSArICdcIi8+PHdwOmNOdkdyYXBoaWNGcmFtZVByPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8YTpncmFwaGljRnJhbWVMb2NrcyB4bWxuczphPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL2RyYXdpbmdtbC8yMDA2L21haW5cIiBub0NoYW5nZUFzcGVjdD1cIjFcIi8+PC93cDpjTnZHcmFwaGljRnJhbWVQcj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGE6Z3JhcGhpYyB4bWxuczphPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL2RyYXdpbmdtbC8yMDA2L21haW5cIj48YTpncmFwaGljRGF0YSB1cmk9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvZHJhd2luZ21sLzIwMDYvcGljdHVyZVwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8cGljOnBpYyB4bWxuczpwaWM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvZHJhd2luZ21sLzIwMDYvcGljdHVyZVwiPjxwaWM6bnZQaWNQcj48cGljOmNOdlByIGlkPVwiJyArIGltYWdlSWQgKyAnXCIgbmFtZT1cIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLm5hbWUgKyAnXCIgdGl0bGU9XCInICsgaW1hZ2UudGl0bGUgKyAnXCIgZGVzY3I9XCInICsgaW1hZ2UudGl0bGUgKyAnXCIvPjxwaWM6Y052UGljUHIvPjwvcGljOm52UGljUHI+PHBpYzpibGlwRmlsbD48YTpibGlwIHI6ZW1iZWQ9XCJycklkJyArIHJySWQgKyAnXCIvPjxhOnN0cmV0Y2g+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxhOmZpbGxSZWN0Lz48L2E6c3RyZXRjaD48L3BpYzpibGlwRmlsbD48cGljOnNwUHIgYndNb2RlPVwiYXV0b1wiPjxhOnhmcm0+PGE6b2ZmIHg9XCIwXCIgeT1cIjBcIi8+PGE6ZXh0IGN4PVwiJyArIHggKyAnXCIgY3k9XCInICsgeSArICdcIi8+PC9hOnhmcm0+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxhOnByc3RHZW9tIHByc3Q9XCJyZWN0XCI+PGE6YXZMc3QvPjwvYTpwcnN0R2VvbT48L3BpYzpzcFByPjwvcGljOnBpYz48L2E6Z3JhcGhpY0RhdGE+PC9hOmdyYXBoaWM+PC93cDppbmxpbmU+PC93OmRyYXdpbmc+PC93OnI+PC93OnA+JztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5QYXJhZ3JhcGggc3RheXMgdW50b3VjaGVkLCB0aGUgZG9jdW1lbnRzIHBhcmFncmFwaCBzdGF0ZSBpcyByZXN0b3JlZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5QYXJhZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N4ICs9ICc8dzpwPic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVudHJpZXMgaW4gZG9jdW1lbnRJbWFnZXMsIHJlbGF0aW9uc2hpcHMgYW5kIGNvbnRlbnRUeXBlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydGVyLmRvY3VtZW50SW1hZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogaW1hZ2Uuc3JjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHppcFBhdGg6ICd3b3JkL21lZGlhLycgKyBpbWFnZS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRlci5yZWxhdGlvbnNoaXBzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIElkOiAncnJJZCcgKyBycklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFR5cGU6ICdodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL2ltYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUYXJnZXQ6ICdtZWRpYS8nICsgaW1hZ2UubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0ZXIuY29udGVudFR5cGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBhcnROYW1lOiAnL3dvcmQvbWVkaWEvJyArIGltYWdlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGVudFR5cGU6IGltYWdlLm1pbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IHBhcmFncmFwaCwgaWYgb25seSBsb29zZSB0ZXh0IGlzIHRoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5QYXJhZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3ggKz0gJzx3OnA+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUGFyYWdyYXBoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jeFBhcnQgPSAnPHc6cj48dzpyUHI+JztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGh5cGVybGluayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0YWdTdGFjay5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnLnRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cm9uZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3hQYXJ0ICs9ICc8dzpiLz48dzpiQ3MvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jeFBhcnQgKz0gJzx3OmkvPjx3OmlDcy8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3Bhbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0YWcuYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N4UGFydCArPSAnPHc6Y29sb3Igdzp2YWw9XCInICsgdGFnLmF0dHJzW2tleV0gKyAnXCIvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JhY2tncm91bmRDb2xvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3hQYXJ0ICs9ICc8dzpzaGQgdzpmaWxsPVwiJyArIHRhZy5hdHRyc1trZXldICsgJ1wiLz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1bmRlcmxpbmUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N4UGFydCArPSAnPHc6dSB3OnZhbD1cInNpbmdsZVwiLz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpa2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N4UGFydCArPSAnPHc6c3RyaWtlLz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jeFBhcnQgKz0gJzx3OnUgdzp2YWw9XCJzaW5nbGVcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaWtlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jeFBhcnQgKz0gJzx3OnN0cmlrZS8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGNvbnZlcnRlci5yZWxhdGlvbnNoaXBzLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3hQYXJ0ID0gJzx3Omh5cGVybGluayByOmlkPVwicnJJZCcgKyBpZCArICdcIj4nICsgZG9jeFBhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3hQYXJ0ICs9ICc8dzpyU3R5bGUgdzp2YWw9XCJJbnRlcm5ldGxpbmtcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydGVyLnJlbGF0aW9uc2hpcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZDogJ3JySWQnICsgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUeXBlOiAnaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9oeXBlcmxpbmsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGFyZ2V0OiB0YWcuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRhcmdldE1vZGU6ICdFeHRlcm5hbCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5cGVybGluayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZG9jeFBhcnQgKz0gJzwvdzpyUHI+PHc6dD4nICsgdGV4dCArICc8L3c6dD48L3c6cj4nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHlwZXJsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N4UGFydCArPSAnPC93Omh5cGVybGluaz4nO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIHRvIGRvY3hcbiAgICAgICAgICAgICAgICAgICAgZG9jeCArPSBkb2N4UGFydDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3g7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlRW50aXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2luZyBvZiBzcGVjaWFsIHN5bWJvbHM6XG4gICAgICAgICAgICAgICAgICAgIGRvY3ggPSBkb2N4LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFwmYXVtbFxcOycsICdnJyksICfDpCcpO1xuICAgICAgICAgICAgICAgICAgICBkb2N4ID0gZG9jeC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcJnV1bWxcXDsnLCAnZycpLCAnw7wnKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jeCA9IGRvY3gucmVwbGFjZShuZXcgUmVnRXhwKCdcXCZvdW1sXFw7JywgJ2cnKSwgJ8O2Jyk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3ggPSBkb2N4LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFwmQXVtbFxcOycsICdnJyksICfDhCcpO1xuICAgICAgICAgICAgICAgICAgICBkb2N4ID0gZG9jeC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcJlV1bWxcXDsnLCAnZycpLCAnw5wnKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jeCA9IGRvY3gucmVwbGFjZShuZXcgUmVnRXhwKCdcXCZPdW1sXFw7JywgJ2cnKSwgJ8OWJyk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3ggPSBkb2N4LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFwmc3psaWdcXDsnLCAnZycpLCAnw58nKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jeCA9IGRvY3gucmVwbGFjZShuZXcgUmVnRXhwKCdcXCZuYnNwXFw7JywgJ2cnKSwgJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jeCA9IGRvY3gucmVwbGFjZShuZXcgUmVnRXhwKCdcXCZzZWN0XFw7JywgJ2cnKSwgJ8KnJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBlbnRpdGllcyBleGNlcHQgZ3QsIGx0IGFuZCBhbXBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudGl0eVJlZ2V4ID0gL1xcJig/IWd0fGx0fGFtcClcXHcrXFw7L2csIG1hdGNoRW50cnksIGluZGV4ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaEVudHJ5ID0gZW50aXR5UmVnZXguZXhlYyhkb2N4KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJZDogbWF0Y2hFbnRyeS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wSWQ6IG1hdGNoRW50cnkuaW5kZXggKyBtYXRjaEVudHJ5WzBdLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ZXMubGVuZ3RoIC0gMTsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N4ID0gZG9jeC5zdWJzdHJpbmcoMCwgaW5kZXhlc1tpXS5zdGFydElkKSArIGRvY3guc3Vic3RyaW5nKGluZGV4ZXNbaV0uc3RvcElkLCBkb2N4Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHRtbC5zdWJzdHJpbmcoMCwzKSAhPSAnPHA+Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jeCArPSAnPHc6cD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEZpcnN0UGFyYWdyYXBoQ2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgPSBodG1sLnNwbGl0KC8oPHw+KS9nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHdoaXRlc3BhY2VzIGFuZCA+IGJyYWNrZXRzLiBMZWF2ZSA8IGJyYWNrZXRzIGluIHRoZXJlIHRvIGNoZWNrLCB3aGV0aGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgc3RyaW5nIGlzIGEgdGFnIG9yIHRleHQuXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgPSBfLmZpbHRlcihodG1sLCBmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNraXBwZWRDaGFyc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXihbXFxzXFxuXFxyXXw+KSokJywgJ2cnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc2tpcHBlZENoYXJzUmVnZXgudGVzdChwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBodG1sLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHRtbFtpXSA9PT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVRhZyhodG1sW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlVGV4dChodG1sW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgZmluaXNoaW5nIGNsb3NlIHRoZSBsYXN0IHBhcmFncmFwaCAoaWYgb3BlbilcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluUGFyYWdyYXBoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N4ICs9ICc8L3c6cD4nO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUVudGl0aWVzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3g7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gcmV0dXJuIGEgd3JhcHBlciBmdW5jdGlvbiBmb3IgaHRtbDJkb2N4LCB0aGF0IGZldGNoZXMgYWxsIHRoZSBpbWFnZXMuXG4gICAgICAgICAgICBjb252ZXJ0ZXIuaHRtbDJkb2N4ID0gZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VTb3VyY2VzID0gXy5tYXAoJChodG1sKS5maW5kKCdpbWcnKSwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBnZXQgaW1hZ2VzIG11bHRpcGxlIHRpbWVzOyBqdXN0IGlmIHRoZSBjb252ZXJ0ZXIgaGFzIG5vdCBzZWVuIHRoZW0gYmVmb3IuXG4gICAgICAgICAgICAgICAgaW1hZ2VTb3VyY2VzID0gXy5maWx0ZXIoaW1hZ2VTb3VyY2VzLCBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhY29udmVydGVyLmltYWdlTWFwW3NyY107XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIEltYWdlQ29udmVydGVyLnRvQmFzZTY0KGltYWdlU291cmNlcykudGhlbihmdW5jdGlvbiAoX2ltYWdlTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goX2ltYWdlTWFwLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRlci5pbWFnZU1hcFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2N4ID0gaHRtbDJkb2N4KGh0bWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkb2N4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb252ZXJ0ZXIudXBkYXRlWmlwRmlsZSA9IGZ1bmN0aW9uICh6aXApIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlUmVsYXRpb25zaGlwcyA9IGZ1bmN0aW9uIChvbGRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gb2xkQ29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChjb252ZXJ0ZXIucmVsYXRpb25zaGlwcywgZnVuY3Rpb24gKHJlbGF0aW9uc2hpcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFsxXSArPSAnPFJlbGF0aW9uc2hpcCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2gocmVsYXRpb25zaGlwLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRbMV0gKz0gJyAnICsga2V5ICsgJz1cIicgKyB2YWx1ZSArICdcIic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRbMV0gKz0gJy8+JztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50LmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUNvbnRlbnRUeXBlcyA9IGZ1bmN0aW9uIChvbGRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gb2xkQ29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChjb252ZXJ0ZXIuY29udGVudFR5cGVzLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFsxXSArPSAnPE92ZXJyaWRlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaCh0eXBlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRbMV0gKz0gJyAnICsga2V5ICsgJz1cIicgKyB2YWx1ZSArICdcIic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRbMV0gKz0gJy8+JztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50LmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHJlbGF0aW9uc2hpcHMgZnJvbSAncmVsYXRpb25zaGlwcydcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpb25zaGlwcyA9IHVwZGF0ZVJlbGF0aW9uc2hpcHMoemlwLmZpbGUoJ3dvcmQvX3JlbHMvZG9jdW1lbnQueG1sLnJlbHMnKS5hc1RleHQoKSk7XG4gICAgICAgICAgICAgICAgemlwLmZpbGUoJ3dvcmQvX3JlbHMvZG9jdW1lbnQueG1sLnJlbHMnLCByZWxhdGlvbnNoaXBzKTtcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBjb250ZW50IHR5cGUgZnJvbSAnY29udGVudFR5cGVzJ1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZXMgPSB1cGRhdGVDb250ZW50VHlwZXMoemlwLmZpbGUoJ1tDb250ZW50X1R5cGVzXS54bWwnKS5hc1RleHQoKSk7XG4gICAgICAgICAgICAgICAgemlwLmZpbGUoJ1tDb250ZW50X1R5cGVzXS54bWwnLCBjb250ZW50VHlwZXMpO1xuXG4gICAgICAgICAgICAgICAgY29udmVydGVyLmRvY3VtZW50SW1hZ2VzID0gXy51bmlxQnkoY29udmVydGVyLmRvY3VtZW50SW1hZ2VzLCAnc3JjJyk7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNvbnZlcnRlci5kb2N1bWVudEltYWdlcywgZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhVXJsID0gY29udmVydGVyLmltYWdlTWFwW2ltYWdlLnNyY10uZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2U2NCA9IGRhdGFVcmwuc3BsaXQoJywnKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgemlwLmZpbGUoaW1hZ2UuemlwUGF0aCwgYmFzZTY0LCB7YmFzZTY0OiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHppcDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZUluc3RhbmNlOiBjcmVhdGVJbnN0YW5jZSxcbiAgICAgICAgfTtcbiAgICB9XG5dKTtcblxufSkoKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAuY29yZS5wZGYnLCBbXSlcblxuLypcbiAqIEdlbmVyYWwgbGF5b3V0IGZ1bmN0aW9ucyBmb3IgYnVpbGRpbmcgUERGcyB3aXRoIHBkZm1ha2UuXG4gKi9cbi5mYWN0b3J5KCdQREZMYXlvdXQnLCBbXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICBmdW5jdGlvbihnZXR0ZXh0Q2F0YWxvZykge1xuICAgICAgICB2YXIgUERGTGF5b3V0ID0ge307XG4gICAgICAgIHZhciBCYWxsb3RDaXJjbGVEaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgeURpc3RhbmNlOiA2LFxuICAgICAgICAgICAgc2l6ZTogOFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHBhZ2UgdGl0bGVcbiAgICAgICAgUERGTGF5b3V0LmNyZWF0ZVRpdGxlID0gZnVuY3Rpb24odGl0bGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dDogdGl0bGUsXG4gICAgICAgICAgICAgICAgc3R5bGU6ICd0aXRsZSdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcGFnZSBzdWJ0aXRsZVxuICAgICAgICBQREZMYXlvdXQuY3JlYXRlU3VidGl0bGUgPSBmdW5jdGlvbihzdWJ0aXRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBzdWJ0aXRsZS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICBzdHlsZTogJ3N1YnRpdGxlJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwYWdlYnJlYWtcbiAgICAgICAgUERGTGF5b3V0LmFkZFBhZ2VCcmVhayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICBwYWdlQnJlYWs6ICdhZnRlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHRhYmxlIHJvdyBzdHlsZVxuICAgICAgICBQREZMYXlvdXQuZmxpcFRhYmxlUm93U3R5bGUgPSBmdW5jdGlvbihjdXJyZW50VGFibGVTaXplKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRhYmxlU2l6ZSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RhYmxlRXZlbic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAndGFibGVPZGQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRyYXdzIGEgY2lyY2xlXG4gICAgICAgIFBERkxheW91dC5kcmF3Q2lyY2xlID0gZnVuY3Rpb24oeSwgc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlbGxpcHNlJyxcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgbGluZUNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgICAgICAgICAgICByMTogc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgcjI6IHNpemVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJldHVybnMgYW4gZW50cnkgaW4gdGhlIGJhbGxvdCB3aXRoIGEgY2lyY2xlIHRvIGRyYXcgaW50b1xuICAgICAgICBQREZMYXlvdXQuY3JlYXRlQmFsbG90RW50cnkgPSBmdW5jdGlvbihkZWNpc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYXJnaW46IFs0MCtCYWxsb3RDaXJjbGVEaW1lbnNpb25zLnNpemUsIDEwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhczogUERGTGF5b3V0LmRyYXdDaXJjbGUoQmFsbG90Q2lyY2xlRGltZW5zaW9ucy55RGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJhbGxvdENpcmNsZURpbWVuc2lvbnMuc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGRlY2lzaW9uXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBjcm9wIG1hcmtzIGZvciBiYWxsb3QgcGFwZXJzXG4gICAgICAgIFBERkxheW91dC5nZXRCYWxsb3RMYXlvdXRMaW5lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICd7e2JhbGxvdC1wbGFjZWhvbGRlci10by1pbnNlcnQtZnVuY3Rpb25zLWhlcmV9fSc7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmV0dXJucyBhIHByb21pc2UgZm9yIGNvbnZlcnRpbmcgYW4gaW1hZ2UgaW4gZGF0YSBVUkwgZm9ybWF0IHdpdGggc2l6ZSBpbmZvcm1hdGlvblxuICAgICAgICBQREZMYXlvdXQuaW1hZ2VVUkx0b0Jhc2U2NCA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2c6ICc8aSBjbGFzcz1cImZhIGZhLWV4Y2xhbWF0aW9uLXRyaWFuZ2xlIGZhLWxnIHNwYWNlci1yaWdodFwiPjwvaT4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdFcnJvciB3aGlsZSBnZW5lcmF0aW5nIFBERiBmaWxlJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOiA8Y29kZT4nICsgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdDYW5ub3QgbG9hZCBpbWFnZScpICsgJyAnICsgdXJsICsgJzwvY29kZT4nLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhVVJMLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGltZy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaW1nLmhlaWdodFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGltYWdlRGF0YSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gUERGTGF5b3V0O1xuICAgIH1cbl0pXG5cblxuLmZhY3RvcnkoJ0hUTUxWYWxpZGl6ZXInLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgSFRNTFZhbGlkaXplciA9IHt9O1xuXG4gICAgLy8gSW4gc29tZSBjYXNlcyBjb3B5aW5nIGZyb20gd29yZCB0byBPcGVuU2xpZGVzIHJlc3VsdHMgaW4gdW1sYXV0c1xuICAgIC8vIHRoYXQgYXJlIHRoZSBiYXNlIGxldHRlciBhbmQgdGhlbiB0aGUgZW50aXR5ICM3NzY7IHRvIG1ha2UgdGhlIGRvdHNcbiAgICAvLyBhYm92ZSB0aGUgYmFzZSBsZXR0ZXIuIFRoaXMgYnJlYWtzIHRoZSBQREYuXG4gICAgSFRNTFZhbGlkaXplci5yZXBsYWNlTWFsZm9ybWVkVW1sYXV0cyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLyhbYWVpb3VBRUlPVXldKVtcXHUwMzA4XS9nLCBmdW5jdGlvbiAobWF0Y2gsIGJhc2VDaGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gJyYnICsgYmFzZUNoYXIgKyAndW1sOyc7XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuICAgIC8vY2hlY2tzIGlmIHN0ciBpcyB2YWxpZCBIVE1MLiBSZXR1cm5zIHZhbGlkIEhUTUwgaWYgbm90LFxuICAgIC8vcmV0dXJuIGVtcHR5c3RyaW5nIGlmIGVtcHR5XG4gICAgSFRNTFZhbGlkaXplci52YWxpZGl6ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICBzdHIgPSBIVE1MVmFsaWRpemVyLnJlcGxhY2VNYWxmb3JtZWRVbWxhdXRzKHN0cik7XG4gICAgICAgICAgICAvLyBTb21ldGltZXMsIHNvbWUgXFxuIGFyZSBpbiB0aGUgdGV4dCBpbnN0ZWFkIG9mIHdoaXRlc3BhY2VzLiBSZXBsYWNlIHRoZW0uXG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxuL2csICcgJyk7XG5cbiAgICAgICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBhLmlubmVySFRNTCA9IHN0cjtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChhLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gJzxwPicgKyBzdHIgKyAnPC9wPic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7IC8vbmVlZGVkIGZvciBibGFuayAncmVhc29ucycgZmllbGRcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEhUTUxWYWxpZGl6ZXI7XG59KVxuXG5cbi5mYWN0b3J5KCdQZGZNYWtlRG9jdW1lbnRQcm92aWRlcicsIFtcbiAgICAnJHEnLFxuICAgICdDb25maWcnLFxuICAgICdQREZMYXlvdXQnLFxuICAgICdJbWFnZUNvbnZlcnRlcicsXG4gICAgZnVuY3Rpb24oJHEsIENvbmZpZywgUERGTGF5b3V0LCBJbWFnZUNvbnZlcnRlcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvdmlkZXMgdGhlIGdsb2JhbCBkb2N1bWVudFxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRlbnRQcm92aWRlciAtIE9iamVjdCB3aXRoIG9uIG1ldGhvZCBgZ2V0Q29udGVudGAsIHdoaWNoXG4gICAgICAgICAqIHJldHVybnMgYW4gYXJyYXkgZm9yIGNvbnRlbnRcbiAgICAgICAgICovXG4gICAgICAgIC8vaW1hZ2VzIHNoYWxsIGNvbnRhaW4gdGhlIHRoZSBsb2dvcyBhcyBVUkw6IGJhc2U2NFN0ciwganVzdCBsaWtlIHRoZSBjb252ZXJ0ZXJcbiAgICAgICAgdmFyIGNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24oY29udGVudFByb3ZpZGVyLCBub0Zvb3Rlcikge1xuICAgICAgICAgICAgLy8gTG9nbyB1cmxzXG4gICAgICAgICAgICB2YXIgbG9nb0hlYWRlckxlZnRVcmwgPSBDb25maWcuZ2V0KCdsb2dvX3BkZl9oZWFkZXJfTCcpLnZhbHVlLnBhdGgsXG4gICAgICAgICAgICAgICAgbG9nb0hlYWRlclJpZ2h0VXJsID0gQ29uZmlnLmdldCgnbG9nb19wZGZfaGVhZGVyX1InKS52YWx1ZS5wYXRoLFxuICAgICAgICAgICAgICAgIGxvZ29Gb290ZXJMZWZ0VXJsID0gQ29uZmlnLmdldCgnbG9nb19wZGZfZm9vdGVyX0wnKS52YWx1ZS5wYXRoLFxuICAgICAgICAgICAgICAgIGxvZ29Gb290ZXJSaWdodFVybCA9IENvbmZpZy5nZXQoJ2xvZ29fcGRmX2Zvb3Rlcl9SJykudmFsdWUucGF0aDtcbiAgICAgICAgICAgIHZhciBpbWFnZU1hcCA9IGNvbnRlbnRQcm92aWRlci5nZXRJbWFnZU1hcCA/IGNvbnRlbnRQcm92aWRlci5nZXRJbWFnZU1hcCgpIDoge307XG5cbiAgICAgICAgICAgIC8vIFBERiBoZWFkZXJcbiAgICAgICAgICAgIHZhciBnZXRIZWFkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvZ29IZWFkZXJMZWZ0VXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dvSGVhZGVyTGVmdFVybC5pbmRleE9mKCcvJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ29IZWFkZXJMZWZ0VXJsID0gbG9nb0hlYWRlckxlZnRVcmwuc3Vic3RyKDEpOyAvLyByZW1vdmUgdHJhaWxpbmcgL1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogbG9nb0hlYWRlckxlZnRVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXQ6IFsxODAsIDQwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMjAlJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbGluZTEgPSBbXG4gICAgICAgICAgICAgICAgICAgIENvbmZpZy50cmFuc2xhdGUoQ29uZmlnLmdldCgnZ2VuZXJhbF9ldmVudF9uYW1lJykudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBDb25maWcudHJhbnNsYXRlKENvbmZpZy5nZXQoJ2dlbmVyYWxfZXZlbnRfZGVzY3JpcHRpb24nKS52YWx1ZSlcbiAgICAgICAgICAgICAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKCcg4oCTICcpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lMiA9IFtcbiAgICAgICAgICAgICAgICAgICAgQ29uZmlnLmdldCgnZ2VuZXJhbF9ldmVudF9sb2NhdGlvbicpLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBDb25maWcuZ2V0KCdnZW5lcmFsX2V2ZW50X2RhdGUnKS52YWx1ZVxuICAgICAgICAgICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBbbGluZTEsIGxpbmUyXS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMTAsXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudDogbG9nb0hlYWRlclJpZ2h0VXJsID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMCwgMTAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvZ29IZWFkZXJSaWdodFVybCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nb0hlYWRlclJpZ2h0VXJsLmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nb0hlYWRlclJpZ2h0VXJsID0gbG9nb0hlYWRlclJpZ2h0VXJsLnN1YnN0cigxKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIC9cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGxvZ29IZWFkZXJSaWdodFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpdDogWzE4MCwgNDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcyMCUnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnIzU1NScsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiA5LFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFs3NSwgMzAsIDc1LCAxMF0sIC8vIFtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21dXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IGNvbHVtbnMsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkdhcDogMTAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgLy8gUERGIGZvb3RlclxuICAgICAgICAgICAgLy8gVXNlZCBwbGFjZWhvbGRlciBmb3IgY3VycmVudFBhZ2UgYW5kIHBhZ2VDb3VudCB3aGljaFxuICAgICAgICAgICAgLy8gYXJlIHJlcGxhY2VkIGJ5IGR5bmFtaWMgZm9vdGVyIGZ1bmN0aW9uIGluIHBkZi13b3JrZXIuanMuXG4gICAgICAgICAgICB2YXIgZ2V0Rm9vdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc2luZ2xlIGxvZ28sIGdpdmUgaXQgYSBsb3Qgb2Ygc3BhY2VcbiAgICAgICAgICAgICAgICB2YXIgbG9nb0NvbnRhaW5lcldpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBsb2dvQ29udGVpbmVyU2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAobG9nb0Zvb3RlckxlZnRVcmwgJiYgbG9nb0Zvb3RlclJpZ2h0VXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ29Db250YWluZXJXaWR0aCA9ICcyMCUnO1xuICAgICAgICAgICAgICAgICAgICBsb2dvQ29udGVpbmVyU2l6ZSA9IFsxODAsIDQwXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dvQ29udGFpbmVyV2lkdGggPSAnODAlJztcbiAgICAgICAgICAgICAgICAgICAgbG9nb0NvbnRlaW5lclNpemUgPSBbNDAwLCA1MF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBvc2l0aW9uIG9mIHRoZSBwYWdlIG51bWJlciBkZXBlbmRzIG9uIHRoZSBsb2dvc1xuICAgICAgICAgICAgICAgIHZhciBwYWdlTnVtYmVyUG9zaXRpb247XG4gICAgICAgICAgICAgICAgaWYgKGxvZ29Gb290ZXJMZWZ0VXJsICYmIGxvZ29Gb290ZXJSaWdodFVybCkge1xuICAgICAgICAgICAgICAgICAgICBwYWdlTnVtYmVyUG9zaXRpb24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvZ29Gb290ZXJMZWZ0VXJsICYmICghbG9nb0Zvb3RlclJpZ2h0VXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBwYWdlTnVtYmVyUG9zaXRpb24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9nb0Zvb3RlclJpZ2h0VXJsICYmICghbG9nb0Zvb3RlckxlZnRVcmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VOdW1iZXJQb3NpdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYWdlTnVtYmVyUG9zaXRpb24gPSBDb25maWcuZ2V0KCdnZW5lcmFsX2V4cG9ydF9wZGZfcGFnZW51bWJlcl9hbGlnbm1lbnQnKS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobG9nb0Zvb3RlckxlZnRVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ29Gb290ZXJMZWZ0VXJsLmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nb0Zvb3RlckxlZnRVcmwgPSBsb2dvRm9vdGVyTGVmdFVybC5zdWJzdHIoMSk7IC8vIHJlbW92ZSB0cmFpbGluZyAvXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBsb2dvRm9vdGVyTGVmdFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpdDogbG9nb0NvbnRlaW5lclNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbG9nb0NvbnRhaW5lcldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50OiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAne3tjdXJyZW50UGFnZX19IC8ge3twYWdlQ291bnR9fScsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnIzU1NScsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiA5LFxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IHBhZ2VOdW1iZXJQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMCwgMTUsIDAsIDBdLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvZ29Gb290ZXJSaWdodFVybCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nb0Zvb3RlclJpZ2h0VXJsLmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nb0Zvb3RlclJpZ2h0VXJsID0gbG9nb0Zvb3RlclJpZ2h0VXJsLnN1YnN0cigxKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIC9cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGxvZ29Gb290ZXJSaWdodFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpdDogbG9nb0NvbnRlaW5lclNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbG9nb0NvbnRhaW5lcldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50OiAncmlnaHQnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbNzUsIDAsIDc1LCAxMF0sXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IGNvbHVtbnMsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkdhcDogMTAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIGRvY3VtZW50KGRlZmluaXRpb24pIGZvciBwZGZNYWtlXG4gICAgICAgICAgICB2YXIgZ2V0RG9jdW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGNvbnRlbnRQcm92aWRlci5nZXRDb250ZW50KCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YW5kYXJkRm9udHNpemUgPSBDb25maWcuZ2V0KCdnZW5lcmFsX2V4cG9ydF9wZGZfZm9udHNpemUnKS52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwYWdlU2l6ZTogJ0E0JyxcbiAgICAgICAgICAgICAgICAgICAgcGFnZU1hcmdpbnM6IFs3NSwgOTAsIDc1LCA3NV0sXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9udDogJ1BkZkZvbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IHN0YW5kYXJkRm9udHNpemVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiBnZXRIZWFkZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgZm9vdGVyVHBsOiBub0Zvb3RlciA/ICcnIDogZ2V0Rm9vdGVyKCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMTgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMCwwLDAsMjBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiA5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogWzAsLTIwLDAsMjBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnZ3JleSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVhbWJsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBzdGFuZGFyZEZvbnRzaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogWzAsMCwwLDEwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YVRpdGxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDI2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogWzAsMCwwLDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0SXRlbToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFswLDddXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGluZzI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMCwwLDAsMTBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkaW5nMzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFswLDEwLDAsMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9sZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhSGVhZGluZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFswLDEwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2xkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFUb3BpYzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFswLDVdXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFWYWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFsxNSw1XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvY0VudHJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogWzAsMCwwLDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9jQ2F0ZWdvcnlFbnRyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFsxMCwwLDAsMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9sZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2NDYXRlZ29yeVRpdGxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogWzAsMCwwLDRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9jQ2F0ZWdvcnlTZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMCwwLDAsMTBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RQYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMCw1XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RDaGlsZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFswLDVdXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVIZWFkZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2xkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJ3doaXRlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlRXZlbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJ3doaXRlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlT2RkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnI2VlZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUNvbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnI2RkZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9sZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICcjZGRkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaWdodGdyZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICcjYWFhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBib2xkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9sZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzbWFsbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiA4LFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBnZXRJbWFnZU1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VNYXA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gJHEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBpbWFnZVNvdXJjZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIGxvZ29IZWFkZXJMZWZ0VXJsLFxuICAgICAgICAgICAgICAgICAgICBsb2dvSGVhZGVyUmlnaHRVcmwsXG4gICAgICAgICAgICAgICAgICAgIGxvZ29Gb290ZXJMZWZ0VXJsLFxuICAgICAgICAgICAgICAgICAgICBsb2dvRm9vdGVyUmlnaHRVcmwsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBJbWFnZUNvbnZlcnRlci50b0Jhc2U2NChpbWFnZVNvdXJjZXMpLnRoZW4oZnVuY3Rpb24gKF9pbWFnZU1hcCkge1xuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goX2ltYWdlTWFwLCBmdW5jdGlvbiAoZGF0YSwgcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWFnZU1hcFtwYXRoXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlTWFwW3BhdGhdID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RG9jdW1lbnQ6IGdldERvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SW1hZ2VNYXA6IGdldEltYWdlTWFwLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVJbnN0YW5jZTogY3JlYXRlSW5zdGFuY2UsXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ1BkZk1ha2VCYWxsb3RQYXBlclByb3ZpZGVyJywgW1xuICAgICdQREZMYXlvdXQnLFxuICAgIGZ1bmN0aW9uKFBERkxheW91dCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvdmlkZXMgdGhlIGdsb2JhbCBEb2N1bWVudFxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRlbnRQcm92aWRlciAtIE9iamVjdCB3aXRoIG9uIG1ldGhvZCBgZ2V0Q29udGVudGAsIHdoaWNoIHJldHVybnMgYW4gYXJyYXkgZm9yIGNvbnRlbnRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uKGNvbnRlbnRQcm92aWRlcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZW5lcmF0ZXMgdGhlIGRvY3VtZW50KGRlZmluaXRpb24pIGZvciBwZGZNYWtlXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGdldERvY3VtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjb250ZW50UHJvdmlkZXIuZ2V0Q29udGVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VTaXplOiAnQTQnLFxuICAgICAgICAgICAgICAgICAgICBwYWdlTWFyZ2luczogWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQ6ICdQZGZGb250JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMzAsIDMwLCAwLCAwXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogWzMwLCAwLCAwLCAwXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBnZXRJbWFnZU1hcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50UHJvdmlkZXIuZ2V0SW1hZ2VNYXAoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2V0RG9jdW1lbnQ6IGdldERvY3VtZW50LFxuICAgICAgICAgICAgICAgIGdldEltYWdlTWFwOiBnZXRJbWFnZU1hcCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVJbnN0YW5jZTogY3JlYXRlSW5zdGFuY2VcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnUGRmTWFrZUNvbnZlcnRlcicsIFtcbiAgICAnSFRNTFZhbGlkaXplcicsXG4gICAgJ0NvbmZpZycsXG4gICAgZnVuY3Rpb24oSFRNTFZhbGlkaXplciwgQ29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0ZXIgY29tcG9uZW50IGZvciBIVE1MLT5KU09OIGZvciBwZGZNYWtlXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaW1hZ2VzICAgLSBLZXktVmFsdWUgc3RydWN0dXJlIHJlcHJlc2VudGluZyBpbWFnZS5zcmMvQkFTRTY0IG9mIGltYWdlc1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24oaW1hZ2VzKSB7XG4gICAgICAgICAgICB2YXIgc2xpY2UgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKFtdLnNsaWNlKSxcbiAgICAgICAgICAgICAgICBtYXAgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKFtdLm1hcCksXG5cbiAgICAgICAgICAgICAgICBESUZGX01PREVfTk9STUFMID0gMCxcbiAgICAgICAgICAgICAgICBESUZGX01PREVfSU5TRVJUID0gMSxcbiAgICAgICAgICAgICAgICBESUZGX01PREVfREVMRVRFID0gMixcblxuICAgICAgICAgICAgICAgIC8vIFNwYWNlIGJldHdlZW4gbGlzdCBlbGVtZW50c1xuICAgICAgICAgICAgICAgIExJX01BUkdJTl9CT1RUT00gPSA4LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ29udmVydGVzIEhUTUwgZm9yIHVzZSB3aXRoIHBkZk1ha2VcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaHRtbCAtIGh0bWxcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGluZU51bWJlck1vZGUgLSBbaW5saW5lLCBvdXRzaWRlLCBub25lXVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnZlcnRIVE1MID0gZnVuY3Rpb24oaHRtbCwgbGluZU51bWJlck1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRTdHlsZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2InOiBbJ2ZvbnQtd2VpZ2h0OmJvbGQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3Ryb25nJzogWydmb250LXdlaWdodDpib2xkJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3UnOiBbJ3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZW0nOiBbJ2ZvbnQtc3R5bGU6aXRhbGljJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2knOiBbJ2ZvbnQtc3R5bGU6aXRhbGljJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2gxJzogWydmb250LXNpemU6MTQnLCAnZm9udC13ZWlnaHQ6Ym9sZCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoMic6IFsnZm9udC1zaXplOjEyJywgJ2ZvbnQtd2VpZ2h0OmJvbGQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaDMnOiBbJ2ZvbnQtc2l6ZToxMCcsICdmb250LXdlaWdodDpib2xkJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2g0JzogWydmb250LXNpemU6MTAnLCAnZm9udC1zdHlsZTppdGFsaWMnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaDUnOiBbJ2ZvbnQtc2l6ZToxMCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoNic6IFsnZm9udC1zaXplOjEwJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2EnOiBbJ2NvbG9yOmJsdWUnLCAndGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdHJpa2UnOiBbJ3RleHQtZGVjb3JhdGlvbjpsaW5lLXRocm91Z2gnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGVsJzogWydjb2xvcjpyZWQnLCAndGV4dC1kZWNvcmF0aW9uOmxpbmUtdGhyb3VnaCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbnMnOiBbJ2NvbG9yOmdyZWVuJywgJ3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmUnXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzU3R5bGVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkZWxldGUnOiBbJ2NvbG9yOnJlZCcsICd0ZXh0LWRlY29yYXRpb246bGluZS10aHJvdWdoJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luc2VydCc6IFsnY29sb3I6Z3JlZW4nLCAndGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZSddXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TGluZU51bWJlciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlTmFtZSA9PSAnU1BBTicgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykuaW5kZXhPZignb3MtbGluZS1udW1iZXInKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1saW5lLW51bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIGFsbCBsaW5lIG51bWJlciBub2RlcyAobm90IGxpbmUtYnJlYWtzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgcmVvdmVkIG51bWJlcnMgaW4gdGhpcyBmb3JtYXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB7IGxpbmVOdW1iZXI6ICc8bGluZU51bWJlcj4nLCBtYXJnaW5Cb3R0b206IDxudW1iZXI+IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHdoZXJlIG1hcmdpbkJvdHRvbSBpcyBvcHRpb25hbC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RMaW5lTnVtYmVycyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRMaW5lTnVtYmVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTnVtYmVyID0gZ2V0TGluZU51bWJlcihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZExpbmVOdW1iZXJzLnB1c2goe2xpbmVOdW1iZXI6IGxpbmVOdW1iZXJ9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0JSJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lLCBidXQgaXQgZG9lcyBub3QgZ2V0IGEgbGluZSBudW1iZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHNvLCBpbnNlcnQgYSBkdW1teSBsaW5lLCBzbyB0aGUgbGluZSBudWJlcnMgc3RheXMgYWxpZ25lZCB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0ZXh0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdldExpbmVOdW1iZXIoZWxlbWVudC5uZXh0U2libGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTGluZU51bWJlcnMucHVzaCh7bGluZU51bWJlcjogJyd9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGROb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5MaW5lTnVtYmVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkxpbmVOdW1iZXJzID0gXy5jb25jYXQoY2hpbGRyZW5MaW5lTnVtYmVycywgZXh0cmFjdExpbmVOdW1iZXJzKGNoaWxkcmVuW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoIDwgY2hpbGRyZW5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpIC09IChjaGlsZHJlbkxlbmd0aCAtIGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBsaXN0IGl0ZW0sIGFkZCBzb21lIHNwYWNlIHRvIHRoZSBsaW5lTnVtYmVyczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuTGluZU51bWJlcnMubGVuZ3RoICYmIGVsZW1lbnQubm9kZU5hbWUgPT09ICdMSScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFzdChjaGlsZHJlbkxpbmVOdW1iZXJzKS5tYXJnaW5Cb3R0b20gPSBMSV9NQVJHSU5fQk9UVE9NO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTGluZU51bWJlcnMgPSBfLmNvbmNhdChmb3VuZExpbmVOdW1iZXJzLCBjaGlsZHJlbkxpbmVOdW1iZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kTGluZU51bWJlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBQYXJzZXMgQ2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgcGFyYWdyYXBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb252ZXJ0ZWQgIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50ICAgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRQYXJhZ3JhcGggLVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlcyAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlmZl9tb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQ2hpbGRyZW4gPSBmdW5jdGlvbihjb252ZXJ0ZWQsIGVsZW1lbnQsIGN1cnJlbnRQYXJhZ3JhcGgsIHN0eWxlcywgZGlmZl9tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZWxlbWVudC5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaCA9IFBhcnNlRWxlbWVudChlbGVtZW50cywgY2hpbGQsIGN1cnJlbnRQYXJhZ3JhcGgsIHN0eWxlcywgZGlmZl9tb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydGVkLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJhZ3JhcGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb2xvciBpbiBhIGhleCBmb3JtYXQgKGUuZy4gIzEyZmYwMCkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBUcmllcyB0byBjb252ZXJ0IHRoZSByZ2IgZm9ybSBpbnRvIHRoaXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUNvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhleFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXiMoWzAtOWEtZl17M318WzAtOWEtZl17Nn0pJCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gI2ZmZiBvciAjZmYwMDQ4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJnYlJlZ2V4ID0gbmV3IFJlZ0V4cCgnXnJnYlxcXFwoKFxcXFxkKyksXFxcXHMqKFxcXFxkKyksXFxcXHMqKFxcXFxkKylcXFxcKSQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuIHJnYigwLDI1NSwzNCkgb3IgcmdiKDIyLCAwLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lUmVnZXggPSBuZXcgUmVnRXhwKCdeW2Etel0rJCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoZXMganVzdCB0ZXh0IGxpa2UgJ3JlZCcsICdibGFjaycsICdncmVlbidcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZXhSZWdleC50ZXN0KGNvbG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZ2JSZWdleC50ZXN0KGNvbG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjaW1hbENvbG9ycyA9IHJnYlJlZ2V4LmV4ZWMoY29sb3IpLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2ltYWxWYWx1ZSA9IHBhcnNlSW50KGRlY2ltYWxDb2xvcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2ltYWxWYWx1ZSA+IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWxWYWx1ZSA9IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZXhTdHJpbmcgPSAnMCcgKyBkZWNpbWFsVmFsdWUudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4U3RyaW5nID0gaGV4U3RyaW5nLnNsaWNlKC0yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWxDb2xvcnNbaV0gPSBoZXhTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcjJyArIGRlY2ltYWxDb2xvcnMuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lUmVnZXgudGVzdChjb2xvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSBjb2xvciBcIicgKyBjb2xvciArICdcIicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRXh0cmFjdHMgdGhlIHN0eWxlIGZyb20gYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvICAgICAgIC0gdGhlIGN1cnJlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzICAtIGFuIGFycmF5IHdpdGggc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIENvbXB1dGVTdHlsZSA9IGZ1bmN0aW9uKG8sIHN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHNpbmdsZVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZURlZmluaXRpb24gPSBzaW5nbGVTdHlsZS50cmltKCkudG9Mb3dlckNhc2UoKS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZURlZmluaXRpb25bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlRGVmaW5pdGlvblsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlRGVmaW5pdGlvbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwYWRkaW5nLWxlZnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLm1hcmdpbiA9IFtwYXJzZUludCh2YWx1ZSksIDAsIDAsIDBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmb250LXNpemUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLmZvbnRTaXplID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0LWFsaWduJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2p1c3RpZnknOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uYWxpZ25tZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9udC13ZWlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib2xkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLmJvbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQtZGVjb3JhdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VuZGVybGluZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5kZWNvcmF0aW9uID0gJ3VuZGVybGluZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsaW5lLXRocm91Z2gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uZGVjb3JhdGlvbiA9ICdsaW5lVGhyb3VnaCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9udC1zdHlsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2l0YWxpYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5pdGFsaWNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb2xvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uY29sb3IgPSBwYXJzZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmFja2dyb3VuZC1jb2xvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uYmFja2dyb3VuZCA9IHBhcnNlQ29sb3IodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgbGl0dGxlIGhlbHBlciBmdW5jdGlvbiB0byBjaGVjaywgaWYgYW4gZWxlbWVudCBoYXMgdGhlIGdpdmVuIGNsYXNzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzID0gY2xhc3Nlcy50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmluZGV4T2YoY2xhc3NlcywgY2xhc3NOYW1lKSA+IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmF0aW5nIHdoZXRoZXIgYSBwYXJlbnQgb2YgZWxlbWVudCBpcyBhIGxpc3QgaXRlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSW5zaWRlQUxpc3QgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2xpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFBhcnNlcyBhIHNpbmdsZSBIVE1MIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGFscmVhZHlDb252ZXJ0ZWQgIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50ICAgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRQYXJhZ3JhcGggLVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlcyAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlmZl9tb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIFBhcnNlRWxlbWVudCA9IGZ1bmN0aW9uKGFscmVhZHlDb252ZXJ0ZWQsIGVsZW1lbnQsIGN1cnJlbnRQYXJhZ3JhcGgsIHN0eWxlcywgZGlmZl9tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gc3R5bGVzID8gXy5jbG9uZShzdHlsZXMpIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVTdHlsZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlU3R5bGUuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGVTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBub2RlU3R5bGUucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaCh0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVDbGFzcyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzID0gbm9kZUNsYXNzLnRvTG93ZXJDYXNlKCkuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbihub2RlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGNsYXNzU3R5bGVzW25vZGVDbGFzc10pICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzU3R5bGVzW25vZGVDbGFzc10uZm9yRWFjaChmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVDbGFzcyA9PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmX21vZGUgPSBESUZGX01PREVfSU5TRVJUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZUNsYXNzID09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZfbW9kZSA9IERJRkZfTU9ERV9ERUxFVEU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaDEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoMic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2gzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaDQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoNSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lTnVtYmVyTW9kZSA9PT0gJ291dHNpZGUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hpbGROb2Rlc1swXS5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGhlYWRpbmcgbWF5IGhhdmUgbXVsdGlwbGUgbGluZXMsIHNvIGhhbmRsZSBsaW5lIGJ5IGxpbmUgc2VwYXJhdGVkIGJ5IGxpbmUgbnVtYmVyIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dGVyU3RhY2sgPSBjcmVhdGUoJ3N0YWNrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDb2wsIGN1cnJlbnRUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChlbGVtZW50LmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1saW5lLW51bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbXB1dGVTdHlsZShjdXJyZW50Q29sLCBlbGVtZW50U3R5bGVzW25vZGVOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJTdGFjay5zdGFjay5wdXNoKGN1cnJlbnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRleHQgPSBjcmVhdGUoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb2wgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRMaW5lTnVtYmVyT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWxpbmUtbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMCwgMiwgMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZFRleHQgPSBQYXJzZUVsZW1lbnQoW10sIG5vZGUsIGNyZWF0ZSgndGV4dCcpLCBzdHlsZXMsIGRpZmZfbW9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcHBlbmQgdGhlIHBhcnNlZCB0ZXh0IHRvIHRoZSBjdXJyZW50VGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKHBhcnNlZFRleHQudGV4dCwgZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dC50ZXh0LnB1c2godGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbXB1dGVTdHlsZShjdXJyZW50Q29sLCBlbGVtZW50U3R5bGVzW25vZGVOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJTdGFjay5zdGFjay5wdXNoKGN1cnJlbnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyU3RhY2subWFyZ2luID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghL2hbMS02XS8udGVzdChlbGVtZW50LnByZXZpb3VzU2libGluZy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlclN0YWNrLm1hcmdpblsxXSA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5Q29udmVydGVkLnB1c2gob3V0ZXJTdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJhZ3JhcGggPSBjcmVhdGUoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyYWdyYXBoLm1hcmdpbkJvdHRvbSA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaC5tYXJnaW5Ub3AgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyYWdyYXBoID0gcGFyc2VDaGlsZHJlbihhbHJlYWR5Q29udmVydGVkLCBlbGVtZW50LCBjdXJyZW50UGFyYWdyYXBoLCBzdHlsZXMuY29uY2F0KGVsZW1lbnRTdHlsZXNbbm9kZU5hbWVdKSwgZGlmZl9tb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5Q29udmVydGVkLnB1c2goY3VycmVudFBhcmFncmFwaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW5zJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaWtlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJhZ3JhcGggPSBwYXJzZUNoaWxkcmVuKGFscmVhZHlDb252ZXJ0ZWQsIGVsZW1lbnQsIGN1cnJlbnRQYXJhZ3JhcGgsIHN0eWxlcy5jb25jYXQoZWxlbWVudFN0eWxlc1tub2RlTmFtZV0pLCBkaWZmX21vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gY3JlYXRlKCd0YWJsZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3JkZXIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYm9yZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNCb3JkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0JvcmRlciA9IChwYXJzZUludChib3JkZXIpID09PSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5sYXlvdXQgPSAnbm9Cb3JkZXJzJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJhZ3JhcGggPSBwYXJzZUNoaWxkcmVuKHQudGFibGUuYm9keSwgZWxlbWVudCwgY3VycmVudFBhcmFncmFwaCwgc3R5bGVzLCBkaWZmX21vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRocyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd3aWR0aHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2lkdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQudGFibGUuYm9keS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQudGFibGUuYm9keVswXS5sZW5ndGggIT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHQudGFibGUuYm9keVswXS5sZW5ndGg7IGsrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnRhYmxlLndpZHRocy5wdXNoKCcqJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHdpZHRocy5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtvID0gMDsga28gPCB3Lmxlbmd0aDsga28rKykgdC50YWJsZS53aWR0aHMucHVzaCh3W2tvXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5Q29udmVydGVkLnB1c2godCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaCA9IHBhcnNlQ2hpbGRyZW4oYWxyZWFkeUNvbnZlcnRlZCwgZWxlbWVudCwgY3VycmVudFBhcmFncmFwaCwgc3R5bGVzLCBkaWZmX21vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJhZ3JhcGggPSBwYXJzZUNoaWxkcmVuKHJvdywgZWxlbWVudCwgY3VycmVudFBhcmFncmFwaCwgc3R5bGVzLCBkaWZmX21vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeUNvbnZlcnRlZC5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndGQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaCA9IGNyZWF0ZSgndGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ID0gY3JlYXRlKCdzdGFjaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Quc3RhY2sucHVzaChjdXJyZW50UGFyYWdyYXBoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByc3BhbiA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb3dzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnNwYW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Qucm93U3BhbiA9IHBhcnNlSW50KHJzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjc3BhbiA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjb2xzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3NwYW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3QuY29sU3BhbiA9IHBhcnNlSW50KGNzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJhZ3JhcGggPSBwYXJzZUNoaWxkcmVuKHN0LnN0YWNrLCBlbGVtZW50LCBjdXJyZW50UGFyYWdyYXBoLCBzdHlsZXMsIGRpZmZfbW9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5Q29udmVydGVkLnB1c2goc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NwYW4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWxpbmUtbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZU51bWJlck1vZGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmX21vZGUgIT09IERJRkZfTU9ERV9JTlNFUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTnVtYmVySW5saW5lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGluZS1udW1iZXInKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyT2JqSW5saW5lID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsaW5lTnVtYmVySW5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2dyYXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogNVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyYWdyYXBoLnRleHQucHVzaChsaW5lTnVtYmVyT2JqSW5saW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZU51bWJlck1vZGUgPT09ICdvdXRzaWRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZU51bWJlck91dGxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmX21vZGUgPT09IERJRkZfTU9ERV9JTlNFUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXJPdXRsaW5lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyT3V0bGluZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWxpbmUtbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRMaW5lTnVtYmVyT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlck91dGxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJhZ3JhcGggPSBjcmVhdGUoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaC5saW5lSGVpZ2h0ID0gMS4yNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sLmNvbHVtbnMucHVzaChjdXJyZW50UGFyYWdyYXBoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeUNvbnZlcnRlZC5wdXNoKGNvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaCA9IHBhcnNlQ2hpbGRyZW4oYWxyZWFkeUNvbnZlcnRlZCwgZWxlbWVudCwgY3VycmVudFBhcmFncmFwaCwgc3R5bGVzLCBkaWZmX21vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiclBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiclBhcmVudE5vZGVOYW1lID0gYnJQYXJlbnQubm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2luIGNhc2Ugb2Ygbm8gb3IgaW5saW5lLWxpbmUtbnVtYmVycyBhbmQgdGhlIGlnbm9yZSBvcy1saW5lLWJyZWFrcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobGluZU51bWJlck1vZGUgPT09ICdpbmxpbmUnIHx8IGxpbmVOdW1iZXJNb2RlID09PSAnbm9uZScpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNDbGFzcyhlbGVtZW50LCAnb3MtbGluZS1icmVhaycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJhZ3JhcGggPSBjcmVhdGUoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZU51bWJlck1vZGUgPT09ICdvdXRzaWRlJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJQYXJlbnROb2RlTmFtZSAhPT0gJ0xJJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnBhcmVudE5vZGUubm9kZU5hbWUgIT09ICdMSScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJyUGFyZW50Tm9kZU5hbWUgPT09ICdJTlMnIHx8IGJyUGFyZW50Tm9kZU5hbWUgPT09ICdERUwnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNQcmV2U2libGluZ0FMaW5lTnVtYmVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJdGVyYXJlIGFsbCBub2RlcyB1cCB0byB0aGUgdG9wIGZyb20gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0TGluZU51bWJlcihlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUHJldlNpYmxpbmdBTGluZU51bWJlcihiclBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaC5tYXJnaW4gPSBbMjAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaC5tYXJnaW4gPSBbMjAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYSBkdW1teSBsaW5lLCBpZiB0aGUgbmV4dCB0YWcgaXMgYSBCUiB0YWcgYWdhaW4uIFRoZSBsaW5lIGNvdWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGJlIGVtcHR5IG90aGVyd2lzZSBpdCB3aWxsIGJlIHJlbW92ZWQgYW5kIHRoZSBlbXB0eSBsaW5lIGlzIG5vdCBkaXNwbGF5ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5uZXh0U2libGluZyAmJiBlbGVtZW50Lm5leHRTaWJsaW5nLm5vZGVOYW1lID09PSAnQlInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJhZ3JhcGgudGV4dC5wdXNoKGNyZWF0ZSgndGV4dCcsICcgJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNJbnNpZGVBTGlzdChlbGVtZW50KSAmJiBsaW5lTnVtYmVyTW9kZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1dCBhIHNwYWNlciB0aGVyZSwgaWYgdGhlcmUgaXMgb25lIEJSIGluIGEgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BhY2VyID0gY3JlYXRlKCd0ZXh0JywgJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VyLmxpbmVIZWlnaHQgPSAwLjI1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5Q29udmVydGVkLnB1c2goc3BhY2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaC5saW5lSGVpZ2h0ID0gMS4yNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5Q29udmVydGVkLnB1c2goY3VycmVudFBhcmFncmFwaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGknOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaCA9IGNyZWF0ZSgndGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaC5saW5lSGVpZ2h0ID0gMS4yNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFja0RpdiA9IGNyZWF0ZSgnc3RhY2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLmluZGV4T2YoY2xhc3NlcywgJ29zLXNwbGl0LWJlZm9yZScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja0Rpdi5saXN0VHlwZSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ2xpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrRGl2Lm1hcmdpbkJvdHRvbSA9IExJX01BUkdJTl9CT1RUT007XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja0Rpdi5zdGFjay5wdXNoKGN1cnJlbnRQYXJhZ3JhcGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29tcHV0ZVN0eWxlKHN0YWNrRGl2LCBzdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaCA9IHBhcnNlQ2hpbGRyZW4oc3RhY2tEaXYuc3RhY2ssIGVsZW1lbnQsIGN1cnJlbnRQYXJhZ3JhcGgsIFtdLCBkaWZmX21vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeUNvbnZlcnRlZC5wdXNoKHN0YWNrRGl2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwT2JqZWN0VG9QdXNoOyAvL2RldGVybWluZSB3aGF0IHRvIHB1c2ggbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJhZ3JhcGggPSBjcmVhdGUoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgZWxlbWVudCBpcyBpbnNpZGUgYSBsaXN0IChoYXBwZW5zIGlmIGNvcGllZCBmcm9tIHdvcmQpLCBkbyBub3Qgc2V0IHNwYWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG1hcmdpbnMuIEp1c3QgbGVhdmUgdGhlIHBhcmFncmFwaCB0aGVyZS4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSW5zaWRlQUxpc3QoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyYWdyYXBoLm1hcmdpbiA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKCdvcy1zcGxpdC1iZWZvcmUnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaC5tYXJnaW5bMV0gPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKCdpbnNlcnQnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJhZ3JhcGgubWFyZ2luWzBdID0gMjA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaC5saW5lSGVpZ2h0ID0gMS4yNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFja1AgPSBjcmVhdGUoJ3N0YWNrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja1Auc3RhY2sucHVzaChjdXJyZW50UGFyYWdyYXBoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbXB1dGVTdHlsZShzdGFja1AsIHN0eWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyYWdyYXBoID0gcGFyc2VDaGlsZHJlbihzdGFja1Auc3RhY2ssIGVsZW1lbnQsIGN1cnJlbnRQYXJhZ3JhcGgsIFtdLCBkaWZmX21vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcE9iamVjdFRvUHVzaCA9IHN0YWNrUDsgLy91c3VhbGx5IHdlIHdhbnQgdG8gcHVzaCBzdGFja1BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lTnVtYmVyTW9kZSA9PT0gJ291dHNpZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7IC8vaWYgd2UgaGl0ID0gMCwgdGhlIGNvZGUgd291bGQgZmFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgZW1wdHkgbGluZSBudW1iZXIgY29sdW1uIGZvciBpbmxpbmUgZGlmZiBvciBwcmFncmFwaCBkaWZmIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGROb2Rlc1swXS50YWdOYW1lID09PSAnSU5TJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jaGlsZE5vZGVzWzBdLnRhZ05hbWUgPT09ICdERUwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcExpbmVOdW1iZXJQbGFjZWhvbGRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMCwgMiwgMCwgMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcExpbmVOdW1iZXJQbGFjZWhvbGRlckNvbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBMaW5lTnVtYmVyUGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrUFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwT2JqZWN0VG9QdXNoID0gcExpbmVOdW1iZXJQbGFjZWhvbGRlckNvbDsgLy9vdmVyd3JpdGUgdGhlIG9iamVjdCB0byBwdXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5Q29udmVydGVkLnB1c2gocE9iamVjdFRvUHVzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW1nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGltYWdlc1twYXRoXS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBpbWFnZXNbcGF0aF0ud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4V2lkdGggPSA0NTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSAxMDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gc3R5bGUubWF0Y2goL3dpZHRoOlxccyooXFxkKylcXCUvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzY2FsZSBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAod2lkdGggKiBzY2FsZSkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSAoaGVpZ2h0ICogc2NhbGUpIC8gMTAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IChoZWlnaHQgKiBtYXhXaWR0aCkgLyB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IG1heFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgLyBmb3IgdGhlIHZpcnR1YWwgZmlsZSBzeXN0ZW0gKHRoZXJlIGlzIG5vIHJvb3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKCcvJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5Q29udmVydGVkLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3QgPSBjcmVhdGUobm9kZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09ICdvbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbXB1dGVTdHlsZShsaXN0LCBzdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVOdW1iZXJNb2RlID09PSAnb3V0c2lkZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSBleHRyYWN0TGluZU51bWJlcnMoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaCA9IHBhcnNlQ2hpbGRyZW4obGlzdFtub2RlTmFtZV0sIGVsZW1lbnQsIGN1cnJlbnRQYXJhZ3JhcGgsIHN0eWxlcywgZGlmZl9tb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdENvbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDIwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGxpbmVzLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0Q29sLmNvbHVtbnNbMF0uc3RhY2sucHVzaChnZXRMaW5lTnVtYmVyT2JqZWN0KGxpbmUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RDb2wuY29sdW1ucy5wdXNoKGxpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsICdvcy1zcGxpdC1iZWZvcmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdENvbC5tYXJnaW4gPSBbMCwgNSwgMCwgMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeUNvbnZlcnRlZC5wdXNoKGxpc3RDb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QubWFyZ2luID0gWzIwLCAwLCAwLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeUNvbnZlcnRlZC5wdXNoKGxpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5tYXJnaW4gPSBbMCwgTElfTUFSR0lOX0JPVFRPTSwgMCwgMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaCA9IHBhcnNlQ2hpbGRyZW4obGlzdFtub2RlTmFtZV0sIGVsZW1lbnQsIGN1cnJlbnRQYXJhZ3JhcGgsIHN0eWxlcywgZGlmZl9tb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5Q29udmVydGVkLnB1c2gobGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0VGV4dCA9IGNyZWF0ZSgndGV4dCcsIGVsZW1lbnQudGV4dENvbnRlbnQucmVwbGFjZSgvXFxuL2csICcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb21wdXRlU3R5bGUoZGVmYXVsdFRleHQsIHN0eWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQYXJhZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyYWdyYXBoID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFncmFwaC50ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyYWdyYXBoLnRleHQucHVzaChkZWZhdWx0VGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJhZ3JhcGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBQYXJzZXMgSFRNTFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udmVydGVkICAgICAgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGh0bWxUZXh0ICAgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBQYXJzZUh0bWwgPSBmdW5jdGlvbihjb252ZXJ0ZWQsIGh0bWxUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBIVE1MVmFsaWRpemVyLnZhbGlkaXplKGh0bWxUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sID0gJChodG1sLnJlcGxhY2UoL1xcdC9nLCAnJykucmVwbGFjZSgvXFxuL2csICcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVtcHR5UGFyYWdyYXBoID0gY3JlYXRlKCd0ZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2UoaHRtbCkuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBhcnNlRWxlbWVudChjb252ZXJ0ZWQsIGVsZW1lbnQsIG51bGwsIFtdLCBESUZGX01PREVfTk9STUFMKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBSZXR1cm5zIHRoZSBvYmplY3QgdG8gcHVzaCBmaXJzdCBpbnRvIGV2ZXJ5IGNvbHVtbiwgdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiBsaW5lLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TGluZU51bWJlck9iamVjdCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YW5kYXJkRm9udHNpemUgPSBDb25maWcuZ2V0KCdnZW5lcmFsX2V4cG9ydF9wZGZfZm9udHNpemUnKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnICcsIC8vIEFkZCBhIGJsYW5rIHdpdGggdGhlIG5vcm1hbCBmb250IHNpemUgaGVyZSwgc28gaW4gcmFyZSBjYXNlcyB0aGUgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgcmVuZGVyZWQgb24gdGhlIG5leHQgcGFnZSBhbmQgdGhlIGxpbmVudW1iZXIgb24gdGhlIHByZXZpb3VzIHBhZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IHN0YW5kYXJkRm9udHNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb3JhdGlvbjogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGxpbmUubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2dyYXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBzdGFuZGFyZEZvbnRzaXplIC0gMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0aW9uOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogbGluZS5tYXJnaW5Cb3R0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDEuMjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gW107XG4gICAgICAgICAgICAgICAgICAgIFBhcnNlSHRtbChjb250ZW50LCBodG1sKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIGNvbnRhaW5lcmVsZW1lbnRzIGZvciBwZGZNYWtlXG4gICAgICAgICAgICAgICAgICogZS5nIGNyZWF0ZSgndGV4dCc6J015VGV4dCcpIHJlc3VsdCBpbiB7IHRleHQ6ICdNeVRleHQnIH1cbiAgICAgICAgICAgICAgICAgKiBvciBjb21wbGV4IG9iamVjdHMgY3JlYXRlKCdzdGFjaycsIFt7dGV4dDonTXlUZXh0J30sIHt0ZXh0OidNeVRleHQyJ31dKVxuICAgICAgICAgICAgICAgICAqZm9yIHVuaXRzIC8gcGFyYWdyYXBocyBvZiB0ZXh0XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICAgIC0gbmFtZSBvZiB0aGUgYXR0cmlidXRlIGhvbGRpbmcgY29udGVudFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50ICAgLSB0aGUgYWN0dWFsIGNvbnRlbnQgKG1heWJlIGVtcHR5KVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNyZWF0ZSA9IGZ1bmN0aW9uKG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIG9bbmFtZV0gPSBjb250ZW50O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0SFRNTDogY29udmVydEhUTUwsXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudDogY3JlYXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlSW5zdGFuY2U6IGNyZWF0ZUluc3RhbmNlXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ0ltYWdlQ29udmVydGVyJywgW1xuICAgICckcScsXG4gICAgJ1BERkxheW91dCcsXG4gICAgZnVuY3Rpb24gKCRxLCBQREZMYXlvdXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvQmFzZTY0OiBmdW5jdGlvbiAoaW1hZ2VTb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlTWFwID0ge307XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlUHJvbWlzZXMgPSBfLm1hcChpbWFnZVNvdXJjZXMsIGZ1bmN0aW9uIChpbWFnZVNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQREZMYXlvdXQuaW1hZ2VVUkx0b0Jhc2U2NChpbWFnZVNvdXJjZSkudGhlbihmdW5jdGlvbiAoaW1nSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlTWFwW2ltYWdlU291cmNlXSA9IGltZ0luZm87XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXNvbHZlIHByb21pc2VzIHRvIGdldCBiYXNlNjRcbiAgICAgICAgICAgICAgICAgICAgJHEuYWxsKGltYWdlUHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGltYWdlTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4vLyBDcmVhdGVzIHRoZSB2aXJ0dWFsIGZpbGVzeXN0ZW0gZm9yIFBkZk1ha2UuXG4uZmFjdG9yeSgnUGRmVmZzJywgW1xuICAgICckcScsXG4gICAgJyRodHRwJyxcbiAgICAnRm9udHMnLFxuICAgICdDb25maWcnLFxuICAgIGZ1bmN0aW9uICgkcSwgJGh0dHAsIEZvbnRzLCBDb25maWcpIHtcbiAgICAgICAgdmFyIHVybENhY2hlID0ge307IC8vIENhY2hlcyB0aGUgZ2V0IHJlcXVlc3QuIE1hcHMgdXJscyB0byBiYXNlNjQgZGF0YSByZWFkeSB0byB1c2UuXG5cbiAgICAgICAgdmFyIGxvYWRGb250ID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuICRxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgZm9udFxuICAgICAgICAgICAgICAgIHJldHVybiAkaHR0cC5nZXQodXJsLCB7cmVzcG9uc2VUeXBlOiAnYmxvYid9KS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gYmFzZTY0XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChzdWNjZXNzLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQuc3BsaXQoJywnKVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbWFwIGZyb20gdXJscyB0byBhcnJheXMgb2YgZm9udCB0eXBlcyB1c2VkIGJ5IFBkZk1ha2UuXG4gICAgICAgICAqIEUuZy4gaWYgdGhlIGZvbnQgJ3JlZ3VsYXInIGFuZCAnYm9sZCcgaGF2ZSB0aGUgdXJscyAnZm9udHMvbXlGb250LnR0ZicsXG4gICAgICAgICAqIHRoZSBtYXAgZm91bGQgYmUgJ2ZvbnRzL215Rm9udC50dGYnOiBbJ09TRm9udC1yZWd1bGFyLnR0ZicsICdPU0ZvbnQtYm9sZC50dGYnXVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGdldFVybE1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXJsTWFwID0ge307XG4gICAgICAgICAgICB2YXIgZm9udHMgPSBbJ3JlZ3VsYXInLCAnaXRhbGljJywgJ2JvbGQnLCAnYm9sZF9pdGFsaWMnXTtcbiAgICAgICAgICAgIF8uZm9yRWFjaChmb250cywgZnVuY3Rpb24gKGZvbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gRm9udHMuZ2V0VXJsKCdmb250XycgKyBmb250KTtcbiAgICAgICAgICAgICAgICBpZiAoIXVybE1hcFt1cmxdKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybE1hcFt1cmxdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVybE1hcFt1cmxdLnB1c2goJ09TRm9udC0nICsgZm9udCArICcudHRmJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB1cmxNYXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgLypcbiAgICAgICAgICogQ3JlYXRlIHRoZSB2aXJ0dWFsIGZpbGVzeXN0ZW0gbmVlZGVkIGJ5IFBkZk1ha2UgZm9yIHRoZSBmb250cy4gR2V0cyB0aGUgdXJsXG4gICAgICAgICAqIG1hcHBpbmcgYW5kIGxvYWRzIGFsbCBmb250cyB2aWEgZ2V0IHJlcXVlc3RzIG9yIHRoZSB1cmxDYWNoZS5cbiAgICAgICAgICogQWRkcyBhbGwgaW1hZ2Ugc291cmNlcyB0byB0aGUgdmZzIGdpdmVuIGJ5IHRoZSBpbWFnZU1hcC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBnZXRWZnMgPSBmdW5jdGlvbiAoaW1hZ2VNYXApIHtcbiAgICAgICAgICAgIHZhciB2ZnMgPSB7fTtcbiAgICAgICAgICAgIF8uZm9yRWFjaChpbWFnZU1hcCB8fCB7fSwgZnVuY3Rpb24gKGRhdGEsIHBhdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKCcvJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDEpOyAvLyByZW1vdmUgdHJhaWxpbmcgL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2ZnNbcGF0aF0gPSBkYXRhLmRhdGEuc3BsaXQoJywnKVsxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICRxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXJscyA9IGdldFVybE1hcHBpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBfLmNoYWluKHVybHMpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGZpbGVuYW1lcywgdXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsQ2FjaGVbdXJsXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3Qgc2F2ZSB0aGUgY2FjaGUgZGF0YSBpbnRvIHZmcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goZmlsZW5hbWVzLCBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmZzW2ZpbGVuYW1lXSA9IHVybENhY2hlW3VybF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBwcm9taXNlIGhlcmUsIGl0IHdhcyBhbGwgY2FjaGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgaW4gdGhlIGNhY2hlLCBnZXQgdGhlIGZvbnQgYW5kIHNhdmUgdGhlIGRhdGEgaW50byB2ZnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRGb250KHVybCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxDYWNoZVt1cmxdID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGZpbGVuYW1lcywgZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZnNbZmlsZW5hbWVdID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudmFsdWUoKTtcbiAgICAgICAgICAgICAgICAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZmcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0OiBnZXRWZnMsXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ1BkZkNyZWF0ZScsIFtcbiAgICAnJHRpbWVvdXQnLFxuICAgICckcScsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnRmlsZVNhdmVyJyxcbiAgICAnUGRmVmZzJyxcbiAgICAnTWVzc2FnaW5nJyxcbiAgICBmdW5jdGlvbiAoJHRpbWVvdXQsICRxLCBnZXR0ZXh0Q2F0YWxvZywgRmlsZVNhdmVyLCBQZGZWZnMsIE1lc3NhZ2luZykge1xuICAgICAgICB2YXIgZmlsZW5hbWVNZXNzYWdlTWFwID0ge307XG4gICAgICAgIHZhciBiNjR0b0Jsb2IgPSBmdW5jdGlvbihiNjREYXRhKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZUNoYXJhY3RlcnMgPSBhdG9iKGI2NERhdGEpO1xuICAgICAgICAgICAgdmFyIGJ5dGVOdW1iZXJzID0gbmV3IEFycmF5KGJ5dGVDaGFyYWN0ZXJzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVDaGFyYWN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnl0ZU51bWJlcnNbaV0gPSBieXRlQ2hhcmFjdGVycy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVOdW1iZXJzKTtcbiAgICAgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2J5dGVBcnJheV0pO1xuICAgICAgICAgICAgcmV0dXJuIGJsb2I7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZmlsZW5hbWUsIGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCwgdGltZW91dDtcbiAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbmZvJzpcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICc8aSBjbGFzcz1cImZhIGZhLXNwaW5uZXIgZmEtcHVsc2UgZmEtbGcgc3BhY2VyLXJpZ2h0XCI+PC9pPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdHZW5lcmF0aW5nIFBERiBmaWxlJykgKyAnICgnICsgZmlsZW5hbWUgKyAnKSAuLi4nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdWNjZXNzJzpcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICc8aSBjbGFzcz1cImZhIGZhLWNoZWNrIGZhLWxnIHNwYWNlci1yaWdodFwiPjwvaT4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnUERGIHN1Y2Nlc3NmdWxseSBnZW5lcmF0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSAzMDAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSAnPGkgY2xhc3M9XCJmYSBmYS1leGNsYW1hdGlvbi10cmlhbmdsZSBmYS1sZyBzcGFjZXItcmlnaHRcIj48L2k+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0Vycm9yIHdoaWxlIGdlbmVyYXRpbmcgUERGIGZpbGUnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICgnICsgZmlsZW5hbWUgKyAnKTogPGNvZGU+JyArIGVycm9yICsgJzwvY29kZT4nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZU1lc3NhZ2VNYXBbZmlsZW5hbWVdID0gTWVzc2FnaW5nLmNyZWF0ZU9yRWRpdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lTWVzc2FnZU1hcFtmaWxlbmFtZV0sIHRleHQsIHN0YXRlLCB7dGltZW91dDogdGltZW91dH0pO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXRCYXNlNjRGcm9tRG9jdW1lbnQ6IGZ1bmN0aW9uIChkb2N1bWVudFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgUGRmVmZzLmdldChkb2N1bWVudFByb3ZpZGVyLmdldEltYWdlTWFwKCkpLnRoZW4oZnVuY3Rpb24gKHZmcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBkZldvcmtlciA9IG5ldyBXb3JrZXIoJy9zdGF0aWMvanMvd29ya2Vycy9wZGYtd29ya2VyLmpzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZGZXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBkZldvcmtlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBkZldvcmtlci5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGRmRG9jdW1lbnQ6IGRvY3VtZW50UHJvdmlkZXIuZ2V0RG9jdW1lbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZnM6IHZmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gU3RydWNrdHVyZSBvZiBwZGZEb2N1bWVudHM6IHsgZmlsbmFtZTE6IGRvYywgZmlsZW5hbWUyOiBkb2MsIC4uLn1cbiAgICAgICAgICAgIGdldEJhc2U2NEZyb21NdWx0aXBsZURvY3VtZW50czogZnVuY3Rpb24gKHBkZkRvY3VtZW50cykge1xuICAgICAgICAgICAgICAgIC8vIGNvbmNhdCBhbGwgaW1hZ2Ugc291cmNlcyB0b2dldGhlclxuICAgICAgICAgICAgICAgIHZhciBpbWFnZU1hcCA9IHt9O1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChwZGZEb2N1bWVudHMsIGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGRvYy5nZXRJbWFnZU1hcCgpLCBmdW5jdGlvbiAoZGF0YSwgcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWFnZU1hcFtwYXRoXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlTWFwW3BhdGhdID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgUGRmVmZzLmdldChpbWFnZU1hcCkudGhlbihmdW5jdGlvbiAodmZzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGRmV29ya2VyID0gbmV3IFdvcmtlcignL3N0YXRpYy9qcy93b3JrZXJzL3BkZi13b3JrZXIuanMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZTY0TWFwID0ge307IC8vIE1hcHMgZmlsZW5hbWUgdG8gYmFzZTY0XG4gICAgICAgICAgICAgICAgICAgICAgICBwZGZXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NE1hcFtkYXRhLmZpbGVuYW1lXSA9IGRhdGEuYmFzZTY0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRDb3VudCA9PT0gXy5rZXlzKHBkZkRvY3VtZW50cykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYmFzZTY0TWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBkZldvcmtlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChwZGZEb2N1bWVudHMsIGZ1bmN0aW9uIChkb2MsIGZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGRmV29ya2VyLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZGZEb2N1bWVudDogZG9jLmdldERvY3VtZW50KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZmczogdmZzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb3dubG9hZDogZnVuY3Rpb24gKGRvY3VtZW50UHJvdmlkZXIsIGZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDaGFuZ2UoJ2luZm8nLCBmaWxlbmFtZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmdldEJhc2U2NEZyb21Eb2N1bWVudChkb2N1bWVudFByb3ZpZGVyKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9iID0gYjY0dG9CbG9iKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZUNoYW5nZSgnc3VjY2VzcycsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgRmlsZVNhdmVyLnNhdmVBcyhibG9iLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlQ2hhbmdlKCdlcnJvcicsIGZpbGVuYW1lLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBjb3JlIG1vZHVsZSBmb3IgdGhlIE9wZW5TbGlkZXMgcHJvamVjdG9yXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5jb3JlLnByb2plY3RvcicsIFsnT3BlblNsaWRlc0FwcC5jb3JlJ10pXG5cbi8vIENhbiBiZSB1c2VkIHRvIGZpbmQgb3V0IGlmIHRoZSBwcm9qZWN0b3Igb3IgdGhlIHNpZGUgaXMgdXNlZFxuLmNvbnN0YW50KCdSRUFMTScsICdwcm9qZWN0b3InKVxuXG4ucnVuKFtcbiAgICAnJGh0dHAnLFxuICAgICdhdXRvdXBkYXRlJyxcbiAgICAnRFMnLFxuICAgIGZ1bmN0aW9uICgkaHR0cCwgYXV0b3VwZGF0ZSwgRFMpIHtcbiAgICAgICAgYXV0b3VwZGF0ZS5uZXdDb25uZWN0KCk7XG5cbiAgICAgICAgLy8gSWYgdGhlIGNvbm5lY3Rpb24gYWJvcnRzLCB3ZSB0cnkgdG8gcGluZyB0aGUgc2VydmVyIHdpdGggd2hvYW1pIHJlcXVlc3RzLiBJZlxuICAgICAgICAvLyB0aGUgc2VydmVyIGlzIGZsdXNoZWQsIHdlIGNsZWFyIHRoZSBkYXRhc3RvcmUsIHNvIHRoZSBtZXNzYWdlICd0aGlzIHByb2plY3RvclxuICAgICAgICAvLyBjYW5ub3QgYmUgc2hvd24nIHdpbGwgYmUgZGlzcGxheWVkLiBPdGhlcndpc2UgZXN0YWJsaXNoIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbi5cbiAgICAgICAgYXV0b3VwZGF0ZS5yZWdpc3RlclJldHJ5Q29ubmVjdENhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAkaHR0cC5nZXQoJy91c2Vycy93aG9hbWknKS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MuZGF0YS51c2VyX2lkID09PSBudWxsICYmICFzdWNjZXNzLmRhdGEuZ3Vlc3RfZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBEUy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF1dG91cGRhdGUubmV3Q29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4vLyBQcm92aWRlciB0byByZWdpc3RlciBzbGlkZXMgaW4gYSAuY29uZmlnKCkgc3RhdGVtZW50LlxuLnByb3ZpZGVyKCdzbGlkZXMnLCBbXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzbGlkZXNNYXAgPSB7fTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyU2xpZGUgPSBmdW5jdGlvbihuYW1lLCBjb25maWcpIHtcbiAgICAgICAgICAgIHNsaWRlc01hcFtuYW1lXSA9IGNvbmZpZztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuJGdldCA9IGZ1bmN0aW9uKCR0ZW1wbGF0ZVJlcXVlc3QsICRxKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdldEVsZW1lbnRzOiBmdW5jdGlvbihwcm9qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKHByb2plY3Rvci5lbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQubmFtZSBpbiBzbGlkZXNNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnRlbXBsYXRlID0gc2xpZGVzTWFwW2VsZW1lbnQubmFtZV0udGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVua25vd24gc2xpZGU6IFwiICsgZWxlbWVudC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb25maWcoW1xuICAgICdzbGlkZXNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oc2xpZGVzUHJvdmlkZXIpIHtcbiAgICAgICAgc2xpZGVzUHJvdmlkZXIucmVnaXN0ZXJTbGlkZSgnY29yZS9jbG9jaycsIHtcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnc3RhdGljL3RlbXBsYXRlcy9jb3JlL3NsaWRlX2Nsb2NrLmh0bWwnLFxuICAgICAgICB9KTtcblxuICAgICAgICBzbGlkZXNQcm92aWRlci5yZWdpc3RlclNsaWRlKCdjb3JlL2NvdW50ZG93bicsIHtcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnc3RhdGljL3RlbXBsYXRlcy9jb3JlL3NsaWRlX2NvdW50ZG93bi5odG1sJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2xpZGVzUHJvdmlkZXIucmVnaXN0ZXJTbGlkZSgnY29yZS9wcm9qZWN0b3ItbWVzc2FnZScsIHtcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnc3RhdGljL3RlbXBsYXRlcy9jb3JlL3NsaWRlX21lc3NhZ2UuaHRtbCcsXG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdMYW5ndWFnZUFuZEZvbnRDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICdMYW5ndWFnZXMnLFxuICAgICdDb25maWcnLFxuICAgICdQcm9qZWN0b3InLFxuICAgICdQcm9qZWN0b3JJRCcsXG4gICAgJ0ZvbnRzJyxcbiAgICBmdW5jdGlvbiAoJHNjb3BlLCBMYW5ndWFnZXMsIENvbmZpZywgUHJvamVjdG9yLCBQcm9qZWN0b3JJRCwgRm9udHMpIHtcbiAgICAgICAgLy8gZm9yIHRoZSBkeW5hbWljIHRpdGxlXG4gICAgICAgICRzY29wZS5wcm9qZWN0b3JJZCA9IFByb2plY3RvcklEKCk7XG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb2plY3Rvci5sYXN0TW9kaWZpZWQoJHNjb3BlLnByb2plY3RvcklkKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb2plY3RvciA9IFByb2plY3Rvci5nZXQoJHNjb3BlLnByb2plY3RvcklkKTtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUucHJvamVjdG9yTmFtZSA9IHByb2plY3Rvci5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBDb25maWcubGFzdE1vZGlmaWVkKCdwcm9qZWN0b3JfbGFuZ3VhZ2UnKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxhbmcgPSBDb25maWcuZ2V0KCdwcm9qZWN0b3JfbGFuZ3VhZ2UnKTtcbiAgICAgICAgICAgIGlmICghbGFuZyB8fCBsYW5nLnZhbHVlID09ICdicm93c2VyJykge1xuICAgICAgICAgICAgICAgICRzY29wZS5zZWxlY3RlZExhbmd1YWdlID0gTGFuZ3VhZ2VzLmdldEJyb3dzZXJMYW5ndWFnZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc2VsZWN0ZWRMYW5ndWFnZSA9IGxhbmcudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMYW5ndWFnZXMuc2V0Q3VycmVudExhbmd1YWdlKCRzY29wZS5zZWxlY3RlZExhbmd1YWdlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29uZmlnLmxhc3RNb2RpZmllZCgnZm9udF9yZWd1bGFyJykgK1xuICAgICAgICAgICAgICAgIENvbmZpZy5sYXN0TW9kaWZpZWQoJ2ZvbnRfaXRhbGljJykgK1xuICAgICAgICAgICAgICAgIENvbmZpZy5sYXN0TW9kaWZpZWQoJ2ZvbnRfYm9sZCcpICtcbiAgICAgICAgICAgICAgICBDb25maWcubGFzdE1vZGlmaWVkKCdmb250X2JvbGRfaXRhbGljJyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5mb250ID0gRm9udHMuZ2V0Rm9yQ3NzKCdmb250X3JlZ3VsYXInKTtcbiAgICAgICAgICAgICRzY29wZS5mb250X21lZGl1bSA9IEZvbnRzLmdldEZvckNzcygnZm9udF9pdGFsaWMnKTtcbiAgICAgICAgICAgICRzY29wZS5mb250X2NvbmRlbnNlZCA9IEZvbnRzLmdldEZvckNzcygnZm9udF9ib2xkJyk7XG4gICAgICAgICAgICAkc2NvcGUuZm9udF9jb25kZW5zZWRfbGlnaHQgPSBGb250cy5nZXRGb3JDc3MoJ2ZvbnRfYm9sZF9pdGFsaWMnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLy8gUHJvamVjdG9yIENvbnRhaW5lciBDb250cm9sbGVyXG4uY29udHJvbGxlcignUHJvamVjdG9yQ29udGFpbmVyQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJHRpbWVvdXQnLFxuICAgICckbG9jYXRpb24nLFxuICAgICdnZXR0ZXh0JyxcbiAgICAnUHJvamVjdG9yJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsICR0aW1lb3V0LCAkbG9jYXRpb24sIGdldHRleHQsIFByb2plY3Rvcikge1xuICAgICAgICAkc2NvcGUuc2hvd0Vycm9yID0gdHJ1ZTtcblxuICAgICAgICAvLyB3YXRjaCBmb3IgY2hhbmdlcyBpbiBQcm9qZWN0b3JcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvamVjdG9yLmxhc3RNb2RpZmllZCgkc2NvcGUucHJvamVjdG9ySWQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJvamVjdG9yID0gUHJvamVjdG9yLmdldCgkc2NvcGUucHJvamVjdG9ySWQpO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rvcikge1xuICAgICAgICAgICAgICAgICRzY29wZS5zaG93RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUucHJvamVjdG9yV2lkdGggPSBwcm9qZWN0b3Iud2lkdGg7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnByb2plY3RvckhlaWdodCA9IHByb2plY3Rvci5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlY2FsY3VsYXRlSWZyYW1lKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRzY29wZS5zaG93RXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGRlbGF5IGRpc3BsYXlpbmcgdGhlIGVycm9yIG1lc3NhZ2UsIGJlY2F1c2Ugd2l0aCBhIHNsb3cgaW50ZXJuZXRcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0aW9uLCB0aGUgYXV0b3VwZGF0ZSB3aXRoIHRoZSBwcm9qZWN0b3IgbWF5IGJlIGRlbGF5ZWQuIFdlXG4gICAgICAgICAgICAgICAgLy8gZGUgbm90IHdhbnQgdG8gaXJyaXRhdGUgdGhlIHVzZXIgYnkgc2hvd2luZyB0aGlzIGVycm9yIHRvIGVhcmx5LlxuICAgICAgICAgICAgICAgICRzY29wZS5lcnJvciA9ICcnO1xuICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5zaG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5lcnJvciA9IGdldHRleHQoJ0NhbiBub3Qgb3BlbiB0aGUgcHJvamVjdG9yLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlY2FsY3VsYXRlIHRoZSBhY3R1YWwgSWZyYW1lc2l6ZSBhbmQgc2NhbGVcbiAgICAgICAgJHNjb3BlLnJlY2FsY3VsYXRlSWZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNjYWxlX3dpZHRoID0gd2luZG93LmlubmVyV2lkdGggLyAkc2NvcGUucHJvamVjdG9yV2lkdGg7XG4gICAgICAgICAgICB2YXIgc2NhbGVfaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC8gJHNjb3BlLnByb2plY3RvckhlaWdodDtcblxuICAgICAgICAgICAgLy8gSWZyYW1lIGhhcyB0byBiZSBzY2FsZWQgZG93biBvciBzYWNlVXAgaXMgYWN0aXZhdGVkXG4gICAgICAgICAgICBpZiAoc2NhbGVfd2lkdGggPD0gc2NhbGVfaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gd2lkdGggaXMgdGhlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICRzY29wZS5pZnJhbWVXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgICAgICRzY29wZS5zY2FsZSA9IHNjYWxlX3dpZHRoO1xuICAgICAgICAgICAgICAgICRzY29wZS5pZnJhbWVIZWlnaHQgPSAkc2NvcGUucHJvamVjdG9ySGVpZ2h0ICogc2NhbGVfd2lkdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGhlaWdodCBpcyB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgJHNjb3BlLmlmcmFtZUhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc2NhbGUgPSBzY2FsZV9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmlmcmFtZVdpZHRoID0gJHNjb3BlLnByb2plY3RvcldpZHRoICogc2NhbGVfaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHdhdGNoIGZvciBjaGFuZ2VzIGluIHRoZSB3aW5kb3dzaXplXG4gICAgICAgICQod2luZG93KS5vbihcInJlc2l6ZS5kb1Jlc2l6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5yZWNhbGN1bGF0ZUlmcmFtZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzY29wZS4kb24oXCIkZGVzdHJveVwiLGZ1bmN0aW9uICgpe1xuICAgICAgICAgICAgJCh3aW5kb3cpLm9mZihcInJlc2l6ZS5kb1Jlc2l6ZVwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ1Byb2plY3RvckN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRsb2NhdGlvbicsXG4gICAgJyR0aW1lb3V0JyxcbiAgICAnUHJvamVjdG9yJyxcbiAgICAnc2xpZGVzJyxcbiAgICAnQ29uZmlnJyxcbiAgICAnUHJvamVjdG9ySUQnLFxuICAgICdMb2dvcycsXG4gICAgZnVuY3Rpb24oJHNjb3BlLCAkbG9jYXRpb24sICR0aW1lb3V0LCBQcm9qZWN0b3IsIHNsaWRlcywgQ29uZmlnLCBQcm9qZWN0b3JJRCwgTG9nb3MpIHtcbiAgICAgICAgdmFyIHByb2plY3RvcklkID0gUHJvamVjdG9ySUQoKTtcblxuICAgICAgICAkc2NvcGUuYnJvYWRjYXN0ID0gMDtcblxuICAgICAgICB2YXIgc2V0RWxlbWVudHMgPSBmdW5jdGlvbiAocHJvamVjdG9yKSB7XG4gICAgICAgICAgICAvLyBHZXQgYWxsIGVsZW1lbnRzLCB0aGF0IHNob3VsZCBiZSBwcm9qZWN0ZWQuXG4gICAgICAgICAgICB2YXIgbmV3RWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBlbmFibGVfY2xvY2sgPSBDb25maWcuZ2V0KCdwcm9qZWN0b3JfZW5hYmxlX2Nsb2NrJyk7XG4gICAgICAgICAgICBlbmFibGVfY2xvY2sgPSBlbmFibGVfY2xvY2sgPyBlbmFibGVfY2xvY2sudmFsdWUgOiB0cnVlO1xuICAgICAgICAgICAgXy5mb3JFYWNoKHNsaWRlcy5nZXRFbGVtZW50cyhwcm9qZWN0b3IpLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeGNsdWRlIHRoZSBjbG9jayBpZiBpdCBzaG91bGQgYmUgZGlzYWJsZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVfY2xvY2sgfHwgZWxlbWVudC5uYW1lICE9PSAnY29yZS9jbG9jaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZm9yIHNsaWRlIFwiICsgZWxlbWVudC5uYW1lICsgXCI6IFwiICsgZWxlbWVudC5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE5vdyB3ZSBoYXZlIHRvIGFsaWduICRzY29wZS5lbGVtZW50cyB0byBuZXdFbGVtZW50czpcbiAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBqdXN0IGFzc2lnbiB0aGVtLCBiZWNhdXNlIHRoZSBuZy1yZXBlYXQgd291bGQgcmVsb2FkIGV2ZXJ5XG4gICAgICAgICAgICAvLyBlbGVtZW50LiBUaGlzIHNob3VsZCBiZSBwcmV2ZW50ZWQgKHNlZSAjMzI1OSkuIFRvIGNoYW5nZSAkc2NvcGUuZWxlbWVudHM6XG4gICAgICAgICAgICAvLyAxKSByZW1vdmUgYWxsIGVsZW1lbnRzIGZyb20gc2NvcGUsIHRoYXQgYXJlIG5vdCBpbiBuZXdFbGVtZW50cyAoY29tcGFyZWQgYnkgdGhlIHV1aWQpXG4gICAgICAgICAgICAvLyAyKSBFdmVyeSBuZXcgZWxlbWVudCBpbiBuZXdFbGVtZW50cywgdGhhdCBpcyBub3QgaW4gJHNjb3BlLmVsZW1lbnRzLCBnZXQgaW5zZXJ0ZWQgdGhlcmUuXG4gICAgICAgICAgICAvLyAzKSBJZiB0aGVyZSBpcyB0aGUgc2FtZSBlbGVtZW50IGluIG5ld0VsZW1lbnRzIGFuZCAkc2NvcGUuZWxlbWVudHMgZXZlcnkgY2hhbmdlZCBwcm9wZXJ0eVxuICAgICAgICAgICAgLy8gICAgaXMgY29waWVkIGZyb20gdGhlIG5ldyBlbGVtZW50IHRvIHRoZSBzY29wZSBlbGVtZW50LlxuXG4gICAgICAgICAgICAkc2NvcGUuZWxlbWVudHMgPSBfLmZpbHRlcigkc2NvcGUuZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc29tZShuZXdFbGVtZW50cywgZnVuY3Rpb24gKG5ld0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQudXVpZCA9PT0gbmV3RWxlbWVudC51dWlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF8uZm9yRWFjaChuZXdFbGVtZW50cywgZnVuY3Rpb24gKG5ld0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hpbmdFbGVtZW50ID0gXy5maW5kKCRzY29wZS5lbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQudXVpZCA9PT0gbmV3RWxlbWVudC51dWlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29weSBhbGwgY2hhbmdlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2gobmV3RWxlbWVudCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtleSBoYXMgb3duIHByb3BlcnR5IGFuZCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgJyQnLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0VsZW1lbnQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkuaW5kZXhPZignJCcpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hdGNoaW5nRWxlbWVudFtrZXldID09PSAndW5kZWZpbmVkJyB8fCBtYXRjaGluZ0VsZW1lbnRba2V5XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdFbGVtZW50W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5lbGVtZW50cy5wdXNoKG5ld0VsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgICRzY29wZS5zY3JvbGwgPSAwO1xuICAgICAgICB2YXIgc2V0U2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xuICAgICAgICAgICAgJHNjb3BlLnNjcm9sbCA9IC0yNTAgKiBzY3JvbGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvamVjdG9yLmxhc3RNb2RpZmllZChwcm9qZWN0b3JJZCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5wcm9qZWN0b3IgPSBQcm9qZWN0b3IuZ2V0KHByb2plY3RvcklkKTtcbiAgICAgICAgICAgIGlmICgkc2NvcGUucHJvamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCRzY29wZS5icm9hZGNhc3QgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudHMoJHNjb3BlLnByb2plY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5ibGFuayA9ICRzY29wZS5wcm9qZWN0b3IuYmxhbms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFNjcm9sbCgkc2NvcGUucHJvamVjdG9yLnNjcm9sbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJsYW5rIHByb2plY3RvciBvbiBlcnJvclxuICAgICAgICAgICAgICAgICRzY29wZS5lbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICRzY29wZS5wcm9qZWN0b3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiAwLFxuICAgICAgICAgICAgICAgICAgICBibGFuazogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2V0U2Nyb2xsKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBDb25maWcubGFzdE1vZGlmaWVkKCdwcm9qZWN0b3JfYnJvYWRjYXN0Jyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYyA9IENvbmZpZy5nZXQoJ3Byb2plY3Rvcl9icm9hZGNhc3QnKTtcbiAgICAgICAgICAgIGlmIChiYykge1xuICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuYnJvYWRjYXN0ICE9IGJjLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5icm9hZGNhc3QgPSBiYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5icm9hZGNhc3REZXJlZ2lzdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXZlcnQgdG8gb3JpZ2luYWwgJHNjb3BlLnByb2plY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmJyb2FkY2FzdERlcmVnaXN0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5icm9hZGNhc3REZXJlZ2lzdGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRzKCRzY29wZS5wcm9qZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmJsYW5rID0gJHNjb3BlLnByb2plY3Rvci5ibGFuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLmJyb2FkY2FzdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGVsZW1lbnRzIGFuZCBibGFuayBmcm9tIGJyb2FkY2FzdCBwcm9qZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmJyb2FkY2FzdERlcmVnaXN0ZXIgPSAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9qZWN0b3IubGFzdE1vZGlmaWVkKCRzY29wZS5icm9hZGNhc3QpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLmJyb2FkY2FzdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnJvYWRjYXN0X3Byb2plY3RvciA9IFByb2plY3Rvci5nZXQoJHNjb3BlLmJyb2FkY2FzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJyb2FkY2FzdF9wcm9qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudHMoYnJvYWRjYXN0X3Byb2plY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5ibGFuayA9IGJyb2FkY2FzdF9wcm9qZWN0b3IuYmxhbms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIENvbmZpZy5sYXN0TW9kaWZpZWQoJ3Byb2plY3Rvcl9lbmFibGVfY2xvY2snKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0RWxlbWVudHMoJHNjb3BlLnByb2plY3Rvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoJHNjb3BlLmJyb2FkY2FzdERlcmVnaXN0ZXIpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYnJvYWRjYXN0RGVyZWdpc3RlcigpO1xuICAgICAgICAgICAgICAgICRzY29wZS5icm9hZGNhc3REZXJlZ2lzdGVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ1NsaWRlQ2xvY2tDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckaW50ZXJ2YWwnLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgJGludGVydmFsKSB7XG4gICAgICAgIC8vIEF0dGVudGlvbiEgRWFjaCBvYmplY3QgdGhhdCBpcyB1c2VkIGhlcmUgaGFzIHRvIGJlIGRlYWx0IG9uIHNlcnZlciBzaWRlLlxuICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGNvcmVzcG9uZGluZyBnZXRfcmVxdWlyZW1lbnRzIG1ldGhvZCBvZiB0aGUgUHJvamVjdG9yRWxlbWVudFxuICAgICAgICAvLyBjbGFzcy5cbiAgICAgICAgJHNjb3BlLnNlcnZlcnRpbWUgPSAoIERhdGUubm93KCkgLyAxMDAwIC0gJHNjb3BlLnNlcnZlck9mZnNldCApICogMTAwMDtcbiAgICAgICAgdmFyIGludGVydmFsID0gJGludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5zZXJ2ZXJ0aW1lID0gKCBEYXRlLm5vdygpIC8gMTAwMCAtICRzY29wZS5zZXJ2ZXJPZmZzZXQgKSAqIDEwMDA7XG4gICAgICAgIH0sIDMwMDAwKTsgLy8gVXBkYXRlIHRoZSBjbG9jayBldmVyeSAzMCBzZWNvbmRzXG5cbiAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICRpbnRlcnZhbC5jYW5jZWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignU2xpZGVDb3VudGRvd25DdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckaW50ZXJ2YWwnLFxuICAgICdDb3VudGRvd24nLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgJGludGVydmFsLCBDb3VudGRvd24pIHtcbiAgICAgICAgLy8gQXR0ZW50aW9uISBFYWNoIG9iamVjdCB0aGF0IGlzIHVzZWQgaGVyZSBoYXMgdG8gYmUgZGVhbHQgb24gc2VydmVyIHNpZGUuXG4gICAgICAgIC8vIEFkZCBpdCB0byB0aGUgY29yZXNwb25kaW5nIGdldF9yZXF1aXJlbWVudHMgbWV0aG9kIG9mIHRoZSBQcm9qZWN0b3JFbGVtZW50XG4gICAgICAgIC8vIGNsYXNzLlxuICAgICAgICB2YXIgaWQgPSAkc2NvcGUuZWxlbWVudC5pZDtcbiAgICAgICAgdmFyIGludGVydmFsO1xuICAgICAgICB2YXIgY2FsY3VsYXRlQ291bnRkb3duVGltZSA9IGZ1bmN0aW9uIChjb3VudGRvd24pIHtcbiAgICAgICAgICAgIGNvdW50ZG93bi5zZWNvbmRzID0gTWF0aC5mbG9vciggJHNjb3BlLmNvdW50ZG93bi5jb3VudGRvd25fdGltZSAtIERhdGUubm93KCkgLyAxMDAwICsgJHNjb3BlLnNlcnZlck9mZnNldCApO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBDb3VudGRvd24ubGFzdE1vZGlmaWVkKGlkKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLmNvdW50ZG93biA9IENvdW50ZG93bi5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgJGludGVydmFsLmNhbmNlbChpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJHNjb3BlLmNvdW50ZG93bikge1xuICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuY291bnRkb3duLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlQ291bnRkb3duVGltZSgkc2NvcGUuY291bnRkb3duKTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSAkaW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyBjYWxjdWxhdGVDb3VudGRvd25UaW1lKCRzY29wZS5jb3VudGRvd24pOyB9LCAxMDAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY291bnRkb3duLnNlY29uZHMgPSAkc2NvcGUuY291bnRkb3duLmNvdW50ZG93bl90aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBDYW5jZWwgdGhlIGludGVydmFsIGlmIHRoZSBjb250cm9sbGVyIGlzIGRlc3Ryb3llZFxuICAgICAgICAgICAgaWYgKGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgJGludGVydmFsLmNhbmNlbChpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdTbGlkZU1lc3NhZ2VDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICdQcm9qZWN0b3JNZXNzYWdlJyxcbiAgICAnUHJvamVjdG9yJyxcbiAgICAnUHJvamVjdG9ySUQnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgZnVuY3Rpb24oJHNjb3BlLCBQcm9qZWN0b3JNZXNzYWdlLCBQcm9qZWN0b3IsIFByb2plY3RvcklELCBnZXR0ZXh0Q2F0YWxvZykge1xuICAgICAgICAvLyBBdHRlbnRpb24hIEVhY2ggb2JqZWN0IHRoYXQgaXMgdXNlZCBoZXJlIGhhcyB0byBiZSBkZWFsdCBvbiBzZXJ2ZXIgc2lkZS5cbiAgICAgICAgLy8gQWRkIGl0IHRvIHRoZSBjb3Jlc3BvbmRpbmcgZ2V0X3JlcXVpcmVtZW50cyBtZXRob2Qgb2YgdGhlIFByb2plY3RvckVsZW1lbnRcbiAgICAgICAgLy8gY2xhc3MuXG4gICAgICAgIHZhciBpZCA9ICRzY29wZS5lbGVtZW50LmlkO1xuXG4gICAgICAgIGlmICgkc2NvcGUuZWxlbWVudC5pZGVudGlmeSkge1xuICAgICAgICAgICAgdmFyIHByb2plY3RvciA9IFByb2plY3Rvci5nZXQoUHJvamVjdG9ySUQoKSk7XG4gICAgICAgICAgICAkc2NvcGUuaWRlbnRpZnlNZXNzYWdlID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdQcm9qZWN0b3InKSArICcgJyArIHByb2plY3Rvci5pZCArICc6ICcgKyBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcocHJvamVjdG9yLm5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLm1lc3NhZ2UgPSBQcm9qZWN0b3JNZXNzYWdlLmdldChpZCk7XG4gICAgICAgICAgICBQcm9qZWN0b3JNZXNzYWdlLmJpbmRPbmUoaWQsICRzY29wZSwgJ21lc3NhZ2UnKTtcbiAgICAgICAgfVxuICAgIH1cbl0pO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5jb3JlLnJlbW92ZS1mb3JtYXQtcGx1Z2luJywgW1xuICAgICdPcGVuU2xpZGVzQXBwLmNvcmUnLFxuXSlcblxuLypcbiAqIFBsdWdpbiBmb3IgdGhlIENLRWRpdG9yIHRoYXQgaG9va3MgaW50byB0aGUgcmVtb3ZlZm9ybWF0IHBsdWdpblxuICogd2hpY2ggaXMgYSBkZWZhdWx0IHBsdWdpbiBlbmFibGVkIGJ5ICdjbGVhbnVwJyBpbiB0aGUgY29uZmlnXG4gKiB0b29sYmFyLlxuICogV2UgY2hhbmdlIHRoZSBiZWhhdmlvciBvZiB0aGUgcmVtb3ZlZm9ybWF0IGNvbW1hbmQgaGVyZTpcbiAqIEl0IHNob3VsZCBub3QgcmVtb3ZlIGFueSB0YWdzIGFuZCBzdHlsZXMsIGJ1dCBvbmx5IHRoZVxuICogJ0RJU0FMTE9XRURfU1RZTEVTJy4gUmVtb3ZlZm9ybWF0IHRyYXZlcnNlcyB0aHJvdWdoIHRoZSBET01cbiAqIGFuZCBjYWxsZXMgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhlIGN1c3RvbSBmaWx0ZXIgZG93biBiZWxvdy5cbiAqIFdlIGNoYW5nZSB0aGUgZWxlbWVudCBhbmQgcmV0dXJuIGZhbHNlLCBzbyB0aGUgcmVtb3ZlZm9ybWF0XG4gKiBwbHVnaW4gZG9lcyBub3QgY2xlYW4gaXQgdXAuXG4gKi9cbi5mYWN0b3J5KCdPU1JlbW92ZUZvcm1hdFBsdWdpbicsIFtcbiAgICAnRWRpdG9yJyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgIGZ1bmN0aW9uIChFZGl0b3IsIGdldHRleHRDYXRhbG9nKSB7XG4gICAgICAgIHZhciBESVNBTExPV0VEX1NUWUxFUyA9IFsnY29sb3InLCAnYmFja2dyb3VuZC1jb2xvciddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0UGx1Z2luOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmFkZFJlbW92ZUZvcm1hdEZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChESVNBTExPV0VEX1NUWUxFUywgZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlU3R5bGUoc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5ydW4oW1xuICAgICdFZGl0b3InLFxuICAgICdPU1JlbW92ZUZvcm1hdFBsdWdpbicsXG4gICAgZnVuY3Rpb24gKEVkaXRvciwgT1NSZW1vdmVGb3JtYXRQbHVnaW4sIGdldHRleHQpIHtcbiAgICAgICAgRWRpdG9yLnJlZ2lzdGVyUGx1Z2luKCdPU1JlbW92ZUZvcm1hdCcsIE9TUmVtb3ZlRm9ybWF0UGx1Z2luLmdldFBsdWdpbigpKTtcbiAgICB9XG5dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIGNvcmUgbW9kdWxlIGZvciB0aGUgT3BlblNsaWRlcyBzaXRlXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5jb3JlLnNpdGUnLCBbXG4gICAgJ09wZW5TbGlkZXNBcHAuY29yZScsXG4gICAgJ09wZW5TbGlkZXNBcHAuY29yZS5zdGFydCcsXG4gICAgJ09wZW5TbGlkZXNBcHAuY29yZS5jc3YnLFxuICAgICdPcGVuU2xpZGVzQXBwLmNvcmUucmVtb3ZlLWZvcm1hdC1wbHVnaW4nLFxuICAgICdPcGVuU2xpZGVzQXBwLnBvbGwubWFqb3JpdHknLFxuICAgICd1aS5yb3V0ZXInLFxuICAgICdjb2xvcnBpY2tlci5tb2R1bGUnLFxuICAgICdmb3JtbHknLFxuICAgICdmb3JtbHlCb290c3RyYXAnLFxuICAgICdsb2NhbHl0aWNzLmRpcmVjdGl2ZXMnLFxuICAgICduZ0RpYWxvZycsXG4gICAgJ25nRmlsZVNhdmVyJyxcbiAgICAnbmdNZXNzYWdlcycsXG4gICAgJ2NrZWRpdG9yJyxcbiAgICAnbHVlZ2cuZGlyZWN0aXZlcycsXG4gICAgJ3hlZGl0YWJsZScsXG4gICAgJ3J6TW9kdWxlJyxcbl0pXG5cbi8vIENhbiBiZSB1c2VkIHRvIGZpbmQgb3V0IGlmIHRoZSBwcm9qZWN0b3Igb3IgdGhlIHNpZGUgaXMgdXNlZFxuLmNvbnN0YW50KCdSRUFMTScsICdzaXRlJylcblxuLmZhY3RvcnkoJ0RhdGVUaW1lUGlja2VyVHJhbnNsYXRpb24nLCBbXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICBmdW5jdGlvbiAoZ2V0dGV4dENhdGFsb2cpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldEJ1dHRvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBub3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ25vdycpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvZGF5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCd0b2RheScpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdjbGVhcicpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ2RhdGUnKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCd0aW1lJylcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ2Nsb3NlJylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG5dKVxuXG4vLyBQcm92aWRlciB0byByZWdpc3RlciBlbnRyaWVzIGZvciB0aGUgbWFpbiBtZW51LlxuLnByb3ZpZGVyKCdtYWluTWVudScsIFtcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1haW5NZW51TGlzdCA9IFtdO1xuICAgICAgICB2YXIgc2NvcGU7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlciA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgbWFpbk1lbnVMaXN0LnB1c2goY29uZmlnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLiRnZXQgPSBbJ29wZXJhdG9yJywgZnVuY3Rpb24ob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJTY29wZTogZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVwZGF0ZU1haW5NZW51OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjb3BlLmVsZW1lbnRzID0gdGhpcy5nZXRFbGVtZW50cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IG1haW5NZW51TGlzdC5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZWxlbWVudC5wZXJtID09PSBcInVuZGVmaW5lZFwiIHx8IG9wZXJhdG9yLmhhc1Blcm1zKGVsZW1lbnQucGVybSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLndlaWdodCAtIGIud2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1dO1xuICAgIH1cbl0pXG5cbi8vIFByb3ZpZGVyIHRvIHJlZ2lzdGVyIGEgc2VhcmNoYWJsZSBtb2R1bGUvYXBwLlxuLnByb3ZpZGVyKCdTZWFyY2gnLCBbXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWFyY2hNb2R1bGVzID0gW107XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlciA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgc2VhcmNoTW9kdWxlcy5wdXNoKG1vZHVsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy4kZ2V0ID0gW1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGdldEFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaE1vZHVsZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH1cbl0pXG5cbi5ydW4oW1xuICAgICdlZGl0YWJsZU9wdGlvbnMnLFxuICAgICdnZXR0ZXh0JyxcbiAgICBmdW5jdGlvbiAoZWRpdGFibGVPcHRpb25zLCBnZXR0ZXh0KSB7XG4gICAgICAgIGVkaXRhYmxlT3B0aW9ucy50aGVtZSA9ICdiczMnO1xuICAgICAgICBlZGl0YWJsZU9wdGlvbnMuY2FuY2VsQnV0dG9uQXJpYUxhYmVsID0gZ2V0dGV4dCgnQ2FuY2VsJyk7XG4gICAgICAgIGVkaXRhYmxlT3B0aW9ucy5jYW5jZWxCdXR0b25UaXRsZSA9IGdldHRleHQoJ0NhbmNlbCcpO1xuICAgICAgICBlZGl0YWJsZU9wdGlvbnMuY2xlYXJCdXR0b25BcmlhTGFiZWwgPSBnZXR0ZXh0KCdDbGVhcicpO1xuICAgICAgICBlZGl0YWJsZU9wdGlvbnMuY2xlYXJCdXR0b25UaXRsZSA9IGdldHRleHQoJ0NsZWFyJyk7XG4gICAgICAgIGVkaXRhYmxlT3B0aW9ucy5zdWJtaXRCdXR0b25BcmlhTGFiZWwgPSBnZXR0ZXh0KCdTdWJtaXQnKTtcbiAgICAgICAgZWRpdGFibGVPcHRpb25zLnN1Ym1pdEJ1dHRvblRpdGxlID0gZ2V0dGV4dCgnU3VibWl0Jyk7XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ1dlYnBhZ2VUaXRsZScsIFtcbiAgICAnJHJvb3RTY29wZScsXG4gICAgZnVuY3Rpb24gKCRyb290U2NvcGUpIHtcbiAgICAgICAgJHJvb3RTY29wZS5hY3RpdmVBcHBUaXRsZSA9ICcnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXBkYXRlVGl0bGU6IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5hY3RpdmVBcHBUaXRsZSA9IHRleHQgfHwgJyc7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi8vIFdhdGNoIGZvciB0aGUgYmFzZVBlcm0gb24gYSBzdGF0ZUNoYW5nZSBhbmQgaW5pdGlhbGl6ZSB0aGUgV2VicGFnZVRpdGxlIGZhY3Rvcnlcbi5ydW4oW1xuICAgICckcm9vdFNjb3BlJyxcbiAgICAnb3BlcmF0b3InLFxuICAgICdXZWJwYWdlVGl0bGUnLFxuICAgIGZ1bmN0aW9uICgkcm9vdFNjb3BlLCBvcGVyYXRvciwgV2VicGFnZVRpdGxlKSB7XG4gICAgICAgICRyb290U2NvcGUuJG9uKCckc3RhdGVDaGFuZ2VTdWNjZXNzJywgZnVuY3Rpb24oZXZlbnQsIHRvU3RhdGUpIHtcbiAgICAgICAgICAgIFdlYnBhZ2VUaXRsZS51cGRhdGVUaXRsZSh0b1N0YXRlLmRhdGEgPyB0b1N0YXRlLmRhdGEudGl0bGUgOiAnJyk7XG4gICAgICAgICAgICBpZiAodG9TdGF0ZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5iYXNlVmlld1Blcm1pc3Npb25zR3JhbnRlZCA9IHRvU3RhdGUuZGF0YS5iYXNlUGVybSA/XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLmhhc1Blcm1zKHRvU3RhdGUuZGF0YS5iYXNlUGVybSkgOiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmJhc2VWaWV3UGVybWlzc2lvbnNHcmFudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNjcm9sbCB0byB0b3Agb24gZXZlcnkgc3RhdGUgY2hhbmdlXG4gICAgICAgICAgICAkcm9vdFNjb3BlLmdvdG9Ub3AoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLy8gTWFrZSB0aGUgbWFpbiBjb250ZW50IGV4cGFuZGFibGVcbi5ydW4oW1xuICAgICckcm9vdFNjb3BlJyxcbiAgICBmdW5jdGlvbiAoJHJvb3RTY29wZSkge1xuICAgICAgICAkcm9vdFNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5leHBhbmRDb250ZW50ID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICAkcm9vdFNjb3BlLnRvZ2dsZUV4cGFuZENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmV4cGFuZENvbnRlbnQgPSAhJHJvb3RTY29wZS5leHBhbmRDb250ZW50O1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb25maWcoW1xuICAgICdtYWluTWVudVByb3ZpZGVyJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgZnVuY3Rpb24gKG1haW5NZW51UHJvdmlkZXIsIGdldHRleHQpIHtcbiAgICAgICAgbWFpbk1lbnVQcm92aWRlci5yZWdpc3Rlcih7XG4gICAgICAgICAgICAndWlfc3JlZic6ICdob21lJyxcbiAgICAgICAgICAgICdpbWdfY2xhc3MnOiAnaG9tZScsXG4gICAgICAgICAgICAndGl0bGUnOiBnZXR0ZXh0KCdIb21lJyksXG4gICAgICAgICAgICAnd2VpZ2h0JzogMTAwLFxuICAgICAgICAgICAgJ3Blcm0nOiAnY29yZS5jYW5fc2VlX2Zyb250cGFnZScsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1haW5NZW51UHJvdmlkZXIucmVnaXN0ZXIoe1xuICAgICAgICAgICAgJ3VpX3NyZWYnOiAnY29uZmlnJyxcbiAgICAgICAgICAgICdpbWdfY2xhc3MnOiAnY29nJyxcbiAgICAgICAgICAgICd0aXRsZSc6IGdldHRleHQoJ1NldHRpbmdzJyksXG4gICAgICAgICAgICAnd2VpZ2h0JzogMTAwMCxcbiAgICAgICAgICAgICdwZXJtJzogJ2NvcmUuY2FuX21hbmFnZV9jb25maWcnLFxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4uY29uZmlnKFtcbiAgICAnJHVybFJvdXRlclByb3ZpZGVyJyxcbiAgICAnJGxvY2F0aW9uUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKCR1cmxSb3V0ZXJQcm92aWRlciwgJGxvY2F0aW9uUHJvdmlkZXIpIHtcbiAgICAgICAgLy8gZGVmaW5lIGZhbGxiYWNrIHVybCBhbmQgaHRtbDVNb2RlXG4gICAgICAgICR1cmxSb3V0ZXJQcm92aWRlci5vdGhlcndpc2UoJy8nKTtcbiAgICAgICAgJGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlKHRydWUpO1xuICAgIH1cbl0pXG5cbi5jb25maWcoW1xuICAgICckaHR0cFByb3ZpZGVyJyxcbiAgICBmdW5jdGlvbigkaHR0cFByb3ZpZGVyKSB7XG4gICAgICAgIC8vIENvbWJpbmUgdGhlIGRqYW5nbyBjc3JmIHN5c3RlbSB3aXRoIHRoZSBhbmd1bGFyIGNzcmYgc3lzdGVtXG4gICAgICAgICRodHRwUHJvdmlkZXIuZGVmYXVsdHMueHNyZkNvb2tpZU5hbWUgPSAnT3BlblNsaWRlc0NzcmZUb2tlbic7XG4gICAgICAgICRodHRwUHJvdmlkZXIuZGVmYXVsdHMueHNyZkhlYWRlck5hbWUgPSAnWC1DU1JGVG9rZW4nO1xuICAgIH1cbl0pXG5cblxuLmNvbmZpZyhbXG4gICAgJyRzdGF0ZVByb3ZpZGVyJyxcbiAgICAnJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyLCAkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlcikge1xuICAgICAgICAvLyBNYWtlIHRoZSB0cmFpbGluZyBzbGFzaCBvcHRpb25hbFxuICAgICAgICAkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlci5zdHJpY3RNb2RlKGZhbHNlKTtcblxuICAgICAgICAvLyBVc2Ugc3RhdGVQcm92aWRlci5kZWNvcmF0b3IgdG8gZ2l2ZSBkZWZhdWx0IHZhbHVlcyB0byBvdXIgc3RhdGVzXG4gICAgICAgICRzdGF0ZVByb3ZpZGVyLmRlY29yYXRvcigndmlld3MnLCBmdW5jdGlvbihzdGF0ZSwgcGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgICAgICAgICAgdmlld3MgPSBwYXJlbnQoc3RhdGUpO1xuXG4gICAgICAgICAgICBpZiAoc3RhdGUuYWJzdHJhY3QgfHwgc3RhdGUuZGF0YSAmJiBzdGF0ZS5kYXRhLmV4dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHZpZXdzLCBmdW5jdGlvbihjb25maWcsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXRzIGFkZGl0aW9uYWwgZGVmYXVsdCB2YWx1ZXMgZm9yIHRlbXBsYXRlVXJsXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlVXJsLFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q29udHJvbGxlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGU6ICdDcmVhdGVDdHJsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogJ1VwZGF0ZUN0cmwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdDogJ0xpc3RDdHJsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDogJ0RldGFpbEN0cmwnLFxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgdXAgc3RhdGUgbmFtZVxuICAgICAgICAgICAgICAgIC8vIGV4YW1wbGU6IFwibW90aW9ucy5tb3Rpb24uZGV0YWlsLnVwZGF0ZVwiIC0+IFsnbW90aW9ucycsICdtb3Rpb24nLCAnZGV0YWlsJywgJ3VwZGF0ZSddXG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm5zID0gc3RhdGUubmFtZS5zcGxpdCgnLicpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IGFwcCBhbmQgbW9kdWxlIG5hbWUgZnJvbSBzdGF0ZVxuICAgICAgICAgICAgICAgIC8vIC0gYXBwTmFtZTogcGF0dGVybnNbMF0gKGUuZy4gXCJtb3Rpb25zXCIpXG4gICAgICAgICAgICAgICAgLy8gLSBtb2R1bGVOYW1lczogcGF0dGVybnMgd2l0aG91dCBmaXJzdCBlbGVtZW50IChlLmcuIFtcIm1vdGlvblwiLCBcImRldGFpbFwiLCBcInVwZGF0ZVwiXSlcbiAgICAgICAgICAgICAgICB2YXIgYXBwTmFtZSA9ICcnO1xuICAgICAgICAgICAgICAgIHZhciBtb2R1bGVOYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgdmFyIG1vZHVsZU5hbWVzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSA9IHBhdHRlcm5zWzBdO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lcyA9IHBhdHRlcm5zLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGZyb20gY2FtY2VsY2FzZSB0byBkYXNoIG5vdGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4YW1wbGU6IFtcIm1vdGlvbkJsb2NrXCIsIFwiZGV0YWlsXCJdIC0+IFtcIm1vdGlvbi1ibG9ja1wiLCBcImRldGFpbFwiXVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZHVsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lc1tpXSA9ICBtb2R1bGVOYW1lc1tpXS5yZXBsYWNlKC8oW2EtelxcZF0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHNwZWNpYWwgdGVtcGxhdGVVcmwgZm9yIGNyZWF0ZSBhbmQgdXBkYXRlIHZpZXdcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhhbXBsZTogW1wibW90aW9uXCIsIFwiZGV0YWlsXCIsIFwidXBkYXRlXCJdIC0+IFwibW90aW9uLWZvcm1cIlxuICAgICAgICAgICAgICAgICAgICBpZiAoXy5sYXN0KG1vZHVsZU5hbWVzKS5tYXRjaCgvKGNyZWF0ZXx1cGRhdGUpLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWUgPSAnLycgKyBtb2R1bGVOYW1lc1swXSArICctZm9ybSc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IG1vZGVsTmFtZXMgYXJyYXkgdG8gdXJsIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhhbXBsZTogW1wibW90aW9uLWJsb2NrXCIsIFwiZGV0YWlsXCJdIC0+IFwibW90aW9uLWJsb2NrLWRldGFpbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lID0gJy8nICsgbW9kdWxlTmFtZXMuam9pbignLScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsID0gJ3N0YXRpYy90ZW1wbGF0ZXMvJyArIGFwcE5hbWUgKyBtb2R1bGVOYW1lICsgJy5odG1sJztcbiAgICAgICAgICAgICAgICBjb25maWcudGVtcGxhdGVVcmwgPSBzdGF0ZS50ZW1wbGF0ZVVybCB8fCB0ZW1wbGF0ZVVybDtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybnMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlciA9IF8udXBwZXJGaXJzdChwYXR0ZXJuc1sxXSkgKyBkZWZhdWx0Q29udHJvbGxlcnNbXy5sYXN0KHBhdHRlcm5zKV07XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5jb250cm9sbGVyID0gc3RhdGUuY29udHJvbGxlciB8fCBjb250cm9sbGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbbmFtZV0gPSBjb25maWc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pXG5cbiAgICAgICAgLmRlY29yYXRvcigndXJsJywgZnVuY3Rpb24oc3RhdGUsIHBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRVcmw7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5hYnN0cmFjdCkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRVcmwgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm5zID0gc3RhdGUubmFtZS5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VXJscyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZTogJy9uZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiAnL2VkaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaWQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gaW50ZWdlciwgaWYgbm90LCB0aGUgdXJsIGhhcyB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgZGVmaW5lZCBtYW51YWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiAnL3tpZDppbnR9JyxcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRlZmF1bHRVcmwgPSBkZWZhdWx0VXJsc1tfLmxhc3QocGF0dGVybnMpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUudXJsID0gc3RhdGUudXJsIHx8IGRlZmF1bHRVcmw7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50KHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLmNvbmZpZyhbXG4gICAgJyRzdGF0ZVByb3ZpZGVyJyxcbiAgICAnJGxvY2F0aW9uUHJvdmlkZXInLFxuICAgICdnZXR0ZXh0JyxcbiAgICBmdW5jdGlvbigkc3RhdGVQcm92aWRlciwgJGxvY2F0aW9uUHJvdmlkZXIsIGdldHRleHQpIHtcbiAgICAgICAgLy8gQ29yZSB1cmxzXG4gICAgICAgICRzdGF0ZVByb3ZpZGVyXG4gICAgICAgICAgICAuc3RhdGUoJ2hvbWUnLCB7XG4gICAgICAgICAgICAgICAgdXJsOiAnLycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdzdGF0aWMvdGVtcGxhdGVzL2hvbWUuaHRtbCcsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogZ2V0dGV4dCgnSG9tZScpLFxuICAgICAgICAgICAgICAgICAgICBiYXNlUGVybTogJ2NvcmUuY2FuX3NlZV9mcm9udHBhZ2UnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXRlKCdwcm9qZWN0b3InLCB7XG4gICAgICAgICAgICAgICAgdXJsOiAnL3Byb2plY3Rvci97aWQ6aW50fS8nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3RhdGljL3RlbXBsYXRlcy9wcm9qZWN0b3ItY29udGFpbmVyLmh0bWwnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtleHRlcm46IHRydWV9LFxuICAgICAgICAgICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uKCR3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgJHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdGhpcy51cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdGF0ZSgncmVhbC1wcm9qZWN0b3InLCB7XG4gICAgICAgICAgICAgICAgdXJsOiAnL3JlYWwtcHJvamVjdG9yL3tpZDppbnR9LycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdzdGF0aWMvdGVtcGxhdGVzL3Byb2plY3Rvci5odG1sJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7ZXh0ZXJuOiB0cnVlfSxcbiAgICAgICAgICAgICAgICBvbkVudGVyOiBmdW5jdGlvbigkd2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHRoaXMudXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3RhdGUoJ21hbmFnZS1wcm9qZWN0b3JzJywge1xuICAgICAgICAgICAgICAgIHVybDogJy9tYW5hZ2UtcHJvamVjdG9ycycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdzdGF0aWMvdGVtcGxhdGVzL2NvcmUvbWFuYWdlLXByb2plY3RvcnMuaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ01hbmFnZVByb2plY3RvcnNDdHJsJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXR0ZXh0KCdNYW5hZ2UgcHJvamVjdG9ycycpLFxuICAgICAgICAgICAgICAgICAgICBiYXNlUGVybTogJ2NvcmUuY2FuX21hbmFnZV9wcm9qZWN0b3InLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXRlKCdjb3JlJywge1xuICAgICAgICAgICAgICAgIHVybDogJy9jb3JlJyxcbiAgICAgICAgICAgICAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8dWktdmlldy8+XCIsXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAvLyBsZWdhbCBub3RpY2UgYW5kIHZlcnNpb25cbiAgICAgICAgICAgIC5zdGF0ZSgnbGVnYWxub3RpY2UnLCB7XG4gICAgICAgICAgICAgICAgdXJsOiAnL2xlZ2Fsbm90aWNlJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnTGVnYWxOb3RpY2VDdHJsJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXR0ZXh0KCdMZWdhbCBub3RpY2UnKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgLy8gcHJpdmFjeSBwb2xpY3lcbiAgICAgICAgICAgIC5zdGF0ZSgncHJpdmFjeXBvbGljeScsIHtcbiAgICAgICAgICAgICAgICB1cmw6ICcvcHJpdmFjeXBvbGljeScsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ1ByaXZhY3lQb2xpY3lDdHJsJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXR0ZXh0KCdQcml2YWN5IHBvbGljeScpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAvL2NvbmZpZ1xuICAgICAgICAgICAgLnN0YXRlKCdjb25maWcnLCB7XG4gICAgICAgICAgICAgICAgdXJsOiAnL2NvbmZpZycsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ0NvbmZpZ0N0cmwnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGdldHRleHQoJ1NldHRpbmdzJyksXG4gICAgICAgICAgICAgICAgICAgIGJhc2VQZXJtOiAnY29yZS5jYW5fbWFuYWdlX2NvbmZpZycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vIHNlYXJjaFxuICAgICAgICAgICAgLnN0YXRlKCdzZWFyY2gnLCB7XG4gICAgICAgICAgICAgICAgdXJsOiAnL3NlYXJjaD9xJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnU2VhcmNoQ3RybCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdzdGF0aWMvdGVtcGxhdGVzL3NlYXJjaC5odG1sJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXR0ZXh0KCdTZWFyY2gnKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgLy8gdGFnXG4gICAgICAgICAgICAuc3RhdGUoJ2NvcmUudGFnJywge1xuICAgICAgICAgICAgICAgIHVybDogJy90YWcnLFxuICAgICAgICAgICAgICAgIGFic3RyYWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjx1aS12aWV3Lz5cIixcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXR0ZXh0KCdUYWdzJyksXG4gICAgICAgICAgICAgICAgICAgIGJhc2VQZXJtOiAnY29yZS5jYW5fbWFuYWdlX3RhZ3MnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXRlKCdjb3JlLnRhZy5saXN0Jywge30pXG5cbiAgICAgICAgICAgIC8vIENvdW50ZG93blxuICAgICAgICAgICAgLnN0YXRlKCdjb3JlLmNvdW50ZG93bicsIHtcbiAgICAgICAgICAgICAgICB1cmw6ICcvY291bnRkb3duJyxcbiAgICAgICAgICAgICAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8dWktdmlldy8+XCIsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogZ2V0dGV4dCgnQ291bnRkb3duJyksXG4gICAgICAgICAgICAgICAgICAgIGJhc2VQZXJtOiAnY29yZS5jYW5fbWFuYWdlX3Byb2plY3RvcicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3RhdGUoJ2NvcmUuY291bnRkb3duLmRldGFpbCcsIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZG93bklkOiBbJyRzdGF0ZVBhcmFtcycsIGZ1bmN0aW9uKCRzdGF0ZVBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRzdGF0ZVBhcmFtcy5pZDtcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgJGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlKHRydWUpO1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdQcm9qZWN0b3JNZXNzYWdlRm9ybScsIFtcbiAgICAnRWRpdG9yJyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgIGZ1bmN0aW9uIChFZGl0b3IsIGdldHRleHRDYXRhbG9nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXREaWFsb2c6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL2NvcmUvcHJvamVjdG9yLW1lc3NhZ2UtZm9ybS5odG1sJyxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ1Byb2plY3Rvck1lc3NhZ2VFZGl0Q3RybCcsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ25nZGlhbG9nLXRoZW1lLWRlZmF1bHQgd2lkZS1mb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VCeUVzY2FwZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlEb2N1bWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3Rvck1lc3NhZ2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Rm9ybUZpZWxkczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VkaXRvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdNZXNzYWdlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNrZWRpdG9yT3B0aW9uczogRWRpdG9yLmdldE9wdGlvbnMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdUYWdGb3JtJywgW1xuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgZnVuY3Rpb24gKGdldHRleHRDYXRhbG9nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXREaWFsb2c6IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJ3N0YXRpYy90ZW1wbGF0ZXMvY29yZS90YWctZm9ybS5odG1sJyxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogKHRhZykgPyAnVGFnVXBkYXRlQ3RybCcgOiAnVGFnQ3JlYXRlQ3RybCcsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ25nZGlhbG9nLXRoZW1lLWRlZmF1bHQgd2lkZS1mb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VCeUVzY2FwZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlEb2N1bWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0lkOiBmdW5jdGlvbiAoKSB7cmV0dXJuIHRhZyA/IHRhZy5pZCA6IHZvaWQgMDt9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Rm9ybUZpZWxkczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnbmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnTmFtZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLyogVGhpcyBmYWN0b3J5IGhhbmRsZXMgdGhlIGZpbHRlcmluZyBvZiB0aGUgT1MtZGF0YS10YWJsZXMuIEl0IGNvbnRhaW5zXG4gKiBhbGwgbG9naWMgbmVlZGVkIGZvciB0aGUgdGFibGUgaGVhZGVyIGZpbHRlcmluZy4gVGhpbmdzIHRvIGNvbmZpZ3VyZTpcbiAqIC0gbXVsdGlzZWxlY3RGaWx0ZXJzOiBBIGRpY3QgYXNzb2NpYXRpbmcgdGhlIGZpbHRlciBuYW1lIHRvIGEgbGlzdCAoZW1wdHkgcGVyIGRlZmF1bHQpLiBFLmcuXG4gKiAgICAgICB7IHRhZzogW10sXG4gKiAgICAgICAgIGNhdGVnb3J5OiBbXSwgfVxuICogLSBib29sZWFuRmlsdGVyczogQSBkaWN0IGNvbnRhaW5pbmcgYSBkaWN0IGZvciBldmVyeSBmaWx0ZXIuIFRoZSB2YWx1ZSBwcm9wZXJ0eSBpcyBhIG11c3QuXG4gKiAgIEZvciBkaXNwbGF5aW5nIHByb3BlcnRpZXMgbGlrZSBkaXNwbGF5TmFtZSwgY2hvaWNlWWVzIGFuZCBjaG9pY2VObyBjb3VsZCBiZSB1c2VmdWxsLiBFLmcuXG4gKiAgICAgIHsgaXNQcmVzZW50OiB7XG4gKiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICogICAgICAgICAgZGlzcGxheU5hbWU6IGdldHRleHQoJ0lzIHByZXNlbnQnKSwgfSB9XG4gKiAtIHByb3BlcnR5TGlzdCwgcHJvcGVydHlGdW5jdGlvbkxpc3QsIHByb3BlcnR5RGljdDogU2VlIGZ1bmN0aW9uIGdldE9iamVjdFF1ZXJ5U3RyaW5nXG4gKi9cbi5mYWN0b3J5KCdvc1RhYmxlRmlsdGVyJywgW1xuICAgICckc2Vzc2lvblN0b3JhZ2UnLFxuICAgIGZ1bmN0aW9uICgkc2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgdmFyIGNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB7XG4gICAgICAgICAgICAgICAgbXVsdGlzZWxlY3RGaWx0ZXJzOiB7fSxcbiAgICAgICAgICAgICAgICBib29sZWFuRmlsdGVyczoge30sXG4gICAgICAgICAgICAgICAgZmlsdGVyU3RyaW5nOiAnJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZXhpc3RzU3RvcmFnZUVudHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkc2Vzc2lvblN0b3JhZ2VbdGFibGVOYW1lXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGV4aXN0c1N0b3JhZ2VFbnRyeSgpO1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmID0gc3RvcmFnZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5leGlzdHNTdG9yYWdlRW50cnkgPSBleGlzdHNTdG9yYWdlRW50cnk7XG4gICAgICAgICAgICBzZWxmLnNhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJHNlc3Npb25TdG9yYWdlW3RhYmxlTmFtZV0gPSBzZWxmO1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYuYXJlRmlsdGVyc1NldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJlRmlsdGVyc1NldCA9IF8uZmluZChzZWxmLm11bHRpc2VsZWN0RmlsdGVycywgZnVuY3Rpb24gKGZpbHRlckxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlckxpc3QubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhcmVGaWx0ZXJzU2V0ID0gYXJlRmlsdGVyc1NldCB8fCBfLmZpbmQoc2VsZi5ib29sZWFuRmlsdGVycywgZnVuY3Rpb24gKGZpbHRlckRpY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlckRpY3QudmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhcmVGaWx0ZXJzU2V0ID0gYXJlRmlsdGVyc1NldCB8fCAoc2VsZi5maWx0ZXJTdHJpbmcgIT09ICcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJlRmlsdGVyc1NldCAhPT0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2VsZi5yZXNldCA9IGZ1bmN0aW9uIChkYW5nZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGFuZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKHNlbGYubXVsdGlzZWxlY3RGaWx0ZXJzLCBmdW5jdGlvbiAoZmlsdGVyTGlzdCwgZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubXVsdGlzZWxlY3RGaWx0ZXJzW2ZpbHRlcl0gPSBbXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goc2VsZi5ib29sZWFuRmlsdGVycywgZnVuY3Rpb24gKGZpbHRlckRpY3QsIGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJvb2xlYW5GaWx0ZXJzW2ZpbHRlcl0udmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsZi5maWx0ZXJTdHJpbmcgPSAnJztcbiAgICAgICAgICAgICAgICBzZWxmLnNhdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWxmLm9wZXJhdGVNdWx0aXNlbGVjdEZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXIsIGlkLCBkYW5nZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRhbmdlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pbmRleE9mKHNlbGYubXVsdGlzZWxlY3RGaWx0ZXJzW2ZpbHRlcl0sIGlkKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubXVsdGlzZWxlY3RGaWx0ZXJzW2ZpbHRlcl0uc3BsaWNlKF8uaW5kZXhPZihzZWxmLm11bHRpc2VsZWN0RmlsdGVyc1tmaWx0ZXJdLCBpZCksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGlkXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm11bHRpc2VsZWN0RmlsdGVyc1tmaWx0ZXJdLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKiBUaHJlZSB0aGluZ3MgYXJlIGNvdWxkIGJlIGdpdmVuIHRvIGNyZWF0ZSB0aGUgcXVlcnkgc3RyaW5nOlxuICAgICAgICAgICAgICogLSBwcm9wZXJ0eUxpc3Q6IEp1c3QgYSBsaXN0IG9mIG9iamVjdCdzIHByb3BlcnRpZXMgbGlrZSBbJ3RpdGxlJywgJ25hbWUnXVxuICAgICAgICAgICAgICogLSBwcm9wZXJ0eUZ1bmt0aW9uTGlzdDogQSBsaXN0IG9mIGZ1bmN0aW9ucyByZXR1cm5pbmcgYSBwcm9wZXJ0eSAoZS5nLiBbZnVuY3Rpb24obW90aW9uKSB7cmV0dXJuIG1vdGlvbi5nZXRUaXRsZSgpO31dIGZvciByZXRyaWV2aW5nIHRoZSBtb3Rpb25zIHRpdGxlKVxuICAgICAgICAgICAgICogLSBwcm9wZXJ0eURpY3Q6IEEgZGljdCBhc3NvY2lhdGlvbiBwcm9wZXJ0aWVzIHRoYXQgYXJlIGxpc3RzIHRvIGZ1bmN0aW9ucyBvbiBob3cgdG8gaGFuZGxlIHRoZW0uXG4gICAgICAgICAgICAgKiAgIEUuZy46IHsndGFncyc6IGZ1bmN0aW9uICh0YWcpIHtyZXR1cm4gdGFnLm5hbWU7fSwgfVxuICAgICAgICAgICAgICogICAgICAgICBUaGUgbGlzdCBvZiB0YWdzIHdpbGwgYmUgbWFwcGVkIHdpdGggdGhpcyBmdW5jdGlvbiB0byBhIGxpc3Qgb2Ygc3RyaW5ncyAodGFnIG5hbWVzKS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2VsZi5nZXRPYmplY3RRdWVyeVN0cmluZyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChzZWxmLnByb3BlcnR5TGlzdCwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ0xpc3QucHVzaChvYmpbcHJvcGVydHldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goc2VsZi5wcm9wZXJ0eUZ1bmN0aW9uTGlzdCwgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ0xpc3QucHVzaChmbihvYmopKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goc2VsZi5wcm9wZXJ0eURpY3QsIGZ1bmN0aW9uIChpZEZ1bmN0aW9uLCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdMaXN0LnB1c2goXy5tYXAob2JqW3Byb3BlcnR5XSwgaWRGdW5jdGlvbikuam9pbignICcpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nTGlzdC5qb2luKCcgJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gU3R1YiBmb3IgY2FsbGJhY2tcbiAgICAgICAgICAgIHNlbGYuY2hhbmdlZCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZUluc3RhbmNlOiBjcmVhdGVJbnN0YW5jZVxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi8qIFRoaXMgZmFjdG9yeSB0YWtlcyBjYXJlIG9mIHRoZSBzb3J0aW5nIG9mIE9TLWRhdGEtdGFibGVzLiBUaGluZ3MgdG8gY29uZmlndXJlOlxuICogLSBjb2x1bW46IHRoZSBkZWZhdWx0IGNvbHVtbiB3aGljaCBpcyB0aGUgbGlzdCBzb3J0ZWQgYnkgKGUuZy5cbiAqICAgaW5zdGFuY2UuY29sdW1uPSd0aXRsZScpXG4gKi9cbi5mYWN0b3J5KCdvc1RhYmxlU29ydCcsIFtcbiAgICAnJHNlc3Npb25TdG9yYWdlJyxcbiAgICBmdW5jdGlvbiAoJHNlc3Npb25TdG9yYWdlKSB7XG4gICAgICAgIHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0ge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogJycsXG4gICAgICAgICAgICAgICAgcmV2ZXJzZTogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSAkc2Vzc2lvblN0b3JhZ2VbdGFibGVOYW1lXTtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgc2VsZiA9IHN0b3JhZ2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuc2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkc2Vzc2lvblN0b3JhZ2VbdGFibGVOYW1lXSA9IHNlbGY7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2VsZi50b2dnbGUgPSBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29sdW1uID09PSBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXZlcnNlID0gIXNlbGYucmV2ZXJzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgc2VsZi5zYXZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZUluc3RhbmNlOiBjcmVhdGVJbnN0YW5jZVxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi8qIEZhY3RvcnkgZm9yIHBhZ2luYXRpb24gb2YgdGhlIHRhYmxlcy4gU2F2ZXMgYWxsIHNldHRpbmdzIChjdXJyZW50UGFnZSwgLi4uKVxuICogdG8gdGhlIHNlc3Npb24gc3RvcmFnZSBhbmQgcmVjb3ZlcnMgdGhlbSB3aGVuIHRoZSB0YWJsZSBpcyByZWxvYWRlZC5cbiAqIFlvdSBoYXZlIHRvIHByb3ZpZGUgYSAndGFibGVOYW1lJyB3aGVyZSB0aGUgc2V0dGluZ3MgYXJlIHNhdmVkIGluIHRoZSBzZXNzaW9uXG4gKiBzdG9yYWdlLiBIYXMgdG8gYmUgdW5pcXVlIGZvciBvYnZpb3VzIHJlYXNvbnMuXG4gKiBUaGUgJ2l0ZW1zUGVyUGFnZScgaXMgb3B0aW9uYWwuIElmIG5vdCBnaXZlbiwgaXQgZGVmYXVsdHMgdG8gMjUuXG4gKi9cbi5mYWN0b3J5KCdvc1RhYmxlUGFnaW5hdGlvbicsIFtcbiAgICAnJHJvb3RTY29wZScsXG4gICAgJyRzZXNzaW9uU3RvcmFnZScsXG4gICAgZnVuY3Rpb24gKCRyb290U2NvcGUsICRzZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICB2YXIgY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiAodGFibGVOYW1lLCBpdGVtc1BlclBhZ2UpIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHRzXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFnZTogMSxcbiAgICAgICAgICAgICAgICBpdGVtc1BlclBhZ2U6IGl0ZW1zUGVyUGFnZSB8fCAyNSxcbiAgICAgICAgICAgICAgICBsaW1pdEJlZ2luOiAwLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgc3RvcmFnZTsgbWF5YmUgcmVjb3ZlciBvbGQgc3RhdGUuXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9ICRzZXNzaW9uU3RvcmFnZVt0YWJsZU5hbWVdO1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmID0gc3RvcmFnZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5zYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICRzZXNzaW9uU3RvcmFnZVt0YWJsZU5hbWVdID0gc2VsZjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWxmLnBhZ2VDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYubGltaXRCZWdpbiA9IChzZWxmLmN1cnJlbnRQYWdlIC0gMSkgKiBzZWxmLml0ZW1zUGVyUGFnZTtcbiAgICAgICAgICAgICAgICBzZWxmLnNhdmUoKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmdvdG9Ub3AoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWxmLmdldFBhZ2VDb3VudCA9IGZ1bmN0aW9uIChvYmpzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9ianMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChvYmpzLmxlbmd0aC9zZWxmLml0ZW1zUGVyUGFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYuc2hvd05leHRQYWdlQXJyb3cgPSBmdW5jdGlvbiAob2Jqcykge1xuICAgICAgICAgICAgICAgIGlmIChvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmN1cnJlbnRQYWdlICE9IHNlbGYuZ2V0UGFnZUNvdW50KG9ianMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWxmLnNob3dQcmV2UGFnZUFycm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmN1cnJlbnRQYWdlICE9IDE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2VsZi5uZXh0UGFnZSA9IGZ1bmN0aW9uIChvYmpzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9ianMgJiYgc2VsZi5jdXJyZW50UGFnZSA8IHNlbGYuZ2V0UGFnZUNvdW50KG9ianMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFBhZ2UrKztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYWdlQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWxmLnByZXZQYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmN1cnJlbnRQYWdlID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRQYWdlLS07XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFnZUNoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZUluc3RhbmNlOiBjcmVhdGVJbnN0YW5jZVxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi8qIFRoaXMgRmFjdG9yeSBjb3VsZCBiZSB1c2VkIGluIGFueSBkaWFsb2csIGlmIHRoZSB1c2VyIHNob3VsZCBiZSB3YXJuZWQsIGlmIGFub3RoZXIgdXNlclxuICogYWxzbyBoYXMgdGhpcyBkaWFsb2cgb3Blbi4gVXNlIGl0IGxpa2UgaW4gdGhpcyBleGFtcGxlIGluIGFueSBkaWFsb2cgY29udHJvbGxlcjpcbiAgICAgIHZhciBlZGl0aW5nU3RvcHBlZENhbGxiYWNrID0gRWRpdGluZ1dhcm5pbmcuZWRpdGluZ1N0YXJ0ZWQoJ2VkaXRpbmdfbmFtZScgKyBpdGVtLmlkKTtcbiAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZWRpdGluZ1N0b3BwZWRDYWxsYmFjayk7XG4gKi9cbi5mYWN0b3J5KCdFZGl0aW5nV2FybmluZycsIFtcbiAgICAnb3BlcmF0b3InLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ05vdGlmeScsXG4gICAgJ01lc3NhZ2luZycsXG4gICAgZnVuY3Rpb24gKG9wZXJhdG9yLCBnZXR0ZXh0Q2F0YWxvZywgTm90aWZ5LCBNZXNzYWdpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIFRoaXMgcmV0dXJucyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB0aGUgY29udHJvbGxlciBzaG91bGQgY2FsbCwgaWZcbiAgICAgICAgICAgIC8vIHRoZSBkaWFsb2cgZ290IGNsb3NlZCBieSB0aGUgdXNlci4gUHJvdmlkZSBhIHVuaXF1ZSBkaWFsb2cgbmFtZS5cbiAgICAgICAgICAgIGVkaXRpbmdTdGFydGVkOiBmdW5jdGlvbiAoZGlhbG9nTmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIExpc3Qgb2YgYWN0aXZlIGVkaXRvcnNcbiAgICAgICAgICAgICAgICB2YXIgZWRpdG9yTmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnaW5nSWQgPSBkaWFsb2dOYW1lICsgJ0VkaXRpbmdXYXJuaW5nJztcbiAgICAgICAgICAgICAgICAvLyBBZGQgYW4gZWRpdG9yIChtYXkgY29tZSBmcm9tIG9wZW5fcmVxdWVzdCBvciBvcGVuX3Jlc3BvbnNlKVxuICAgICAgICAgICAgICAgIHZhciBhZGRBY3RpdmVFZGl0b3IgPSBmdW5jdGlvbiAoZWRpdG9yTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3JOYW1lcy5wdXNoKGVkaXRvck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVBY3RpdmVFZGl0b3JzKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW4gZWRpdG9yLCBpZiBoZSBjbG9zZXMgaGlzIGRpYWxvZyAoZGlhbG9nX2Nsb3NlZClcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlQWN0aXZlRWRpdG9yID0gZnVuY3Rpb24gKGVkaXRvck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0SW5kZXggPSBfLmluZGV4T2YoZWRpdG9yTmFtZXMsIGVkaXRvck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3JOYW1lcy5zcGxpY2UoZmlyc3RJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUFjdGl2ZUVkaXRvcnMoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFNob3cgYSB3YXJuaW5nLlxuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVBY3RpdmVFZGl0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdG9yTmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdpbmcuZGVsZXRlTWVzc2FnZShtZXNzYWdpbmdJZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGJsb2NrIGlzIG9ubHkgZm9yIGdldHRpbmcgdGhlIG1lc3NhZ2Ugc3RyaW5nIHRvZ2V0aGVyLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdG9yc1dpdGhvdXRBbm9ueW1vdXMgPSBfLmZpbHRlcihlZGl0b3JOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1dhcm5pbmcnKSArICc6ICc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdG9yc1dpdGhvdXRBbm9ueW1vdXMubGVuZ3RoID09PSAwKSB7IC8vIE9ubHkgYW5vbnltb3VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luZ3VsYXIgdnMuIHBsdXJhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZGl0b3JOYW1lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ09uZSBhbm9ueW1vdXMgdXNlcnMgaXMgYWxzbyBlZGl0aW5nIHRoaXMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBlZGl0b3JOYW1lcy5sZW5ndGggKyAnICcgKyBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ2Fub255bW91cyB1c2VycyBhcmUgYWxzbyBlZGl0aW5nIHRoaXMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdCBsZWFzdCBvbmUgbmFtZWQgdXNlci4gVGhlIG1heCB1c2VycyB0byBkaXNwbGF5IGlzIDUuIEFub255bW91cyB1c2VycyBkb2Vzbid0IGdldCBkaXNwbGF5ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieSBuYW1lLCBidXQgdGhlIGFtb3VudCBvZiB1c2VycyBpcyBzaG93bi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IF8uc2xpY2UoZWRpdG9yc1dpdGhvdXRBbm9ueW1vdXMsIDAsIDUpLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVkaXRvcnNXaXRob3V0QW5vbnltb3VzLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9yZSB0aGFuIDUgdXNlcnMgd2l0aCBuYW1lcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSAnLCAuLi4gWysnICsgKGVkaXRvck5hbWVzLmxlbmd0aCAtIDUpICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yc1dpdGhvdXRBbm9ueW1vdXMubGVuZ3RoICE9PSBlZGl0b3JOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVzcyB0aGFuIDUgdXNlcnMsIHNvIHRoZSBkaWZmZXJlbmNlIGlzIGNhbGN1bGF0ZWQgZGlmZmVyZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9ICcsIC4uLiBbKycgKyAoZWRpdG9yTmFtZXMubGVuZ3RoIC0gZWRpdG9yc1dpdGhvdXRBbm9ueW1vdXMubGVuZ3RoKSArICddJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luZ3VsYXIgdnMuIHBsdXJhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZGl0b3JOYW1lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSAnICcgKyBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ2lzIGFsc28gZWRpdGluZyB0aGlzLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgKz0gJyAnICsgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdhcmUgYWxzbyBlZGl0aW5nIHRoaXMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgTWVzc2FnaW5nLmNyZWF0ZU9yRWRpdE1lc3NhZ2UobWVzc2FnaW5nSWQsIHRleHQsICd3YXJuaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHN0dWN0dXJlIG9mIGRldGVybWluYXRpbmcgd2hpY2ggdXNlcnMgYXJlIGVkaXRpbmcgdGhpcyBkaWFsb2c6XG4gICAgICAgICAgICAgICAgLy8gLSBzZW5kIGFuIG9wZW5fcXVlcnkgdG8gZXZlcnkgdXNlciB3aXRoIHRoZSBuYW1lIG9mIHRoaXMgb3BlcmF0b3IgaW4gdGhlIHBhcmFtZXRlci4gV2l0aFxuICAgICAgICAgICAgICAgIC8vICAgdGhpcyBpbmZvcm1hdGlvbiBhbGwgY2xpZW50cyB0aGF0IGxpc3RlbiB0byB0aGlzIHJlcXVlc3Qga25vd3MgdGhhdCB0aGlzIG9wZXJhdG9yIGhhc1xuICAgICAgICAgICAgICAgIC8vICAgb3BlbmVkIHRoZSBkaWFsb2cuXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgY2xpZW50cywgd2hpY2ggaGF2ZSByZWNpZXZlZCB0aGUgcXVlcnkgc2VuZCBhbiBhbnN3ZXIgKG9wZW5fcmVzb25zZSkgdG8gdGhpcyBvcGVyYXRvci5cbiAgICAgICAgICAgICAgICAvLyAtIFRoZSBvcGVyYXRvciBjb2xsZWN0cyBhbGwgcmVzb25zZXMgYW5kIGZpbGxzIHRoZSBlZGl0b3JuYW1lcyBsaXN0LlxuICAgICAgICAgICAgICAgIC8vIC0gSWYgdGhlIGRpYWxvZyBnZXQgY2xvc2VkLCBhIGRpYWxvZ19jbG9zZWQgaXMgc2VuZC4gQWxsIHJlY2lldmVuIGNsaWVudHMgcmVtb3ZlIHRoaXNcbiAgICAgICAgICAgICAgICAvLyAgIG9wZXJhdG8gZnJvbSB0aGVpciBlZGl0b3JOYW1lcyBsaXN0LlxuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZUNhbGxiYWNrSWQgPSBOb3RpZnkucmVnaXN0ZXJDYWxsYmFjayhkaWFsb2dOYW1lICsgJ19vcGVuX3Jlc3BvbnNlJywgZnVuY3Rpb24gKG5vdGlmeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vdGlmeS5zZW5kQnlTZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRBY3RpdmVFZGl0b3Iobm90aWZ5LnBhcmFtcy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeUNhbGxiYWNrSWQgPSBOb3RpZnkucmVnaXN0ZXJDYWxsYmFjayhkaWFsb2dOYW1lICsgJ19vcGVuX3F1ZXJ5JywgZnVuY3Rpb24gKG5vdGlmeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vdGlmeS5zZW5kQnlTZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRBY3RpdmVFZGl0b3Iobm90aWZ5LnBhcmFtcy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RpZnkuc2VuZGVyVXNlcklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTm90aWZ5Lm5vdGlmeShkaWFsb2dOYW1lICsgJ19vcGVuX3Jlc3BvbnNlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBvcGVyYXRvci51c2VyID8gb3BlcmF0b3IudXNlci5zaG9ydF9uYW1lIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW25vdGlmeS5zZW5kZXJVc2VySWRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTm90aWZ5Lm5vdGlmeShkaWFsb2dOYW1lICsgJ19vcGVuX3Jlc3BvbnNlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBvcGVyYXRvci51c2VyID8gb3BlcmF0b3IudXNlci5zaG9ydF9uYW1lIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgbnVsbCwgW25vdGlmeS5zZW5kZXJSZXBseUNoYW5uZWxOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgY2xvc2VDYWxsYmFja0lkID0gTm90aWZ5LnJlZ2lzdGVyQ2FsbGJhY2soZGlhbG9nTmFtZSArICdfZGlhbG9nX2Nsb3NlZCcsIGZ1bmN0aW9uIChub3RpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQWN0aXZlRWRpdG9yKG5vdGlmeS5wYXJhbXMubmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCBoZXJlIHRoZSBvcGVuX3F1ZXJ5IHRvIGdldCB0aGUgbm90aWZ5LWNoYWluIHN0YXJ0ZWQuXG4gICAgICAgICAgICAgICAgTm90aWZ5Lm5vdGlmeShkaWFsb2dOYW1lICsgJ19vcGVuX3F1ZXJ5Jywge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBvcGVyYXRvci51c2VyID8gb3BlcmF0b3IudXNlci5zaG9ydF9uYW1lIDogJycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGZ1bmN0aW9uIHJldHVybmVkIGlzIHRvIGRlcmVnaXN0ZXIgdGhlIGNhbGxiYWNrcyBhbmQgc2VuZCB0aGUgZGlhbG9nX2Nsb3NlZCBub3RpZnksIGlmXG4gICAgICAgICAgICAgICAgLy8gdGhlIGRpYWxvZyBnZXQgY2xvc2VkLlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIE5vdGlmeS5kZXJlZ2lzdGVyQ2FsbGJhY2tzKHJlc3BvbnNlQ2FsbGJhY2tJZCwgcXVlcnlDYWxsYmFja0lkLCBjbG9zZUNhbGxiYWNrSWQpO1xuICAgICAgICAgICAgICAgICAgICBNZXNzYWdpbmcuZGVsZXRlTWVzc2FnZShtZXNzYWdpbmdJZCk7XG4gICAgICAgICAgICAgICAgICAgIE5vdGlmeS5ub3RpZnkoZGlhbG9nTmFtZSArICdfZGlhbG9nX2Nsb3NlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG9wZXJhdG9yLnVzZXIgPyBvcGVyYXRvci51c2VyLnNob3J0X25hbWUgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLypcbiAqIFRoaXMgZmlsdGVyIGZpbHRlcnMgYWxsIGl0ZW1zIGluIGFuIGFycmF5LiBJZiB0aGUgZmlsdGVyQXJyYXkgaXMgZW1wdHksIHRoZVxuICogYXJyYXkgaXMgcGFzc2VkLiBUaGUgZmlsdGVyQXJyYXkgY29udGFpbnMgbnVtYmVycyBvZiB0aGUgbXVsdGlzZWxlY3QsIGUuIGcuIFsxLCAzLCA0XS5cbiAqIFRoZW4sIGFsbCBpdGVtcyBpbiB0aGUgYXJyYXkgYXJlIHBhc3NlZCwgaWYgdGhlIGl0ZW1faWQgKGdldCB3aXRoIGlkX2Z1bmN0aW9uKSBtYXRjaGVzXG4gKiBvbmUgb2YgdGhlIGlkcyBpbiBmaWx0ZXJBcnJheS4gaWRfZnVuY3Rpb24gY291bGQgYWxzbyByZXR1cm4gYSBsaXN0IG9mIGlkcy4gRXhhbXBsZTpcbiAqIEl0ZW0gMSBoYXMgdHdvIHRhZ3Mgd2l0aCBpZHMgWzEsIDRdLiBmaWx0ZXJBcnJheSA9PSBbMywgNF0gLS0+IG1hdGNoXG4gKlxuICogSWYgLTEgaXMgaW4gdGhlIGFycmF5IGl0ZW1zIHdpdGhvdXQgYW4gaWQgd2lsbCBub3QgYmUgZmlsdGVyZWQuIFRoaXMgaXMgZm9yIGltcGxlbWVudGluZ1xuICogYSBmaWx0ZXIgb3B0aW9uIGxpa2U6IFwiQWxsIGl0ZW1zIHdpdGhvdXQgYSBjYXRlZ29yeVwiXG4gKi9cbi5maWx0ZXIoJ011bHRpc2VsZWN0RmlsdGVyJywgW1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcnJheSwgZmlsdGVyQXJyYXksIGlkRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXRlbXNXaXRob3V0UHJvcGVydHkgPSBfLmluZGV4T2YoZmlsdGVyQXJyYXksIC0xKSA+IC0xO1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChhcnJheSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBpZEZ1bmN0aW9uKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gW2lkXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlkID09PSBudWxsIHx8ICFpZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zV2l0aG91dFByb3BlcnR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXy5pbnRlcnNlY3Rpb24oaWQsIGZpbHRlckFycmF5KS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZpbHRlcignb3NGaWx0ZXInLCBbXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFycmF5LCBzdHJpbmcsIGdldEZpbHRlclN0cmluZykge1xuICAgICAgICAgICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGFycmF5LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRGaWx0ZXJTdHJpbmcoaXRlbSkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cmluZy50b0xvd2VyQ2FzZSgpKSA+IC0xO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLy8gYW5ndWxhciBmb3JtbHkgY29uZmlnIG9wdGlvbnNcbi5ydW4oW1xuICAgICdmb3JtbHlDb25maWcnLFxuICAgIGZ1bmN0aW9uIChmb3JtbHlDb25maWcpIHtcbiAgICAgICAgLy8gTk9URTogVGhpcyBuZXh0IGxpbmUgaXMgaGlnaGx5IHJlY29tbWVuZGVkLiBPdGhlcndpc2UgQ2hyb21lJ3MgYXV0b2NvbXBsZXRlXG4gICAgICAgIC8vIHdpbGwgYXBwZWFyIG92ZXIgeW91ciBvcHRpb25zIVxuICAgICAgICBmb3JtbHlDb25maWcuZXh0cmFzLnJlbW92ZUNocm9tZUF1dG9Db21wbGV0ZSA9IHRydWU7XG5cbiAgICAgICAgLy8gQ29uZmlndXJlIGN1c3RvbSB0eXBlc1xuICAgICAgICBmb3JtbHlDb25maWcuc2V0VHlwZSh7XG4gICAgICAgICAgICBuYW1lOiAnZWRpdG9yJyxcbiAgICAgICAgICAgIGV4dGVuZHM6ICd0ZXh0YXJlYScsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3N0YXRpYy90ZW1wbGF0ZXMvY29yZS9lZGl0b3IuaHRtbCcsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3JtbHlDb25maWcuc2V0VHlwZSh7XG4gICAgICAgICAgICBuYW1lOiAncGFzc3dvcmQnLFxuICAgICAgICAgICAgZXh0ZW5kczogJ2lucHV0JyxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3RhdGljL3RlbXBsYXRlcy9jb3JlL3Bhc3N3b3JkLmh0bWwnLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9ybWx5Q29uZmlnLnNldFR5cGUoe1xuICAgICAgICAgICAgbmFtZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3RhdGljL3RlbXBsYXRlcy9jb3JlL2NoZWNrYm94Lmh0bWwnLFxuICAgICAgICAgICAgb3ZlcndyaXRlT2s6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3JtbHlDb25maWcuc2V0VHlwZSh7XG4gICAgICAgICAgICBuYW1lOiAnY2hlY2tib3gtYnV0dG9ucycsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3N0YXRpYy90ZW1wbGF0ZXMvY29yZS9jaGVja2JveC1idXR0b25zLmh0bWwnLFxuICAgICAgICAgICAgb3ZlcndyaXRlT2s6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3JtbHlDb25maWcuc2V0VHlwZSh7XG4gICAgICAgICAgICBuYW1lOiAnc2VsZWN0LXNpbmdsZScsXG4gICAgICAgICAgICBleHRlbmRzOiAnc2VsZWN0JyxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3RhdGljL3RlbXBsYXRlcy9jb3JlL3NlbGVjdC1zaW5nbGUuaHRtbCdcbiAgICAgICAgfSk7XG4gICAgICAgIGZvcm1seUNvbmZpZy5zZXRUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWxlY3QtbXVsdGlwbGUnLFxuICAgICAgICAgICAgZXh0ZW5kczogJ3NlbGVjdCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3N0YXRpYy90ZW1wbGF0ZXMvY29yZS9zZWxlY3QtbXVsdGlwbGUuaHRtbCdcbiAgICAgICAgfSk7XG4gICAgICAgIGZvcm1seUNvbmZpZy5zZXRUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICdyYWRpby1idXR0b25zJyxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3RhdGljL3RlbXBsYXRlcy9jb3JlL3JhZGlvLWJ1dHRvbnMuaHRtbCcsXG4gICAgICAgICAgICB3cmFwcGVyOiBbJ2Jvb3RzdHJhcEhhc0Vycm9yJ10sXG4gICAgICAgICAgICBkZWZhdWx0T3B0aW9uczoge1xuICAgICAgICAgICAgICAgIG5vRm9ybUNvbnRyb2w6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmb3JtbHlDb25maWcuc2V0VHlwZSh7XG4gICAgICAgICAgICBuYW1lOiAnZmlsZScsXG4gICAgICAgICAgICBleHRlbmRzOiAnaW5wdXQnLFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdzdGF0aWMvdGVtcGxhdGVzL2NvcmUvZmlsZS5odG1sJyxcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLy8gaHRtbC10YWcgb3MtZm9ybS1maWVsZCB0byBnZW5lcmF0ZSBnZW5lcmljIGZyb20gZmllbGRzXG4vLyBUT0RPOiBtYWtlIGl0IHBvc3NpYmxlIHRvIHVzZSBvdGhlciBmaWVsZHMgdGhlbiBjb25maWcgZmllbGRzXG4uZGlyZWN0aXZlKCdvc0Zvcm1GaWVsZCcsIFtcbiAgICAnJHBhcnNlJyxcbiAgICAnQ29uZmlnJyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgIGZ1bmN0aW9uKCRwYXJzZSwgQ29uZmlnLCBnZXR0ZXh0Q2F0YWxvZykge1xuICAgICAgICB2YXIgZ2V0SHRtbFR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdHJpbmc6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICB0ZXh0OiAndGV4dGFyZWEnLFxuICAgICAgICAgICAgICAgIG1hcmt1cFRleHQ6ICdlZGl0b3InLFxuICAgICAgICAgICAgICAgIGludGVnZXI6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgIGJvb2xlYW46ICdjaGVja2JveCcsXG4gICAgICAgICAgICAgICAgY2hvaWNlOiAnY2hvaWNlJyxcbiAgICAgICAgICAgICAgICBjb21tZW50czogJ2NvbW1lbnRzJyxcbiAgICAgICAgICAgICAgICBjb2xvcnBpY2tlcjogJ2NvbG9ycGlja2VyJyxcbiAgICAgICAgICAgICAgICBkYXRldGltZXBpY2tlcjogJ2RhdGV0aW1lcGlja2VyJyxcbiAgICAgICAgICAgICAgICBtYWpvcml0eU1ldGhvZDogJ2Nob2ljZScsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25zOiAndHJhbnNsYXRpb25zJyxcbiAgICAgICAgICAgIH1bdHlwZV07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZTogdHJ1ZSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3RhdGljL3RlbXBsYXRlcy9jb25maWctZm9ybS1maWVsZC5odG1sJyxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uICgkc2NvcGUsIGlFbGVtZW50LCBpQXR0cnMsIGNvbnRyb2xsZXIsIHRyYW5zY2x1ZGVGbikge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9ICRwYXJzZShpQXR0cnMuZmllbGQpKCRzY29wZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IENvbmZpZy5nZXQoZmllbGQua2V5KTtcbiAgICAgICAgICAgICAgICAkc2NvcGUudHlwZSA9IGdldEh0bWxUeXBlKGZpZWxkLmlucHV0X3R5cGUpO1xuICAgICAgICAgICAgICAgIGlmICgkc2NvcGUudHlwZSA9PSAnY2hvaWNlJykge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2hvaWNlcyA9IGZpZWxkLmNob2ljZXM7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS52YWx1ZSA9IGNvbmZpZy52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudmFsdWUgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoY29uZmlnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLmxhYmVsID0gZmllbGQubGFiZWw7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmtleSA9ICdmaWVsZC0nICsgZmllbGQua2V5O1xuICAgICAgICAgICAgICAgICRzY29wZS5oZWxwX3RleHQgPSBmaWVsZC5oZWxwX3RleHQ7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlZmF1bHRfdmFsdWUgPSBmaWVsZC5kZWZhdWx0X3ZhbHVlO1xuICAgICAgICAgICAgICAgICRzY29wZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS50eXBlID09ICdjaG9pY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUudmFsdWUgPSAkc2NvcGUuZGVmYXVsdF92YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS52YWx1ZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygkc2NvcGUuZGVmYXVsdF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNhdmUoZmllbGQsICRzY29wZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4vKiBUaGlzIGRpcmVjdGl2ZSBwcm92aWRlcyBhIGNzdiBpbXBvcnQgdGVtcGxhdGUuXG4gKiBQYXBhIFBhcnNlIGlzIHVzZWQgdG8gcGFyc2UgdGhlIGNzdiBmaWxlLiBBY2NlcHRlZCBhdHRyaWJ1dGVzOlxuICogKiBjaGFuZ2U6XG4gKiAgIENhbGxiYWNrIGlmIGZpbGUgY2hhbmdlcy4gVGhlIG9uZSBwYXJhbWV0ZXIgaXMgY3N2IHBhc3NpbmcgdGhlIHBhcnNlZCBmaWxlXG4gKiAqIGNvbmZpZyAob3B0aW9uYWwpOlxuICogICAtIGFjY2VwdDogU3RyaW5nIHdpdGggZXh0ZW5zaW9uczogZGVmYXVsdCAnLmNzdiAudHh0J1xuICogICAtIGVuY29kaW5nT3B0aW9uczogTGlzdCB3aXRoIGVuY29kaW5ncy4gRGVmYXVsdCBbJ1VURi04JywgJ0lTTy04ODU5LTEnXVxuICogICAtIHBhcnNlQ29uZmlnOiBhIGRpY3QgcGFzc2VkIHRvIFBhcGFQYXJzZVxuICovXG4uZGlyZWN0aXZlKCdjc3ZJbXBvcnQnLCBbXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3RhdGljL3RlbXBsYXRlcy9jc3YtaW1wb3J0Lmh0bWwnLFxuICAgICAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgICAgICBjaGFuZ2U6ICcmJyxcbiAgICAgICAgICAgICAgICBjb25maWc6ICc9PycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udHJvbGxlcjogZnVuY3Rpb24gKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgJGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGNvbmZpZyBpZiBpdCBpcyBub3QgZ2l2ZW5cbiAgICAgICAgICAgICAgICBpZiAoISRzY29wZS5jb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNvbmZpZyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoISRzY29wZS5jb25maWcucGFyc2VDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNvbmZpZy5wYXJzZUNvbmZpZyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICRzY29wZS5pbnB1dEVsZW1lbnQgPSBhbmd1bGFyLmVsZW1lbnQoJGVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvcignI2NzdkZpbGVTZWxlY3RvcicpKTtcblxuICAgICAgICAgICAgICAgIC8vIHNldCBhY2NlcHQgYW5kIGVuY29kaW5nXG4gICAgICAgICAgICAgICAgJHNjb3BlLmFjY2VwdCA9ICRzY29wZS5jb25maWcuYWNjZXB0IHx8ICcuY3N2JztcbiAgICAgICAgICAgICAgICAkc2NvcGUuZW5jb2RpbmdPcHRpb25zID0gJHNjb3BlLmNvbmZpZy5lbmNvZGluZ09wdGlvbnMgfHwgWydVVEYtOCddO1xuICAgICAgICAgICAgICAgICRzY29wZS5lbmNvZGluZyA9ICRzY29wZS5lbmNvZGluZ09wdGlvbnNbMF07XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUucGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dEVsZW1lbnQgPSAkc2NvcGUuaW5wdXRFbGVtZW50WzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0RWxlbWVudC5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5jaGFuZ2Uoe2Nzdjoge2RhdGE6IHt9fX0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlQ29uZmlnID0gXy5kZWZhdWx0cyhfLmNsb25lKCRzY29wZS5jb25maWcucGFyc2VDb25maWcpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyOiAkc2NvcGUuZGVsaW1pdGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nOiAkc2NvcGUuZW5jb2RpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiBmYWxzZSwgLy8gd2UgZG8gbm90IHdhbnQgdG8gaGF2ZSBkaWN0cyBpbiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKGNzdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3N2LmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3YubWV0YS5maWVsZHMgPSBjc3YuZGF0YVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzdi5tZXRhLmZpZWxkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzdi5kYXRhID0gY3N2LmRhdGEuc3BsaWNlKDEpOyAvLyBkbyBub3QgaW50ZXJwcmV0IHRoZSBoZWFkZXIgYXMgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3YubWV0YS5kZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYXV0b2RlbGltaXRlciA9IGNzdi5tZXRhLmRlbGltaXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5jaGFuZ2Uoe2NzdjogY3N2fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2hhbmdlKHtjc3Y6IHtkYXRhOiB7fX19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBQYXBhLnBhcnNlKGlucHV0RWxlbWVudC5maWxlc1swXSwgcGFyc2VDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICRzY29wZS5jbGVhckZpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5pbnB1dEVsZW1lbnRbMF0udmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdGVkRmlsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnBhcnNlKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICRzY29wZS5pbnB1dEVsZW1lbnQub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdGVkRmlsZSA9IF8ubGFzdCgkc2NvcGUuaW5wdXRFbGVtZW50WzBdLnZhbHVlLnNwbGl0KCdcXFxcJykpO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUucGFyc2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmRpcmVjdGl2ZSgnbWVzc2FnaW5nJywgW1xuICAgICckdGltZW91dCcsXG4gICAgJ01lc3NhZ2luZycsXG4gICAgZnVuY3Rpb24gKCR0aW1lb3V0LCBNZXNzYWdpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3N0YXRpYy90ZW1wbGF0ZXMvbWVzc2FnaW5nLmh0bWwnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgY29udHJvbGxlcjogZnVuY3Rpb24gKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgJGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm1lc3NhZ2VzID0ge307XG5cbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUubWVzc2FnZXMgPSBNZXNzYWdpbmcuZ2V0TWVzc2FnZXMoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1lc3NhZ2luZy5yZWdpc3Rlck1lc3NhZ2VDaGFuZ2VDYWxsYmFjayh1cGRhdGUpO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2luZy5kZWxldGVNZXNzYWdlKGlkKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignTWFpbk1lbnVDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICdtYWluTWVudScsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgbWFpbk1lbnUpIHtcbiAgICAgICAgbWFpbk1lbnUucmVnaXN0ZXJTY29wZSgkc2NvcGUpO1xuICAgICAgICAkc2NvcGUuaXNNZW51T3BlbiA9IGZhbHNlO1xuICAgICAgICAkc2NvcGUuY2xvc2VNZW51ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLmlzTWVudU9wZW4gPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignTGFuZ3VhZ2VDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0xhbmd1YWdlcycsXG4gICAgJ2ZpbHRlckZpbHRlcicsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgZ2V0dGV4dENhdGFsb2csIExhbmd1YWdlcywgZmlsdGVyRmlsdGVyKSB7XG4gICAgICAgICRzY29wZS5sYW5ndWFnZXMgPSBMYW5ndWFnZXMuZ2V0TGFuZ3VhZ2VzKCk7XG4gICAgICAgICRzY29wZS5zZWxlY3RlZExhbmd1YWdlID0gZmlsdGVyRmlsdGVyKCRzY29wZS5sYW5ndWFnZXMsIHtzZWxlY3RlZDogdHJ1ZX0pO1xuICAgICAgICAvLyBjb250cm9sbGVyIHRvIHN3aXRjaCBhcHAgbGFuZ3VhZ2VcbiAgICAgICAgJHNjb3BlLnN3aXRjaExhbmd1YWdlID0gZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgICAgICRzY29wZS5sYW5ndWFnZXMgPSBMYW5ndWFnZXMuc2V0Q3VycmVudExhbmd1YWdlKGxhbmcpO1xuICAgICAgICAgICAgJHNjb3BlLnNlbGVjdGVkTGFuZ3VhZ2UgPSBmaWx0ZXJGaWx0ZXIoJHNjb3BlLmxhbmd1YWdlcywge3NlbGVjdGVkOiB0cnVlfSk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ0dvdG9Ub3BDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckd2luZG93JyxcbiAgICAnJHRpbWVvdXQnLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsICR3aW5kb3csICR0aW1lb3V0KSB7XG4gICAgICAgICRzY29wZS5zaG93ID0gZmFsc2U7XG4gICAgICAgIGFuZ3VsYXIuZWxlbWVudCgkd2luZG93KS5iaW5kKCdzY3JvbGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNob3cgPSAoJHdpbmRvdy5wYWdlWU9mZnNldCA+PSAxNTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5ydW4oW1xuICAgICckcm9vdFNjb3BlJyxcbiAgICAnJHdpbmRvdycsXG4gICAgZnVuY3Rpb24gKCRyb290U2NvcGUsICR3aW5kb3cpIHtcbiAgICAgICAgJHJvb3RTY29wZS5nb3RvVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4vLyBQcmV2ZW50IHNjcm9sbGluZyBpbiBudW1iZXIgaW5wdXRzLiBJbnN0ZWFkIG9mIGNoYW5naW5nIHRoZSBudW1iZXIsIHRoZSBpbnB1dFxuLy8gaXMgYmx1cnJlZCBhbmQgdGhlIHdpbmRvdyBpcyBzY3JvbGxlZC4gVGhpcyBpcyB2ZXJ5IGltcG9ydGFudCBmb3Igb3VyIGRpYWxvZ1xuLy8gZm9ybXMsIHNvIGEgdXNlciBkaWRuJ3QgY2hhbmdlIGEgdmFsdWUsIHdoZW4gaGUgd2FudHMgdG8gc2Nyb2xsIHRoZSBmb3JtLlxuLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgJCgnYm9keScpLm9uKCdtb3VzZXdoZWVsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0Lm5vZGVOYW1lID09PSAnSU5QVVQnICYmIGUudGFyZ2V0LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAkKGUudGFyZ2V0KS5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pXG5cbi8vIFByb2plY3RvciBTaWRlYmFyIENvbnRyb2xsZXJcbi5jb250cm9sbGVyKCdQcm9qZWN0b3JTaWRlYmFyQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJGRvY3VtZW50JyxcbiAgICAnJHdpbmRvdycsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgJGRvY3VtZW50LCAkd2luZG93KSB7XG4gICAgICAgICRzY29wZS5pc1Byb2plY3RvclNpZGViYXIgPSBmYWxzZTtcbiAgICAgICAgJHNjb3BlLnNob3dQcm9qZWN0b3JTaWRlYmFyID0gZnVuY3Rpb24gKHNob3cpIHtcbiAgICAgICAgICAgICRzY29wZS5pc1Byb2plY3RvclNpZGViYXIgPSBzaG93O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNpZGViYXIgc2Nyb2xsXG4gICAgICAgIHZhciBtYXJnaW5Ub3AgPSAyMCwgLy8gbWFyZ2luLXRvcCBmcm9tICNjb250ZW50XG4gICAgICAgICAgICBtYXJnaW5Cb3R0b20gPSAzMCwgLy8gMzBweCArIDIwcHggc2lkZWJhciBtYXJnaW4tYm90dG9tID0gNTBweCBmcm9tIGZvb3RlclxuICAgICAgICAgICAgc2lkZWJhcjtcblxuICAgICAgICB2YXIgc2lkZWJhclNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzaWRlYmFySGVpZ2h0ID0gc2lkZWJhci5oZWlnaHQoKSxcbiAgICAgICAgICAgICAgICBzaWRlYmFyT2Zmc2V0ID0gc2lkZWJhci5vZmZzZXQoKS50b3AsXG4gICAgICAgICAgICAgICAgc2lkZWJhck1pbk9mZnNldCA9ICQoJyNoZWFkZXInKS5oZWlnaHQoKSArICQoJyNuYXYnKS5oZWlnaHQoKSArIG1hcmdpblRvcCxcbiAgICAgICAgICAgICAgICBkb2N1bWVudEhlaWdodCA9ICRkb2N1bWVudC5oZWlnaHQoKSxcbiAgICAgICAgICAgICAgICB3aW5kb3dIZWlnaHQgPSAkd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9ICR3aW5kb3cucGFnZVlPZmZzZXQ7XG5cbiAgICAgICAgICAgIC8vIEZpcnN0LCBjaGVjayBpZiB0aGVyZSBpcyBhIG5lZWQgdG8gc2Nyb2xsOiBzY3JvbGwgaWYgdGhlIHNpZGViYXIgaXMgc21hbGxlciB0aGVuIHRoZSBjb250ZW50XG4gICAgICAgICAgICBpZiAoc2lkZWJhckhlaWdodCA8ICQoJy5jb2wxJykuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNjcm9sbFRvcCArIG1hcmdpblRvcCArIHNpZGViYXJIZWlnaHQpID4gKGRvY3VtZW50SGVpZ2h0IC0gbWFyZ2luQm90dG9tKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGljayB0byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIHZhciBib3R0b20gPSBtYXJnaW5Cb3R0b20gKyBzY3JvbGxUb3AgKyB3aW5kb3dIZWlnaHQgLSBkb2N1bWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgc2lkZWJhci5jc3Moeydwb3NpdGlvbic6ICdmaXhlZCcsICd0b3AnOiAnJywgJ2JvdHRvbSc6IGJvdHRvbX0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHNjcm9sbFRvcCArIG1hcmdpblRvcCkgPiBzaWRlYmFyTWluT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNjcm9sbCB3aXRoIHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgICAgIHNpZGViYXIuY3NzKHsncG9zaXRpb24nOiAnZml4ZWQnLCAndG9wJzogbWFyZ2luVG9wLCAnYm90dG9tJzogJyd9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGljayB0byB0aGUgdG9wXG4gICAgICAgICAgICAgICAgICAgIHNpZGViYXIuY3NzKHsncG9zaXRpb24nOiAncmVsYXRpdmUnLCAndG9wJzogMCwgJ2JvdHRvbSc6ICcnfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTdGljayB0byB0aGUgdG9wLCBpZiB0aGUgc2lkZWJhciBpcyBsYXJnZXIgdGhlbiB0aGUgY29udGVudFxuICAgICAgICAgICAgICAgIHNpZGViYXIuY3NzKHsncG9zaXRpb24nOiAncmVsYXRpdmUnLCAndG9wJzogMCwgJ2JvdHRvbSc6ICcnfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLmluaXRTaWRlYmFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2lkZWJhciA9ICQoJyNzaWRlYmFyJyk7XG4gICAgICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lkZWJhci5oZWlnaHQoKTtcbiAgICAgICAgICAgIH0sIHNpZGViYXJTY3JvbGwpO1xuICAgICAgICAgICAgYW5ndWxhci5lbGVtZW50KCR3aW5kb3cpLmJpbmQoJ3Njcm9sbCcsIHNpZGViYXJTY3JvbGwpO1xuICAgICAgICB9O1xuXG4gICAgfVxuXSlcblxuLy8gTGVnYWwgTm90aWNlIENvbnRyb2xsZXJcbi5jb250cm9sbGVyKCdMZWdhbE5vdGljZUN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRodHRwJyxcbiAgICBmdW5jdGlvbiAoJHNjb3BlLCAkaHR0cCkge1xuICAgICAgICAkaHR0cC5nZXQoJy9jb3JlL3ZlcnNpb24vJykudGhlbihmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgJHNjb3BlLmNvcmVfdmVyc2lvbiA9IHN1Y2Nlc3MuZGF0YS5vcGVuc2xpZGVzX3ZlcnNpb247XG4gICAgICAgICAgICAkc2NvcGUuY29yZV9saWNlbnNlID0gc3VjY2Vzcy5kYXRhLm9wZW5zbGlkZXNfbGljZW5zZTtcbiAgICAgICAgICAgICRzY29wZS5jb3JlX3VybCA9IHN1Y2Nlc3MuZGF0YS5vcGVuc2xpZGVzX3VybDtcbiAgICAgICAgICAgICRzY29wZS5wbHVnaW5zID0gc3VjY2Vzcy5kYXRhLnBsdWdpbnM7XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi8vIFByaXZhY3kgUG9saWN5IENvbnRyb2xsZXJcbi5jb250cm9sbGVyKCdQcml2YWN5UG9saWN5Q3RybCcsIGZ1bmN0aW9uICgpIHt9KVxuXG4vLyBDb25maWcgQ29udHJvbGxlclxuLmNvbnRyb2xsZXIoJ0NvbmZpZ0N0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyR0aW1lb3V0JyxcbiAgICAnTWFqb3JpdHlNZXRob2RDaG9pY2VzJyxcbiAgICAnQ29uZmlnJyxcbiAgICAnT3BlblNsaWRlc0NvbmZpZ1ZhcmlhYmxlcycsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnRGF0ZVRpbWVQaWNrZXJUcmFuc2xhdGlvbicsXG4gICAgJ0VkaXRvcicsXG4gICAgZnVuY3Rpb24oJHNjb3BlLCAkdGltZW91dCwgTWFqb3JpdHlNZXRob2RDaG9pY2VzLCBDb25maWcsIE9wZW5TbGlkZXNDb25maWdWYXJpYWJsZXMsXG4gICAgICAgIGdldHRleHRDYXRhbG9nLCBEYXRlVGltZVBpY2tlclRyYW5zbGF0aW9uLCBFZGl0b3IpIHtcbiAgICAgICAgQ29uZmlnLmJpbmRBbGwoe30sICRzY29wZSwgJ2NvbmZpZ3MnKTtcbiAgICAgICAgJHNjb3BlLmNvbmZpZ0dyb3VwcyA9IE9wZW5TbGlkZXNDb25maWdWYXJpYWJsZXM7XG4gICAgICAgICRzY29wZS5kYXRlVGltZVBpY2tlclRyYW5zbGF0ZWRCdXR0b25zID0gRGF0ZVRpbWVQaWNrZXJUcmFuc2xhdGlvbi5nZXRCdXR0b25zKCk7XG5cbiAgICAgICAgJHNjb3BlLmNrZWRpdG9yT3B0aW9ucyA9IEVkaXRvci5nZXRPcHRpb25zKCk7XG4gICAgICAgICRzY29wZS5ja2VkaXRvck9wdGlvbnMub24uY2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyB3ZSBjb3VsZCBqdXN0IHJldHJpZXZlIHRoZSBrZXksIGJ1dCB3ZSBuZWVkIHRoZSBjb25maWdPcHRpb24gb2JqZWN0LlxuICAgICAgICAgICAgdmFyIGNvbmZpZ09wdGlvbl9rZXkgPSBldmVudC5lZGl0b3IuZWxlbWVudC4kLmlkO1xuXG4gICAgICAgICAgICAvLyBmaW5kIGNvbmZpZ09wdGlvbiBvYmplY3RcbiAgICAgICAgICAgIHZhciBzdWJncm91cHMgPSBfLmZsYXRNYXAoJHNjb3BlLmNvbmZpZ0dyb3VwcywgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwLnN1Ymdyb3VwcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gXy5mbGF0TWFwKHN1Ymdyb3VwcywgZnVuY3Rpb24gKHN1Ymdyb3VwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Ymdyb3VwLml0ZW1zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgY29uZmlnT3B0aW9uID0gXy5maW5kKGl0ZW1zLCBmdW5jdGlvbiAoX2l0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2l0ZW0ua2V5ID09PSBjb25maWdPcHRpb25fa2V5O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzO1xuICAgICAgICAgICAgLy8gVGhlICR0aW1lb3V0IGV4ZWN1dGVzIHRoZSBnaXZlbiBmdW5jdGlvbiBpbiBhbiBhbmd1bGFyIGNvbnRleHQuIEJlY2F1c2VcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzdGFuZGFyZCBKUyBldmVudCwgYWxsIGNoYW5nZXMgbWF5IG5vdCBoYXBwZW4gaW4gdGhlIGRpZ2lzdC1jeWxjZS5cbiAgICAgICAgICAgIC8vIEJ5IHVzaW5nICR0aW1lb3V0IGFuZ3VsYXIgY2FsbHMgJGFwcGx5IGZvciB1cyB0aGF0IHdlIGRvIG5vdCBoYXZlIHRvIGNhcmVcbiAgICAgICAgICAgIC8vIGFib3V0IHN0YXJ0aW5nIHRoZSBkaWdpc3QtY3ljbGUuXG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNhdmUoY29uZmlnT3B0aW9uLCBlZGl0b3IuZ2V0RGF0YSgpKTtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNhdmUgY2hhbmdlZCBjb25maWcgdmFsdWVcbiAgICAgICAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbihjb25maWdPcHRpb24sIHZhbHVlKSB7XG4gICAgICAgICAgICBDb25maWcuZ2V0KGNvbmZpZ09wdGlvbi5rZXkpLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBDb25maWcuc2F2ZShjb25maWdPcHRpb24ua2V5KS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnT3B0aW9uLnN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGZhZGUgb3V0IHRoZSBzdWNjZXNzIHN5bWJvbCBhZnRlciAyIHNlY29uZHMuXG4gICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9ICQoJyNzdWNjZXNzLWZpZWxkLScgKyBjb25maWdPcHRpb24ua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5mYWRlT3V0KDgwMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnT3B0aW9uLnN1Y2Nlc3MgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnT3B0aW9uLnN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25maWdPcHRpb24uZXJyb3JNZXNzYWdlID0gZXJyb3IuZGF0YS5kZXRhaWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBGb3IgY29tbWVudHMgaW5wdXRcbiAgICAgICAgJHNjb3BlLmFkZENvbW1lbnQgPSBmdW5jdGlvbiAoY29uZmlnT3B0aW9uLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBtYXhJZCA9IF8ubWF4KF8ua2V5cyhwYXJlbnQudmFsdWUpKTtcbiAgICAgICAgICAgIGlmIChtYXhJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWF4SWQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXhJZCA9IHBhcnNlSW50KG1heElkKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQudmFsdWVbbWF4SWRdID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnTmV3JyksXG4gICAgICAgICAgICAgICAgcHVibGljOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAkc2NvcGUuc2F2ZShjb25maWdPcHRpb24sIHBhcmVudC52YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5yZW1vdmVDb21tZW50ID0gZnVuY3Rpb24gKGNvbmZpZ09wdGlvbiwgcGFyZW50LCBpZCkge1xuICAgICAgICAgICAgcGFyZW50LnZhbHVlW2lkXSA9IG51bGw7XG4gICAgICAgICAgICAkc2NvcGUuc2F2ZShjb25maWdPcHRpb24sIHBhcmVudC52YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRm9yIGN1c3RvbSB0cmFuc2xhdGlvbnMgaW5wdXRcbiAgICAgICAgJHNjb3BlLmFkZFRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKGNvbmZpZ09wdGlvbiwgcGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQudmFsdWUucHVzaCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnTmV3JyksXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb246IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnTmV3JyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzY29wZS5zYXZlKGNvbmZpZ09wdGlvbiwgcGFyZW50LnZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLnJlbW92ZVRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKGNvbmZpZ09wdGlvbiwgcGFyZW50LCBpbmRleCkge1xuICAgICAgICAgICAgcGFyZW50LnZhbHVlLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAkc2NvcGUuc2F2ZShjb25maWdPcHRpb24sIHBhcmVudC52YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRm9yIG1ham9yaXR5IG1ldGhvZFxuICAgICAgICBhbmd1bGFyLmZvckVhY2goXG4gICAgICAgICAgICBfLmZpbHRlcigkc2NvcGUuY29uZmlnR3JvdXBzLCBmdW5jdGlvbiAoY29uZmlnR3JvdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnR3JvdXAubmFtZSA9PT0gJ01vdGlvbnMnIHx8IGNvbmZpZ0dyb3VwLm5hbWUgPT09ICdFbGVjdGlvbnMnO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBmdW5jdGlvbiAoY29uZmlnR3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnSXRlbTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goY29uZmlnR3JvdXAuc3ViZ3JvdXBzLCBmdW5jdGlvbiAoc3ViZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnSXRlbSA9IF8uZmluZChzdWJncm91cC5pdGVtcywgWydpbnB1dF90eXBlJywgJ21ham9yaXR5TWV0aG9kJ10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnSXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCcmVhayB0aGUgZm9yRWFjaCBsb29wIGlmIHdlIGZvdW5kIHNvbWV0aGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWdJdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnSXRlbS5jaG9pY2VzID0gTWFqb3JpdHlNZXRob2RDaG9pY2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG5dKVxuXG4vLyBTZWFyY2ggQmFyIENvbnRyb2xsZXJcbi5jb250cm9sbGVyKCdTZWFyY2hCYXJDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckc3RhdGUnLFxuICAgICckc2FuaXRpemUnLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSwgJHNhbml0aXplKSB7XG4gICAgICAgICRzY29wZS5zZWFyY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IF8uZXNjYXBlKCRzY29wZS5xdWVyeWJhcik7XG4gICAgICAgICAgICAkc2NvcGUucXVlcnliYXIgPSAnJztcbiAgICAgICAgICAgICRzdGF0ZS5nbygnc2VhcmNoJywge3E6IHF1ZXJ5fSk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLy8gU2VhcmNoIENvbnRyb2xsZXJcbi5jb250cm9sbGVyKCdTZWFyY2hDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckZmlsdGVyJyxcbiAgICAnJHN0YXRlUGFyYW1zJyxcbiAgICAnU2VhcmNoJyxcbiAgICAnRFMnLFxuICAgICdNb3Rpb24nLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsICRmaWx0ZXIsICRzdGF0ZVBhcmFtcywgU2VhcmNoLCBEUywgTW90aW9uKSB7XG4gICAgICAgICRzY29wZS5zZWFyY2hyZXN1bHRzID0gW107XG4gICAgICAgIHZhciBzZWFyY2hNb2R1bGVzID0gU2VhcmNoLmdldEFsbCgpO1xuXG4gICAgICAgIC8vIHNlYXJjaCBmdW5jdGlvblxuICAgICAgICAkc2NvcGUuc2VhcmNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUucmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGZvdW5kT2JqZWN0cyA9IFtdO1xuICAgICAgICAgICAgLy8gc2VhcmNoIGluIHJlc3QgcHJvcGVydGllcyBvZiBhbGwgZGVmaW5lZCBzZWFyY2hNb2R1bGVcbiAgICAgICAgICAgIC8vIChkb2VzIG5vdCBmb3VuZCBhbnkgcmVsYXRlZCBvYmplY3RzLCBlLmcuIHNwZWFrZXJzIG9mIGl0ZW1zKVxuICAgICAgICAgICAgXy5mb3JFYWNoKHNlYXJjaE1vZHVsZXMsIGZ1bmN0aW9uKHNlYXJjaE1vZHVsZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICByZXN1bHQudmVyYm9zZU5hbWUgPSBzZWFyY2hNb2R1bGUudmVyYm9zZU5hbWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvbGxlY3Rpb25OYW1lID0gc2VhcmNoTW9kdWxlLmNvbGxlY3Rpb25OYW1lO1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cmxEZXRhaWxTdGF0ZSA9IHNlYXJjaE1vZHVsZS51cmxEZXRhaWxTdGF0ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQud2VpZ2h0ID0gc2VhcmNoTW9kdWxlLndlaWdodDtcbiAgICAgICAgICAgICAgICByZXN1bHQuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVsZW1lbnRzID0gJGZpbHRlcignZmlsdGVyJykoRFMuZ2V0QWxsKHNlYXJjaE1vZHVsZS5jb2xsZWN0aW9uTmFtZSksICRzY29wZS5zZWFyY2hxdWVyeSk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChyZXN1bHQuZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRPYmplY3RzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNlYXJjaCBhZGRpdGlvbmFsbHkgaW4gc3BlY2lmaWMgcmVsZWF0aW9ucyBvZiBhbGwgZGVmaW5lZCBzZWFyY2hNb2R1bGVzXG4gICAgICAgICAgICBfLmZvckVhY2goc2VhcmNoTW9kdWxlcywgZnVuY3Rpb24oc2VhcmNoTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKERTLmdldEFsbChzZWFyY2hNb2R1bGUuY29sbGVjdGlvbk5hbWUpLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmplY3QuaGFzU2VhcmNoUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNTZWFyY2hSZXN1bHQoZm91bmRPYmplY3RzLCAkc2NvcGUuc2VhcmNocXVlcnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVsZWF0aW9uIGZvdW5kLCBjaGVjayBpZiBvYmplY3QgaXMgbm90IHlldCBpbiBzZWFyY2ggcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaCgkc2NvcGUucmVzdWx0cywgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob2JqZWN0LmdldFJlc291cmNlTmFtZSgpID09PSByZXN1bHQuY29sbGVjdGlvbk5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5maW5kSW5kZXgocmVzdWx0LmVsZW1lbnRzLCB7J2lkJzogb2JqZWN0LmlkfSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZWxlbWVudHMucHVzaChvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vZ2V0IHNlYXJjaCBzdHJpbmcgZnJvbSBwYXJhbWV0ZXJzIHN1Ym1pdHRlZCBmcm9tIG91dHNpZGUgdGhlIHNjb3BlXG4gICAgICAgIGlmICgkc3RhdGVQYXJhbXMucSkge1xuICAgICAgICAgICAgJHNjb3BlLnNlYXJjaHF1ZXJ5ID0gJHN0YXRlUGFyYW1zLnE7XG4gICAgICAgICAgICAkc2NvcGUuc2VhcmNoKCk7XG4gICAgICAgIH1cbiAgICB9XG5dKVxuXG4vLyBQcm9qZWN0b3IgQ29udHJvbCBDb250cm9sbGVyXG4uY29udHJvbGxlcignUHJvamVjdG9yQ29udHJvbEN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRodHRwJyxcbiAgICAnJGludGVydmFsJyxcbiAgICAnJHN0YXRlJyxcbiAgICAnJHEnLFxuICAgICckZmlsdGVyJyxcbiAgICAnQ29uZmlnJyxcbiAgICAnUHJvamVjdG9yJyxcbiAgICAnQ3VycmVudExpc3RPZlNwZWFrZXJzSXRlbScsXG4gICAgJ0N1cnJlbnRMaXN0T2ZTcGVha2Vyc1NsaWRlJyxcbiAgICAnUHJvamVjdGlvbkRlZmF1bHQnLFxuICAgICdQcm9qZWN0b3JNZXNzYWdlJyxcbiAgICAnQ291bnRkb3duJyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICduZ0RpYWxvZycsXG4gICAgJ1Byb2plY3Rvck1lc3NhZ2VGb3JtJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsICRodHRwLCAkaW50ZXJ2YWwsICRzdGF0ZSwgJHEsICRmaWx0ZXIsIENvbmZpZywgUHJvamVjdG9yLCBDdXJyZW50TGlzdE9mU3BlYWtlcnNJdGVtLFxuICAgICAgICBDdXJyZW50TGlzdE9mU3BlYWtlcnNTbGlkZSwgUHJvamVjdGlvbkRlZmF1bHQsIFByb2plY3Rvck1lc3NhZ2UsIENvdW50ZG93biwgZ2V0dGV4dENhdGFsb2csXG4gICAgICAgIG5nRGlhbG9nLCBQcm9qZWN0b3JNZXNzYWdlRm9ybSkge1xuICAgICAgICBQcm9qZWN0b3JNZXNzYWdlLmJpbmRBbGwoe30sICRzY29wZSwgJ21lc3NhZ2VzJyk7XG5cbiAgICAgICAgdmFyIGludGVydmFscyA9IFtdO1xuICAgICAgICB2YXIgY2FsY3VsYXRlQ291bnRkb3duVGltZSA9IGZ1bmN0aW9uIChjb3VudGRvd24pIHtcbiAgICAgICAgICAgIGNvdW50ZG93bi5zZWNvbmRzID0gTWF0aC5mbG9vciggY291bnRkb3duLmNvdW50ZG93bl90aW1lIC0gRGF0ZS5ub3coKSAvIDEwMDAgKyAkc2NvcGUuc2VydmVyT2Zmc2V0ICk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjYW5jZWxJbnRlcnZhbFRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGludGVydmFscy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICRpbnRlcnZhbC5jYW5jZWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIENvdW50ZG93bi5sYXN0TW9kaWZpZWQoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLmNvdW50ZG93bnMgPSBDb3VudGRvd24uZ2V0QWxsKCk7XG5cbiAgICAgICAgICAgIC8vIHN0b3AgQUxMIGludGVydmFsIHRpbWVyXG4gICAgICAgICAgICBjYW5jZWxJbnRlcnZhbFRpbWVycygpO1xuICAgICAgICAgICAgJHNjb3BlLmNvdW50ZG93bnMuZm9yRWFjaChmdW5jdGlvbiAoY291bnRkb3duKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZG93bi5ydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZUNvdW50ZG93blRpbWUoY291bnRkb3duKTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxzLnB1c2goJGludGVydmFsKGZ1bmN0aW9uICgpIHsgY2FsY3VsYXRlQ291bnRkb3duVGltZShjb3VudGRvd24pOyB9LCAxMDAwKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRkb3duLnNlY29uZHMgPSBjb3VudGRvd24uY291bnRkb3duX3RpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gQ2FuY2VsIGFsbCBpbnRlcnZhbHMgaWYgdGhlIGNvbnRyb2xsZXIgaXMgZGVzdHJveWVkXG4gICAgICAgICAgICBjYW5jZWxJbnRlcnZhbFRpbWVycygpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9qZWN0b3IubGFzdE1vZGlmaWVkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5wcm9qZWN0b3JzID0gUHJvamVjdG9yLmdldEFsbCgpO1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuYWN0aXZlX3Byb2plY3Rvcikge1xuICAgICAgICAgICAgICAgICRzY29wZS5hY3RpdmVfcHJvamVjdG9yID0gJGZpbHRlcignb3JkZXJCeScpKCRzY29wZS5wcm9qZWN0b3JzLCAnaWQnKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5zZXRJZnJhbWVTaXplKCRzY29wZS5hY3RpdmVfcHJvamVjdG9yKTtcbiAgICAgICAgICAgIGlmICgkc2NvcGUucHJvamVjdG9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuY3VycmVudExpc3RPZlNwZWFrZXJzQXNPdmVybGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJHNjb3BlLm1lc3NhZ2VEZWZhdWx0UHJvamVjdG9ySWQgPSBQcm9qZWN0aW9uRGVmYXVsdC5maWx0ZXIoe25hbWU6ICdtZXNzYWdlcyd9KVswXS5wcm9qZWN0b3JfaWQ7XG4gICAgICAgICAgICAkc2NvcGUuY291bnRkb3duRGVmYXVsdFByb2plY3RvcklkID0gUHJvamVjdGlvbkRlZmF1bHQuZmlsdGVyKHtuYW1lOiAnY291bnRkb3ducyd9KVswXS5wcm9qZWN0b3JfaWQ7XG4gICAgICAgICAgICAkc2NvcGUubGlzdE9mU3BlYWtlcnNEZWZhdWx0UHJvamVjdG9ySWQgPSBQcm9qZWN0aW9uRGVmYXVsdC5maWx0ZXIoe25hbWU6ICdhZ2VuZGFfY3VycmVudF9saXN0X29mX3NwZWFrZXJzJ30pWzBdLnByb2plY3Rvcl9pZDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHdhdGNoIGZvciBjaGFuZ2VzIGluIHByb2plY3Rvcl9icm9hZGNhc3QgYW5kIGN1cnJlbnRMaXN0T2ZTcGVha2Vyc1JlZmVyZW5jZVxuICAgICAgICB2YXIgbGFzdF9icm9hZGNhc3Q7XG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIENvbmZpZy5sYXN0TW9kaWZpZWQoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJyb2FkY2FzdCA9IENvbmZpZy5nZXQoJ3Byb2plY3Rvcl9icm9hZGNhc3QnKS52YWx1ZTtcbiAgICAgICAgICAgIGlmICghbGFzdF9icm9hZGNhc3QgfHwgbGFzdF9icm9hZGNhc3QgIT0gYnJvYWRjYXN0KSB7XG4gICAgICAgICAgICAgICAgbGFzdF9icm9hZGNhc3QgPSBicm9hZGNhc3Q7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmJyb2FkY2FzdCA9IGJyb2FkY2FzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5jdXJyZW50TGlzdE9mU3BlYWtlcnNSZWZlcmVuY2UgPSAkc2NvcGUuY29uZmlnKCdwcm9qZWN0b3JfY3VycmVudExpc3RPZlNwZWFrZXJzX3JlZmVyZW5jZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkc2NvcGUuY2hhbmdlUHJvamVjdG9yID0gZnVuY3Rpb24gKHByb2plY3Rvcikge1xuICAgICAgICAgICAgJHNjb3BlLmFjdGl2ZV9wcm9qZWN0b3IgPSBwcm9qZWN0b3I7XG4gICAgICAgICAgICAkc2NvcGUuc2V0SWZyYW1lU2l6ZShwcm9qZWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuc2V0SWZyYW1lU2l6ZSA9IGZ1bmN0aW9uIChwcm9qZWN0b3IpIHtcbiAgICAgICAgICAgICRzY29wZS5zY2FsZSA9IDI1Ni4wIC8gcHJvamVjdG9yLndpZHRoO1xuICAgICAgICAgICAgJHNjb3BlLmlmcmFtZUhlaWdodCA9ICRzY29wZS5zY2FsZSAqIHByb2plY3Rvci5oZWlnaHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLmVkaXRDdXJyZW50U2xpZGUgPSBmdW5jdGlvbiAocHJvamVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHByb2plY3Rvci5nZXRGb3JtT3JTdGF0ZUZvckN1cnJlbnRTbGlkZSgpO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5mb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIG5nRGlhbG9nLm9wZW4oZGF0YS5mb3JtLmdldERpYWxvZyh7aWQ6IGRhdGEuaWR9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKGRhdGEuc3RhdGUsIHtpZDogZGF0YS5pZH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyAqKiogY291bnRkb3duIGZ1bmN0aW9ucyAqKipcbiAgICAgICAgJHNjb3BlLmNhbGN1bGF0ZUNvdW50ZG93blRpbWUgPSBmdW5jdGlvbiAoY291bnRkb3duKSB7XG4gICAgICAgICAgICBjb3VudGRvd24uc2Vjb25kcyA9IE1hdGguZmxvb3IoIGNvdW50ZG93bi5jb3VudGRvd25fdGltZSAtIERhdGUubm93KCkgLyAxMDAwICsgJHNjb3BlLnNlcnZlck9mZnNldCApO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuZWRpdENvdW50ZG93biA9IGZ1bmN0aW9uIChjb3VudGRvd24pIHtcbiAgICAgICAgICAgIGNvdW50ZG93bi5lZGl0RmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgY291bnRkb3duLmRlc2NyaXB0aW9uID0gY291bnRkb3duLm5ld19kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIENvdW50ZG93bi5zYXZlKGNvdW50ZG93bik7XG4gICAgICAgICAgICBpZiAoIWNvdW50ZG93bi5ydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgY291bnRkb3duLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5hZGRDb3VudGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdF90aW1lID0gcGFyc2VJbnQoJHNjb3BlLmNvbmZpZygncHJvamVjdG9yX2RlZmF1bHRfY291bnRkb3duJykpO1xuICAgICAgICAgICAgdmFyIGNvdW50ZG93biA9IHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICAgICAgICAgICAgZGVmYXVsdF90aW1lOiBkZWZhdWx0X3RpbWUsXG4gICAgICAgICAgICAgICAgY291bnRkb3duX3RpbWU6IGRlZmF1bHRfdGltZSxcbiAgICAgICAgICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDb3VudGRvd24uY3JlYXRlKGNvdW50ZG93bik7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5yZW1vdmVDb3VudGRvd24gPSBmdW5jdGlvbiAoY291bnRkb3duKSB7XG4gICAgICAgICAgICBDb3VudGRvd24uZGVzdHJveShjb3VudGRvd24uaWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vICoqKiBtZXNzYWdlIGZ1bmN0aW9ucyAqKipcbiAgICAgICAgJHNjb3BlLmVkaXRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG5nRGlhbG9nLm9wZW4oUHJvamVjdG9yTWVzc2FnZUZvcm0uZ2V0RGlhbG9nKG1lc3NhZ2UpKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmFkZE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHttZXNzYWdlOiAnJ307XG4gICAgICAgICAgICBQcm9qZWN0b3JNZXNzYWdlLmNyZWF0ZShtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLnJlbW92ZU1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgUHJvamVjdG9yTWVzc2FnZS5kZXN0cm95KG1lc3NhZ2UuaWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qIEN1cnJlbnQgbGlzdCBvZiBzcGVha2VycyAqL1xuICAgICAgICAkc2NvcGUuY3VycmVudExpc3RPZlNwZWFrZXJzID0gQ3VycmVudExpc3RPZlNwZWFrZXJzU2xpZGU7XG4gICAgICAgIC8vIFNldCB0aGUgY3VycmVudCBvdmVybGF5IHN0YXR1c1xuICAgICAgICBpZiAoJHNjb3BlLmN1cnJlbnRMaXN0T2ZTcGVha2Vycy5pc1Byb2plY3RlZCgpLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGlzUHJvamVjdGVkID0gJHNjb3BlLmN1cnJlbnRMaXN0T2ZTcGVha2Vycy5pc1Byb2plY3RlZFdpdGhPdmVybGF5U3RhdHVzKCk7XG4gICAgICAgICAgICAkc2NvcGUuY3VycmVudExpc3RPZlNwZWFrZXJzQXNPdmVybGF5ID0gaXNQcm9qZWN0ZWRbMF0ub3ZlcmxheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzY29wZS5jdXJyZW50TGlzdE9mU3BlYWtlcnNBc092ZXJsYXkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdvIHRvIHRoZSBsaXN0IG9mIHNwZWFrZXJzKG1hbmFnZW1lbnQpIG9mIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIGxpc3Qgb2Ygc3BlYWtlcnMgcmVmZXJlbmNlIHNsaWRlXG4gICAgICAgICRzY29wZS5nb1RvTGlzdE9mU3BlYWtlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gJHNjb3BlLmN1cnJlbnRMaXN0T2ZTcGVha2Vyc0l0ZW0oKTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdhZ2VuZGEuaXRlbS5kZXRhaWwnLCB7aWQ6IGl0ZW0uaWR9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmN1cnJlbnRMaXN0T2ZTcGVha2Vyc0l0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ3VycmVudExpc3RPZlNwZWFrZXJzSXRlbS5nZXRJdGVtKCRzY29wZS5jdXJyZW50TGlzdE9mU3BlYWtlcnNSZWZlcmVuY2UpO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuc2V0T3ZlcmxheSA9IGZ1bmN0aW9uIChvdmVybGF5KSB7XG4gICAgICAgICAgICAkc2NvcGUuY3VycmVudExpc3RPZlNwZWFrZXJzQXNPdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgICAgIHZhciBpc1Byb2plY3RlZCA9ICRzY29wZS5jdXJyZW50TGlzdE9mU3BlYWtlcnMuaXNQcm9qZWN0ZWRXaXRoT3ZlcmxheVN0YXR1cygpO1xuICAgICAgICAgICAgaWYgKGlzUHJvamVjdGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChpc1Byb2plY3RlZCwgZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHBpbmcub3ZlcmxheSAhPSBvdmVybGF5KSB7IC8vIGNoYW5nZSB0aGUgb3ZlcmxheSBpZiBpdCBpcyBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5jdXJyZW50TGlzdE9mU3BlYWtlcnMucHJvamVjdChtYXBwaW5nLnByb2plY3RvcklkLCBvdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdQcm9qZWN0b3JNZXNzYWdlRWRpdEN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ3Byb2plY3Rvck1lc3NhZ2VJZCcsXG4gICAgJ1Byb2plY3Rvck1lc3NhZ2UnLFxuICAgICdQcm9qZWN0b3JNZXNzYWdlRm9ybScsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgcHJvamVjdG9yTWVzc2FnZUlkLCBQcm9qZWN0b3JNZXNzYWdlLCBQcm9qZWN0b3JNZXNzYWdlRm9ybSkge1xuICAgICAgICAkc2NvcGUuZm9ybUZpZWxkcyA9IFByb2plY3Rvck1lc3NhZ2VGb3JtLmdldEZvcm1GaWVsZHMoKTtcbiAgICAgICAgJHNjb3BlLm1vZGVsID0gYW5ndWxhci5jb3B5KFByb2plY3Rvck1lc3NhZ2UuZ2V0KHByb2plY3Rvck1lc3NhZ2VJZCkpO1xuXG4gICAgICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIFByb2plY3Rvck1lc3NhZ2UuaW5qZWN0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgUHJvamVjdG9yTWVzc2FnZS5zYXZlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgJHNjb3BlLmNsb3NlVGhpc0RpYWxvZygpO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdNYW5hZ2VQcm9qZWN0b3JzQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJGh0dHAnLFxuICAgICckdGltZW91dCcsXG4gICAgJ1Byb2plY3RvcicsXG4gICAgJ1Byb2plY3Rpb25EZWZhdWx0JyxcbiAgICAnQ29uZmlnJyxcbiAgICAnUHJvamVjdG9yTWVzc2FnZScsXG4gICAgJ25nRGlhbG9nJyxcbiAgICBmdW5jdGlvbiAoJHNjb3BlLCAkaHR0cCwgJHRpbWVvdXQsIFByb2plY3RvciwgUHJvamVjdGlvbkRlZmF1bHQsIENvbmZpZyxcbiAgICAgICAgUHJvamVjdG9yTWVzc2FnZSwgbmdEaWFsb2cpIHtcbiAgICAgICAgUHJvamVjdGlvbkRlZmF1bHQuYmluZEFsbCh7fSwgJHNjb3BlLCAncHJvamVjdGlvbmRlZmF1bHRzJyk7XG5cbiAgICAgICAgLyogSW5mbyBvbiByZXNvbHV0aW9uIGNhbGN1bGF0aW5nOlxuICAgICAgICAgKiBJbnRlcm5hbGx5IHRoZSByZXNvbHV0aW9uIGlzIHNhdmVkIGFzICh3aWR0aCwgaGVpZ2h0KSBidXQgdGhlIHVzZXIgaGFzXG4gICAgICAgICAqIGFuIGFzcGVjdCByYXRpbyB0byBjaG9vc2UgYW5kIGEgd2lkdGggZnJvbSA4MDAgdG8gMzg0MCAoNEspLiovXG4gICAgICAgICRzY29wZS5hc3BlY3RSYXRpb3MgPSB7XG4gICAgICAgICAgICAnNDozJzogNC8zLFxuICAgICAgICAgICAgJzE2OjknOiAxNi85LFxuICAgICAgICAgICAgJzE2OjEwJzogMTYvMTAsXG4gICAgICAgIH07XG4gICAgICAgIC8vIHdoZW4gY29udmVydGluZyAoeCx5KSAtPiAocmF0aW8sIHBlcmNlbnRhZ2UpIHJvdW5kIGlzc3VlcyBtYXkgb2NjdXJcbiAgICAgICAgLy8gKGUuZy4gODAwLzYwMCAhPSA0LzMgd2l0aCBpbnRlcm5hbCBjYWxjdWxhdGlvbiBpc3N1ZXMpLiBXaXRoIHRoaXMgZW52aXJvbm1lbnRcbiAgICAgICAgLy8gaXMgdGVzdGVkLCBpZiB0aGUgY2FsY3VsYXRlZCB2YWx1ZSBpcyBpbiB0aGUgZm9sbG93aW5nIGludGVydmFsOlxuICAgICAgICAvLyBbZXhwZWN0ZWQtZW52aXJvbm1lbnQ7IGV4cGVjdGVkK2Vudmlyb25tZW50XVxuICAgICAgICB2YXIgUkFUSU9fRU5WSVJPTk1FTlQgPSAwLjA1O1xuXG4gICAgICAgIC8vIHdhdGNoIGZvciBjaGFuZ2VzIGluIHByb2plY3Rvcl9icm9hZGNhc3RcbiAgICAgICAgLy8gYW5kIHByb2plY3Rvcl9jdXJyZW50TGlzdE9mU3BlYWtlcnNfcmVmZXJlbmNlXG4gICAgICAgIHZhciBsYXN0X2Jyb2FkY2FzdCwgbGFzdF9jbG9zO1xuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBDb25maWcubGFzdE1vZGlmaWVkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBicm9hZGNhc3QgPSAkc2NvcGUuY29uZmlnKCdwcm9qZWN0b3JfYnJvYWRjYXN0JyksXG4gICAgICAgICAgICBjdXJyZW50TGlzdE9mU3BlYWtlcnMgPSAkc2NvcGUuY29uZmlnKCdwcm9qZWN0b3JfY3VycmVudExpc3RPZlNwZWFrZXJzX3JlZmVyZW5jZScpO1xuICAgICAgICAgICAgaWYgKCFsYXN0X2Jyb2FkY2FzdCB8fCBsYXN0X2Jyb2FkY2FzdCAhPSBicm9hZGNhc3QpIHtcbiAgICAgICAgICAgICAgICBsYXN0X2Jyb2FkY2FzdCA9IGJyb2FkY2FzdDtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYnJvYWRjYXN0ID0gYnJvYWRjYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsYXN0X2Nsb3MgfHwgbGFzdF9jbG9zICE9IGN1cnJlbnRMaXN0T2ZTcGVha2Vycykge1xuICAgICAgICAgICAgICAgIGxhc3RfY2xvcyA9IGN1cnJlbnRMaXN0T2ZTcGVha2VycztcbiAgICAgICAgICAgICAgICAkc2NvcGUuY3VycmVudExpc3RPZlNwZWFrZXJzID0gY3VycmVudExpc3RPZlNwZWFrZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3YXRjaCBmb3IgY2hhbmdlcyBpbiBQcm9qZWN0b3IsIGFuZCByZWNhbGMgc2NhbGUgYW5kIGlmcmFtZUhlaWdodFxuICAgICAgICB2YXIgZmlyc3Rfd2F0Y2ggPSB0cnVlO1xuICAgICAgICAkc2NvcGUucmVzb2x1dGlvbnMgPSB7fTtcbiAgICAgICAgJHNjb3BlLmVkaXQgPSBbXTtcbiAgICAgICAgJHNjb3BlLnNsaWRlcnMgPSB7fTtcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvamVjdG9yLmxhc3RNb2RpZmllZCgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUucHJvamVjdG9ycyA9IFByb2plY3Rvci5nZXRBbGwoKTtcbiAgICAgICAgICAgICRzY29wZS5wcm9qZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHByb2plY3Rvcikge1xuICAgICAgICAgICAgICAgIHByb2plY3Rvci5pZnJhbWVTY2FsZSA9IDI1Ni4wIC8gcHJvamVjdG9yLndpZHRoO1xuICAgICAgICAgICAgICAgIHByb2plY3Rvci5pZnJhbWVIZWlnaHQgPSBwcm9qZWN0b3IuaWZyYW1lU2NhbGUgKiBwcm9qZWN0b3IuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdF93YXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUucmVzb2x1dGlvbnNbcHJvamVjdG9yLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9qZWN0b3Iud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHByb2plY3Rvci5oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmVkaXRbcHJvamVjdG9yLmlkXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2xpZGVyc1twcm9qZWN0b3IuaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByb2plY3Rvci53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcHJvamVjdG9yLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb29yOiA4MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VpbDogMzg0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5jYWxjUmVzb2x1dGlvbihwcm9qZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FbmQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zYXZlUmVzb2x1dGlvbihwcm9qZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZUxpbWl0TGFiZWxzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNldEFzcGVjdFJhdGlvKHByb2plY3RvciwgJHNjb3BlLmdldEFzcGVjdFJhdGlvKHByb2plY3RvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCRzY29wZS5wcm9qZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZpcnN0X3dhdGNoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzY29wZS5nZXRBc3BlY3RSYXRpbyA9IGZ1bmN0aW9uIChwcm9qZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IHByb2plY3Rvci53aWR0aC9wcm9qZWN0b3IuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGZvdW5kUmF0aW8gPSBfLmZpbmRLZXkoJHNjb3BlLmFzcGVjdFJhdGlvcywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID49IChyYXRpby1SQVRJT19FTlZJUk9OTUVOVCkgJiYgdmFsdWUgPD0gKHJhdGlvK1JBVElPX0VOVklST05NRU5UKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGZvdW5kUmF0aW8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLmtleXMoJHNjb3BlLmFzcGVjdFJhdGlvcylbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuc2V0QXNwZWN0UmF0aW8gPSBmdW5jdGlvbiAocHJvamVjdG9yLCBhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgJHNjb3BlLnJlc29sdXRpb25zW3Byb2plY3Rvci5pZF0uYXNwZWN0UmF0aW8gPSBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICRzY29wZS5yZXNvbHV0aW9uc1twcm9qZWN0b3IuaWRdLmFzcGVjdFJhdGlvTnVtYmVyID0gJHNjb3BlLmFzcGVjdFJhdGlvc1thc3BlY3RSYXRpb107XG4gICAgICAgICAgICAkc2NvcGUuY2FsY1Jlc29sdXRpb24ocHJvamVjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmNhbGNSZXNvbHV0aW9uID0gZnVuY3Rpb24gKHByb2plY3Rvcikge1xuICAgICAgICAgICAgdmFyIHJhdGlvID0gJHNjb3BlLnJlc29sdXRpb25zW3Byb2plY3Rvci5pZF0uYXNwZWN0UmF0aW9OdW1iZXI7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSAkc2NvcGUuc2xpZGVyc1twcm9qZWN0b3IuaWRdLnZhbHVlO1xuICAgICAgICAgICAgJHNjb3BlLnJlc29sdXRpb25zW3Byb2plY3Rvci5pZF0ud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICRzY29wZS5yZXNvbHV0aW9uc1twcm9qZWN0b3IuaWRdLmhlaWdodCA9IE1hdGgucm91bmQod2lkdGgvcmF0aW8pO1xuICAgICAgICB9O1xuXG4gICAgICAgICRzY29wZS50b2dnbGVFZGl0TWVudSA9IGZ1bmN0aW9uIChwcm9qZWN0b3JJZCkge1xuICAgICAgICAgICAgJHNjb3BlLmVkaXRbcHJvamVjdG9ySWRdID0gISRzY29wZS5lZGl0W3Byb2plY3RvcklkXTtcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgncnpTbGlkZXJGb3JjZVJlbmRlcicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2V0IGxpc3Qgb2Ygc3BlYWtlcnMgcmVmZXJlbmNlXG4gICAgICAgICRzY29wZS5zZXRMaXN0T2ZTcGVha2VycyA9IGZ1bmN0aW9uIChwcm9qZWN0b3IpIHtcbiAgICAgICAgICAgIENvbmZpZy5nZXQoJ3Byb2plY3Rvcl9jdXJyZW50TGlzdE9mU3BlYWtlcnNfcmVmZXJlbmNlJykudmFsdWUgPSBwcm9qZWN0b3IuaWQ7XG4gICAgICAgICAgICBDb25maWcuc2F2ZSgncHJvamVjdG9yX2N1cnJlbnRMaXN0T2ZTcGVha2Vyc19yZWZlcmVuY2UnKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQcm9qZWN0b3IgZnVuY3Rpb25zXG4gICAgICAgICRzY29wZS5zZXRQcm9qZWN0aW9uRGVmYXVsdCA9IGZ1bmN0aW9uIChwcm9qZWN0b3IsIHByb2plY3Rpb25kZWZhdWx0KSB7XG4gICAgICAgICAgICBpZiAocHJvamVjdGlvbmRlZmF1bHQucHJvamVjdG9yX2lkICE9PSBwcm9qZWN0b3IuaWQpIHtcbiAgICAgICAgICAgICAgICAkaHR0cC5wb3N0KCcvcmVzdC9jb3JlL3Byb2plY3Rvci8nICsgcHJvamVjdG9yLmlkICsgJy9zZXRfcHJvamVjdGlvbmRlZmF1bHQvJywgcHJvamVjdGlvbmRlZmF1bHQuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuY3JlYXRlUHJvamVjdG9yID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBwcm9qZWN0b3IgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IHt9LFxuICAgICAgICAgICAgICAgIHNjYWxlOiAwLFxuICAgICAgICAgICAgICAgIHNjcm9sbDogMCxcbiAgICAgICAgICAgICAgICBibGFuazogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbmRlZmF1bHRzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQcm9qZWN0b3IuY3JlYXRlKHByb2plY3RvcikudGhlbihmdW5jdGlvbiAocHJvamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgJGh0dHAucG9zdCgnL3Jlc3QvY29yZS9wcm9qZWN0b3IvJyArIHByb2plY3Rvci5pZCArICcvYWN0aXZhdGVfZWxlbWVudHMvJywgW3tcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NvcmUvY2xvY2snLFxuICAgICAgICAgICAgICAgICAgICBzdGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlc29sdXRpb25zW3Byb2plY3Rvci5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9qZWN0b3Iud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcHJvamVjdG9yLmhlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmRlbGV0ZVByb2plY3RvciA9IGZ1bmN0aW9uIChwcm9qZWN0b3IpIHtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0b3IuaWQgIT0gMSkge1xuICAgICAgICAgICAgICAgIFByb2plY3Rvci5kZXN0cm95KHByb2plY3Rvci5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5lZGl0Q3VycmVudFNsaWRlID0gZnVuY3Rpb24gKHByb2plY3Rvcikge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBwcm9qZWN0b3IuZ2V0Rm9ybU9yU3RhdGVGb3JDdXJyZW50U2xpZGUoKTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKGRhdGEuZm9ybS5nZXREaWFsb2coe2lkOiBkYXRhLmlkfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbyhkYXRhLnN0YXRlLCB7aWQ6IGRhdGEuaWR9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5lZGl0TmFtZSA9IGZ1bmN0aW9uIChwcm9qZWN0b3IpIHtcbiAgICAgICAgICAgIHByb2plY3Rvci5jb25maWcgPSBwcm9qZWN0b3IuZWxlbWVudHM7XG4gICAgICAgICAgICBQcm9qZWN0b3Iuc2F2ZShwcm9qZWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuc2F2ZVJlc29sdXRpb24gPSBmdW5jdGlvbiAocHJvamVjdG9yKSB7XG4gICAgICAgICAgICAkaHR0cC5wb3N0KFxuICAgICAgICAgICAgICAgICcvcmVzdC9jb3JlL3Byb2plY3Rvci8nICsgcHJvamVjdG9yLmlkICsgJy9zZXRfcmVzb2x1dGlvbi8nLFxuICAgICAgICAgICAgICAgICRzY29wZS5yZXNvbHV0aW9uc1twcm9qZWN0b3IuaWRdXG4gICAgICAgICAgICApLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUucmVzb2x1dGlvbnNbcHJvamVjdG9yLmlkXS5lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUucmVzb2x1dGlvbnNbcHJvamVjdG9yLmlkXS5lcnJvciA9IGVycm9yLmRhdGEuZGV0YWlsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5yZXNvbHV0aW9uc1twcm9qZWN0b3IuaWRdLmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJZGVudGlmeSBwcm9qZWN0b3JzXG4gICAgICAgICRzY29wZS5pZGVudGlmeVByb2plY3RvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoJHNjb3BlLmlkZW50aWZ5UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCgkc2NvcGUuaWRlbnRpZnlQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUucmVtb3ZlSWRlbnRpZmllck1lc3NhZ2VzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgTWVzc2FnZVxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFByb2plY3Rvck1lc3NhZ2UuY3JlYXRlKG1lc3NhZ2UpLnRoZW4oZnVuY3Rpb24obWVzc2FnZSl7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5wcm9qZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHByb2plY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGh0dHAucG9zdCgnL3Jlc3QvY29yZS9wcm9qZWN0b3IvJyArIHByb2plY3Rvci5pZCArICcvYWN0aXZhdGVfZWxlbWVudHMvJywgW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY29yZS9wcm9qZWN0b3ItbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBtZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZ5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfV0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmlkZW50aWZpZXJNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaWRlbnRpZnlQcm9taXNlID0gJHRpbWVvdXQoJHNjb3BlLnJlbW92ZUlkZW50aWZpZXJNZXNzYWdlcywgMzAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5yZW1vdmVJZGVudGlmaWVyTWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBQcm9qZWN0b3IuZ2V0QWxsKCkuZm9yRWFjaChmdW5jdGlvbiAocHJvamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKHByb2plY3Rvci5lbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQsIHV1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQubmFtZSA9PT0gJ2NvcmUvcHJvamVjdG9yLW1lc3NhZ2UnICYmIGVsZW1lbnQuaWQgPT09ICRzY29wZS5pZGVudGlmaWVyTWVzc2FnZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGh0dHAucG9zdCgnL3Jlc3QvY29yZS9wcm9qZWN0b3IvJyArIHByb2plY3Rvci5pZCArICcvZGVhY3RpdmF0ZV9lbGVtZW50cy8nLCBbdXVpZF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFByb2plY3Rvck1lc3NhZ2UuZGVzdHJveSgkc2NvcGUuaWRlbnRpZmllck1lc3NhZ2UuaWQpO1xuICAgICAgICAgICAgJHNjb3BlLmlkZW50aWZ5UHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLy8gVGFnIENvbnRyb2xsZXJcbi5jb250cm9sbGVyKCdUYWdMaXN0Q3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnVGFnJyxcbiAgICAnbmdEaWFsb2cnLFxuICAgICdUYWdGb3JtJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgJ0Vycm9yTWVzc2FnZScsXG4gICAgZnVuY3Rpb24oJHNjb3BlLCBUYWcsIG5nRGlhbG9nLCBUYWdGb3JtLCBnZXR0ZXh0LCBFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgVGFnLmJpbmRBbGwoe30sICRzY29wZSwgJ3RhZ3MnKTtcbiAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge307XG5cbiAgICAgICAgLy8gc2V0dXAgdGFibGUgc29ydGluZ1xuICAgICAgICAkc2NvcGUuc29ydENvbHVtbiA9ICduYW1lJztcbiAgICAgICAgJHNjb3BlLnJldmVyc2UgPSBmYWxzZTtcbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gc29ydCBieSBjbGlja2VkIGNvbHVtblxuICAgICAgICAkc2NvcGUudG9nZ2xlU29ydCA9IGZ1bmN0aW9uICggY29sdW1uICkge1xuICAgICAgICAgICAgaWYgKCAkc2NvcGUuc29ydENvbHVtbiA9PT0gY29sdW1uICkge1xuICAgICAgICAgICAgICAgICRzY29wZS5yZXZlcnNlID0gISRzY29wZS5yZXZlcnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHNjb3BlLnNvcnRDb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5kZWxldGUgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgICBUYWcuZGVzdHJveSh0YWcuaWQpLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2c6IGdldHRleHQoJ1RoZSBkZWxldGUgd2FzIHN1Y2Nlc3NmdWwuJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5lZGl0T3JDcmVhdGUgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKFRhZ0Zvcm0uZ2V0RGlhbG9nKHRhZykpO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdUYWdDcmVhdGVDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICdUYWcnLFxuICAgICdUYWdGb3JtJyxcbiAgICAnRXJyb3JNZXNzYWdlJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsIFRhZywgVGFnRm9ybSwgRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICRzY29wZS5tb2RlbCA9IHt9O1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcbiAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHMgPSBUYWdGb3JtLmdldEZvcm1GaWVsZHMoKTtcbiAgICAgICAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgICBUYWcuY3JlYXRlKHRhZykudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VUaGlzRGlhbG9nKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdUYWdVcGRhdGVDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICdUYWcnLFxuICAgICd0YWdJZCcsXG4gICAgJ1RhZ0Zvcm0nLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgVGFnLCB0YWdJZCwgVGFnRm9ybSwgRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICRzY29wZS5tb2RlbCA9IGFuZ3VsYXIuY29weShUYWcuZ2V0KHRhZ0lkKSk7XG4gICAgICAgICRzY29wZS5hbGVydCA9IHt9O1xuICAgICAgICAkc2NvcGUuZm9ybUZpZWxkcyA9IFRhZ0Zvcm0uZ2V0Rm9ybUZpZWxkcygpO1xuICAgICAgICAkc2NvcGUuc2F2ZSA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgIFRhZy5pbmplY3QodGFnKTtcbiAgICAgICAgICAgIFRhZy5zYXZlKHRhZykudGhlbihmdW5jdGlvbihzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlVGhpc0RpYWxvZygpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gc2F2ZSBlcnJvcjogcmV2ZXJ0IGFsbCBjaGFuZ2VzIGJ5IHJlc3RvcmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb2JqZWN0XG4gICAgICAgICAgICAgICAgVGFnLnJlZnJlc2godGFnKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ0NvdW50ZG93bkRldGFpbEN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRpbnRlcnZhbCcsXG4gICAgJ0NvdW50ZG93bicsXG4gICAgJ2NvdW50ZG93bklkJyxcbiAgICBmdW5jdGlvbiAoJHNjb3BlLCAkaW50ZXJ2YWwsIENvdW50ZG93biwgY291bnRkb3duSWQpIHtcbiAgICAgICAgdmFyIGludGVydmFsO1xuICAgICAgICB2YXIgY2FsY3VsYXRlQ291bnRkb3duVGltZSA9IGZ1bmN0aW9uIChjb3VudGRvd24pIHtcbiAgICAgICAgICAgIGNvdW50ZG93bi5zZWNvbmRzID0gTWF0aC5mbG9vciggJHNjb3BlLmNvdW50ZG93bi5jb3VudGRvd25fdGltZSAtIERhdGUubm93KCkgLyAxMDAwICsgJHNjb3BlLnNlcnZlck9mZnNldCApO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBDb3VudGRvd24ubGFzdE1vZGlmaWVkKGNvdW50ZG93bklkKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLmNvdW50ZG93biA9IENvdW50ZG93bi5nZXQoY291bnRkb3duSWQpO1xuICAgICAgICAgICAgaWYgKGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgJGludGVydmFsLmNhbmNlbChpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJHNjb3BlLmNvdW50ZG93bikge1xuICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuY291bnRkb3duLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlQ291bnRkb3duVGltZSgkc2NvcGUuY291bnRkb3duKTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSAkaW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyBjYWxjdWxhdGVDb3VudGRvd25UaW1lKCRzY29wZS5jb3VudGRvd24pOyB9LCAxMDAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY291bnRkb3duLnNlY29uZHMgPSAkc2NvcGUuY291bnRkb3duLmNvdW50ZG93bl90aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBDYW5jZWwgdGhlIGludGVydmFsIGlmIHRoZSBjb250cm9sbGVyIGlzIGRlc3Ryb3llZFxuICAgICAgICAgICAgaWYgKGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgJGludGVydmFsLmNhbmNlbChpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi8vIGNvdW50ZXIgb2YgbmV3ICh1bnJlYWQpIGNoYXQgbWVzc2FnZXNcbi52YWx1ZSgnTmV3Q2hhdE1lc3NhZ2VzJywgW10pXG5cbi8vIENoYXRNZXNzYWdlIENvbnRyb2xsZXJcbi5jb250cm9sbGVyKCdDaGF0TWVzc2FnZUN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRodHRwJyxcbiAgICAnJHRpbWVvdXQnLFxuICAgICdDaGF0TWVzc2FnZScsXG4gICAgJ05ld0NoYXRNZXNzYWdlcycsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgJGh0dHAsICR0aW1lb3V0LCBDaGF0TWVzc2FnZSwgTmV3Q2hhdE1lc3NhZ2VzKSB7XG4gICAgICAgIENoYXRNZXNzYWdlLmJpbmRBbGwoe30sICRzY29wZSwgJ2NoYXRtZXNzYWdlcycpO1xuICAgICAgICAkc2NvcGUudW5yZWFkTWVzc2FnZXMgPSBOZXdDaGF0TWVzc2FnZXMubGVuZ3RoO1xuICAgICAgICAkc2NvcGUuY2hhdGJveElzQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgJHNjb3BlLm9wZW5DaGF0Ym94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLmNoYXRib3hJc0NvbGxhcHNlZCA9ICEkc2NvcGUuY2hhdGJveElzQ29sbGFwc2VkO1xuICAgICAgICAgICAgTmV3Q2hhdE1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICAkc2NvcGUudW5yZWFkTWVzc2FnZXMgPSBOZXdDaGF0TWVzc2FnZXMubGVuZ3RoO1xuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudCgnI21lc3NhZ2VJbnB1dCcpLmZvY3VzKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYW5ndWxhci5lbGVtZW50KCcjbWVzc2FnZVNlbmRCdXR0b24nKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudCgnI21lc3NhZ2VJbnB1dCcpLmF0dHIoJ2Rpc2FibGVkJywgJycpO1xuICAgICAgICAgICAgJGh0dHAucG9zdChcbiAgICAgICAgICAgICAgICAnL3Jlc3QvY29yZS9jaGF0LW1lc3NhZ2UvJyxcbiAgICAgICAgICAgICAgICB7bWVzc2FnZTogJHNjb3BlLm5ld01lc3NhZ2V9XG4gICAgICAgICAgICApLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUubmV3TWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudCgnI21lc3NhZ2VTZW5kQnV0dG9uJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5lbGVtZW50KCcjbWVzc2FnZUlucHV0JykucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudCgnI21lc3NhZ2VJbnB1dCcpLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmVsZW1lbnQoJyNtZXNzYWdlU2VuZEJ1dHRvbicpLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudCgnI21lc3NhZ2VJbnB1dCcpLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gaW5jcmVtZW50IHVucmVhZCBtZXNzYWdlcyBjb3VudGVyIGZvciBlYWNoIG5ldyBtZXNzYWdlXG4gICAgICAgICRzY29wZS4kd2F0Y2goJ2NoYXRtZXNzYWdlcycsIGZ1bmN0aW9uIChuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICAgICAgLy8gYWRkIG5ldyBtZXNzYWdlIGlkIGlmIHRoZXJlIGlzIHJlYWxseSBhIG5ldyBtZXNzYWdlIHdoaWNoIGlzIG5vdCB5ZXQgdHJhY2tlZFxuICAgICAgICAgICAgaWYgKG9sZFZhbC5sZW5ndGggPiAwICYmIG5ld1ZhbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKChvbGRWYWxbb2xkVmFsLmxlbmd0aC0xXS5pZCAhPSBuZXdWYWxbbmV3VmFsLmxlbmd0aC0xXS5pZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCQuaW5BcnJheShuZXdWYWxbbmV3VmFsLmxlbmd0aC0xXS5pZCwgTmV3Q2hhdE1lc3NhZ2VzKSA9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgTmV3Q2hhdE1lc3NhZ2VzLnB1c2gobmV3VmFsW25ld1ZhbC5sZW5ndGgtMV0uaWQpO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudW5yZWFkTWVzc2FnZXMgPSBOZXdDaGF0TWVzc2FnZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3VmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIE5ld0NoYXRNZXNzYWdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICRzY29wZS51bnJlYWRNZXNzYWdlcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzY29wZS5jbGVhckNoYXRIaXN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJGh0dHAucG9zdCgnL3Jlc3QvY29yZS9jaGF0LW1lc3NhZ2UvY2xlYXIvJyk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLy8gZm9ybWF0IHRpbWUgc3RyaW5nIGZvciBtb2RlbCAoXCJzXCIpIGFuZCB2aWV3IGZvcm1hdCAoXCJoOm1tOnNzXCIgb3IgXCJtbTpzc1wiKVxuLmRpcmVjdGl2ZSgnbWluU2VjRm9ybWF0JywgW1xuICAgICdIdW1hblRpbWVDb252ZXJ0ZXInLFxuICAgIGZ1bmN0aW9uIChIdW1hblRpbWVDb252ZXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbmdNb2RlbENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBuZ01vZGVsQ29udHJvbGxlci4kcGFyc2Vycy5wdXNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb252ZXJ0IGRhdGEgZnJvbSB2aWV3IGZvcm1hdCAobW06c3MpIHRvIG1vZGVsIGZvcm1hdCAocylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEh1bWFuVGltZUNvbnZlcnRlci5odW1hblRpbWVUb1NlY29uZHMoZGF0YSwge3NlY29uZHM6IHRydWV9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG5nTW9kZWxDb250cm9sbGVyLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnZlcnQgZGF0YSBmcm9tIG1vZGVsIGZvcm1hdCAocykgdG8gdmlldyBmb3JtYXQgKG1tOnNzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSHVtYW5UaW1lQ29udmVydGVyLnNlY29uZHNUb0h1bWFuVGltZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4vLyBmb3JtYXQgdGltZSBzdHJpbmcgZm9yIG1vZGVsIChcIm1cIikgYW5kIHZpZXcgZm9ybWF0IChcImg6bW1cIiBvciBcImhoOm1tXCIpXG4uZGlyZWN0aXZlKCdob3VyTWluRm9ybWF0JywgW1xuICAgICdIdW1hblRpbWVDb252ZXJ0ZXInLFxuICAgIGZ1bmN0aW9uIChIdW1hblRpbWVDb252ZXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbmdNb2RlbENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBuZ01vZGVsQ29udHJvbGxlci4kcGFyc2Vycy5wdXNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb252ZXJ0IGRhdGEgZnJvbSB2aWV3IGZvcm1hdCAoaGg6bW0pIHRvIG1vZGVsIGZvcm1hdCAobSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEh1bWFuVGltZUNvbnZlcnRlci5odW1hblRpbWVUb1NlY29uZHMoZGF0YSwge2hvdXJzOiB0cnVlfSkvNjA7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBuZ01vZGVsQ29udHJvbGxlci4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb252ZXJ0IGRhdGEgZnJvbSBtb2RlbCBmb3JtYXQgKG0pIHRvIHZpZXcgZm9ybWF0IChoaDptbSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEh1bWFuVGltZUNvbnZlcnRlci5zZWNvbmRzVG9IdW1hblRpbWUoZGF0YSo2MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgc2Vjb25kczogJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyczogJ2VuYWJsZWQnIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uZGlyZWN0aXZlKCdvc0ZvY3VzTWUnLCBbXG4gICAgJyR0aW1lb3V0JyxcbiAgICBmdW5jdGlvbiAoJHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZpbHRlcigndG9BcnJheScsIGZ1bmN0aW9uKCl7XG4gICAgLypcbiAgICAgKiBUcmFuc2Zvcm1zIGFuIG9iamVjdCB0byBhbiBhcnJheS4gSXRlbXMgb2YgdGhlIGFycmF5IGFyZSB0aGUgdmFsdWVzIG9mXG4gICAgICogdGhlIG9iamVjdCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KVxuXG4vL01hcmsgYWxsIGNvcmUgY29uZmlnIHN0cmluZ3MgZm9yIHRyYW5zbGF0aW9uIGluIEphdmFzY3JpcHRcbi5jb25maWcoW1xuICAgICdnZXR0ZXh0JyxcbiAgICBmdW5jdGlvbiAoZ2V0dGV4dCkge1xuICAgICAgICBnZXR0ZXh0KCdQcmVzZW50YXRpb24gYW5kIGFzc2VtYmx5IHN5c3RlbScpO1xuICAgICAgICBnZXR0ZXh0KCdFdmVudCBuYW1lJyk7XG4gICAgICAgIGdldHRleHQoJzxhIGhyZWY9XCJodHRwOi8vd3d3Lm9wZW5zbGlkZXMub3JnXCI+T3BlblNsaWRlczwvYT4gaXMgYSBmcmVlICcgK1xuICAgICAgICAgICAgICAgICd3ZWIgYmFzZWQgcHJlc2VudGF0aW9uIGFuZCBhc3NlbWJseSBzeXN0ZW0gZm9yIHZpc3VhbGl6aW5nICcgK1xuICAgICAgICAgICAgICAgICdhbmQgY29udHJvbGxpbmcgYWdlbmRhLCBtb3Rpb25zIGFuZCBlbGVjdGlvbnMgb2YgYW4gJyArXG4gICAgICAgICAgICAgICAgJ2Fzc2VtYmx5LicpO1xuICAgICAgICBnZXR0ZXh0KCdHZW5lcmFsJyk7XG4gICAgICAgIGdldHRleHQoJ0V2ZW50Jyk7XG4gICAgICAgIGdldHRleHQoJ1Nob3J0IGRlc2NyaXB0aW9uIG9mIGV2ZW50Jyk7XG4gICAgICAgIGdldHRleHQoJ0V2ZW50IGRhdGUnKTtcbiAgICAgICAgZ2V0dGV4dCgnRXZlbnQgbG9jYXRpb24nKTtcbiAgICAgICAgZ2V0dGV4dCgnRXZlbnQgb3JnYW5pemVyJyk7XG4gICAgICAgIGdldHRleHQoJ0xlZ2FsIG5vdGljZScpO1xuICAgICAgICBnZXR0ZXh0KCdQcml2YWN5IHBvbGljeScpO1xuICAgICAgICBnZXR0ZXh0KCdGcm9udCBwYWdlIHRpdGxlJyk7XG4gICAgICAgIGdldHRleHQoJ1dlbGNvbWUgdG8gT3BlblNsaWRlcycpO1xuICAgICAgICBnZXR0ZXh0KCdGcm9udCBwYWdlIHRleHQnKTtcbiAgICAgICAgZ2V0dGV4dCgnW1NwYWNlIGZvciB5b3VyIHdlbGNvbWUgdGV4dC5dJyk7XG4gICAgICAgIGdldHRleHQoJ0FsbG93IGFjY2VzcyBmb3IgYW5vbnltb3VzIGd1ZXN0IHVzZXJzJyk7XG4gICAgICAgIGdldHRleHQoJ1Nob3cgdGhpcyB0ZXh0IG9uIHRoZSBsb2dpbiBwYWdlJyk7XG4gICAgICAgIGdldHRleHQoJ1NlcGFyYXRvciB1c2VkIGZvciBhbGwgY3N2IGV4cG9ydHMgYW5kIGV4YW1wbGVzJyk7XG4gICAgICAgIGdldHRleHQoJ1BhZ2UgbnVtYmVyIGFsaWdubWVudCBpbiBQREYnKTtcbiAgICAgICAgZ2V0dGV4dCgnTGVmdCcpO1xuICAgICAgICBnZXR0ZXh0KCdDZW50ZXInKTtcbiAgICAgICAgZ2V0dGV4dCgnUmlnaHQnKTtcbiAgICAgICAgZ2V0dGV4dCgnU3RhbmRhcmQgZm9udCBzaXplIGluIFBERicpO1xuICAgICAgICBnZXR0ZXh0KCdTaG93IGxvZ28gb24gcHJvamVjdG9yJyk7XG4gICAgICAgIGdldHRleHQoJ1lvdSBjYW4gcmVwbGFjZSB0aGUgbG9nbyBieSB1cGxvYWRpbmcgYW4gaW1hZ2UgYW5kIHNldCBpdCBhcyAnICtcbiAgICAgICAgICAgICAgICAndGhlIFwiUHJvamVjdG9yIGxvZ29cIiBpbiBcImZpbGVzXCIuJyk7XG4gICAgICAgIGdldHRleHQoJ1Byb2plY3RvcicpO1xuICAgICAgICBnZXR0ZXh0KCdQcm9qZWN0b3IgbGFuZ3VhZ2UnKTtcbiAgICAgICAgZ2V0dGV4dCgnQ3VycmVudCBicm93c2VyIGxhbmd1YWdlJyk7XG4gICAgICAgIGdldHRleHQoJ1Nob3cgdGl0bGUgYW5kIGRlc2NyaXB0aW9uIG9mIGV2ZW50IG9uIHByb2plY3RvcicpO1xuICAgICAgICBnZXR0ZXh0KCdEaXNwbGF5IGhlYWRlciBhbmQgZm9vdGVyJyk7XG4gICAgICAgIGdldHRleHQoJ1Nob3cgdGhlIGNsb2NrIG9uIHByb2plY3RvcicpO1xuICAgICAgICBnZXR0ZXh0KCdCYWNrZ3JvdW5kIGNvbG9yIG9mIHByb2plY3RvciBoZWFkZXIgYW5kIGZvb3RlcicpO1xuICAgICAgICBnZXR0ZXh0KCdGb250IGNvbG9yIG9mIHByb2plY3RvciBoZWFkZXIgYW5kIGZvb3RlcicpO1xuICAgICAgICBnZXR0ZXh0KCdGb250IGNvbG9yIG9mIHByb2plY3RvciBoZWFkbGluZScpO1xuICAgICAgICBnZXR0ZXh0KCdQcmVkZWZpbmVkIHNlY29uZHMgb2YgbmV3IGNvdW50ZG93bnMnKTtcbiAgICAgICAgZ2V0dGV4dCgnQ29sb3IgZm9yIGJsYW5rZWQgcHJvamVjdG9yJyk7XG4gICAgICAgIGdldHRleHQoJ0xpc3Qgb2Ygc3BlYWtlcnMgb3ZlcmxheScpO1xuICAgICAgICBnZXR0ZXh0KCdQcm9qZWN0b3IgbG9nbycpO1xuICAgICAgICBnZXR0ZXh0KCdQcm9qZWN0b3IgaGVhZGVyIGltYWdlJyk7XG4gICAgICAgIGdldHRleHQoJ1BERiBoZWFkZXIgbG9nbyAobGVmdCknKTtcbiAgICAgICAgZ2V0dGV4dCgnUERGIGhlYWRlciBsb2dvIChyaWdodCknKTtcbiAgICAgICAgZ2V0dGV4dCgnUERGIGZvb3RlciBsb2dvIChsZWZ0KScpO1xuICAgICAgICBnZXR0ZXh0KCdQREYgZm9vdGVyIGxvZ28gKHJpZ2h0KScpO1xuICAgICAgICBnZXR0ZXh0KCdXZWIgaW50ZXJmYWNlIGhlYWRlciBsb2dvJyk7XG4gICAgICAgIGdldHRleHQoJ1BERiBiYWxsb3QgcGFwZXIgbG9nbycpO1xuICAgICAgICBnZXR0ZXh0KCdDdXN0b20gdHJhbnNsYXRpb25zJyk7XG5cbiAgICAgICAgLy8gTWFyayB0aGUgc3RyaW5nICdEZWZhdWx0IHByb2plY3RvcicgaGVyZSwgYmVjYXVzZSBpdCBkb2VzIG5vdCBhcHBlYXIgaW4gdGhlIHRlbXBsYXRlcy5cbiAgICAgICAgZ2V0dGV4dCgnRGVmYXVsdCBwcm9qZWN0b3InKTtcbiAgICB9XG5dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAuY29yZS5zdGFydCcsIFtdKVxuXG4uZmFjdG9yeSgnT3BlblNsaWRlcycsIFtcbiAgICAnJGh0dHAnLFxuICAgICckcm9vdFNjb3BlJyxcbiAgICAnJHN0YXRlJyxcbiAgICAnJHEnLFxuICAgICdEUycsXG4gICAgJ2F1dG91cGRhdGUnLFxuICAgICdvcGVyYXRvcicsXG4gICAgJ0dyb3VwJyxcbiAgICAnbWFpbk1lbnUnLFxuICAgICduZ0RpYWxvZycsXG4gICAgJ0xvZ2luRGlhbG9nJyxcbiAgICBmdW5jdGlvbigkaHR0cCwgJHJvb3RTY29wZSwgJHN0YXRlLCAkcSwgRFMsIGF1dG91cGRhdGUsIG9wZXJhdG9yLCBHcm91cCwgbWFpbk1lbnUsIG5nRGlhbG9nLCBMb2dpbkRpYWxvZykge1xuICAgICAgICB2YXIgT3BlblNsaWRlcyA9IHtcbiAgICAgICAgICAgIGJvb3R1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUub3BlbnNsaWRlc0Jvb3RzdHJhcERvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAkaHR0cC5nZXQoJy91c2Vycy93aG9hbWkvJykudGhlbihmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmd1ZXN0X2VuYWJsZWQgPSBzdWNjZXNzLmRhdGEuZ3Vlc3RfZW5hYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MuZGF0YS51c2VyX2lkID09PSBudWxsICYmICFzdWNjZXNzLmRhdGEuZ3Vlc3RfZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVkaXJlY3QgdG8gbG9naW4gZGlhbG9nIGlmIHVzZXIgaXMgbm90IGxvZ2dlZCBpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnbG9naW4nLCB7Z3Vlc3RfZW5hYmxlZDogc3VjY2Vzcy5kYXRhLmd1ZXN0X2VuYWJsZWR9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG91cGRhdGUubmV3Q29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b3VwZGF0ZS5maXJzdE1lc3NhZ2VEZWZlcnJlZC5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLnNldFVzZXIoc3VjY2Vzcy5kYXRhLnVzZXJfaWQsIHN1Y2Nlc3MuZGF0YS51c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbk1lbnUudXBkYXRlTWFpbk1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLm9wZW5zbGlkZXNCb290c3RyYXBEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2h1dGRvd246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBjb25uZWN0aW9uLCBjbGVhciB0aGUgc3RvcmUgYW5kIHNob3cgdGhlIE9TIG92ZXJsYXkuXG4gICAgICAgICAgICAgICAgYXV0b3VwZGF0ZS5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBEUy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yLnNldFVzZXIobnVsbCk7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5vcGVuc2xpZGVzQm9vdHN0cmFwRG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICAgICAgICAvLyBjbG9zZSBhbGwgb3BlbiBkaWFsb2dzIChleGNlcHQgdGhlIGxvZ2luIGRpYWxvZylcbiAgICAgICAgICAgICAgICBfLmZvckVhY2gobmdEaWFsb2cuZ2V0T3BlbkRpYWxvZ3MoKSwgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gTG9naW5EaWFsb2cuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5nRGlhbG9nLmNsb3NlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2h1dGRvd24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJvb3R1cCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBXZSBuZWVkIHRvICdwaW5nJyB0aGUgc2VydmVyIHdpdGggYSBnZXQgcmVxdWVzdCB0byB3aG9hbWksIGJlY2F1c2UgdGhlbiB3ZSBjYW4gZGVjaWRlLFxuICAgICAgICAvLyBpZiB0aGUgc2VydmVyIGlzIGRvd24gb3IgcmVzcG9uZCB3aXRoIGEgNDAzICh0aGlzIGNhbm5vdCBiZSBkaWZmZXJlbnRpYXRlZCB3aXRoIHdlYnNvY2tldHMpXG4gICAgICAgIGF1dG91cGRhdGUucmVnaXN0ZXJSZXRyeUNvbm5lY3RDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KCcvdXNlcnMvd2hvYW1pJykudGhlbihmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzLmRhdGEudXNlcl9pZCA9PT0gbnVsbCAmJiAhc3VjY2Vzcy5kYXRhLmd1ZXN0X2VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgT3BlblNsaWRlcy5zaHV0ZG93bigpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWRpcmVjdCB0byBsb2dpbiBkaWFsb2cgaWYgdXNlciBpcyBub3QgbG9nZ2VkIGluLlxuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ2xvZ2luJywge2d1ZXN0X2VuYWJsZWQ6IHN1Y2Nlc3MuZGF0YS5ndWVzdF9lbmFibGVkfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b3VwZGF0ZS5uZXdDb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBPcGVuU2xpZGVzO1xuICAgIH1cbl0pXG5cbi5ydW4oW1xuICAgICdPcGVuU2xpZGVzJyxcbiAgICBmdW5jdGlvbiAoT3BlblNsaWRlcykge1xuICAgICAgICBPcGVuU2xpZGVzLmJvb3R1cCgpO1xuICAgIH1cbl0pXG5cbi5ydW4oW1xuICAgICckcm9vdFNjb3BlJyxcbiAgICAnJHN0YXRlJyxcbiAgICAnb3BlcmF0b3InLFxuICAgICdVc2VyJyxcbiAgICAnR3JvdXAnLFxuICAgICdtYWluTWVudScsXG4gICAgZnVuY3Rpb24gKCRyb290U2NvcGUsICRzdGF0ZSwgb3BlcmF0b3IsIFVzZXIsIEdyb3VwLCBtYWluTWVudSkge1xuICAgICAgICB2YXIgcGVybWlzc2lvbkNoYW5nZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3BlcmF0b3IucmVsb2FkUGVybXMoKTtcbiAgICAgICAgICAgIG1haW5NZW51LnVwZGF0ZU1haW5NZW51KCk7XG4gICAgICAgICAgICB2YXIgc3RhdGVEYXRhID0gJHN0YXRlLmN1cnJlbnQuZGF0YTtcbiAgICAgICAgICAgIHZhciBiYXNlUGVybSA9IHN0YXRlRGF0YSA/IHN0YXRlRGF0YS5iYXNlUGVybSA6ICcnO1xuICAgICAgICAgICAgJHJvb3RTY29wZS5iYXNlVmlld1Blcm1pc3Npb25zR3JhbnRlZCA9IGJhc2VQZXJtID9cbiAgICAgICAgICAgICAgICBvcGVyYXRvci5oYXNQZXJtcyhiYXNlUGVybSkgOiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgICRyb290U2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBHcm91cC5sYXN0TW9kaWZpZWQoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKEdyb3VwLmdldEFsbCgpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25DaGFuZ2VDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAkcm9vdFNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IudXNlciA/IFVzZXIubGFzdE1vZGlmaWVkKG9wZXJhdG9yLnVzZXIuaWQpIDogdHJ1ZTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcGVybWlzc2lvbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbl0pO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5tZWRpYWZpbGVzLmZvcm1zJywgW1xuICAgICdnZXR0ZXh0JyxcbiAgICAnbmdGaWxlVXBsb2FkJyxcbiAgICAndWkucm91dGVyJyxcbiAgICAvL1RPRE86IEFkZCBkZXBzIGZvciBvcGVyYXRvciwgVXNlclxuXSlcblxuLy8gU2VydmljZSBmb3IgbWVkaWFmaWxlIGZvcm1cbi5mYWN0b3J5KCdNZWRpYWZpbGVGb3JtJywgW1xuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnVXNlcicsXG4gICAgZnVuY3Rpb24gKGdldHRleHRDYXRhbG9nLCBvcGVyYXRvciwgVXNlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gbmdEaWFsb2cgZm9yIG1lZGlhZmlsZSBmb3JtXG4gICAgICAgICAgICBnZXREaWFsb2c6IGZ1bmN0aW9uIChtZWRpYWZpbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlhbG9nID0ge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICduZ2RpYWxvZy10aGVtZS1kZWZhdWx0IHdpZGUtZm9ybScsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlFc2NhcGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUJ5RG9jdW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICBkaWFsb2cudGVtcGxhdGUgPSAnc3RhdGljL3RlbXBsYXRlcy9tZWRpYWZpbGVzL21lZGlhZmlsZS1mb3JtLmh0bWwnO1xuICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY29udHJvbGxlciA9ICdNZWRpYWZpbGVVcGRhdGVDdHJsJztcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnJlc29sdmUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYWZpbGVJZDogZnVuY3Rpb24gKCkge3JldHVybiBtZWRpYWZpbGUgPyBtZWRpYWZpbGUuaWQgOiB2b2lkIDA7fVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy50ZW1wbGF0ZSA9ICdzdGF0aWMvdGVtcGxhdGVzL21lZGlhZmlsZXMvbWVkaWFmaWxlLXVwbG9hZC1mb3JtLmh0bWwnO1xuICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY29udHJvbGxlciA9ICdNZWRpYWZpbGVVcGxvYWRDdHJsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpYWxvZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRGb3JtRmllbGRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAndGl0bGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1RpdGxlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0hpZGRlbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6ICFvcGVyYXRvci5oYXNQZXJtcygnbWVkaWFmaWxlcy5jYW5fc2VlX2hpZGRlbicpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICd1cGxvYWRlcl9pZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2VsZWN0LXNpbmdsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdVcGxvYWRlZCBieScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IFVzZXIuZ2V0QWxsKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmdPcHRpb25zOiAnb3B0aW9uLmlkIGFzIG9wdGlvbi5mdWxsX25hbWUgZm9yIG9wdGlvbiBpbiB0by5vcHRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTZWxlY3Qgb3Igc2VhcmNoIGEgcGFydGljaXBhbnQgLi4uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlOiAhb3BlcmF0b3IuaGFzUGVybXMoJ21lZGlhZmlsZXMuY2FuX21hbmFnZScpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5tZWRpYWZpbGVzLmltYWdlLXBsdWdpbicsIFtcbiAgICAnT3BlblNsaWRlc0FwcC5tZWRpYWZpbGVzLnJlc291cmNlcycsXG4gICAgJ2dldHRleHQnLFxuICAgICdPcGVuU2xpZGVzQXBwLmNvcmUnLFxuXSlcblxuLmZhY3RvcnkoJ0ltYWdlQnJvd3NlclBsdWdpbicsIFtcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxuICAgICdNZWRpYWZpbGUnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0VkaXRvcicsXG4gICAgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlLCBNZWRpYWZpbGUsIGdldHRleHRDYXRhbG9nLCBFZGl0b3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldFBsdWdpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIENLRURJVE9SLnRvb2xzLmltYWdlYnJvd3NlciA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoaXMgZGlhbG9nLCBpZiBpdCBpcyBvcGVuZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iub24oJ2RpYWxvZ1Nob3cnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlhbG9nID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlhbG9nLmdldE5hbWUoKSA9PT0gJ2ltYWdlYnJvd3Nlci1kaWFsb2cnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENLRURJVE9SLmRpYWxvZy5nZXRDdXJyZW50KCkuZGlzYWJsZUJ1dHRvbignb2snKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2FkIHRoZSBtYWluIHBsdWdpbiB0ZW1wbGF0ZSBhbmQgcGFzdGUgaXQgaW50byB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9ICR0ZW1wbGF0ZUNhY2hlLmdldCgnc3RhdGljL3RlbXBsYXRlcy9tZWRpYWZpbGVzL2ltYWdlLXBsdWdpbi5odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdUZW1wbGF0ZSBmb3IgaW1hZ2UgcGx1Z2luIG5vdCBmb3VuZCEnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyNpbWFnZUJyb3dzZXJDb250YWluZXInKS5odG1sKHRlbXBsYXRlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2FkIGFsbCBpbWFnZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZXMgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKE1lZGlhZmlsZS5nZXRBbGxJbWFnZXMoKSwgZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzICs9ICc8ZGl2IGNsYXNzPVwiaW1hZ2VcIiBvbmNsaWNrPVwiQ0tFRElUT1IudG9vbHMuaW1hZ2Vicm93c2VyLnNlbGVjdEltYWdlKFxcJycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS52YWx1ZSArICdcXCcpO1wiIHN0eWxlPVwiYmFja2dyb3VuZC1pbWFnZTp1cmwoXFwnJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnZhbHVlICsgJ1xcJyk7XCIgZGF0YS1pbWFnZT1cIicgKyBpbWFnZS52YWx1ZSArICdcIj48L2Rpdj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2ltYWdlQnJvd3NlcicpLmh0bWwoaW1hZ2VzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2xhdGUgc29tZSBzdHJpbmdzLiBBbmd1bGFyIHRhZ3MgYXJlIG5vdCBhdmFpbGFibGUgaW4gQ0tFZGl0b3IuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyNzY2FsZUxhYmVsJykuaHRtbChnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1NjYWxlJykpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkaWFsb2cgd2FzIG9wZW5lZCB2aWEgZG91YmxlIGNsaWNrLCBjaGVjayB0aGUgc2VsZWN0ZWQgZWxlbWVudC4gSXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF5IGJlIGFuIGltYWdlLCBzbyBwcmVzZWxlY3QgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEVsZW1lbnQgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0U3RhcnRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnQuaXMoJ2ltZycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgZ2l2ZW4gc2NhbGUgb2YgdGhpcyBpbWFnZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZUF0dHIgPSAkKHNlbGVjdGVkRWxlbWVudCkuYXR0cignc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVJlZ2V4ID0gL3dpZHRoXFxzKjpcXHMqKFxcZCspXFxzKiUvZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZU1hdGNoID0gc2NhbGVSZWdleC5leGVjKHN0eWxlQXR0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlID0gcGFyc2VJbnQoc2NhbGVNYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDS0VESVRPUi50b29scy5pbWFnZWJyb3dzZXIuc2VsZWN0SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50LmdldEF0dHJpYnV0ZSgnc3JjJyksIHNjYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXR1cCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyNpbWFnZS1zY2FsZScpLmJpbmQoJ2tleXVwIG1vdXNldXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IHBhcnNlSW50KCQoJyNpbWFnZS1zY2FsZScpLnZhbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZSAhPT0gQ0tFRElUT1IudG9vbHMuaW1hZ2Vicm93c2VyLnNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0tFRElUT1IudG9vbHMuaW1hZ2Vicm93c2VyLnVwZGF0ZUltYWdlU2l6ZShzY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVhY3Qgb24gZG91YmxlIGNsaWNrcyBpbiB0aGUgdGV4dGFyZWEuIElmIGFuIGltYWdlIHdhcyBzZWxlY3RlZCwgb3BlbiB0aGlzIGRpYWxvZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5vbignZG91YmxlY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LmRhdGEuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQuaXNSZWFkT25seSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmlzKCdpbWcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5kaWFsb2cgPSAnaW1hZ2Vicm93c2VyLWRpYWxvZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0RWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlciBmb3Igc2VsZWN0aW5nIGFuIGltYWdlLiBJdCBtYXkgYmUgY2FsbGVkIGJ5IGNsaWNraW5nIG9uIGEgdGh1bWJuYWlsIG9yIGJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGdpdmluZyB0aGUgdXJsLiBUaGUgc2NhbGUgaXMgb3B0aW9uYWwuXG4gICAgICAgICAgICAgICAgICAgICAgICBDS0VESVRPUi50b29scy5pbWFnZWJyb3dzZXIuc2VsZWN0SW1hZ2UgPSBmdW5jdGlvbiAodXJsLCBzY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBicm93c2VyID0gJCgnI2ltYWdlQnJvd3NlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChicm93c2VyLmNoaWxkcmVuKCksIGZ1bmN0aW9uIChjaGlsZCkgeyAvLyBjaGVjayBldmVyeSBhdmFpbGFibGUgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmdldEF0dHJpYnV0ZSgnZGF0YS1pbWFnZScpID09IHVybCkgeyAvL21hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlID0gJCgnI2ltYWdlUHJldmlldyBpbWcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldHVwIGFuIGxvYWQgZXZlbnQgaGFuZGxlciwgc28gd2UgY2FuIGdldCB0aGUgc2l6ZSBvZiB0aGUgaW1hZ2Ugd2hlbiBsb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5vbignbG9hZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ID0gZXZlbnQudGFyZ2V0Lm5hdHVyYWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IGV2ZW50LnRhcmdldC5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyNvcmlnaW5hbFNpemVUZXh0JykuaHRtbChnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ09yaWdpbmFsIHNpemUnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6ICcgKyB3ICsgJyAmdGltZXM7ICcgKyBoICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2Z1bGxTaXplQ29udGFpbmVyJykud2lkdGgodykuaGVpZ2h0KGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBjdXN0b20gc2NhbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENLRURJVE9SLnRvb2xzLmltYWdlYnJvd3Nlci51cGRhdGVJbWFnZVNpemUoc2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENLRURJVE9SLnRvb2xzLmltYWdlYnJvd3Nlci51cGRhdGVJbWFnZVNpemUoMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgdXJsIG9mIHRoZSBtYWluIHByZXZpZXcgaW1hZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5hdHRyKCdzcmMnLCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2ltYWdlUHJldmlld1NlY3Rpb24nKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDS0VESVRPUi50b29scy5pbWFnZWJyb3dzZXIuc2VsZWN0ZWQgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXcm9uZyBpbWFnZSwgZGVzZWxlY3QgaXQgaW4gdGhlIHByZXZpZXcgd2luZG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZXIgZm9yIHVwZGF0ZWluZyB0aGUgaW1hZ2Ugc2l6ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIENLRURJVE9SLnRvb2xzLmltYWdlYnJvd3Nlci51cGRhdGVJbWFnZVNpemUgPSBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oc2NhbGUpIHx8IHNjYWxlIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0tFRElUT1IuZGlhbG9nLmdldEN1cnJlbnQoKS5kaXNhYmxlQnV0dG9uKCdvaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENLRURJVE9SLmRpYWxvZy5nZXRDdXJyZW50KCkuZW5hYmxlQnV0dG9uKCdvaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDS0VESVRPUi50b29scy5pbWFnZWJyb3dzZXIuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2ltYWdlUHJldmlldyBpbWcnKS53aWR0aChzY2FsZSArICclJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyNpbWFnZS1zY2FsZScpLnZhbChzY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgc2VsZWN0ZWQgaW1hZ2UgaW50byB0aGUgdGV4dGFyZWEuXG4gICAgICAgICAgICAgICAgICAgICAgICBDS0VESVRPUi50b29scy5pbWFnZWJyb3dzZXIuaW5zZXJ0SW1hZ2UgPSBmdW5jdGlvbiAodXJsLCBzY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGl0b3IgPSBDS0VESVRPUi5jdXJyZW50SW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpYWxvZyA9IENLRURJVE9SLmRpYWxvZy5nZXRDdXJyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWwgPSAnPGltZyBzcmM9XCInICsgdXJsICsgJ1wiIGRhdGEtY2tlLXNhdmVkLXNyYz1cIicgKyB1cmwgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCIgYWx0PVwiJyArIHVybCArICdcIiBzdHlsZT1cIndpZHRoOiAnICsgc2NhbGUgKyAnJTtcIiAvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmNvbmZpZy5hbGxvd2VkQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmluc2VydEh0bWwoaHRtbC50cmltKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWxvZy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmFkZENvbW1hbmQoJ2ltYWdlYnJvd3Nlci1vcGVuJywgbmV3IENLRURJVE9SLmRpYWxvZ0NvbW1hbmQoJ2ltYWdlYnJvd3Nlci1kaWFsb2cnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCeSBuYW1pbmcgdGhlIGJ1dHRvbiAnaW1hZ2UnLCBpdCBnZXRzIHRoZSBzYW1lIGltYWdlIGFzIHRoZSBvcmlnaW5hbCBpbWFnZSBidXR0b24uXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IudWkuYWRkQnV0dG9uKCdpbWFnZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdPcGVuIGltYWdlIGJyb3dzZXInKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAnaW1hZ2Vicm93c2VyLW9wZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xiYXI6ICdpbnNlcnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXREaWFsb2c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnSW1hZ2UgYnJvd3NlcicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IDEwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5IZWlnaHQ6IDUwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2ltYWdlYnJvd3Nlci10YWIxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQnJvd3NlIGZvciBpbWFnZXMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3RpdGxlaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnZm9udC1zaXplOiAyMHB4OyBmb250LXdlaWdodDogYm9sZDsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQnJvd3NlIGZvciBpbWFnZXMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ21zZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6ICc8ZGl2IGlkPVwiaW1hZ2VCcm93c2VyQ29udGFpbmVyXCI+PC9kaXY+J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGltYWdlIG9uIE9LLlxuICAgICAgICAgICAgICAgICAgICAgICAgb25PazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IENLRURJVE9SLnRvb2xzLmltYWdlYnJvd3Nlci5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IENLRURJVE9SLnRvb2xzLmltYWdlYnJvd3Nlci5zY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0tFRElUT1IudG9vbHMuaW1hZ2Vicm93c2VyLmluc2VydEltYWdlKHVybCwgc2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLnJ1bihbXG4gICAgJ0VkaXRvcicsXG4gICAgJ0ltYWdlQnJvd3NlclBsdWdpbicsXG4gICAgJ2dldHRleHQnLFxuICAgIGZ1bmN0aW9uIChFZGl0b3IsIEltYWdlQnJvd3NlclBsdWdpbiwgZ2V0dGV4dCkge1xuICAgICAgICBFZGl0b3IucmVnaXN0ZXJEaWFsb2coJ2ltYWdlYnJvd3Nlci1kaWFsb2cnLCBJbWFnZUJyb3dzZXJQbHVnaW4uZ2V0RGlhbG9nKCkpO1xuICAgICAgICBFZGl0b3IucmVnaXN0ZXJQbHVnaW4oJ2ltYWdlYnJvd3NlcicsIEltYWdlQnJvd3NlclBsdWdpbi5nZXRQbHVnaW4oKSk7XG5cbiAgICAgICAgLy8gbWFyayBhbGwgcGx1Z2luIHN0cmluZ3NcbiAgICAgICAgZ2V0dGV4dCgnT3JpZ2luYWwgc2l6ZScpO1xuICAgICAgICBnZXR0ZXh0KCdTY2FsZScpO1xuICAgICAgICBnZXR0ZXh0KCdJbWFnZSBicm93c2VyJyk7XG4gICAgICAgIGdldHRleHQoJ0Jyb3dzZSBmb3IgaW1hZ2VzJyk7XG4gICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmFuZ3VsYXIubW9kdWxlKCdPcGVuU2xpZGVzQXBwLm1lZGlhZmlsZXMubGlzdCcsIFtcbiAgICAnZ2V0dGV4dCcsXG4gICAgJ25nRGlhbG9nJyxcbiAgICAnT3BlblNsaWRlc0FwcC5tZWRpYWZpbGVzLmZvcm1zJyxcbiAgICAnT3BlblNsaWRlc0FwcC5tZWRpYWZpbGVzLnJlc291cmNlcycsXG4gICAgLy9UT0RPOiBBZGQgZGVwcyBmb3Igb3BlcmF0b3IsIFVzZXIsIFByb2plY3RvciwgUHJvamVjdGlvbkRlZmF1bHQsIG9zVGFibGVGaWx0ZXIsIG9zVGFibGVTb3J0LFxuXSlcblxuLmNvbnRyb2xsZXIoJ01lZGlhZmlsZUxpc3RDdHJsJywgW1xuICAgICckaHR0cCcsXG4gICAgJyRzY29wZScsXG4gICAgJ2dldHRleHQnLFxuICAgICduZ0RpYWxvZycsXG4gICAgJ29zVGFibGVGaWx0ZXInLFxuICAgICdvc1RhYmxlU29ydCcsXG4gICAgJ29zVGFibGVQYWdpbmF0aW9uJyxcbiAgICAnUHJvamVjdGlvbkRlZmF1bHQnLFxuICAgICdQcm9qZWN0b3InLFxuICAgICdVc2VyJyxcbiAgICAnTWVkaWFmaWxlJyxcbiAgICAnTWVkaWFmaWxlRm9ybScsXG4gICAgJ0xvZ29zJyxcbiAgICAnRm9udHMnLFxuICAgIGZ1bmN0aW9uICgkaHR0cCwgJHNjb3BlLCBnZXR0ZXh0LCBuZ0RpYWxvZywgb3NUYWJsZUZpbHRlciwgb3NUYWJsZVNvcnQsIG9zVGFibGVQYWdpbmF0aW9uLFxuICAgICAgICAgICAgICBQcm9qZWN0aW9uRGVmYXVsdCwgUHJvamVjdG9yLCBVc2VyLCBNZWRpYWZpbGUsIE1lZGlhZmlsZUZvcm0sIExvZ29zLCBGb250cykge1xuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNZWRpYWZpbGUubGFzdE1vZGlmaWVkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5tZWRpYWZpbGVzID0gXy5vcmRlckJ5KE1lZGlhZmlsZS5nZXRBbGwoKSwgWyd0aXRsZSddKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFVzZXIuYmluZEFsbCh7fSwgJHNjb3BlLCAndXNlcnMnKTtcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9qZWN0b3IubGFzdE1vZGlmaWVkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLnByb2plY3RvcnMgPSBQcm9qZWN0b3IuZ2V0QWxsKCk7XG4gICAgICAgICAgICB1cGRhdGVQcmVzZW50ZWRNZWRpYWZpbGVzKCk7XG4gICAgICAgICAgICB2YXIgcHJvamVjdGlvbmRlZmF1bHQgPSBQcm9qZWN0aW9uRGVmYXVsdC5maWx0ZXIoe25hbWU6ICdtZWRpYWZpbGVzJ30pWzBdO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rpb25kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlZmF1bHRQcm9qZWN0b3JJZCA9IHByb2plY3Rpb25kZWZhdWx0LnByb2plY3Rvcl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlUHJlc2VudGVkTWVkaWFmaWxlcyAoKSB7XG4gICAgICAgICAgICAkc2NvcGUucHJlc2VudGVkTWVkaWFmaWxlcyA9IFtdO1xuICAgICAgICAgICAgUHJvamVjdG9yLmdldEFsbCgpLmZvckVhY2goZnVuY3Rpb24gKHByb2plY3Rvcikge1xuICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0b3JFbGVtZW50cyA9IF8ubWFwKHByb2plY3Rvci5lbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudDsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG1lZGlhRWxlbWVudHMgPSBfLmZpbHRlcihwcm9qZWN0b3JFbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQubmFtZSA9PT0gJ21lZGlhZmlsZXMvbWVkaWFmaWxlJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtZWRpYUVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnByZXNlbnRlZE1lZGlhZmlsZXMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCRzY29wZS5wcmVzZW50ZWRNZWRpYWZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5pc01ldGEgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmlzTWV0YSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVQcmVzZW50ZWRNZWRpYWZpbGVzKCk7XG5cbiAgICAgICAgLy8gRmlsdGVyaW5nXG4gICAgICAgICRzY29wZS5maWx0ZXIgPSBvc1RhYmxlRmlsdGVyLmNyZWF0ZUluc3RhbmNlKCdNZWRpYWZpbGVzVGFibGVGaWx0ZXInKTtcblxuICAgICAgICBpZiAoISRzY29wZS5maWx0ZXIuZXhpc3RzU3RvcmFnZUVudHJ5KCkpIHtcbiAgICAgICAgICAgICRzY29wZS5maWx0ZXIuYm9vbGVhbkZpbHRlcnMgPSB7XG4gICAgICAgICAgICAgICAgaXNIaWRkZW46IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IGdldHRleHQoJ0hpZGRlbicpLFxuICAgICAgICAgICAgICAgICAgICBjaG9pY2VZZXM6IGdldHRleHQoJ0lzIGhpZGRlbicpLFxuICAgICAgICAgICAgICAgICAgICBjaG9pY2VObzogZ2V0dGV4dCgnSXMgbm90IGhpZGRlbicpLFxuICAgICAgICAgICAgICAgICAgICBuZWVkRXh0cmFQZXJtaXNzaW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNQZGY6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IGdldHRleHQoJ0lzIFBERicpLFxuICAgICAgICAgICAgICAgICAgICBjaG9pY2VZZXM6IGdldHRleHQoJ0lzIFBERiBmaWxlJyksXG4gICAgICAgICAgICAgICAgICAgIGNob2ljZU5vOiBnZXR0ZXh0KCdJcyBubyBQREYgZmlsZScpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgICRzY29wZS5maWx0ZXIucHJvcGVydHlMaXN0ID0gWyd0aXRsZV9vcl9maWxlbmFtZSddO1xuICAgICAgICAkc2NvcGUuZmlsdGVyLnByb3BlcnR5RnVuY3Rpb25MaXN0ID0gW1xuICAgICAgICAgICAgZnVuY3Rpb24gKG1lZGlhZmlsZSkge3JldHVybiBtZWRpYWZpbGUudXBsb2FkZXIuZ2V0X3Nob3J0X25hbWUoKTt9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKG1lZGlhZmlsZSkge3JldHVybiBtZWRpYWZpbGUubWVkaWFmaWxlLnR5cGU7fSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChtZWRpYWZpbGUpIHtyZXR1cm4gbWVkaWFmaWxlLm1lZGlhZmlsZS5uYW1lO30sXG4gICAgICAgIF07XG4gICAgICAgIC8vIFNvcnRpbmdcbiAgICAgICAgJHNjb3BlLnNvcnQgPSBvc1RhYmxlU29ydC5jcmVhdGVJbnN0YW5jZSgnTWVkaWFmaWxlVGFibGVTb3J0Jyk7XG4gICAgICAgIGlmICghJHNjb3BlLnNvcnQuY29sdW1uKSB7XG4gICAgICAgICAgICAkc2NvcGUuc29ydC5jb2x1bW4gPSAndGl0bGVfb3JfZmlsZW5hbWUnO1xuICAgICAgICB9XG4gICAgICAgICRzY29wZS5zb3J0T3B0aW9ucyA9IFtcbiAgICAgICAgICAgIHtuYW1lOiAndGl0bGVfb3JfZmlsZW5hbWUnLFxuICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogZ2V0dGV4dCgnVGl0bGUnKX0sXG4gICAgICAgICAgICB7bmFtZTogJ21lZGlhZmlsZS50eXBlJyxcbiAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGdldHRleHQoJ1R5cGUnKX0sXG4gICAgICAgICAgICB7bmFtZTogJ2ZpbGVzaXplJyxcbiAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGdldHRleHQoJ0ZpbGUgc2l6ZScpfSxcbiAgICAgICAgICAgIHtuYW1lOiAndGltZXN0YW1wJyxcbiAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGdldHRleHQoJ1VwbG9hZCB0aW1lJyl9LFxuICAgICAgICAgICAge25hbWU6ICd1cGxvYWRlci5nZXRfc2hvcnRfbmFtZSgpJyxcbiAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGdldHRleHQoJ1VwbG9hZGVkIGJ5Jyl9LFxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIHBhZ2luYXRpb25cbiAgICAgICAgJHNjb3BlLnBhZ2luYXRpb24gPSBvc1RhYmxlUGFnaW5hdGlvbi5jcmVhdGVJbnN0YW5jZSgnTWVkaWFmaWxlVGFibGVQYWdpbmF0aW9uJyk7XG5cbiAgICAgICAgLy8gb3BlbiBuZXcvZWRpdCBkaWFsb2dcbiAgICAgICAgJHNjb3BlLm9wZW5EaWFsb2cgPSBmdW5jdGlvbiAobWVkaWFmaWxlKSB7XG4gICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKE1lZGlhZmlsZUZvcm0uZ2V0RGlhbG9nKG1lZGlhZmlsZSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vICoqKiBzZWxlY3QgbW9kZSBmdW5jdGlvbnMgKioqXG4gICAgICAgICRzY29wZS5pc1NlbGVjdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgLy8gY2hlY2sgYWxsIGNoZWNrYm94ZXNcbiAgICAgICAgJHNjb3BlLmNoZWNrQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLnNlbGVjdGVkQWxsID0gISRzY29wZS5zZWxlY3RlZEFsbDtcbiAgICAgICAgICAgIF8uZm9yRWFjaCgkc2NvcGUubWVkaWFmaWxlcywgZnVuY3Rpb24gKG1lZGlhZmlsZSkge1xuICAgICAgICAgICAgICAgIG1lZGlhZmlsZS5zZWxlY3RlZCA9ICRzY29wZS5zZWxlY3RlZEFsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyB1bmNoZWNrIGFsbCBjaGVja2JveGVzIGlmIFNlbGVjdE1vZGUgaXMgY2xvc2VkXG4gICAgICAgICRzY29wZS51bmNoZWNrQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuaXNTZWxlY3RNb2RlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdGVkQWxsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKCRzY29wZS5tZWRpYWZpbGVzLCBmdW5jdGlvbiAobWVkaWFmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lZGlhZmlsZS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBkZWxldGUgYWxsIHNlbGVjdGVkIG1lZGlhZmlsZXNcbiAgICAgICAgJHNjb3BlLmRlbGV0ZU11bHRpcGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5tZWRpYWZpbGVzLCBmdW5jdGlvbiAobWVkaWFmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhZmlsZS5zZWxlY3RlZClcbiAgICAgICAgICAgICAgICAgICAgTWVkaWFmaWxlLmRlc3Ryb3kobWVkaWFmaWxlLmlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHNjb3BlLmlzU2VsZWN0TW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgJHNjb3BlLnVuY2hlY2tBbGwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZGVsZXRlIHNpbmdsZSBtZWRpYWZpbGVcbiAgICAgICAgJHNjb3BlLmRlbGV0ZSA9IGZ1bmN0aW9uIChtZWRpYWZpbGUpIHtcbiAgICAgICAgICAgIE1lZGlhZmlsZS5kZXN0cm95KG1lZGlhZmlsZS5pZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gKiogUERGIHByZXNlbnRhdGlvbiBmdW5jdGlvbnMgKiovXG4gICAgICAgIC8vIHNob3cgZG9jdW1lbnQgb24gcHJvamVjdG9yXG4gICAgICAgICRzY29wZS5zaG93TWVkaWFmaWxlID0gZnVuY3Rpb24gKHByb2plY3RvcklkLCBtZWRpYWZpbGUpIHtcbiAgICAgICAgICAgIHZhciBpc1Byb2plY3RlZElkcyA9IG1lZGlhZmlsZS5pc1Byb2plY3RlZCgpO1xuICAgICAgICAgICAgXy5mb3JFYWNoKGlzUHJvamVjdGVkSWRzLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICAkaHR0cC5wb3N0KCcvcmVzdC9jb3JlL3Byb2plY3Rvci8nICsgaWQgKyAnL2NsZWFyX2VsZW1lbnRzLycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoXy5pbmRleE9mKGlzUHJvamVjdGVkSWRzLCBwcm9qZWN0b3JJZCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zdFVybCA9ICcvcmVzdC9jb3JlL3Byb2plY3Rvci8nICsgcHJvamVjdG9ySWQgKyAnL3BydW5lX2VsZW1lbnRzLyc7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21lZGlhZmlsZXMvbWVkaWFmaWxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBtZWRpYWZpbGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1QYWdlczogbWVkaWFmaWxlLm1lZGlhZmlsZS5wYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2U6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogJ3BhZ2UtZml0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxzY3JlZW46IG1lZGlhZmlsZS5pc19wZGYgfHwgbWVkaWFmaWxlLmlzX2ltYWdlXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgJGh0dHAucG9zdChwb3N0VXJsLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2VuZE1lZGlhZmlsZUNvbW1hbmQgPSBmdW5jdGlvbiAobWVkaWFmaWxlLCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlRGF0YSA9IF8uZXh0ZW5kKHt9LCBtZWRpYWZpbGUpO1xuICAgICAgICAgICAgXy5leHRlbmQodXBkYXRlRGF0YSwgZGF0YSk7XG4gICAgICAgICAgICB2YXIgcG9zdERhdGEgPSB7fTtcbiAgICAgICAgICAgIHBvc3REYXRhW21lZGlhZmlsZS51dWlkXSA9IHVwZGF0ZURhdGE7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgUHJvamVjdG9yIHdoZXJlIHRoZSBtZWRpYWZpbGUgaXMgcHJvamVjdGVkXG4gICAgICAgICAgICAkc2NvcGUucHJvamVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5maW5kKHByb2plY3Rvci5lbGVtZW50cywgZnVuY3Rpb24gKGUpIHtyZXR1cm4gZS51dWlkID09IG1lZGlhZmlsZS51dWlkO30pKSB7XG4gICAgICAgICAgICAgICAgICAgICRodHRwLnBvc3QoJy9yZXN0L2NvcmUvcHJvamVjdG9yLycgKyBwcm9qZWN0b3IuaWQgKyAnL3VwZGF0ZV9lbGVtZW50cy8nLCBwb3N0RGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLmdldFRpdGxlID0gZnVuY3Rpb24gKG1lZGlhZmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1lZGlhZmlsZS5nZXQobWVkaWFmaWxlLmlkKS50aXRsZTtcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIChwcmVzZW50ZWRNZWRpYWZpbGUpIHtcbiAgICAgICAgICAgIHZhciBtZWRpYWZpbGUgPSBNZWRpYWZpbGUuZ2V0KHByZXNlbnRlZE1lZGlhZmlsZS5pZCk7XG4gICAgICAgICAgICByZXR1cm4gbWVkaWFmaWxlLmlzX3BkZiA/ICdwZGYnIDogbWVkaWFmaWxlLmlzX2ltYWdlID8gJ2ltYWdlJyA6ICd2aWRlbyc7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLm1lZGlhZmlsZUdvVG9QYWdlID0gZnVuY3Rpb24gKG1lZGlhZmlsZSwgcGFnZSkge1xuICAgICAgICAgICAgcGFnZSA9IHBhcnNlSW50KHBhZ2UpO1xuICAgICAgICAgICAgaWYgKHBhZ2UgPiAwICYmIHBhZ2UgPD0gbWVkaWFmaWxlLm51bVBhZ2VzKSB7XG4gICAgICAgICAgICAgICAgc2VuZE1lZGlhZmlsZUNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhZmlsZSxcbiAgICAgICAgICAgICAgICAgICAge3BhZ2U6IHBhZ2V9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLm1lZGlhZmlsZVpvb21JbiA9IGZ1bmN0aW9uIChtZWRpYWZpbGUpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDE7XG4gICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtZWRpYWZpbGUuc2NhbGUpKSB7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSBtZWRpYWZpbGUuc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZW5kTWVkaWFmaWxlQ29tbWFuZChcbiAgICAgICAgICAgICAgICBtZWRpYWZpbGUsXG4gICAgICAgICAgICAgICAge3NjYWxlOiBzY2FsZSArIDAuMn1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5tZWRpYWZpbGVGaXQgPSBmdW5jdGlvbiAobWVkaWFmaWxlKSB7XG4gICAgICAgICAgICBzZW5kTWVkaWFmaWxlQ29tbWFuZChcbiAgICAgICAgICAgICAgICBtZWRpYWZpbGUsXG4gICAgICAgICAgICAgICAge3NjYWxlOiAncGFnZS1maXQnfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLm1lZGlhZmlsZVpvb21PdXQgPSBmdW5jdGlvbiAobWVkaWFmaWxlKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSAxO1xuICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobWVkaWFmaWxlLnNjYWxlKSkge1xuICAgICAgICAgICAgICAgIHNjYWxlID0gbWVkaWFmaWxlLnNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VuZE1lZGlhZmlsZUNvbW1hbmQoXG4gICAgICAgICAgICAgICAgbWVkaWFmaWxlLFxuICAgICAgICAgICAgICAgIHtzY2FsZTogc2NhbGUgLSAwLjJ9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUubWVkaWFmaWxlQ2hhbmdlUGFnZSA9IGZ1bmN0aW9uIChtZWRpYWZpbGUsIHBhZ2VOdW0pIHtcbiAgICAgICAgICAgIHNlbmRNZWRpYWZpbGVDb21tYW5kKFxuICAgICAgICAgICAgICAgIG1lZGlhZmlsZSxcbiAgICAgICAgICAgICAgICB7cGFnZVRvRGlzcGxheTogcGFnZU51bX1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5tZWRpYWZpbGVSb3RhdGUgPSBmdW5jdGlvbiAobWVkaWFmaWxlKSB7XG4gICAgICAgICAgICB2YXIgcm90YXRpb24gPSBtZWRpYWZpbGUucm90YXRlO1xuICAgICAgICAgICAgaWYgKHJvdGF0aW9uID09PSAyNzApIHtcbiAgICAgICAgICAgICAgICByb3RhdGlvbiA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gcm90YXRpb24gKyA5MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbmRNZWRpYWZpbGVDb21tYW5kKFxuICAgICAgICAgICAgICAgIG1lZGlhZmlsZSxcbiAgICAgICAgICAgICAgICB7cm90YXRlOiByb3RhdGlvbn1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5tZWRpYWZpbGVUb2dnbGVGdWxsc2NyZWVuID0gZnVuY3Rpb24gKG1lZGlhZmlsZSkge1xuICAgICAgICAgICAgc2VuZE1lZGlhZmlsZUNvbW1hbmQoXG4gICAgICAgICAgICAgICAgbWVkaWFmaWxlLFxuICAgICAgICAgICAgICAgIHtmdWxsc2NyZWVuOiAhbWVkaWFmaWxlLmZ1bGxzY3JlZW59XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUubWVkaWFmaWxlVG9nZ2xlUGxheWluZyA9IGZ1bmN0aW9uIChtZWRpYWZpbGUpIHtcbiAgICAgICAgICAgIHNlbmRNZWRpYWZpbGVDb21tYW5kKFxuICAgICAgICAgICAgICAgIG1lZGlhZmlsZSxcbiAgICAgICAgICAgICAgICB7cGxheWluZzogIW1lZGlhZmlsZS5wbGF5aW5nfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKiogTG9nb3MgYW5kIGZvbnRzICoqL1xuICAgICAgICAkc2NvcGUubG9nb3MgPSBMb2dvcy5nZXRBbGwoKTtcbiAgICAgICAgJHNjb3BlLmZvbnRzID0gRm9udHMuZ2V0QWxsKCk7XG4gICAgICAgICRzY29wZS5oYXNQcm9qZWN0b3JIZWFkZXJMb2dvID0gZnVuY3Rpb24gKG1lZGlhZmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIF8uc29tZShtZWRpYWZpbGUuZ2V0TG9nb3MoKSwgZnVuY3Rpb24gKGxvZ28pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nby5rZXkgPT09ICdsb2dvX3Byb2plY3Rvcl9oZWFkZXInO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLypcbiAqIFNwZWNpYWwgZmlsdGVyIG9ubHkgZm9yIG1lZGlhZmlsZSBsaXN0IHZpZXcuXG4gKi9cbi5maWx0ZXIoJ2hpZGRlbkZpbHRlcicsIFtcbiAgICAnJGZpbHRlcicsXG4gICAgJ29wZXJhdG9yJyxcbiAgICBmdW5jdGlvbiAoJGZpbHRlciwgb3BlcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKG9wZXJhdG9yLmhhc1Blcm1zKCdtZWRpYWZpbGVzLmNhbl9zZWVfaGlkZGVuJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGFycmF5LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXRlbS5oaWRkZW47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAubWVkaWFmaWxlcy5wcm9qZWN0b3InLCBbXG4gICAgJ09wZW5TbGlkZXNBcHAubWVkaWFmaWxlcy5yZXNvdXJjZXMnLFxuICAgIC8vVE9ETzogQWRkIGRlcHMgZm9yIHNsaWRlc1Byb3ZpZGVyXG5dKVxuXG4uY29uZmlnKFtcbiAgICAnc2xpZGVzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uIChzbGlkZXNQcm92aWRlcikge1xuICAgICAgICBzbGlkZXNQcm92aWRlci5yZWdpc3RlclNsaWRlKCdtZWRpYWZpbGVzL21lZGlhZmlsZScsIHtcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnc3RhdGljL3RlbXBsYXRlcy9tZWRpYWZpbGVzL3NsaWRlX21lZGlhZmlsZS5odG1sJ1xuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignU2xpZGVNZWRpYWZpbGVDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckdGltZW91dCcsXG4gICAgJ01lZGlhZmlsZScsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgJHRpbWVvdXQsIE1lZGlhZmlsZSkge1xuICAgICAgICAvLyBsb2FkIG1lZGlhZmlsZSBvYmplY3RcbiAgICAgICAgTWVkaWFmaWxlLmJpbmRPbmUoJHNjb3BlLmVsZW1lbnQuaWQsICRzY29wZSwgJ21lZGlhZmlsZScpO1xuXG4gICAgICAgICRzY29wZS5zaG93UGRmID0gdHJ1ZTtcblxuICAgICAgICAvLyBXYXRjaCBmb3IgcGFnZSBjaGFuZ2VzIGluIHRoZSBwcm9qZWN0b3IgZWxlbWVudC4gQWRqdXN0IHRoZSBwYWdlXG4gICAgICAgIC8vIGluIHRoZSBjYW52YXMgc2NvcGUsIHNvIHRoZSB2aWV3ZXIgY2FuIGNoYW5nZSB0aGUgc2l6ZSBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAkc2NvcGUuZWxlbWVudC5wYWdlO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzU2NvcGUgPSBhbmd1bGFyLmVsZW1lbnQoJyNwZGYtY2FudmFzJykuc2NvcGUoKTtcbiAgICAgICAgICAgIGlmIChjYW52YXNTY29wZSkge1xuICAgICAgICAgICAgICAgIGNhbnZhc1Njb3BlLnBhZ2VOdW0gPSAkc2NvcGUuZWxlbWVudC5wYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBXYXRjaCBmb3Igc2NhbGUgY2hhbmdlcy4gSWYgdGhlIHNjYWxlIGlzIGNoYW5nZWQsIHJlbG9hZCB0aGUgcGRmXG4gICAgICAgIC8vIHZpZXdlciBieSBqdXN0IGRpc2FibGUgYW5kIHJlLWVuYWJsZSBpdC5cbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJHNjb3BlLmVsZW1lbnQuc2NhbGU7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5zaG93UGRmID0gZmFsc2U7XG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNob3dQZGYgPSB0cnVlO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFsbG93IHRoZSBlbGVtZW50cyB0byByZW5kZXIgcHJvcGVybHlcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICgkc2NvcGUubWVkaWFmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCRzY29wZS5tZWRpYWZpbGUuaXNfcGRmKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5wZGZOYW1lID0gJHNjb3BlLm1lZGlhZmlsZS50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnBkZlVybCA9ICRzY29wZS5tZWRpYWZpbGUubWVkaWFmaWxlVXJsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHNjb3BlLm1lZGlhZmlsZS5pc192aWRlbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGxheWVyID0gYW5ndWxhci5lbGVtZW50LmZpbmQoJyN2aWRlby1wbGF5ZXInKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5lbGVtZW50LnBsYXlpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllci5wbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXIucGF1c2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmFuZ3VsYXIubW9kdWxlKCdPcGVuU2xpZGVzQXBwLm1lZGlhZmlsZXMucmVzb3VyY2VzJywgW1xuICAgICdnZXR0ZXh0JyxcbiAgICAnanMtZGF0YScsXG4gICAgLy9UT0RPOiBBZGQgZGVwcyBmb3IganNEYXRhTW9kZWxcbl0pXG5cbi5mYWN0b3J5KCdNZWRpYWZpbGUnLCBbXG4gICAgJ0RTJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgJ2pzRGF0YU1vZGVsJyxcbiAgICAnTG9nb3MnLFxuICAgICdGb250cycsXG4gICAgZnVuY3Rpb24gKERTLCBnZXR0ZXh0LCBqc0RhdGFNb2RlbCwgTG9nb3MsIEZvbnRzKSB7XG4gICAgICAgIHZhciBuYW1lID0gJ21lZGlhZmlsZXMvbWVkaWFmaWxlJztcbiAgICAgICAgcmV0dXJuIERTLmRlZmluZVJlc291cmNlKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB1c2VDbGFzczoganNEYXRhTW9kZWwsXG4gICAgICAgICAgICB2ZXJib3NlTmFtZTogZ2V0dGV4dCgnRmlsZXMnKSxcbiAgICAgICAgICAgIHZlcmJvc2VOYW1lUGx1cmFsOiBnZXR0ZXh0KCdGaWxlcycpLFxuICAgICAgICAgICAgZ2V0QWxsSW1hZ2VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh0aGlzLmdldEFsbCgpLCBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLmlzX2ltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZXMucHVzaCh7dGl0bGU6IGZpbGUudGl0bGUsIHZhbHVlOiBmaWxlLm1lZGlhZmlsZVVybH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltYWdlcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXRob2RzOiB7XG4gICAgICAgICAgICAgICAgZ2V0UmVzb3VyY2VOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gbGluayBuYW1lIHdoaWNoIGlzIHNob3duIGluIHNlYXJjaCByZXN1bHRcbiAgICAgICAgICAgICAgICBnZXRTZWFyY2hSZXN1bHROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRydWUgaWYgYSBzcGVjaWZpYyByZWxhdGlvbiBtYXRjaGVzIGZvciBnaXZlbiBzZWFyY2hxdWVyeVxuICAgICAgICAgICAgICAgIC8vIChoZXJlOiBzcGVha2VycylcbiAgICAgICAgICAgICAgICBoYXNTZWFyY2hSZXN1bHQ6IGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZWRpYWZpbGUgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWFyY2ggZm9yIHNwZWFrZXJzIChjaGVjayBpZiBhbnkgdXNlci5pZCBmcm9tIGFscmVhZHkgZm91bmQgdXNlcnMgbWF0Y2hlcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uc29tZShyZXN1bHRzLCBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0LmdldFJlc291cmNlTmFtZSgpID09PSBcInVzZXJzL3VzZXJcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1lZGlhZmlsZS51cGxvYWRlcl9pZCA9PT0gcmVzdWx0LmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzVXNlZEFzTG9nbzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVkaWFmaWxlID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZmluZChMb2dvcy5nZXRBbGwoKSwgZnVuY3Rpb24gKGxvZ29QbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ29QbGFjZWhvbGRlci5wYXRoID09PSBtZWRpYWZpbGUubWVkaWFmaWxlVXJsO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbkJlVXNlZEFzTG9nbzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc19pbWFnZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldExvZ29zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZWRpYWZpbGUgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5maWx0ZXIoTG9nb3MuZ2V0QWxsKCksIGZ1bmN0aW9uIChsb2dvUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dvUGxhY2Vob2xkZXIucGF0aCA9PT0gbWVkaWFmaWxlLm1lZGlhZmlsZVVybDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYXNMb2dvOiBmdW5jdGlvbiAobG9nbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxsVXJscyA9IF8ubWFwKHRoaXMuZ2V0TG9nb3MoKSwgZnVuY3Rpb24gKGxvZ28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ28ucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmluY2x1ZGVzKGFsbFVybHMsIGxvZ28ucGF0aCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0b2dnbGVMb2dvOiBmdW5jdGlvbiAobG9nbykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNMb2dvKGxvZ28pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dvcy5zZXQobG9nby5rZXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nb3Muc2V0KGxvZ28ua2V5LCB0aGlzLm1lZGlhZmlsZVVybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzVXNlZEFzRm9udDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVkaWFmaWxlID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZmluZChGb250cy5nZXRBbGwoKSwgZnVuY3Rpb24gKGZvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb250LnBhdGggPT09IG1lZGlhZmlsZS5tZWRpYWZpbGVVcmw7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FuQmVVc2VkQXNGb250OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzX2ZvbnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRGb250czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVkaWFmaWxlID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZmlsdGVyKEZvbnRzLmdldEFsbCgpLCBmdW5jdGlvbiAoZm9udCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvbnQucGF0aCA9PT0gbWVkaWFmaWxlLm1lZGlhZmlsZVVybDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYXNGb250OiBmdW5jdGlvbiAoZm9udCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxsVXJscyA9IF8ubWFwKHRoaXMuZ2V0Rm9udHMoKSwgZnVuY3Rpb24gKGZvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvbnQucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmluY2x1ZGVzKGFsbFVybHMsIGZvbnQucGF0aCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0b2dnbGVGb250OiBmdW5jdGlvbiAoZm9udCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNGb250KGZvbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBGb250cy5zZXQoZm9udC5rZXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgRm9udHMuc2V0KGZvbnQua2V5LCB0aGlzLm1lZGlhZmlsZVVybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgICAgICAgICAgaXNfcGRmOiBbJ2ZpbGV0eXBlJywgZnVuY3Rpb24gKGZpbGV0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBQREZfRklMRV9UWVBFUyA9IFsnYXBwbGljYXRpb24vcGRmJ107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmluY2x1ZGVzKFBERl9GSUxFX1RZUEVTLCBmaWxldHlwZSk7XG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgaXNfaW1hZ2U6IFsnZmlsZXR5cGUnLCBmdW5jdGlvbiAoZmlsZXR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIElNQUdFX0ZJTEVfVFlQRVMgPSBbJ2ltYWdlL3BuZycsICdpbWFnZS9qcGVnJywgJ2ltYWdlL2dpZiddO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5pbmNsdWRlcyhJTUFHRV9GSUxFX1RZUEVTLCBmaWxldHlwZSk7XG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgaXNfdmlkZW86IFsnZmlsZXR5cGUnLCBmdW5jdGlvbiAoZmlsZXR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFZJREVPX0ZJTEVfVFlQRVMgPSBbICd2aWRlby9xdWlja3RpbWUnLCAndmlkZW8vbXA0JywgJ3ZpZGVvL3dlYm0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ZpZGVvL29nZycsICd2aWRlby94LWZsdicsICdhcHBsaWNhdGlvbi94LW1wZWdVUkwnLCAndmlkZW8vTVAyVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndmlkZW8vM2dwcCcsICd2aWRlby94LW1zdmlkZW8nLCAndmlkZW8veC1tcy13bXYnLCAndmlkZW8veC1tYXRyb3NrYScgXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uaW5jbHVkZXMoVklERU9fRklMRV9UWVBFUywgZmlsZXR5cGUpO1xuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIGlzX3ByZXNlbnRhYmxlOiBbJ2lzX3BkZicsICdpc19pbWFnZScsICdpc192aWRlbycsIGZ1bmN0aW9uIChpc19wZGYsIGlzX2ltYWdlLCBpc192aWRlbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGlzX3BkZiAmJiAhdGhpcy5tZWRpYWZpbGUuZW5jcnlwdGVkKSB8fCBpc19pbWFnZSB8fCBpc192aWRlbztcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBpc19mb250OiBbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgRk9OVF9GSUxFX0VYVEVOU0lPTlMgPSBbJ3R0ZicsICd3b2ZmJ107XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHQgPSBfLmxhc3QodGhpcy5tZWRpYWZpbGUubmFtZS5zcGxpdCgnLicpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uaW5jbHVkZXMoRk9OVF9GSUxFX0VYVEVOU0lPTlMsIGV4dCk7XG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgbWVkaWFmaWxlVXJsOiBbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZWRpYV91cmxfcHJlZml4ICsgdGhpcy5tZWRpYWZpbGUubmFtZTtcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gdGhpcy5tZWRpYWZpbGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9cXC8oLis/KSQvLmV4ZWMoZmlsZW5hbWUpWzFdO1xuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIGZpbGV0eXBlOiBbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZWRpYWZpbGUudHlwZSB8fCBnZXR0ZXh0KCd1bmRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICB0aXRsZV9vcl9maWxlbmFtZTogWyd0aXRsZScsICdtZWRpYWZpbGUnLCBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpdGxlIHx8IHRoaXMuZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWxhdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBiZWxvbmdzVG86IHtcbiAgICAgICAgICAgICAgICAgICAgJ3VzZXJzL3VzZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAndXBsb2FkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxLZXk6ICd1cGxvYWRlcl9pZCcsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5ydW4oWydNZWRpYWZpbGUnLCBmdW5jdGlvbiAoTWVkaWFmaWxlKSB7fV0pO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5tZWRpYWZpbGVzLnNpdGUnLCBbXG4gICAgJ09wZW5TbGlkZXNBcHAubWVkaWFmaWxlcy5saXN0JyxcbiAgICAnT3BlblNsaWRlc0FwcC5tZWRpYWZpbGVzLnN0YXRlcycsXG4gICAgJ09wZW5TbGlkZXNBcHAubWVkaWFmaWxlcy51cGRhdGUnLFxuICAgICdPcGVuU2xpZGVzQXBwLm1lZGlhZmlsZXMudXBsb2FkJyxcbiAgICAnT3BlblNsaWRlc0FwcC5tZWRpYWZpbGVzLmltYWdlLXBsdWdpbicsXG5dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAubWVkaWFmaWxlcy5zdGF0ZXMnLCBbXG4gICAgJ2dldHRleHQnLFxuICAgICd1aS5yb3V0ZXInLFxuICAgIC8vVE9ETzogQWRkIGRlcHMgZm9yIG1haW5NZW51UHJvdmlkZXJcbl0pXG5cbi5jb25maWcoW1xuICAgICdnZXR0ZXh0JyxcbiAgICAnbWFpbk1lbnVQcm92aWRlcicsXG4gICAgZnVuY3Rpb24gKGdldHRleHQsIG1haW5NZW51UHJvdmlkZXIpIHtcbiAgICAgICAgbWFpbk1lbnVQcm92aWRlci5yZWdpc3Rlcih7XG4gICAgICAgICAgICAndWlfc3JlZic6ICdtZWRpYWZpbGVzLm1lZGlhZmlsZS5saXN0JyxcbiAgICAgICAgICAgICdpbWdfY2xhc3MnOiAncGFwZXJjbGlwJyxcbiAgICAgICAgICAgICd0aXRsZSc6IGdldHRleHQoJ0ZpbGVzJyksXG4gICAgICAgICAgICAnd2VpZ2h0JzogNjAwLFxuICAgICAgICAgICAgJ3Blcm0nOiAnbWVkaWFmaWxlcy5jYW5fc2VlJyxcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLmNvbmZpZyhbXG4gICAgJ1NlYXJjaFByb3ZpZGVyJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgZnVuY3Rpb24gKFNlYXJjaFByb3ZpZGVyLCBnZXR0ZXh0KSB7XG4gICAgICAgIFNlYXJjaFByb3ZpZGVyLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICd2ZXJib3NlTmFtZSc6IGdldHRleHQoJ0ZpbGVzJyksXG4gICAgICAgICAgICAnY29sbGVjdGlvbk5hbWUnOiAnbWVkaWFmaWxlcy9tZWRpYWZpbGUnLFxuICAgICAgICAgICAgJ3VybERldGFpbFN0YXRlJzogJ21lZGlhZmlsZXMubWVkaWFmaWxlLmRldGFpbCcsXG4gICAgICAgICAgICAnd2VpZ2h0JzogNjAwLFxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4uY29uZmlnKFtcbiAgICAnZ2V0dGV4dCcsXG4gICAgJyRzdGF0ZVByb3ZpZGVyJyxcbiAgICBmdW5jdGlvbiAoZ2V0dGV4dCwgJHN0YXRlUHJvdmlkZXIpIHtcbiAgICAgICAgJHN0YXRlUHJvdmlkZXJcbiAgICAgICAgLnN0YXRlKCdtZWRpYWZpbGVzJywge1xuICAgICAgICAgICAgdXJsOiAnL21lZGlhZmlsZXMnLFxuICAgICAgICAgICAgYWJzdHJhY3Q6IHRydWUsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8dWktdmlldy8+XCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGdldHRleHQoJ0ZpbGVzJyksXG4gICAgICAgICAgICAgICAgYmFzZVBlcm06ICdtZWRpYWZpbGVzLmNhbl9zZWUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgLnN0YXRlKCdtZWRpYWZpbGVzLm1lZGlhZmlsZScsIHtcbiAgICAgICAgICAgIGFic3RyYWN0OiB0cnVlLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHVpLXZpZXcvPlwiLFxuICAgICAgICB9KVxuICAgICAgICAuc3RhdGUoJ21lZGlhZmlsZXMubWVkaWFmaWxlLmxpc3QnLCB7fSk7XG4gICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmFuZ3VsYXIubW9kdWxlKCdPcGVuU2xpZGVzQXBwLm1lZGlhZmlsZXMudXBkYXRlJywgW1xuICAgICdPcGVuU2xpZGVzQXBwLm1lZGlhZmlsZXMucmVzb3VyY2VzJyxcbiAgICAvL1RPRE86IEFkZCBkZXBzIGZvciBvcGVyYXRvciwgVXNlclxuXSlcblxuLmNvbnRyb2xsZXIoJ01lZGlhZmlsZVVwZGF0ZUN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnVXNlcicsXG4gICAgJ01lZGlhZmlsZScsXG4gICAgJ21lZGlhZmlsZUlkJyxcbiAgICAnTWVkaWFmaWxlRm9ybScsXG4gICAgJ0Vycm9yTWVzc2FnZScsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgb3BlcmF0b3IsIFVzZXIsIE1lZGlhZmlsZSwgbWVkaWFmaWxlSWQsIE1lZGlhZmlsZUZvcm0sIEVycm9yTWVzc2FnZSkge1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcbiAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHMgPSBNZWRpYWZpbGVGb3JtLmdldEZvcm1GaWVsZHMoKTtcblxuICAgICAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZXMgZm9yIGZvcm0gbW9kZWwgYnkgY3JlYXRlIGRlZXAgY29weSBvZiBtb3Rpb24gb2JqZWN0XG4gICAgICAgIC8vIHNvIGxpc3QvZGV0YWlsIHZpZXcgaXMgbm90IHVwZGF0ZWQgd2hpbGUgZWRpdGluZ1xuICAgICAgICAkc2NvcGUubW9kZWwgPSBhbmd1bGFyLmNvcHkoTWVkaWFmaWxlLmdldChtZWRpYWZpbGVJZCkpO1xuXG4gICAgICAgIC8vIHNhdmUgbWVkaWFmaWxlXG4gICAgICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24gKG1lZGlhZmlsZSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgdGl0bGUgYW5kIHVwbG9hZGVyX2lkIGlmIGVtcHR5XG4gICAgICAgICAgICBpZiAoIW1lZGlhZmlsZS50aXRsZSkge1xuICAgICAgICAgICAgICAgIG1lZGlhZmlsZS50aXRsZSA9IG1lZGlhZmlsZS5maWxlbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWVkaWFmaWxlLnVwbG9hZGVyX2lkKSB7XG4gICAgICAgICAgICAgICAgbWVkaWFmaWxlLnVwbG9hZGVyX2lkID0gb3BlcmF0b3IudXNlci5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluamVjdCB0aGUgY2hhbmdlZCBtZWRpYWZpbGUgKGNvcHkpIG9iamVjdCBiYWNrIGludG8gRFMgc3RvcmVcbiAgICAgICAgICAgIE1lZGlhZmlsZS5pbmplY3QobWVkaWFmaWxlKTtcbiAgICAgICAgICAgIC8vIHNhdmUgY2hhbmdlIG1lZGlhZmlsZSBvYmplY3Qgb24gc2VydmVyXG4gICAgICAgICAgICBNZWRpYWZpbGUuc2F2ZShtZWRpYWZpbGUpLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlVGhpc0RpYWxvZygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIE1lZGlhZmlsZS5yZWZyZXNoKG1lZGlhZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IEVycm9yTWVzc2FnZS5mb3JBbGVydChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9XG5dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAubWVkaWFmaWxlcy51cGxvYWQnLCBbXG4gICAgJ09wZW5TbGlkZXNBcHAubWVkaWFmaWxlcy5mb3JtcycsXG4gICAgJ25nRmlsZVVwbG9hZCcsXG5dKVxuXG4uY29udHJvbGxlcignTWVkaWFmaWxlVXBsb2FkQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJHEnLFxuICAgICdVc2VyJyxcbiAgICAnVXBsb2FkJyxcbiAgICAnb3BlcmF0b3InLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0Vycm9yTWVzc2FnZScsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgJHEsIFVzZXIsIFVwbG9hZCwgb3BlcmF0b3IsIGdldHRleHRDYXRhbG9nLCBFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgVXNlci5iaW5kQWxsKHt9LCAkc2NvcGUsICd1c2VycycpO1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcbiAgICAgICAgJHNjb3BlLmZpbGVzID0gW107XG4gICAgICAgICRzY29wZS51cGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIGlkQ291bnRlciA9IDA7IC8vIFVzZWQgZm9yIHVuaXFseSBpZGVudGlmaW5nIGVhY2ggZmlsZSBpbiAkc2NvcGUuZmlsZXMuXG5cbiAgICAgICAgLy8gQ29udmVydCBieXRlcyB0byBodW1hbiByZWFkYWJsZSBzaSB1bml0cy5cbiAgICAgICAgdmFyIGh1bWFuRmlsZVNpemUgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIGlmKE1hdGguYWJzKGJ5dGVzKSA8IDEwMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXMgKyAnIEInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVuaXRzID0gWydrQicsJ01CJywnR0InLCdUQicsJ1BCJywnRUInLCdaQicsJ1lCJ107XG4gICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGJ5dGVzIC89IDEwMDA7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSB3aGlsZShieXRlcyA+PSAxMDAwICYmIGkgPCB1bml0cy5sZW5ndGggLSAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzLnRvRml4ZWQoMSkgKyAnICcgKyB1bml0c1tpXTtcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuYWRkRmlsZXMgPSBmdW5jdGlvbiAoZmlsZXMpIHtcbiAgICAgICAgICAgIGZpbGVzID0gXy5tYXAoZmlsZXMsIGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWRDb3VudGVyICs9IDE7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNsaWVudCBzaWRlIHJlcHJlc2VudGF0aW9uIHVzZWQgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZENvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZGVyX2lkOiBvcGVyYXRvci51c2VyLmlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgaHVtYW5TaXplOiBodW1hbkZpbGVTaXplKGZpbGUuc2l6ZSksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQWRkIGVhY2ggZmlsZSwgdGhhdCBpcyBub3QgYSBkdXBsaWNhdGUgdG8gJHNjb3BlLmZpbGVzXG4gICAgICAgICAgICBfLmZvckVhY2goZmlsZXMsIGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR1cGxpY2F0ZSA9IF8uc29tZSgkc2NvcGUuZmlsZXMsIGZ1bmN0aW9uIChfZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5uYW1lID09PSBfZmlsZS5uYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnNpemUgPT09IF9maWxlLnNpemUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUudHlwZSA9PT0gX2ZpbGUudHlwZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWR1cGxpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUucmVtb3ZlRmlsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgJHNjb3BlLmZpbGVzID0gXy5maWx0ZXIoJHNjb3BlLmZpbGVzLCBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmlkICE9PSBpZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFkZCBmaWxlcyB2aWEgZHJhZyBhbmQgZHJvcFxuICAgICAgICAkc2NvcGUuJHdhdGNoKCdkcm9wRmlsZXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoJHNjb3BlLmRyb3BGaWxlcykge1xuICAgICAgICAgICAgICAgICRzY29wZS5hZGRGaWxlcygkc2NvcGUuZHJvcEZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdXBsb2FkIGFsbCBmaWxlc1xuICAgICAgICAkc2NvcGUudXBsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLnVwbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBfLm1hcCgkc2NvcGUuZmlsZXMsIGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgZXJyb3JcbiAgICAgICAgICAgICAgICBmaWxlLmVycm9yID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2ssIGlmIGFsbCBuZWNlc3NhcnkgZmllbGRzIGFyZSBzZXQuXG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlLnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGUudGl0bGUgPSBmaWxlLmZpbGUubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlLnVwbG9hZGVyX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGUudXBsb2FkZXJfaWQgPSBvcGVyYXRvci51c2VyLmlkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBVcGxvYWQudXBsb2FkKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnL3Jlc3QvbWVkaWFmaWxlcy9tZWRpYWZpbGUvJyxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhZmlsZTogZmlsZS5maWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGZpbGUudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRlcl9pZDogZmlsZS51cGxvYWRlcl9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbjogZmlsZS5oaWRkZW5cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KS50aGVuKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlbW92ZUZpbGUoZmlsZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5lcnJvciA9IEVycm9yTWVzc2FnZS5mb3JBbGVydChlcnJvcikubXNnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUucHJvZ3Jlc3MgPSBwYXJzZUludCgxMDAuMCAqIHByb2dyZXNzLmxvYWRlZCAvIHByb2dyZXNzLnRvdGFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9ycyA9IF8uZmlsdGVyKHN1Y2Nlc3MsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudXBsb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTb21lIGZpbGVzIGNvdWxkIG5vdCBiZSB1cGxvYWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSB7IHR5cGU6ICdkYW5nZXInLCBtc2c6IG1lc3NhZ2UsIHNob3c6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUudXBsb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAkc2NvcGUuZmlsZXMgPSBbXTtcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUuY2xvc2VUaGlzRGlhbG9nKCk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLnJ1bihbXG4gICAgJ2dldHRleHQnLFxuICAgIGZ1bmN0aW9uIChnZXR0ZXh0KSB7XG4gICAgICAgIGdldHRleHQoJ1NvbWUgZmlsZXMgY291bGQgbm90IGJlIHVwbG9hZGVkJyk7XG4gICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAubW90aW9ucycsIFtcbiAgICAnT3BlblNsaWRlc0FwcC5tb3Rpb25zLm1vdGlvbkJsb2NrJyxcbiAgICAnT3BlblNsaWRlc0FwcC5tb3Rpb25zLmxpbmVOdW1iZXJpbmcnLFxuICAgICdPcGVuU2xpZGVzQXBwLm1vdGlvbnMuZGlmZicsXG4gICAgJ09wZW5TbGlkZXNBcHAucG9sbC5tYWpvcml0eScsXG4gICAgJ09wZW5TbGlkZXNBcHAudXNlcnMnLFxuXSlcblxuLmZhY3RvcnkoJ01vdGlvblN0YXRlJywgW1xuICAgICdEUycsXG4gICAgZnVuY3Rpb24gKERTKSB7XG4gICAgICAgIHJldHVybiBEUy5kZWZpbmVSZXNvdXJjZSh7XG4gICAgICAgICAgICBuYW1lOiAnbW90aW9ucy9zdGF0ZScsXG4gICAgICAgICAgICBtZXRob2RzOiB7XG4gICAgICAgICAgICAgICAgZ2V0TmV4dFN0YXRlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5tYXAodGhpcy5uZXh0X3N0YXRlc19pZCwgZnVuY3Rpb24gKHN0YXRlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEUy5nZXQoJ21vdGlvbnMvc3RhdGUnLCBzdGF0ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRSZWNvbW1lbmRhdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dvcmtmbG93X2lkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPT0nOiB0aGlzLndvcmtmbG93X2lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVjb21tZW5kYXRpb25fbGFiZWwnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICchPSc6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEUy5maWx0ZXIoJ21vdGlvbnMvc3RhdGUnLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWxhdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBoYXNPbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21vdGlvbnMvd29ya2Zsb3cnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAnd29ya2Zsb3cnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxLZXk6ICd3b3JrZmxvd19pZCcsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnV29ya2Zsb3cnLCBbXG4gICAgJ0RTJyxcbiAgICBmdW5jdGlvbiAoRFMpIHtcbiAgICAgICAgcmV0dXJuIERTLmRlZmluZVJlc291cmNlKHtcbiAgICAgICAgICAgIG5hbWU6ICdtb3Rpb25zL3dvcmtmbG93JyxcbiAgICAgICAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgICAgICAgICBnZXRGaXJzdFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEUy5nZXQoJ21vdGlvbnMvc3RhdGUnLCB0aGlzLmZpcnN0X3N0YXRlX2lkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbGF0aW9uczoge1xuICAgICAgICAgICAgICAgIGhhc01hbnk6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21vdGlvbnMvc3RhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAnc3RhdGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmVpZ25LZXk6ICd3b3JrZmxvd19pZCcsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdNb3Rpb25Qb2xsJywgW1xuICAgICdEUycsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnQ29uZmlnJyxcbiAgICAnTWFqb3JpdHlNZXRob2RzJyxcbiAgICBmdW5jdGlvbiAoRFMsIGdldHRleHRDYXRhbG9nLCBDb25maWcsIE1ham9yaXR5TWV0aG9kcykge1xuICAgICAgICByZXR1cm4gRFMuZGVmaW5lUmVzb3VyY2Uoe1xuICAgICAgICAgICAgbmFtZTogJ21vdGlvbnMvbW90aW9uLXBvbGwnLFxuICAgICAgICAgICAgcmVsYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgYmVsb25nc1RvOiB7XG4gICAgICAgICAgICAgICAgICAgICdtb3Rpb25zL21vdGlvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRmllbGQ6ICdtb3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxLZXk6ICdtb3Rpb25faWQnLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJlZm9yZUluamVjdDogZnVuY3Rpb24gKHJlc291cmNlLCBpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IFsneWVzJywgJ25vJywgJ2Fic3RhaW4nLCAndm90ZXNjYXN0JywgJ3ZvdGVzaW52YWxpZCcsICd2b3Rlc3ZhbGlkJ107XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGF0dHJzLCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2VbYXR0cl0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlW2F0dHJdID0gcGFyc2VGbG9hdChpbnN0YW5jZVthdHRyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXRob2RzOiB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyBwZXJjZW50IGJhc2UuIFJldHVybnMgdW5kZWZpbmVkIGlmIGNhbGN1bGF0aW9uIGlzIG5vdCBwb3NzaWJsZSBpbiBnZW5lcmFsLlxuICAgICAgICAgICAgICAgIGdldFBlcmNlbnRCYXNlOiBmdW5jdGlvbiAoY29uZmlnLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQ0FTVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudm90ZXNjYXN0IDw9IDAgfHwgdGhpcy52b3Rlc2ludmFsaWQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0IHdvdWxkIGJlIE9LIHRvIGNoZWNrIG9ubHkgdGhpcy52b3Rlc2Nhc3QgPCAwIGJlY2F1c2UgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBjaGVja2VkIGFnYWluIGxhdGVyIGJ1dCB0aGlzIGlzIGEgbGl0dGxlIGJpdCBmYXN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gdGhpcy52b3Rlc2Nhc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVkFMSUQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZvdGVzdmFsaWQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJhc2UgPT09ICd1bmRlZmluZWQnICYmIHR5cGUgIT09ICd2b3Rlc2Nhc3QnICYmIHR5cGUgIT09ICd2b3Rlc2ludmFsaWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSB0aGlzLnZvdGVzdmFsaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lFU19OT19BQlNUQUlOJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hYnN0YWluIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSAndW5kZWZpbmVkJyAmJiB0eXBlICE9PSAndm90ZXNjYXN0JyAmJiB0eXBlICE9PSAndm90ZXNpbnZhbGlkJyAmJiB0eXBlICE9PSAndm90ZXN2YWxpZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9IHRoaXMueWVzICsgdGhpcy5ubyArIHRoaXMuYWJzdGFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWUVTX05PJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy55ZXMgPCAwIHx8IHRoaXMubm8gPCAwIHx8IHRoaXMuYWJzdGFpbiA9PT0gLTEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0IGlzIG5vdCBhbGxvd2VkIHRvIHNldCAnQWJzdGFpbicgdG8gJ21ham9yaXR5JyBidXQgZXhjbHVkZSBpdCBmcm9tIGNhbGN1bGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXR0aW5nICdBYnN0YWluJyB0byAndW5kb2N1bWVudGVkJyBpcyBwb3NzaWJsZSwgb2YgY291cnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSAndW5kZWZpbmVkJyAmJiAodHlwZSA9PT0gJ3llcycgfHwgdHlwZSA9PT0gJ25vJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9IHRoaXMueWVzICsgdGhpcy5ubztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgb2JqZWN0IHdpdGggdmFsdWUgYW5kIHBlcmNlbnQgZm9yIHRoaXMgcG9sbC5cbiAgICAgICAgICAgICAgICBnZXRWb3RlOiBmdW5jdGlvbiAodm90ZSwgdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzX3ZvdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdW5kZWZpbmVkIGlmIHRoaXMgcG9sbCBoYXMgbm8gdm90ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnRTdHIgPSAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnROdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBDb25maWcuZ2V0KCdtb3Rpb25zX3BvbGxfMTAwX3BlcmNlbnRfYmFzZScpLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHNwZWNpYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodm90ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnbWFqb3JpdHknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgLTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ3VuZG9jdW1lbnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm90ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdm90ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7ICAvLyBWb3RlIHdhcyBub3QgZGVmaW5lZC4gU2V0IHZhbHVlIHRvIDAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBlcmNlbnQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2UgPSB0aGlzLmdldFBlcmNlbnRCYXNlKGNvbmZpZywgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50TnVtYmVyID0gTWF0aC5yb3VuZCh2b3RlICogMTAwIC8gKGJhc2UpICogMTAwKSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnRTdHIgPSAnKCcgKyBwZXJjZW50TnVtYmVyICsgJyAlKSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BlcmNlbnRTdHInOiBwZXJjZW50U3RyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BlcmNlbnROdW1iZXInOiBwZXJjZW50TnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc3BsYXknOiB2YWx1ZSArICcgJyArIHBlcmNlbnRTdHJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyAwIG9yIHBvc2l0aXZlIGludGVnZXIgaWYgcXVvcnVtIGlzIHJlYWNoZWQgb3Igc3VycGFzc2VkLlxuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgbmVnYXRpdiBpbnRlZ2VyIGlmIHF1b3J1bSBpcyBub3QgcmVhY2hlZC5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIHVuZGVmaW5lZCBpZiB3ZSBjYW4gbm90IGNhbGN1bGF0ZSB0aGUgcXVvcnVtLlxuICAgICAgICAgICAgICAgIGlzUmVhY2hlZDogZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzX3ZvdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdW5kZWZpbmVkIGlmIHRoaXMgcG9sbCBoYXMgbm8gdm90ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSZWFjaGVkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gQ29uZmlnLmdldCgnbW90aW9uc19wb2xsXzEwMF9wZXJjZW50X2Jhc2UnKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2UgPSB0aGlzLmdldFBlcmNlbnRCYXNlKGNvbmZpZywgJ3llcycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvdmlkZSByZXN1bHQgb25seSBpZiBiYXNlIGlzIG5vdCB1bmRlZmluZWQgYW5kIG5vdCAwLlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZWFjaGVkID0gTWFqb3JpdHlNZXRob2RzW21ldGhvZF0odGhpcy55ZXMsIGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1JlYWNoZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4ucHJvdmlkZXIoJ01vdGlvblBvbGxEZWNpbWFsUGxhY2VzJywgW1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kZ2V0ID0gWyckcScsIGZ1bmN0aW9uICgkcSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBnZXRQbGFjZXM6IGZ1bmN0aW9uIChwb2xsLCBmaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnTW90aW9uU3RhdGVBbmRSZWNvbW1lbmRhdGlvblBhcnNlcicsIFtcbiAgICAnRFMnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgZnVuY3Rpb24gKERTLCBnZXR0ZXh0Q2F0YWxvZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0TW90aW9uOiBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbbW90aW9uOicgKyBtb3Rpb24uaWQgKyAnXSc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChyZWNvbW1lbmRhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvbW1lbmRhdGlvbi5yZXBsYWNlKC9cXFttb3Rpb246KFxcZCspXFxdL2csIGZ1bmN0aW9uIChtYXRjaCwgaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdGlvbiA9IERTLmdldCgnbW90aW9ucy9tb3Rpb24nLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb3Rpb24uaWRlbnRpZmllciA/IG1vdGlvbi5pZGVudGlmaWVyIDogbW90aW9uLmdldFRpdGxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCc8dW5rbm93biBtb3Rpb24+Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ1N1Ym1pdHRlcicsIFtcbiAgICAnRFMnLFxuICAgIGZ1bmN0aW9uIChEUykge1xuICAgICAgICByZXR1cm4gRFMuZGVmaW5lUmVzb3VyY2Uoe1xuICAgICAgICAgICAgbmFtZTogJ21vdGlvbnMvc3VibWl0dGVyJyxcbiAgICAgICAgICAgIHJlbGF0aW9uczoge1xuICAgICAgICAgICAgICAgIGJlbG9uZ3NUbzoge1xuICAgICAgICAgICAgICAgICAgICAndXNlcnMvdXNlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRmllbGQ6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsS2V5OiAndXNlcl9pZCcsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdNb3Rpb24nLCBbXG4gICAgJ0RTJyxcbiAgICAnJGh0dHAnLFxuICAgICckY2FjaGVGYWN0b3J5JyxcbiAgICAnTW90aW9uUG9sbCcsXG4gICAgJ01vdGlvblN0YXRlQW5kUmVjb21tZW5kYXRpb25QYXJzZXInLFxuICAgICdNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbicsXG4gICAgJ01vdGlvbkNvbW1lbnQnLFxuICAgICdqc0RhdGFNb2RlbCcsXG4gICAgJ2dldHRleHQnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0NvbmZpZycsXG4gICAgJ2xpbmVOdW1iZXJpbmdTZXJ2aWNlJyxcbiAgICAnZGlmZlNlcnZpY2UnLFxuICAgICdPcGVuU2xpZGVzU2V0dGluZ3MnLFxuICAgICdQcm9qZWN0b3InLFxuICAgICdQcm9qZWN0SGVscGVyJyxcbiAgICAnb3BlcmF0b3InLFxuICAgICdVbmlmaWVkQ2hhbmdlT2JqZWN0Q29sbGlzc2lvbicsXG4gICAgZnVuY3Rpb24oRFMsICRodHRwLCAkY2FjaGVGYWN0b3J5LCBNb3Rpb25Qb2xsLCBNb3Rpb25TdGF0ZUFuZFJlY29tbWVuZGF0aW9uUGFyc2VyLCBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbixcbiAgICAgICAgTW90aW9uQ29tbWVudCwganNEYXRhTW9kZWwsIGdldHRleHQsIGdldHRleHRDYXRhbG9nLCBDb25maWcsIGxpbmVOdW1iZXJpbmdTZXJ2aWNlLFxuICAgICAgICBkaWZmU2VydmljZSwgT3BlblNsaWRlc1NldHRpbmdzLCBQcm9qZWN0b3IsIFByb2plY3RIZWxwZXIsIG9wZXJhdG9yLCBVbmlmaWVkQ2hhbmdlT2JqZWN0Q29sbGlzc2lvbikge1xuXG4gICAgICAgIHZhciBkaWZmQ2FjaGUgPSAkY2FjaGVGYWN0b3J5KCdtb3Rpb24uc2VydmljZScpO1xuXG4gICAgICAgIHZhciBuYW1lID0gJ21vdGlvbnMvbW90aW9uJztcbiAgICAgICAgcmV0dXJuIERTLmRlZmluZVJlc291cmNlKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB1c2VDbGFzczoganNEYXRhTW9kZWwsXG4gICAgICAgICAgICB2ZXJib3NlTmFtZTogZ2V0dGV4dCgnTW90aW9uJyksXG4gICAgICAgICAgICB2ZXJib3NlTmFtZVBsdXJhbDogZ2V0dGV4dCgnTW90aW9ucycpLFxuICAgICAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChyZXNvdXJjZSwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBNb3Rpb25Db21tZW50LnBvcHVsYXRlRmllbGRzUmV2ZXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wdXRlZDoge1xuICAgICAgICAgICAgICAgIGlzQW1lbmRtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudF9pZCAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgICAgICAgICBnZXRSZXNvdXJjZU5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRWZXJzaW9uOiBmdW5jdGlvbiAodmVyc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb25JZCA9IHZlcnNpb25JZCB8fCB0aGlzLmFjdGl2ZV92ZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uSWQgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy52ZXJzaW9ucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBfLmZpbmRJbmRleCh0aGlzLnZlcnNpb25zLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmlkID09IHZlcnNpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcnNpb25zW2luZGV4XSB8fCB7fTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzUGFyYWdyYXBoQmFzZWRBbWVuZG1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnNpb24gPSB0aGlzLmdldFZlcnNpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNBbWVuZG1lbnQgJiYgdmVyc2lvbi5hbWVuZG1lbnRfcGFyYWdyYXBocztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFRpdGxlOiBmdW5jdGlvbiAodmVyc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZlcnNpb24odmVyc2lvbklkKS50aXRsZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldEFnZW5kYVRpdGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnTW90aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlICs9ICcgJyArIHRoaXMuaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlICs9ICcgKCcgKyB0aGlzLmdldFRpdGxlKCkgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpdGxlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0TGlzdE9mU3BlYWtlcnNUaXRsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ01vdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSArPSAnICcgKyB0aGlzLmlkZW50aWZpZXI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSArPSAnICgnICsgdGhpcy5nZXRUaXRsZSgpICsgJyknO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aXRsZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFRpdGxlV2l0aENoYW5nZXM6IGZ1bmN0aW9uIChjaGFuZ2VSZWNvbW1lbmRhdGlvbk1vZGUsIHZlcnNpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGVDaGFuZ2UgPSB0aGlzLmdldFRpdGxlQ2hhbmdlUmVjb21tZW5kYXRpb24odmVyc2lvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpdGxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGl0bGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VSZWNvbW1lbmRhdGlvbk1vZGUgPT09IFwiY2hhbmdlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSB0aXRsZUNoYW5nZS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoY2hhbmdlUmVjb21tZW5kYXRpb25Nb2RlID09PSAnYWdyZWVkJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VSZWNvbW1lbmRhdGlvbk1vZGUgPT09ICdtb2RpZmllZF9hZ3JlZWQnKSAmJiAhdGl0bGVDaGFuZ2UucmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHRpdGxlQ2hhbmdlLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gdGhpcy5nZXRUaXRsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSB0aGlzLmdldFRpdGxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpdGxlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0U2VxdWVudGlhbE51bWJlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLmlkICsgJyc7XG4gICAgICAgICAgICAgICAgICAgIHZhciB6ZXJvcyA9IE1hdGgubWF4KDAsIE9wZW5TbGlkZXNTZXR0aW5ncy5NT1RJT05fSURFTlRJRklFUl9NSU5fRElHSVRTIC0gaWQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6ZXJvczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9ICcwJyArIGlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFRleHQ6IGZ1bmN0aW9uICh2ZXJzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmVyc2lvbih2ZXJzaW9uSWQpLnRleHQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRUZXh0V2l0aExpbmVCcmVha3M6IGZ1bmN0aW9uICh2ZXJzaW9uSWQsIGhpZ2hsaWdodCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBDb25maWcuZ2V0KCdtb3Rpb25zX2xpbmVfbGVuZ3RoJykudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sID0gdGhpcy5nZXRWZXJzaW9uKHZlcnNpb25JZCkudGV4dDtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZU51bWJlcmluZ1NlcnZpY2UuaW5zZXJ0TGluZU51bWJlcnMoaHRtbCwgbGluZUxlbmd0aCwgaGlnaGxpZ2h0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRNb2RpZmllZEZpbmFsVmVyc2lvbldpdGhMaW5lQnJlYWtzOiBmdW5jdGlvbiAodmVyc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gQ29uZmlnLmdldCgnbW90aW9uc19saW5lX2xlbmd0aCcpLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCA9IHRoaXMuZ2V0VmVyc2lvbih2ZXJzaW9uSWQpLm1vZGlmaWVkX2ZpbmFsX3ZlcnNpb247XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVOdW1iZXJpbmdTZXJ2aWNlLmluc2VydExpbmVOdW1iZXJzKGh0bWwsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0VGV4dEJldHdlZW5DaGFuZ2VzOiBmdW5jdGlvbiAodmVyc2lvbklkLCBjaGFuZ2UxLCBjaGFuZ2UyLCBoaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVfZnJvbSA9IChjaGFuZ2UxID8gY2hhbmdlMS5saW5lX3RvIDogMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lX3RvID0gKGNoYW5nZTIgPyBjaGFuZ2UyLmxpbmVfZnJvbSA6IG51bGwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lX2Zyb20gPiBsaW5lX3RvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnSW52YWxpZCBjYWxsIG9mIGdldFRleHRCZXR3ZWVuQ2hhbmdlczogY2hhbmdlMSBuZWVkcyB0byBiZSBiZWZvcmUgY2hhbmdlMic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVfZnJvbSA9PT0gbGluZV90bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dEluTGluZVJhbmdlKHZlcnNpb25JZCwgbGluZV9mcm9tLCBsaW5lX3RvLCBoaWdobGlnaHQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0VGV4dEluTGluZVJhbmdlOiBmdW5jdGlvbiAodmVyc2lvbklkLCBsaW5lX2Zyb20sIGxpbmVfdG8sIGhpZ2hsaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IENvbmZpZy5nZXQoJ21vdGlvbnNfbGluZV9sZW5ndGgnKS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxSYXcgPSB0aGlzLmdldFZlcnNpb24odmVyc2lvbklkKS50ZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9ICdnZXRUZXh0SW5MaW5lUmFuZ2UgJyArIGxpbmVfZnJvbSArICcgJyArIGxpbmVfdG8gKyAnICcgKyBoaWdobGlnaHQgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcmluZ1NlcnZpY2UuZGpiMmhhc2goaHRtbFJhdyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBkaWZmQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmd1bGFyLmlzVW5kZWZpbmVkKGNhY2hlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLmluc2VydExpbmVOdW1iZXJzKGh0bWxSYXcsIGxpbmVMZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRpZmZTZXJ2aWNlLmV4dHJhY3RSYW5nZUJ5TGluZU51bWJlcnMoaHRtbCwgbGluZV9mcm9tLCBsaW5lX3RvKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBvbmx5IGhhcHBlbnMgKGFzIGZhciBhcyB3ZSBrbm93KSB3aGVuIHRoZSBtb3Rpb24gdGV4dCBoYXMgYmVlbiBhbHRlcmVkIChzaG9ydGVuZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRob3V0IG1vZGlmeWluZyB0aGUgY2hhbmdlIHJlY29tbWVuZGF0aW9ucyBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoYXQncyBhIHByZXR0eSBzZXJpb3VzIGluY29uc2lzdGVuY3kgdGhhdCBzaG91bGQgbm90IGhhcHBlbiBhdCBhbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSBqdXN0IGRvaW5nIHNvbWUgYmFzaWMgZGFtYWdlIGNvbnRyb2wgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnSW5jb25zaXN0ZW50IGRhdGEuIEEgY2hhbmdlIHJlY29tbWVuZGF0aW9uIGlzIHByb2JhYmx5IHJlZmVycmluZyB0byBhIG5vbi1leGlzdGFudCBsaW5lIG51bWJlci4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8ZW0gc3R5bGU9XCJjb2xvcjogcmVkOyBmb250LXdlaWdodDogYm9sZDtcIj4nICsgbXNnICsgJzwvZW0+JztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBcIm1lcmdlLWJlZm9yZVwiLWNzcy1jbGFzcyBpZiB0aGUgZmlyc3QgbGluZSBiZWdpbnMgaW4gdGhlIG1pZGRsZSBvZiBhIHBhcmFncmFwaC4gVXNlZCBmb3IgUERGLlxuICAgICAgICAgICAgICAgICAgICBodG1sID0gZGlmZlNlcnZpY2UuYWRkQ1NTQ2xhc3NUb0ZpcnN0VGFnKGRhdGEub3V0ZXJDb250ZXh0U3RhcnQgKyBkYXRhLmlubmVyQ29udGV4dFN0YXJ0LCBcIm1lcmdlLWJlZm9yZVwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmh0bWwgKyBkYXRhLmlubmVyQ29udGV4dEVuZCArIGRhdGEub3V0ZXJDb250ZXh0RW5kO1xuICAgICAgICAgICAgICAgICAgICBodG1sID0gbGluZU51bWJlcmluZ1NlcnZpY2UuaW5zZXJ0TGluZU51bWJlcnMoaHRtbCwgbGluZUxlbmd0aCwgaGlnaGxpZ2h0LCBudWxsLCBsaW5lX2Zyb20pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpZmZDYWNoZS5wdXQoY2FjaGVLZXksIGh0bWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0VGV4dFJlbWFpbmRlckFmdGVyTGFzdENoYW5nZTogZnVuY3Rpb24odmVyc2lvbklkLCBjaGFuZ2VzLCBoaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heExpbmUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VzW2ldLmxpbmVfdG8gPiBtYXhMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4TGluZSA9IGNoYW5nZXNbaV0ubGluZV90bztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gQ29uZmlnLmdldCgnbW90aW9uc19saW5lX2xlbmd0aCcpLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCA9IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLmluc2VydExpbmVOdW1iZXJzKHRoaXMuZ2V0VmVyc2lvbih2ZXJzaW9uSWQpLnRleHQsIGxpbmVMZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRpZmZTZXJ2aWNlLmV4dHJhY3RSYW5nZUJ5TGluZU51bWJlcnMoaHRtbCwgbWF4TGluZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgb25seSBoYXBwZW5zIChhcyBmYXIgYXMgd2Uga25vdykgd2hlbiB0aGUgbW90aW9uIHRleHQgaGFzIGJlZW4gYWx0ZXJlZCAoc2hvcnRlbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aG91dCBtb2RpZnlpbmcgdGhlIGNoYW5nZSByZWNvbW1lbmRhdGlvbnMgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGF0J3MgYSBwcmV0dHkgc2VyaW91cyBpbmNvbnNpc3RlbmN5IHRoYXQgc2hvdWxkIG5vdCBoYXBwZW4gYXQgYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUganVzdCBkb2luZyBzb21lIGJhc2ljIGRhbWFnZSBjb250cm9sIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ0luY29uc2lzdGVudCBkYXRhLiBBIGNoYW5nZSByZWNvbW1lbmRhdGlvbiBpcyBwcm9iYWJseSByZWZlcnJpbmcgdG8gYSBub24tZXhpc3RhbnQgbGluZSBudW1iZXIuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnPGVtIHN0eWxlPVwiY29sb3I6IHJlZDsgZm9udC13ZWlnaHQ6IGJvbGQ7XCI+JyArIG1zZyArICc8L2VtPic7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5odG1sICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIFwibWVyZ2UtYmVmb3JlXCItY3NzLWNsYXNzIGlmIHRoZSBmaXJzdCBsaW5lIGJlZ2lucyBpbiB0aGUgbWlkZGxlIG9mIGEgcGFyYWdyYXBoLiBVc2VkIGZvciBQREYuXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sID0gZGlmZlNlcnZpY2UuYWRkQ1NTQ2xhc3NUb0ZpcnN0VGFnKGRhdGEub3V0ZXJDb250ZXh0U3RhcnQgKyBkYXRhLmlubmVyQ29udGV4dFN0YXJ0LCBcIm1lcmdlLWJlZm9yZVwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5odG1sICsgZGF0YS5pbm5lckNvbnRleHRFbmQgKyBkYXRhLm91dGVyQ29udGV4dEVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgPSBsaW5lTnVtYmVyaW5nU2VydmljZS5pbnNlcnRMaW5lTnVtYmVycyhodG1sLCBsaW5lTGVuZ3RoLCBoaWdobGlnaHQsIG51bGwsIG1heExpbmUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudHMgZW1wdHkgbGluZXMgYXQgdGhlIGVuZCBvZiB0aGUgbW90aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfZ2V0VGV4dFdpdGhDaGFuZ2VzOiBmdW5jdGlvbiAodmVyc2lvbklkLCBoaWdobGlnaHQsIGxpbmVCcmVha3MsIHJlY29tbWVuZGF0aW9uX2ZpbHRlciwgYW1lbmRtZW50X2ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IENvbmZpZy5nZXQoJ21vdGlvbnNfbGluZV9sZW5ndGgnKS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgPSB0aGlzLmdldFZlcnNpb24odmVyc2lvbklkKS50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlX3JlY29tbWVuZGF0aW9ucyA9IHRoaXMuZ2V0VGV4dENoYW5nZVJlY29tbWVuZGF0aW9ucyh2ZXJzaW9uSWQsICdERVNDJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbWVuZG1lbnRzID0gdGhpcy5nZXRQYXJhZ3JhcGhCYXNlZEFtZW5kbWVudHMoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYWxsQ2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VfcmVjb21tZW5kYXRpb25zLmZpbHRlcihyZWNvbW1lbmRhdGlvbl9maWx0ZXIpLmZvckVhY2goZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxDaGFuZ2VzLnB1c2goe1widGV4dFwiOiBjaGFuZ2UudGV4dCwgXCJsaW5lX2Zyb21cIjogY2hhbmdlLmxpbmVfZnJvbSwgXCJsaW5lX3RvXCI6IGNoYW5nZS5saW5lX3RvfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhbWVuZG1lbnRzLmZpbHRlcihhbWVuZG1lbnRfZmlsdGVyKS5mb3JFYWNoKGZ1bmN0aW9uKGFtZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gYW1lbmQuZ2V0QW1lbmRtZW50c0FmZmVjdGVkTGluZXNDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxDaGFuZ2VzLnB1c2goe1widGV4dFwiOiBjaGFuZ2UudGV4dCwgXCJsaW5lX2Zyb21cIjogY2hhbmdlLmxpbmVfZnJvbSwgXCJsaW5lX3RvXCI6IGNoYW5nZS5saW5lX3RvfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZXMgbmVlZCB0byBiZSBhcHBsaWVkIGZyb20gdGhlIGJvdHRvbSB1cCwgdG8gcHJldmVudCBjb25mbGljdHMgd2l0aCBjaGFuZ2luZyBsaW5lIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICAgIGFsbENoYW5nZXMuc29ydChmdW5jdGlvbihjaGFuZ2UxLCBjaGFuZ2UyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlMS5saW5lX2Zyb20gPCBjaGFuZ2UyLmxpbmVfZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2UxLmxpbmVfZnJvbSA+IGNoYW5nZTIubGluZV9mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgYWxsQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCA9IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLmluc2VydExpbmVOdW1iZXJzKGh0bWwsIGxpbmVMZW5ndGgsIG51bGwsIG51bGwsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCA9IGRpZmZTZXJ2aWNlLnJlcGxhY2VMaW5lcyhodG1sLCBjaGFuZ2UudGV4dCwgY2hhbmdlLmxpbmVfZnJvbSwgY2hhbmdlLmxpbmVfdG8pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZUJyZWFrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCA9IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLmluc2VydExpbmVOdW1iZXJzKGh0bWwsIGxpbmVMZW5ndGgsIGhpZ2hsaWdodCwgbnVsbCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFRleHRXaXRoQWxsQ2hhbmdlUmVjb21tZW5kYXRpb25zOiBmdW5jdGlvbiAodmVyc2lvbklkLCBoaWdobGlnaHQsIGxpbmVCcmVha3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRleHRXaXRoQ2hhbmdlcyh2ZXJzaW9uSWQsIGhpZ2hsaWdodCwgbGluZUJyZWFrcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gQWxsIGNoYW5nZSByZWNvbW1lbmRhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIGFtZW5kbWVudHNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRUZXh0V2l0aEFncmVlZENoYW5nZXM6IGZ1bmN0aW9uICh2ZXJzaW9uSWQsIGhpZ2hsaWdodCwgbGluZUJyZWFrcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VGV4dFdpdGhDaGFuZ2VzKHZlcnNpb25JZCwgaGlnaGxpZ2h0LCBsaW5lQnJlYWtzLCBmdW5jdGlvbihyZWNvbW1lbmRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFyZWNvbW1lbmRhdGlvbi5yZWplY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oYW1lbmRtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW1lbmRtZW50LnN0YXRlICYmIGFtZW5kbWVudC5zdGF0ZS5uYW1lID09PSAncmVqZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFtZW5kbWVudC5zdGF0ZSAmJiBhbWVuZG1lbnQuc3RhdGUubmFtZSA9PT0gJ2FjY2VwdGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhbWVuZG1lbnQucmVjb21tZW5kYXRpb24gJiYgYW1lbmRtZW50LnJlY29tbWVuZGF0aW9uLm5hbWUgPT09ICdhY2NlcHRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFRleHRCeU1vZGU6IGZ1bmN0aW9uKG1vZGUsIHZlcnNpb25JZCwgaGlnaGxpZ2h0LCBsaW5lQnJlYWtzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBtb2RlIFsnb3JpZ2luYWwnLCAnZGlmZicsICdjaGFuZ2VkJywgJ2FncmVlZCcsICdtb2RpZmllZF9hZ3JlZWQnXVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdmVyc2lvbklkIFtpZiB1bmRlZmluZWQsIGFjdGl2ZV92ZXJzaW9uIHdpbGwgYmUgdXNlZF1cbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIGhpZ2hsaWdodCBbdGhlIGxpbmUgbnVtYmVyIHRvIGhpZ2hsaWdodF1cbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIGxpbmVCcmVha3MgW2lmIGxpbmUgbnVtYmVycyAvIGJyZWFrcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdF1cbiAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgbGluZUJyZWFrcyA9IChsaW5lQnJlYWtzID09PSB1bmRlZmluZWQgPyB0cnVlIDogbGluZUJyZWFrcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3JpZ2luYWwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lQnJlYWtzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0aGlzLmdldFRleHRXaXRoTGluZUJyZWFrcyh2ZXJzaW9uSWQsIGhpZ2hsaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMuZ2V0VmVyc2lvbih2ZXJzaW9uSWQpLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGlmZic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFtZW5kbWVudHNfY3JzID0gdGhpcy5nZXRUZXh0Q2hhbmdlUmVjb21tZW5kYXRpb25zKHZlcnNpb25JZCwgJ0FTQycpLm1hcChmdW5jdGlvbiAoY3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyLmdldFVuaWZpZWRDaGFuZ2VPYmplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0UGFyYWdyYXBoQmFzZWRBbWVuZG1lbnRzRm9yRGlmZlZpZXcoKS5tYXAoZnVuY3Rpb24gKGFtZW5kbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFtZW5kbWVudC5nZXRVbmlmaWVkQ2hhbmdlT2JqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbWVuZG1lbnRzX2Nycy5zb3J0KGZ1bmN0aW9uIChjaGFuZ2UxLCBjaGFuZ2UyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UxLmxpbmVfZnJvbSA+IGNoYW5nZTIubGluZV9mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2UxLmxpbmVfZnJvbSA8IGNoYW5nZTIubGluZV9mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1lbmRtZW50c19jcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGk9PT0wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IHRoaXMuZ2V0VGV4dEJldHdlZW5DaGFuZ2VzKHZlcnNpb25JZCwgbnVsbCwgYW1lbmRtZW50c19jcnNbMF0sIGhpZ2hsaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYW1lbmRtZW50c19jcnNbaSAtIDFdLmxpbmVfdG8gPCBhbWVuZG1lbnRzX2Nyc1tpXS5saW5lX2Zyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgKz0gdGhpcy5nZXRUZXh0QmV0d2VlbkNoYW5nZXModmVyc2lvbklkLCBhbWVuZG1lbnRzX2Nyc1tpIC0gMV0sIGFtZW5kbWVudHNfY3JzW2ldLCBoaWdobGlnaHQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBhbWVuZG1lbnRzX2Nyc1tpXS5nZXREaWZmKHRoaXMsIHZlcnNpb25JZCwgaGlnaGxpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSB0aGlzLmdldFRleHRSZW1haW5kZXJBZnRlckxhc3RDaGFuZ2UodmVyc2lvbklkLCBhbWVuZG1lbnRzX2Nycyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmVCcmVha3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLnN0cmlwTGluZU51bWJlcnModGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hhbmdlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMuZ2V0VGV4dFdpdGhBbGxDaGFuZ2VSZWNvbW1lbmRhdGlvbnModmVyc2lvbklkLCBoaWdobGlnaHQsIGxpbmVCcmVha3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWdyZWVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5nZXRUZXh0V2l0aEFncmVlZENoYW5nZXModmVyc2lvbklkLCBoaWdobGlnaHQsIGxpbmVCcmVha3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbW9kaWZpZWRfYWdyZWVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5nZXRNb2RpZmllZEZpbmFsVmVyc2lvbih2ZXJzaW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBsaW5lIG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBDb25maWcuZ2V0KCdtb3Rpb25zX2xpbmVfbGVuZ3RoJykudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBsaW5lTnVtYmVyaW5nU2VydmljZS5pbnNlcnRMaW5lTnVtYmVycyh0ZXh0LCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGFncmVlZCB2ZXJzaW9uIGFzIGZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0aGlzLmdldFRleHRCeU1vZGUoJ2FncmVlZCcsIHZlcnNpb25JZCwgaGlnaGxpZ2h0LCBsaW5lQnJlYWtzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRUZXh0UGFyYWdyYXBoczogZnVuY3Rpb24odmVyc2lvbklkLCBsaW5lQnJlYWtzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB2ZXJzaW9uSWQgW2lmIHVuZGVmaW5lZCwgYWN0aXZlX3ZlcnNpb24gd2lsbCBiZSB1c2VkXVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbGluZUJyZWFrcyBbaWYgbGluZSBudW1iZXJzIC8gYnJlYWtzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0XVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lQnJlYWtzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5nZXRUZXh0V2l0aExpbmVCcmVha3ModmVyc2lvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0aGlzLmdldFZlcnNpb24odmVyc2lvbklkKS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVOdW1iZXJpbmdTZXJ2aWNlLnNwbGl0VG9QYXJhZ3JhcGhzKHRleHQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0VGV4dEhlYWRpbmdzOiBmdW5jdGlvbih2ZXJzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWwgPSB0aGlzLmdldFRleHRXaXRoTGluZUJyZWFrcyh2ZXJzaW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZU51bWJlcmluZ1NlcnZpY2UuZ2V0SGVhZGluZ3NXaXRoTGluZU51bWJlcnMoaHRtbCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRBbWVuZG1lbnRQYXJhZ3JhcGhzQnlNb2RlOiBmdW5jdGlvbiAobW9kZSwgdmVyc2lvbklkLCBsaW5lQnJlYWtzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBtb2RlIFsnb3JpZ2luYWwnLCAnZGlmZicsICdjaGFuZ2VkJ11cbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHZlcnNpb25JZCBbaWYgdW5kZWZpbmVkLCBhY3RpdmVfdmVyc2lvbiB3aWxsIGJlIHVzZWRdXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBsaW5lQnJlYWtzIFtpZiBsaW5lIG51bWJlcnMgLyBicmVha3Mgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRdXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIFN0cnVjdHVyZSBvZiB0aGUgcmV0dXJuIGFycmF5IGVsZW1lbnRzOlxuICAgICAgICAgICAgICAgICAgICAgKiB7XG4gICAgICAgICAgICAgICAgICAgICAqICAgXCJwYXJhZ3JhcGhOb1wiOiBwYXJhZ3JhcGggbnVtYmVyLCBzdGFydGluZyB3aXRoIDBcbiAgICAgICAgICAgICAgICAgICAgICogICBcImxpbmVGcm9tXCI6IEZpcnN0IGxpbmUgbnVtYmVyIG9mIHRoZSBhZmZlY3RlZCBwYXJhZ3JhcGhcbiAgICAgICAgICAgICAgICAgICAgICogICBcImxpbmVUb1wiOiBMYXN0IGxpbmUgbnVtYmVyIG9mIHRoZSBhZmZlY3RlZCBwYXJhZ3JhcGg7XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgIHJlZmVycyB0byB0aGUgbGluZSBicmVha2luZyBlbGVtZW50IGF0IHRoZSBlbmQsIGkuZS4gdGhlIHN0YXJ0IG9mIHRoZSBmb2xsb3dpbmcgbGluZVxuICAgICAgICAgICAgICAgICAgICAgKiAgIFwidGV4dFwiOiB0aGUgYWN0dWFsIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICogfVxuICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICBsaW5lQnJlYWtzID0gKGxpbmVCcmVha3MgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBsaW5lQnJlYWtzKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSAnZ2V0QW1lbmRtZW50UGFyYWdyYXBoc0J5TW9kZSAnICsgbW9kZSArICcgJyArIHZlcnNpb25JZCArICcgJyArIGxpbmVCcmVha3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcmluZ1NlcnZpY2UuZGpiMmhhc2goSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRWZXJzaW9uKHZlcnNpb25JZCkuYW1lbmRtZW50X3BhcmFncmFwaHMpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGRpZmZDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFuZ3VsYXIuaXNVbmRlZmluZWQoY2FjaGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbF90ZXh0ID0gdGhpcy5nZXRQYXJlbnRNb3Rpb24oKS5nZXRUZXh0QnlNb2RlKCdvcmlnaW5hbCcsIG51bGwsIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxfcGFyYWdyYXBocyA9IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLnNwbGl0VG9QYXJhZ3JhcGhzKG9yaWdpbmFsX3RleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFZlcnNpb24odmVyc2lvbklkKS5hbWVuZG1lbnRfcGFyYWdyYXBocy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFncmFwaF9hbWVuZCwgcGFyYWdyYXBoTm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhZ3JhcGhfYW1lbmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxfcGFyYWdyYXBoc1twYXJhZ3JhcGhOb10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiVGhlIGFtZW5kbWVudCBhcHBlYXJzIHRvIGhhdmUgbW9yZSBwYXJhZ3JhcGhzIHRoYW4gdGhlIG1vdGlvbi4gVGhpcyBtZWFucywgdGhlIGRhdGEgbWlnaHQgYmUgY29ycnVwdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFncmFwaF9vcmlnID0gb3JpZ2luYWxfcGFyYWdyYXBoc1twYXJhZ3JhcGhOb107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZV9yYW5nZSA9IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLmdldExpbmVOdW1iZXJSYW5nZShwYXJhZ3JhcGhfb3JpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZV9sZW5ndGggPSBDb25maWcuZ2V0KCdtb3Rpb25zX2xpbmVfbGVuZ3RoJykudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhZ3JhcGhfb3JpZyA9IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLnN0cmlwTGluZU51bWJlcnMocGFyYWdyYXBoX29yaWcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkaWZmXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lQnJlYWtzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZGlmZlNlcnZpY2UuZGlmZihwYXJhZ3JhcGhfb3JpZywgcGFyYWdyYXBoX2FtZW5kLCBsaW5lX2xlbmd0aCwgbGluZV9yYW5nZS5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBkaWZmU2VydmljZS5kaWZmKHBhcmFncmFwaF9vcmlnLCBwYXJhZ3JhcGhfYW1lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvcmlnaW5hbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gcGFyYWdyYXBoX29yaWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lQnJlYWtzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gbGluZU51bWJlcmluZ1NlcnZpY2UuaW5zZXJ0TGluZU51bWJlcnModGV4dCwgbGluZV9sZW5ndGgsIG51bGwsIG51bGwsIGxpbmVfcmFuZ2UuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNoYW5nZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHBhcmFncmFwaF9hbWVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVCcmVha3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBsaW5lTnVtYmVyaW5nU2VydmljZS5pbnNlcnRMaW5lTnVtYmVycyh0ZXh0LCBsaW5lX2xlbmd0aCwgbnVsbCwgbnVsbCwgbGluZV9yYW5nZS5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdGV4dCBtb2RlOiBcIiArIG1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYXJhZ3JhcGhOb1wiOiBwYXJhZ3JhcGhObyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxpbmVGcm9tXCI6IGxpbmVfcmFuZ2UuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxpbmVUb1wiOiBsaW5lX3JhbmdlLnRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGlmZkNhY2hlLnB1dChjYWNoZUtleSwgb3V0cHV0KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0QW1lbmRtZW50UGFyYWdyYXBoc0xpbmVzQnlNb2RlOiBmdW5jdGlvbiAobW9kZSwgdmVyc2lvbklkLCBsaW5lQnJlYWtzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBtb2RlIFsnb3JpZ2luYWwnLCAnZGlmZicsICdjaGFuZ2VkJ11cbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHZlcnNpb25JZCBbaWYgdW5kZWZpbmVkLCBhY3RpdmVfdmVyc2lvbiB3aWxsIGJlIHVzZWRdXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBsaW5lQnJlYWtzIFtpZiBsaW5lIG51bWJlcnMgLyBicmVha3Mgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRdXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIFN0cnVjdHVyZSBvZiB0aGUgcmV0dXJuIGFycmF5IGVsZW1lbnRzOlxuICAgICAgICAgICAgICAgICAgICAgKiB7XG4gICAgICAgICAgICAgICAgICAgICAqICAgXCJwYXJhZ3JhcGhOb1wiOiBwYXJhZ3JhcGggbnVtYmVyLCBzdGFydGluZyB3aXRoIDBcbiAgICAgICAgICAgICAgICAgICAgICogICBcInBhcmFncmFwaExpbmVGcm9tXCI6IEZpcnN0IGxpbmUgbnVtYmVyIG9mIHRoZSBhZmZlY3RlZCBwYXJhZ3JhcGhcbiAgICAgICAgICAgICAgICAgICAgICogICBcInBhcmFncmFwaExpbmVUb1wiOiBFbmQgb2YgdGhlIGFmZmVjdGVkIHBhcmFncmFwaCAobGluZSBudW1iZXIgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgKiAgIFwiZGlmZkxpbmVGcm9tXCI6IEZpcnN0IGxpbmUgbnVtYmVyIG9mIHRoZSBhZmZlY3RlZCBsaW5lc1xuICAgICAgICAgICAgICAgICAgICAgKiAgIFwiZGlmZkxpbmVUb1wiOiBFbmQgb2YgdGhlIGFmZmVjdGVkIGxpbmVzIChsaW5lIG51bWJlciArIDEpXG4gICAgICAgICAgICAgICAgICAgICAqICAgXCJ0ZXh0UHJlXCI6IFRoZSBiZWdpbm5pbmcgb2YgdGhlIHBhcmFncmFwaCwgYmVmb3JlIHRoZSBkaWZmXG4gICAgICAgICAgICAgICAgICAgICAqICAgXCJ0ZXh0XCI6IHRoZSBkaWZmXG4gICAgICAgICAgICAgICAgICAgICAqICAgXCJ0ZXh0UG9zdFwiOiBUaGUgZW5kIG9mIHRoZSBwYXJhZ3JhcGgsIGFmdGVyIHRoZSBkaWZmXG4gICAgICAgICAgICAgICAgICAgICAqIH1cbiAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUGFyYWdyYXBoQmFzZWRBbWVuZG1lbnQoKSB8fCAhdGhpcy5nZXRQYXJlbnRNb3Rpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gJ2dldEFtZW5kbWVudFBhcmFncmFwaHNMaW5lc0J5TW9kZSAnICsgbW9kZSArICcgJyArIHZlcnNpb25JZCArICcgJyArIGxpbmVCcmVha3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcmluZ1NlcnZpY2UuZGpiMmhhc2goSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRWZXJzaW9uKHZlcnNpb25JZCkuYW1lbmRtZW50X3BhcmFncmFwaHMpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGRpZmZDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFuZ3VsYXIuaXNVbmRlZmluZWQoY2FjaGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbF90ZXh0ID0gdGhpcy5nZXRQYXJlbnRNb3Rpb24oKS5nZXRUZXh0QnlNb2RlKCdvcmlnaW5hbCcsIG51bGwsIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxfcGFyYWdyYXBocyA9IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLnNwbGl0VG9QYXJhZ3JhcGhzKG9yaWdpbmFsX3RleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFZlcnNpb24odmVyc2lvbklkKS5hbWVuZG1lbnRfcGFyYWdyYXBocy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFncmFwaF9hbWVuZCwgcGFyYWdyYXBoTm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhZ3JhcGhfYW1lbmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxfcGFyYWdyYXBoc1twYXJhZ3JhcGhOb10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiVGhlIGFtZW5kbWVudCBhcHBlYXJzIHRvIGhhdmUgbW9yZSBwYXJhZ3JhcGhzIHRoYW4gdGhlIG1vdGlvbi4gVGhpcyBtZWFucywgdGhlIGRhdGEgbWlnaHQgYmUgY29ycnVwdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVfbGVuZ3RoID0gQ29uZmlnLmdldCgnbW90aW9uc19saW5lX2xlbmd0aCcpLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFncmFwaF9vcmlnID0gb3JpZ2luYWxfcGFyYWdyYXBoc1twYXJhZ3JhcGhOb10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWdyYXBoX2xpbmVfcmFuZ2UgPSBsaW5lTnVtYmVyaW5nU2VydmljZS5nZXRMaW5lTnVtYmVyUmFuZ2UocGFyYWdyYXBoX29yaWcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBkaWZmU2VydmljZS5kaWZmKHBhcmFncmFwaF9vcmlnLCBwYXJhZ3JhcGhfYW1lbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkX2xpbmVzID0gZGlmZlNlcnZpY2UuZGV0ZWN0QWZmZWN0ZWRMaW5lUmFuZ2UoZGlmZik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWZmZWN0ZWRfbGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IE1ha2UgdGhpcyB3b3JrLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlX3BhcmFncmFwaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ29yaWdpbmFsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iYXNlX3BhcmFncmFwaCA9IHBhcmFncmFwaF9vcmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Jhc2VfcGFyYWdyYXBoID0gZGlmZlNlcnZpY2UuZGlmZihwYXJhZ3JhcGhfb3JpZywgcGFyYWdyYXBoX29yaWcsIGxpbmVfbGVuZ3RoLCBwYXJhZ3JhcGhfbGluZV9yYW5nZS5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZV9wYXJhZ3JhcGggPSBkaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkaWZmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZV9wYXJhZ3JhcGggPSBkaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGFuZ2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iYXNlX3BhcmFncmFwaCA9IHBhcmFncmFwaF9hbWVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iYXNlX3BhcmFncmFwaCA9IGRpZmZTZXJ2aWNlLmRpZmYocGFyYWdyYXBoX2FtZW5kLCBwYXJhZ3JhcGhfYW1lbmQsIGxpbmVfbGVuZ3RoLCBwYXJhZ3JhcGhfbGluZV9yYW5nZS5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZV9wYXJhZ3JhcGggPSBkaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRQcmUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0UG9zdCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFmZmVjdGVkX2xpbmVzLmZyb20gPiBwYXJhZ3JhcGhfbGluZV9yYW5nZS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFByZSA9IGRpZmZTZXJ2aWNlLmV4dHJhY3RSYW5nZUJ5TGluZU51bWJlcnMoYmFzZV9wYXJhZ3JhcGgsIHBhcmFncmFwaF9saW5lX3JhbmdlLmZyb20sIGFmZmVjdGVkX2xpbmVzLmZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lQnJlYWtzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQcmUgPSBkaWZmU2VydmljZS5mb3JtYXREaWZmV2l0aExpbmVOdW1iZXJzKHRleHRQcmUsIGxpbmVfbGVuZ3RoLCBwYXJhZ3JhcGhfbGluZV9yYW5nZS5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYWdyYXBoX2xpbmVfcmFuZ2UudG8gPiBhZmZlY3RlZF9saW5lcy50bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb3N0ID0gZGlmZlNlcnZpY2UuZXh0cmFjdFJhbmdlQnlMaW5lTnVtYmVycyhiYXNlX3BhcmFncmFwaCwgYWZmZWN0ZWRfbGluZXMudG8sIHBhcmFncmFwaF9saW5lX3JhbmdlLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZUJyZWFrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdCA9IGRpZmZTZXJ2aWNlLmZvcm1hdERpZmZXaXRoTGluZU51bWJlcnModGV4dFBvc3QsIGxpbmVfbGVuZ3RoLCBhZmZlY3RlZF9saW5lcy50byk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGRpZmZTZXJ2aWNlLmV4dHJhY3RSYW5nZUJ5TGluZU51bWJlcnMoYmFzZV9wYXJhZ3JhcGgsIGFmZmVjdGVkX2xpbmVzLmZyb20sIGFmZmVjdGVkX2xpbmVzLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lQnJlYWtzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGRpZmZTZXJ2aWNlLmZvcm1hdERpZmZXaXRoTGluZU51bWJlcnModGV4dCwgbGluZV9sZW5ndGgsIGFmZmVjdGVkX2xpbmVzLmZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYXJhZ3JhcGhOb1wiOiBwYXJhZ3JhcGhObyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhcmFncmFwaExpbmVGcm9tXCI6IHBhcmFncmFwaF9saW5lX3JhbmdlLmZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYXJhZ3JhcGhMaW5lVG9cIjogcGFyYWdyYXBoX2xpbmVfcmFuZ2UudG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaWZmTGluZUZyb21cIjogYWZmZWN0ZWRfbGluZXMuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpZmZMaW5lVG9cIjogYWZmZWN0ZWRfbGluZXMudG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0UHJlXCI6IHRleHRQcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0UG9zdFwiOiB0ZXh0UG9zdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpZmZDYWNoZS5wdXQoY2FjaGVLZXksIG91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldEFtZW5kbWVudFBhcmFncmFwaHNMaW5lc0RpZmY6IGZ1bmN0aW9uICh2ZXJzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHZlcnNpb25JZCBbaWYgdW5kZWZpbmVkLCBhY3RpdmVfdmVyc2lvbiB3aWxsIGJlIHVzZWRdXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBbWVuZG1lbnRQYXJhZ3JhcGhzTGluZXNCeU1vZGUoJ2RpZmYnLCB2ZXJzaW9uSWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0QW1lbmRtZW50c0FmZmVjdGVkTGluZXNDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhZ3JhcGhfZGlmZiA9IHRoaXMuZ2V0QW1lbmRtZW50UGFyYWdyYXBoc0J5TW9kZShcImRpZmZcIilbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZF9saW5lcyA9IGRpZmZTZXJ2aWNlLmRldGVjdEFmZmVjdGVkTGluZVJhbmdlKHBhcmFncmFwaF9kaWZmLnRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRyYWN0ZWRfbGluZXMgPSBkaWZmU2VydmljZS5leHRyYWN0UmFuZ2VCeUxpbmVOdW1iZXJzKHBhcmFncmFwaF9kaWZmLnRleHQsIGFmZmVjdGVkX2xpbmVzLmZyb20sIGFmZmVjdGVkX2xpbmVzLnRvKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZl9odG1sID0gZXh0cmFjdGVkX2xpbmVzLm91dGVyQ29udGV4dFN0YXJ0ICsgZXh0cmFjdGVkX2xpbmVzLmlubmVyQ29udGV4dFN0YXJ0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0ZWRfbGluZXMuaHRtbCArIGV4dHJhY3RlZF9saW5lcy5pbm5lckNvbnRleHRFbmQgKyBleHRyYWN0ZWRfbGluZXMub3V0ZXJDb250ZXh0RW5kO1xuICAgICAgICAgICAgICAgICAgICBkaWZmX2h0bWwgPSBkaWZmU2VydmljZS5kaWZmSHRtbFRvRmluYWxUZXh0KGRpZmZfaHRtbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGluZV9mcm9tXCI6IGFmZmVjdGVkX2xpbmVzLmZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxpbmVfdG9cIjogYWZmZWN0ZWRfbGluZXMudG8sXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogZGlmZl9odG1sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRVbmlmaWVkQ2hhbmdlT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhZ3JhcGggPSB0aGlzLmdldEFtZW5kbWVudFBhcmFncmFwaHNCeU1vZGUoXCJkaWZmXCIpWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRfbGluZXMgPSBkaWZmU2VydmljZS5kZXRlY3RBZmZlY3RlZExpbmVSYW5nZShwYXJhZ3JhcGgudGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhZmZlY3RlZF9saW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gY2hhbmdlcywgbm8gb2JqZWN0IHRvIHVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmFjdGVkX2xpbmVzID0gZGlmZlNlcnZpY2UuZXh0cmFjdFJhbmdlQnlMaW5lTnVtYmVycyhwYXJhZ3JhcGgudGV4dCwgYWZmZWN0ZWRfbGluZXMuZnJvbSwgYWZmZWN0ZWRfbGluZXMudG8pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IENvbmZpZy5nZXQoJ21vdGlvbnNfbGluZV9sZW5ndGgnKS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZl9odG1sID0gZGlmZlNlcnZpY2UuZm9ybWF0RGlmZldpdGhMaW5lTnVtYmVycyhleHRyYWN0ZWRfbGluZXMsIGxpbmVMZW5ndGgsIGFmZmVjdGVkX2xpbmVzLmZyb20pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY2NlcHRhbmNlX3N0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlamVjdGlvbl9zdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZ2V0UmVjb21tZW5kYXRpb25zKCkuZm9yRWFjaChmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm5hbWUgPT09IFwiYWNjZXB0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdGFuY2Vfc3RhdGUgPSBzdGF0ZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5uYW1lID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Rpb25fc3RhdGUgPSBzdGF0ZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGludGVyZmFjZSBvZiB0aGlzIG9iamVjdCBuZWVkcyB0byBiZSBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgc2FtZSBtZXRob2QgaW4gTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNoYW5nZSBvYmplY3QgbmVlZHMgdG8gYmUgY2FjaGVkIHRvIHByZXZlbnQgY29uZnVzaW5nIEFuZ3VsYXIncyBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgYSBuZXcgb2JqZWN0IHdvdWxkIGJlIGNyZWF0ZWQgd2l0aCBldmVyeSBjYWxsLCBsZWFkaW5nIHRvIGZsaWNrZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFtZW5kbWVudCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZV9vYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGVydGllcyB0aGF0IGFyZSBndWFyYW50ZWVkIHRvIGJlIGNvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2Vfb2JqZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImFtZW5kbWVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCJhbWVuZG1lbnQtXCIgKyBhbWVuZG1lbnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbFwiOiBhbWVuZG1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzYXZlU3RhdHVzXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHN0YXR1cyBuZWVkcyB0byBiZSByZXNldCBmaXJzdCwgYXMgdGhlIHdvcmtmbG93IGRvZXMgbm90IGFsbG93IGNoYW5naW5nIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXB0YW5jZSB0byByZWplY3Rpb24gZGlyZWN0bHkgb3IgdmljZS12ZXJzYS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1lbmRtZW50LnNldFN0YXRlKG51bGwpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFtZW5kbWVudC5fY2hhbmdlX29iamVjdC5hY2NlcHRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtZW5kbWVudC5zZXRTdGF0ZShhY2NlcHRhbmNlX3N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbWVuZG1lbnQuX2NoYW5nZV9vYmplY3QucmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbWVuZG1lbnQuc2V0U3RhdGUocmVqZWN0aW9uX3N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdldERpZmZcIjogZnVuY3Rpb24gKG1vdGlvbiwgdmVyc2lvbiwgaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmX2h0bWwgPSBsaW5lTnVtYmVyaW5nU2VydmljZS5oaWdobGlnaHRMaW5lKGRpZmZfaHRtbCwgaGlnaGxpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZl9odG1sO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0aWVzIHRoYXQgbWlnaHQgY2hhbmdlIHdoZW4gdGhlIEFtZW5kbWVudCBpcyBlZGl0ZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlX29iamVjdC5saW5lX2Zyb20gPSBhZmZlY3RlZF9saW5lcy5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2Vfb2JqZWN0LmxpbmVfdG8gPSBhZmZlY3RlZF9saW5lcy50bztcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2Vfb2JqZWN0LmFjY2VwdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZV9vYmplY3QucmVqZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiYgdGhpcy5zdGF0ZS5uYW1lID09PSAncmVqZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2Vfb2JqZWN0LnJlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUubmFtZSA9PT0gJ2FjY2VwdGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlX29iamVjdC5hY2NlcHRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5yZWNvbW1lbmRhdGlvbiAmJiB0aGlzLnJlY29tbWVuZGF0aW9uLm5hbWUgPT09ICdyZWplY3RlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZV9vYmplY3QucmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgVW5pZmllZENoYW5nZU9iamVjdENvbGxpc3Npb24ucG9wdWxhdGUodGhpcy5fY2hhbmdlX29iamVjdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZV9vYmplY3Q7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXRUZXh0U3RyaXBwaW5nTGluZUJyZWFrczogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gbGluZU51bWJlcmluZ1NlcnZpY2Uuc3RyaXBMaW5lTnVtYmVycyh0ZXh0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldE1vZGlmaWVkRmluYWxWZXJzaW9uU3RyaXBwaW5nTGluZUJyZWFrczogZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RpZmllZF9maW5hbF92ZXJzaW9uID0gbGluZU51bWJlcmluZ1NlcnZpY2Uuc3RyaXBMaW5lTnVtYmVycyhodG1sKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIENvcGllcyB0byBmaW5hbCB2ZXJzaW9uIHRvIHRoZSBtb2RpZmllZF9maW5hbF92ZXJzaW9uIGZpZWxkXG4gICAgICAgICAgICAgICAgY29weU1vZGlmaWVkRmluYWxWZXJzaW9uU3RyaXBwaW5nTGluZUJyZWFrczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxWZXJzaW9uID0gdGhpcy5nZXRUZXh0QnlNb2RlKCdhZ3JlZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRNb2RpZmllZEZpbmFsVmVyc2lvblN0cmlwcGluZ0xpbmVCcmVha3MoZmluYWxWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldE1vZGlmaWVkRmluYWxWZXJzaW9uOiBmdW5jdGlvbiAodmVyc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZlcnNpb24odmVyc2lvbklkKS5tb2RpZmllZF9maW5hbF92ZXJzaW9uO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0UmVhc29uOiBmdW5jdGlvbiAodmVyc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZlcnNpb24odmVyc2lvbklkKS5yZWFzb247XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBmdWxsIHN0YXRlIG5hbWUgLSBvcHRpb25hbCB3aXRoIGN1c3RvbSBzdGF0ZSBuYW1lIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIC8vIGRlcGVuZGVkIGJ5IHN0YXRlIGFuZCBwcm92aWRlZCBieSBhIGN1c3RvbSBjb21tZW50IGZpZWxkXG4gICAgICAgICAgICAgICAgZ2V0U3RhdGVOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKHRoaXMuc3RhdGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5zaG93X3N0YXRlX2V4dGVuc2lvbl9maWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIG1vdGlvbiBjb21tZW50IGZpZWxkcyBmb3IgZmxhZyAnZm9yU3RhdGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnRGaWVsZEZvclN0YXRlSWQgPSBNb3Rpb25Db21tZW50LmdldEZpZWxkSWRGb3JGbGFnKCdmb3JTdGF0ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50RmllbGRGb3JTdGF0ZUlkID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArPSAnICcgKyB0aGlzLmNvbW1lbnRzW2NvbW1lbnRGaWVsZEZvclN0YXRlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW90aW9uU3RhdGVBbmRSZWNvbW1lbmRhdGlvblBhcnNlci5wYXJzZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIElEIG9mIHRoZSBzdGF0ZSAtIG9yIG51bGwsIGlmIHRvIGJlIHJlc2V0XG4gICAgICAgICAgICAgICAgc2V0U3RhdGU6IGZ1bmN0aW9uKHN0YXRlX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZV9pZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRodHRwLnB1dCgnL3Jlc3QvbW90aW9ucy9tb3Rpb24vJyArIHRoaXMuaWQgKyAnL3NldF9zdGF0ZS8nLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGh0dHAucHV0KCcvcmVzdC9tb3Rpb25zL21vdGlvbi8nICsgdGhpcy5pZCArICcvc2V0X3N0YXRlLycsIHsnc3RhdGUnOiBzdGF0ZV9pZH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBmdWxsIHJlY29tbWVuZGF0aW9uIHN0cmluZyAtIG9wdGlvbmFsIHdpdGggY3VzdG9tIHJlY29tbWVuZGF0aW9uZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgLy8gZGVwZW5kZWQgYnkgc3RhdGUgYW5kIHByb3ZpZGVkIGJ5IGEgY3VzdG9tIGNvbW1lbnQgZmllbGRcbiAgICAgICAgICAgICAgICBnZXRSZWNvbW1lbmRhdGlvbk5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29tbWVuZGF0aW9uID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChDb25maWcuZ2V0KCdtb3Rpb25zX3JlY29tbWVuZGF0aW9uc19ieScpLnZhbHVlICE9PSAnJyAmJiB0aGlzLnJlY29tbWVuZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvbW1lbmRhdGlvbiA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZyh0aGlzLnJlY29tbWVuZGF0aW9uLnJlY29tbWVuZGF0aW9uX2xhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY29tbWVuZGF0aW9uLnNob3dfcmVjb21tZW5kYXRpb25fZXh0ZW5zaW9uX2ZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgbW90aW9uIGNvbW1lbnQgZmllbGRzIGZvciBmbGFnICdmb3JSZWNvbW1lbmRhdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudEZpZWxkRm9yUmVjb21tZW5kYXRpb25JZCA9IE1vdGlvbkNvbW1lbnQuZ2V0RmllbGRJZEZvckZsYWcoJ2ZvclJlY29tbWVuZGF0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRGaWVsZEZvclJlY29tbWVuZGF0aW9uSWQgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvbW1lbmRhdGlvbiArPSAnICcgKyB0aGlzLmNvbW1lbnRzW2NvbW1lbnRGaWVsZEZvclJlY29tbWVuZGF0aW9uSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW90aW9uU3RhdGVBbmRSZWNvbW1lbmRhdGlvblBhcnNlci5wYXJzZShyZWNvbW1lbmRhdGlvbik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBJRCBvZiB0aGUgc3RhdGUgLSBvciBudWxsLCBpZiB0byBiZSByZXNldFxuICAgICAgICAgICAgICAgIHNldFJlY29tbWVuZGF0aW9uOiBmdW5jdGlvbihyZWNvbW1lbmRhdGlvbl9pZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb21tZW5kYXRpb25faWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkaHR0cC5wdXQoJy9yZXN0L21vdGlvbnMvbW90aW9uLycgKyB0aGlzLmlkICsgJy9zZXRfcmVjb21tZW5kYXRpb24vJywge30pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRodHRwLnB1dCgnL3Jlc3QvbW90aW9ucy9tb3Rpb24vJyArIHRoaXMuaWQgKyAnL3NldF9yZWNvbW1lbmRhdGlvbi8nLCB7J3JlY29tbWVuZGF0aW9uJzogcmVjb21tZW5kYXRpb25faWR9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gbGluayBuYW1lIHdoaWNoIGlzIHNob3duIGluIHNlYXJjaCByZXN1bHRcbiAgICAgICAgICAgICAgICBnZXRTZWFyY2hSZXN1bHROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRpdGxlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdHJ1ZSBpZiBhIHNwZWNpZmljIHJlbGF0aW9uIG1hdGNoZXMgZm9yIGdpdmVuIHNlYXJjaHF1ZXJ5XG4gICAgICAgICAgICAgICAgLy8gZS5nLiBzdWJtaXR0ZXIsIHN1cHBvcnRlcnMgb3IgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICBoYXNTZWFyY2hSZXN1bHQ6IGZ1bmN0aW9uIChyZXN1bHRzLCBzZWFyY2hxdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW90aW9uID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VhcmNoIGZvciBzdWJtaXR0ZXJzIGFuZCBzdXBwb3J0ZXJzIChjaGVjayBpZiBhbnkgdXNlci5pZCBmcm9tIGFscmVhZHkgZm91bmQgdXNlcnMgbWF0Y2hlcylcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kU29tZXRoaW5nID0gXy5zb21lKHJlc3VsdHMsIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5nZXRSZXNvdXJjZU5hbWUoKSA9PT0gXCJ1c2Vycy91c2VyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5zb21lKG1vdGlvbi5zdWJtaXR0ZXJzLCB7J2lkJzogcmVzdWx0LmlkfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfLnNvbWUobW90aW9uLnN1cHBvcnRlcnMsIHsgJ2lkJzogcmVzdWx0LmlkIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBmb3IgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZFNvbWV0aGluZyAmJiBtb3Rpb24uY2F0ZWdvcnkgJiYgbW90aW9uLmNhdGVnb3J5Lm5hbWUubWF0Y2gobmV3IFJlZ0V4cChzZWFyY2hxdWVyeSwgJ2knKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBmb3IgY2hhbmdlIHJlY29tbWVuZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRTb21ldGhpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWNvbW1lbmRhdGlvbnMgPSBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbi5maWx0ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7bW90aW9uX3ZlcnNpb25faWQ6IHRoaXMuYWN0aXZlX3ZlcnNpb259XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kU29tZXRoaW5nID0gXy5zb21lKHJlY29tbWVuZGF0aW9ucywgZnVuY3Rpb24ocmVjb21tZW5kYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjb21tZW5kYXRpb24udGV4dC5tYXRjaChuZXcgUmVnRXhwKHNlYXJjaHF1ZXJ5LCAnaScpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRTb21ldGhpbmc7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRUZXh0Q2hhbmdlUmVjb21tZW5kYXRpb25zOiBmdW5jdGlvbiAodmVyc2lvbklkLCBvcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIGFsbCBjaGFuZ2UgcmVjb21tZW5kYXRpb25zIGZvciB0aGlzIGdpdmVuIHZlcnNpb24sIHNvcnRlZCBieSBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB2ZXJzaW9uSWRcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIG9yZGVyIFsnREVTQycgb3IgJ0FTQycgKGRlZmF1bHQpXVxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb25JZCA9IHZlcnNpb25JZCB8fCB0aGlzLmFjdGl2ZV92ZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICBvcmRlciA9IG9yZGVyIHx8ICdBU0MnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24uZmlsdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uX3ZlcnNpb25faWQ6IHZlcnNpb25JZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyQnk6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ2xpbmVfZnJvbScsIG9yZGVyXVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlLmlzVGV4dFJlY29tbWVuZGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0VGl0bGVDaGFuZ2VSZWNvbW1lbmRhdGlvbjogZnVuY3Rpb24gKHZlcnNpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgY2hhbmdlIHJlY29tbWVuZGF0aW9uIGFmZmVjdGluZyB0aGUgdGl0bGUsIG9yIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHZlcnNpb25JZFxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbnxudWxsXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uSWQgPSB2ZXJzaW9uSWQgfHwgdGhpcy5hY3RpdmVfdmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbi5maWx0ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb25fdmVyc2lvbl9pZDogdmVyc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfZnJvbTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lX3RvOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNoYW5nZXMubGVuZ3RoID4gMCA/IGNoYW5nZXNbMF0gOiBudWxsKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldEFtZW5kbWVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERTLmZpbHRlcignbW90aW9ucy9tb3Rpb24nLCB7cGFyZW50X2lkOiB0aGlzLmlkfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYXNBbWVuZG1lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEUy5maWx0ZXIoJ21vdGlvbnMvbW90aW9uJywge3BhcmVudF9pZDogdGhpcy5pZH0pLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRQYXJhZ3JhcGhCYXNlZEFtZW5kbWVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERTLmZpbHRlcignbW90aW9ucy9tb3Rpb24nLCB7cGFyZW50X2lkOiB0aGlzLmlkfSkuZmlsdGVyKGZ1bmN0aW9uKGFtZW5kbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhbWVuZG1lbnQuaXNQYXJhZ3JhcGhCYXNlZEFtZW5kbWVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRQYXJhZ3JhcGhCYXNlZEFtZW5kbWVudHNGb3JEaWZmVmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5maWx0ZXIodGhpcy5nZXRQYXJhZ3JhcGhCYXNlZEFtZW5kbWVudHMoKSwgZnVuY3Rpb24oYW1lbmRtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBhY2NlcHRlZC9yZWplY3RlZCBzdGF0dXMgaXMgZ2l2ZW4sIG9ubHkgYW1lbmRtZW50cyB0aGF0IGhhdmUgYSByZWNvbW1lbmRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgXCJhY2NlcHRlZFwiIGFuZCBoYXZlIG5vdCBiZWVuIG9mZmljaWFsbHkgcmVqZWN0ZWQgYXJlIHRvIGJlIHNob3duIGluIHRoZSBkaWZmLXZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbWVuZG1lbnQuc3RhdGUgJiYgYW1lbmRtZW50LnN0YXRlLm5hbWUgPT09ICdyZWplY3RlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW1lbmRtZW50LnN0YXRlICYmIGFtZW5kbWVudC5zdGF0ZS5uYW1lID09PSAnYWNjZXB0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGFtZW5kbWVudC5yZWNvbW1lbmRhdGlvbiAmJiBhbWVuZG1lbnQucmVjb21tZW5kYXRpb24ubmFtZSA9PT0gJ2FjY2VwdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0UGFyZW50TW90aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudF9pZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRzID0gRFMuZmlsdGVyKCdtb3Rpb25zL21vdGlvbicsIHtpZDogdGhpcy5wYXJlbnRfaWR9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNBbGxvd2VkOiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSByZXF1ZXN0ZWQgdXNlciBpcyBhbGxvd2VkIHRvIGRvIHRoZSBzcGVjaWZpYyBhY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZXJlIGFyZSB0aGUgZm9sbG93aW5nIHBvc3NpYmxlIGFjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAqIC0gc2VlXG4gICAgICAgICAgICAgICAgICAgICAqIC0gdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAqIC0gdXBkYXRlX3N1Ym1pdHRlcnNcbiAgICAgICAgICAgICAgICAgICAgICogLSBkZWxldGVcbiAgICAgICAgICAgICAgICAgICAgICogLSBjcmVhdGVfcG9sbFxuICAgICAgICAgICAgICAgICAgICAgKiAtIHN1cHBvcnRcbiAgICAgICAgICAgICAgICAgICAgICogLSB1bnN1cHBvcnRcbiAgICAgICAgICAgICAgICAgICAgICogLSBjaGFuZ2Vfc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICogLSByZXNldF9zdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgKiAtIGNoYW5nZV9jb21tZW50c1xuICAgICAgICAgICAgICAgICAgICAgKiAtIGNoYW5nZV9yZWNvbW1lbmRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgKiAtIGNhbl9tYW5hZ2VcbiAgICAgICAgICAgICAgICAgICAgICogLSBjYW5fc2VlX2FtZW5kbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICogLSBjYW5fY3JlYXRlX2FtZW5kbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogIE5PVEU6IElmIHlvdSB1cGRhdGUgdGhpcyBmdW5jdGlvbiBwbGVhc2UgdGhpbmsgYWJvdXRcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHNlcnZlciBwZXJtaXNzaW9ucywgc2VlIG1vdGlvbnMvdmlld3MucHkuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvci5oYXNQZXJtcygnbW90aW9ucy5jYW5fc2VlJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuc3RhdGUucmVxdWlyZWRfcGVybWlzc2lvbl90b19zZWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLmhhc1Blcm1zKHRoaXMuc3RhdGUucmVxdWlyZWRfcGVybWlzc2lvbl90b19zZWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3BlcmF0b3IudXNlciBpbiB0aGlzLnN1Ym1pdHRlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXBkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvci5oYXNQZXJtcygnbW90aW9ucy5jYW5fbWFuYWdlJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF8uaW5kZXhPZih0aGlzLnN1Ym1pdHRlcnMsIG9wZXJhdG9yLnVzZXIpICE9PSAtMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuYWxsb3dfc3VibWl0dGVyX2VkaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1cGRhdGVfc3VibWl0dGVycyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yLmhhc1Blcm1zKCdtb3Rpb25zLmNhbl9tYW5hZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IuaGFzUGVybXMoJ21vdGlvbnMuY2FuX21hbmFnZScpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfLmluZGV4T2YodGhpcy5zdWJtaXR0ZXJzLCBvcGVyYXRvci51c2VyKSAhPT0gLTEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmFsbG93X3N1Ym1pdHRlcl9lZGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY3JlYXRlX3BvbGwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLmhhc1Blcm1zKCdtb3Rpb25zLmNhbl9tYW5hZ2UnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuYWxsb3dfY3JlYXRlX3BvbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3VwcG9ydCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IuaGFzUGVybXMoJ21vdGlvbnMuY2FuX3N1cHBvcnQnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmFsbG93X3N1cHBvcnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29uZmlnLmdldCgnbW90aW9uc19taW5fc3VwcG9ydGVycycpLnZhbHVlID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXy5pbmRleE9mKHRoaXMuc3VibWl0dGVycywgb3BlcmF0b3IudXNlcikgPT09IC0xKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXy5pbmRleE9mKHRoaXMuc3VwcG9ydGVycywgb3BlcmF0b3IudXNlcikgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1bnN1cHBvcnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmFsbG93X3N1cHBvcnQgJiYgXy5pbmRleE9mKHRoaXMuc3VwcG9ydGVycywgb3BlcmF0b3IudXNlcikgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hhbmdlX3N0YXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IuaGFzUGVybXMoJ21vdGlvbnMuY2FuX21hbmFnZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVzZXRfc3RhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvci5oYXNQZXJtcygnbW90aW9ucy5jYW5fbWFuYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGFuZ2VfY29tbWVudHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvci5oYXNQZXJtcygnbW90aW9ucy5jYW5fbWFuYWdlX2NvbW1lbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGFuZ2VfcmVjb21tZW5kYXRpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvci5oYXNQZXJtcygnbW90aW9ucy5jYW5fbWFuYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjYW5fbWFuYWdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IuaGFzUGVybXMoJ21vdGlvbnMuY2FuX21hbmFnZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2FuX3NlZV9hbWVuZG1lbnRzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvci5oYXNQZXJtcygnbW90aW9ucy5jYW5fY3JlYXRlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQ29uZmlnLmdldCgnbW90aW9uc19hbWVuZG1lbnRzX2VuYWJsZWQnKS52YWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuaGFzQW1lbmRtZW50cygpIHx8IHRoaXMuaXNBbGxvd2VkKCdjYW5fY3JlYXRlX2FtZW5kbWVudCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yLmhhc1Blcm1zKCdtb3Rpb25zLmNhbl9zZWUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBDb25maWcuZ2V0KCdtb3Rpb25zX2FtZW5kbWVudHNfZW5hYmxlZCcpLnZhbHVlICYmIHRoaXMuaGFzQW1lbmRtZW50cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2FuX2NyZWF0ZV9hbWVuZG1lbnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLmhhc1Blcm1zKCdtb3Rpb25zLmNhbl9jcmVhdGUnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb25maWcuZ2V0KCdtb3Rpb25zX2FtZW5kbWVudHNfZW5hYmxlZCcpLnZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggIXRoaXMuaXNBbWVuZG1lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5pc0FtZW5kbWVudCAmJiBPcGVuU2xpZGVzU2V0dGluZ3MuTU9USU9OU19BTExPV19BTUVORE1FTlRTX09GX0FNRU5ETUVOVFMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLyogT3ZlcnJpZGVzIGZyb20ganNEYXRhTW9kZWwgZmFjdG9yeS5cbiAgICAgICAgICAgICAgICAgKiBBbHNvIHNldHMgdGhlIHByb2plY3Rpb24gbW9kZSBpZiBnaXZlbjsgSWYgbm90IGl0IHByb2plY3RzIGluICdvcmlnaW5hbCcgbW9kZS4gKi9cbiAgICAgICAgICAgICAgICBwcm9qZWN0OiBmdW5jdGlvbiAocHJvamVjdG9ySWQsIG1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBvYmplY3QgaXMgYWxyZWFkeSBwcm9qZWN0ZWQgb24gcHJvamVjdG9ySWQsIGRlbGV0ZSB0aGlzIGVsZW1lbnQgZnJvbSB0aGlzIHByb2plY3RvclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9pZHM6IHRoaXMuaXNQcm9qZWN0ZWQoKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2FzIHRoZXJlIGEgcHJvamVjdG9yIHdpdGggdGhlIHNhbWUgaWQgYW5kIG1vZGUgYXMgdGhlIGdpdmVuIGlkIGFuZCBtb2RlP1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QsIHByb2plY3QgdGhlIG1vdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHdhc1Byb2plY3RlZEJlZm9yZSA9IF8uc29tZSh0aGlzLmlzUHJvamVjdGVkV2l0aE1vZGUoKSwgZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IChtYXBwaW5nLnByb2plY3RvcklkID09PSBwcm9qZWN0b3JJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgJiYgKG1hcHBpbmcubW9kZSA9PT0gbW9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBtb2RlID0gbW9kZSB8fCBDb25maWcuZ2V0KCdtb3Rpb25zX3JlY29tbWVuZGF0aW9uX3RleHRfbW9kZScpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdhc1Byb2plY3RlZEJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERhdGEucHJ1bmUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHByb2plY3RvcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb2plY3RIZWxwZXIucHJvamVjdChyZXF1ZXN0RGF0YSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc1Byb2plY3RlZDogZnVuY3Rpb24gKG1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZGljYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVsZW1lbnQubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaWQgPT09IHNlbGYuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgJiYgKGVsZW1lbnQubW9kZSA9PT0gbW9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0b3JJZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKFByb2plY3Rvci5nZXRBbGwoKSwgZnVuY3Rpb24gKHByb2plY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfLmZpbmRLZXkocHJvamVjdG9yLmVsZW1lbnRzLCBwcmVkaWNhdGUpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3Rvcklkcy5wdXNoKHByb2plY3Rvci5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdG9ySWRzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLyogcmV0dXJucyBhIGxpc3Qgb2YgbWFwcGluZ3MgYmV0d2VlbiBwcm9qZWN0b3IgaWQgYW5kIG1vZGU6XG4gICAgICAgICAgICAgICAgICogWyB7cHJvamVjdG9ySWQ6IDIsIG1vZGU6ICdvcmlnaW5hbCd9LCAuLi4gXSAqL1xuICAgICAgICAgICAgICAgIGlzUHJvamVjdGVkV2l0aE1vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwcGluZyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goUHJvamVjdG9yLmdldEFsbCgpLCBmdW5jdGlvbiAocHJvamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2gocHJvamVjdG9yLmVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm5hbWUgPT09IG5hbWUgJiYgZWxlbWVudC5pZCA9PT0gc2VsZi5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdG9ySWQ6IHByb2plY3Rvci5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IGVsZW1lbnQubW9kZSB8fCAnb3JpZ2luYWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXBwaW5nO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNSZWxhdGVkUHJvamVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgbW90aW9uIHJlbGF0ZWQgb2JqZWN0IGlzIHRoZSBsaXN0IG9mIHNwZWFrZXJzICh0aHJvdWdoIHRoZSBhZ2VuZGEgaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWdlbmRhX2l0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFnZW5kYV9pdGVtLmlzTGlzdE9mU3BlYWtlcnNQcm9qZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVsYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgYmVsb25nc1RvOiB7XG4gICAgICAgICAgICAgICAgICAgICdtb3Rpb25zL2NhdGVnb3J5Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGaWVsZDogJ2NhdGVnb3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsS2V5OiAnY2F0ZWdvcnlfaWQnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnbW90aW9ucy9tb3Rpb24tYmxvY2snOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAnbW90aW9uQmxvY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxLZXk6ICdtb3Rpb25fYmxvY2tfaWQnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnYWdlbmRhL2l0ZW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEtleTogJ2FnZW5kYV9pdGVtX2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRmllbGQ6ICdhZ2VuZGFfaXRlbScsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhc01hbnk6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NvcmUvdGFnJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGaWVsZDogJ3RhZ3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxLZXlzOiAndGFnc19pZCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdtZWRpYWZpbGVzL21lZGlhZmlsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRmllbGQ6ICdhdHRhY2htZW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEtleXM6ICdhdHRhY2htZW50c19pZCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICd1c2Vycy91c2VyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGaWVsZDogJ3N1cHBvcnRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxLZXlzOiAnc3VwcG9ydGVyc19pZCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdtb3Rpb25zL21vdGlvbi1wb2xsJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGaWVsZDogJ3BvbGxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmVpZ25LZXk6ICdtb3Rpb25faWQnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnbW90aW9ucy9zdWJtaXR0ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAnc3VibWl0dGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JlaWduS2V5OiAnbW90aW9uX2lkJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhc09uZToge1xuICAgICAgICAgICAgICAgICAgICAnbW90aW9ucy9zdGF0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAnc3RhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsS2V5OiAnc3RhdGVfaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAncmVjb21tZW5kYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsS2V5OiAncmVjb21tZW5kYXRpb25faWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4vLyBTZXJ2aWNlIGZvciBnZW5lcmljIGNvbW1lbnQgZmllbGRzXG4uZmFjdG9yeSgnTW90aW9uQ29tbWVudCcsIFtcbiAgICAnJGZpbHRlcicsXG4gICAgJ0NvbmZpZycsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnRWRpdG9yJyxcbiAgICBmdW5jdGlvbiAoJGZpbHRlciwgQ29uZmlnLCBvcGVyYXRvciwgRWRpdG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1NwZWNpYWxDb21tZW50RmllbGQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQuZm9yU3RhdGUgfHwgZmllbGQuZm9yUmVjb21tZW5kYXRpb247XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRDb21tZW50c0ZpZWxkczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZHMgPSBDb25maWcuZ2V0KCdtb3Rpb25zX2NvbW1lbnRzJykudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRmaWx0ZXIoJ2V4Y2x1ZGVEZWxldGVkQW5kRm9yYmlkZGVuQ29tbWVudHNGaWVsZHMnKShmaWVsZHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldE5vU3BlY2lhbENvbW1lbnRzRmllbGRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZ2V0Q29tbWVudHNGaWVsZHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGZpbHRlcignZXhjbHVkZVNwZWNpYWxDb21tZW50c0ZpZWxkcycpKGZpZWxkcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Rm9ybUZpZWxkczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldE5vU3BlY2lhbENvbW1lbnRzRmllbGRzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ubWFwKGZpZWxkcywgZnVuY3Rpb24gKGZpZWxkLCBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb21tZW50XycgKyBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZWRpdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGZpZWxkLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNrZWRpdG9yT3B0aW9uczogRWRpdG9yLmdldE9wdGlvbnMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTogIW9wZXJhdG9yLmhhc1Blcm1zKFwibW90aW9ucy5jYW5fbWFuYWdlX2NvbW1lbnRzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRGb3JtRmllbGQgOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5nZXROb1NwZWNpYWxDb21tZW50c0ZpZWxkcygpO1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb21tZW50XycgKyBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlZGl0b3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGZpZWxkLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNrZWRpdG9yT3B0aW9uczogRWRpdG9yLmdldE9wdGlvbnMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6ICFvcGVyYXRvci5oYXNQZXJtcyhcIm1vdGlvbnMuY2FuX21hbmFnZV9jb21tZW50c1wiKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3B1bGF0ZUZpZWxkczogZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIGNvbnRlbnQgb2YgbW90aW9uLmNvbW1lbnRzIHRvIHRoZSBzaW5nbGUgY29tbWVudFxuICAgICAgICAgICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldENvbW1lbnRzRmllbGRzKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdGlvbi5jb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goZmllbGRzLCBmdW5jdGlvbiAoZmllbGQsIGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb25bJ2NvbW1lbnRfJyArIGlkXSA9IG1vdGlvbi5jb21tZW50c1tpZF07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3B1bGF0ZUZpZWxkc1JldmVyc2U6IGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBSZXZlcnNlIGVxdWl2YWxlbnQgdG8gcG9wdWxhdGVGaWVsZHMuXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZ2V0Q29tbWVudHNGaWVsZHMoKTtcbiAgICAgICAgICAgICAgICBtb3Rpb24uY29tbWVudHMgPSB7fTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goZmllbGRzLCBmdW5jdGlvbiAoZmllbGQsIGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdGlvbi5jb21tZW50c1tpZF0gPSBtb3Rpb25bJ2NvbW1lbnRfJyArIGlkXSB8fCAnJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRGaWVsZElkRm9yRmxhZzogZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5nZXRDb21tZW50c0ZpZWxkcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfLmZpbmRLZXkoZmllbGRzLCBbZmxhZywgdHJ1ZV0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uZmlsdGVyKCdleGNsdWRlU3BlY2lhbENvbW1lbnRzRmllbGRzJywgW1xuICAgICdNb3Rpb25Db21tZW50JyxcbiAgICBmdW5jdGlvbiAoTW90aW9uQ29tbWVudCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbW1lbnRzRmllbGRzKSB7XG4gICAgICAgICAgICB2YXIgd2l0aG91dFNwZWNpYWxDb21tZW50c0ZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgXy5mb3JFYWNoKGNvbW1lbnRzRmllbGRzLCBmdW5jdGlvbiAoZmllbGQsIGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFNb3Rpb25Db21tZW50LmlzU3BlY2lhbENvbW1lbnRGaWVsZChmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2l0aG91dFNwZWNpYWxDb21tZW50c0ZpZWxkc1tpZF0gPSBmaWVsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3BlY2lhbENvbW1lbnRzRmllbGRzO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5maWx0ZXIoJ2V4Y2x1ZGVEZWxldGVkQW5kRm9yYmlkZGVuQ29tbWVudHNGaWVsZHMnLCBbXG4gICAgJ01vdGlvbkNvbW1lbnQnLFxuICAgICdvcGVyYXRvcicsXG4gICAgZnVuY3Rpb24gKE1vdGlvbkNvbW1lbnQsIG9wZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29tbWVudHNGaWVsZHMpIHtcbiAgICAgICAgICAgIHZhciB3aXRob3V0RGVsZXRlZEFuZEZvcmJpZGRlbkNvbW1lbnRzRmllbGRzID0ge307XG4gICAgICAgICAgICBfLmZvckVhY2goY29tbWVudHNGaWVsZHMsIGZ1bmN0aW9uIChmaWVsZCwgaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQgJiYgKGZpZWxkLnB1YmxpYyB8fCBvcGVyYXRvci5oYXNQZXJtcygnbW90aW9ucy5jYW5fc2VlX2NvbW1lbnRzJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpdGhvdXREZWxldGVkQW5kRm9yYmlkZGVuQ29tbWVudHNGaWVsZHNbaWRdID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dERlbGV0ZWRBbmRGb3JiaWRkZW5Db21tZW50c0ZpZWxkcztcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnQ2F0ZWdvcnknLCBbXG4gICAgJ0RTJyxcbiAgICBmdW5jdGlvbihEUykge1xuICAgICAgICByZXR1cm4gRFMuZGVmaW5lUmVzb3VyY2Uoe1xuICAgICAgICAgICAgbmFtZTogJ21vdGlvbnMvY2F0ZWdvcnknLFxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24nLCBbXG4gICAgJ0RTJyxcbiAgICAnQ29uZmlnJyxcbiAgICAnanNEYXRhTW9kZWwnLFxuICAgICdkaWZmU2VydmljZScsXG4gICAgJ2xpbmVOdW1iZXJpbmdTZXJ2aWNlJyxcbiAgICAnVW5pZmllZENoYW5nZU9iamVjdENvbGxpc3Npb24nLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgZnVuY3Rpb24gKERTLCBDb25maWcsIGpzRGF0YU1vZGVsLCBkaWZmU2VydmljZSwgbGluZU51bWJlcmluZ1NlcnZpY2UsXG4gICAgICAgIFVuaWZpZWRDaGFuZ2VPYmplY3RDb2xsaXNzaW9uLCBnZXR0ZXh0Q2F0YWxvZykge1xuICAgICAgICByZXR1cm4gRFMuZGVmaW5lUmVzb3VyY2Uoe1xuICAgICAgICAgICAgbmFtZTogJ21vdGlvbnMvbW90aW9uLWNoYW5nZS1yZWNvbW1lbmRhdGlvbicsXG4gICAgICAgICAgICB1c2VDbGFzczoganNEYXRhTW9kZWwsXG4gICAgICAgICAgICBtZXRob2RzOiB7XG4gICAgICAgICAgICAgICAgc2F2ZVN0YXR1czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRFNTYXZlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc1RpdGxlUmVjb21tZW5kYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMubGluZV9mcm9tID09PSAwICYmIHRoaXMubGluZV90byA9PT0gMCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc1RleHRSZWNvbW1lbmRhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5saW5lX2Zyb20gIT09IDAgfHwgdGhpcy5saW5lX3RvICE9PSAwKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldERpZmY6IGZ1bmN0aW9uKG1vdGlvbiwgdmVyc2lvbiwgaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gQ29uZmlnLmdldCgnbW90aW9uc19saW5lX2xlbmd0aCcpLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCA9IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLmluc2VydExpbmVOdW1iZXJzKG1vdGlvbi5nZXRWZXJzaW9uKHZlcnNpb24pLnRleHQsIGxpbmVMZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSwgb2xkVGV4dDtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRpZmZTZXJ2aWNlLmV4dHJhY3RSYW5nZUJ5TGluZU51bWJlcnMoaHRtbCwgdGhpcy5saW5lX2Zyb20sIHRoaXMubGluZV90byk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRUZXh0ID0gZGF0YS5vdXRlckNvbnRleHRTdGFydCArIGRhdGEuaW5uZXJDb250ZXh0U3RhcnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaHRtbCArIGRhdGEuaW5uZXJDb250ZXh0RW5kICsgZGF0YS5vdXRlckNvbnRleHRFbmQ7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgb25seSBoYXBwZW5zIChhcyBmYXIgYXMgd2Uga25vdykgd2hlbiB0aGUgbW90aW9uIHRleHQgaGFzIGJlZW4gYWx0ZXJlZCAoc2hvcnRlbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aG91dCBtb2RpZnlpbmcgdGhlIGNoYW5nZSByZWNvbW1lbmRhdGlvbnMgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGF0J3MgYSBwcmV0dHkgc2VyaW91cyBpbmNvbnNpc3RlbmN5IHRoYXQgc2hvdWxkIG5vdCBoYXBwZW4gYXQgYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUganVzdCBkb2luZyBzb21lIGJhc2ljIGRhbWFnZSBjb250cm9sIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ0luY29uc2lzdGVudCBkYXRhLiBBIGNoYW5nZSByZWNvbW1lbmRhdGlvbiBpcyBwcm9iYWJseSByZWZlcnJpbmcgdG8gYSBub24tZXhpc3RhbnQgbGluZSBudW1iZXIuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnPGVtIHN0eWxlPVwiY29sb3I6IHJlZDsgZm9udC13ZWlnaHQ6IGJvbGQ7XCI+JyArIG1zZyArICc8L2VtPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb2xkVGV4dCA9IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLmluc2VydExpbmVOdW1iZXJzKG9sZFRleHQsIGxpbmVMZW5ndGgsIG51bGwsIG51bGwsIHRoaXMubGluZV9mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBkaWZmU2VydmljZS5kaWZmKG9sZFRleHQsIHRoaXMudGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW4gaW5zZXJ0aW9uIG1ha2VzIHRoZSBsaW5lIGxvbmdlciB0aGFuIHRoZSBsaW5lIGxlbmd0aCBsaW1pdCwgd2UgbmVlZCB0d28gbGluZSBicmVha2luZyBydW5zOlxuICAgICAgICAgICAgICAgICAgICAvLyAtIEZpcnN0LCBmb3IgdGhlIG9mZmljaWFsIGxpbmUgbnVtYmVycywgaWdub3JpbmcgaW5zZXJ0aW9ucyAodGhhdCdzIGJlZW4gZG9uZSBzb21lIGxpbmVzIGJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBTZWNvbmQsIGFub3RoZXIgb25lIHRvIHByZXZlbnQgdGhlIGRpc3BsYXllZCBpbmNsdWRpbmcgaW5zZXJ0aW9ucyB0byBleGNlZWQgdGhlIHBhZ2Ugd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA9IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLmluc2VydExpbmVCcmVha3NXaXRob3V0TnVtYmVycyhkaWZmLCBsaW5lTGVuZ3RoLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiA9IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLmhpZ2hsaWdodExpbmUoZGlmZiwgaGlnaGxpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnQmVnaW5uaW5nID0gZGF0YS5vdXRlckNvbnRleHRTdGFydCArIGRhdGEuaW5uZXJDb250ZXh0U3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWZmLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihvcmlnQmVnaW5uaW5nLnRvTG93ZXJDYXNlKCkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgXCJtZXJnZS1iZWZvcmVcIi1jc3MtY2xhc3MgaWYgdGhlIGZpcnN0IGxpbmUgYmVnaW5zIGluIHRoZSBtaWRkbGUgb2YgYSBwYXJhZ3JhcGguIFVzZWQgZm9yIFBERi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBkaWZmU2VydmljZS5hZGRDU1NDbGFzc1RvRmlyc3RUYWcob3JpZ0JlZ2lubmluZywgXCJtZXJnZS1iZWZvcmVcIikgKyBkaWZmLnN1YnN0cmluZyhvcmlnQmVnaW5uaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKG9yaWdpbmFsX2Z1bGxfaHRtbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0VGl0bGU6IGZ1bmN0aW9uKG9yaWdpbmFsX2Z1bGxfaHRtbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbmVfdG8gPiAodGhpcy5saW5lX2Zyb20gKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJyVUWVBFJSBmcm9tIGxpbmUgJUZST00lIHRvICVUTyUnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCclVFlQRSUgaW4gbGluZSAlRlJPTSUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0VHlwZShvcmlnaW5hbF9mdWxsX2h0bWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGRpZmZTZXJ2aWNlLlRZUEVfSU5TRVJUSU9OOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gdGl0bGUucmVwbGFjZSgnJVRZUEUlJywgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdJbnNlcnRpb24nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGRpZmZTZXJ2aWNlLlRZUEVfREVMRVRJT046XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSB0aXRsZS5yZXBsYWNlKCclVFlQRSUnLCBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0RlbGV0aW9uJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBkaWZmU2VydmljZS5UWVBFX1JFUExBQ0VNRU5UOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gdGl0bGUucmVwbGFjZSgnJVRZUEUlJywgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdSZXBsYWNlbWVudCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgZGlmZlNlcnZpY2UuVFlQRV9PVEhFUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHRpdGxlLnJlcGxhY2UoJyVUWVBFJScsIHRoaXMub3RoZXJfZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gdGl0bGUucmVwbGFjZSgnJUZST00lJywgdGhpcy5saW5lX2Zyb20pLnJlcGxhY2UoJyVUTyUnLCAodGhpcy5saW5lX3RvIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGl0bGU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRVbmlmaWVkQ2hhbmdlT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBpbnRlcmZhY2Ugb2YgdGhpcyBvYmplY3QgbmVlZHMgdG8gYmUgc3luY2hyb25pemVkIHdpdGggdGhlIHNhbWUgbWV0aG9kIGluIE1vdGlvblxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY2hhbmdlIG9iamVjdCBuZWVkcyB0byBiZSBjYWNoZWQgdG8gcHJldmVudCBjb25mdXNpbmcgQW5ndWxhcidzIGNoYW5nZSBkZXRlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhIG5ldyBvYmplY3Qgd291bGQgYmUgY3JlYXRlZCB3aXRoIGV2ZXJ5IGNhbGwsIGxlYWRpbmcgdG8gZmxpY2tlcmluZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb21tZW5kYXRpb24gPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2Vfb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgdGhhdCBhcmUgZ3VhcmFudGVlZCB0byBiZSBjb25zdGFudFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlX29iamVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJyZWNvbW1lbmRhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3RoZXJfZGVzY3JpcHRpb25cIjogcmVjb21tZW5kYXRpb24ub3RoZXJfZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcInJlY29tbWVuZGF0aW9uLVwiICsgcmVjb21tZW5kYXRpb24uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbFwiOiByZWNvbW1lbmRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNhdmVTdGF0dXNcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvbW1lbmRhdGlvbi5yZWplY3RlZCA9IHJlY29tbWVuZGF0aW9uLl9jaGFuZ2Vfb2JqZWN0LnJlamVjdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvbW1lbmRhdGlvbi5zYXZlU3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdldERpZmZcIjogZnVuY3Rpb24gKG1vdGlvbiwgdmVyc2lvbiwgaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNvbW1lbmRhdGlvbi5nZXREaWZmKG1vdGlvbiwgdmVyc2lvbiwgaGlnaGxpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgdGhhdCBtaWdodCBjaGFuZ2Ugd2hlbiB0aGUgQ2hhbmdlIFJlY29tbWVuZGF0aW9uIGlzIGVkaXRlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2Vfb2JqZWN0LmxpbmVfZnJvbSA9IHJlY29tbWVuZGF0aW9uLmxpbmVfZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlX29iamVjdC5saW5lX3RvID0gcmVjb21tZW5kYXRpb24ubGluZV90bztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlX29iamVjdC5yZWplY3RlZCA9IHJlY29tbWVuZGF0aW9uLnJlamVjdGVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2Vfb2JqZWN0LmFjY2VwdGVkID0gIXJlY29tbWVuZGF0aW9uLnJlamVjdGVkO1xuXG4gICAgICAgICAgICAgICAgICAgIFVuaWZpZWRDaGFuZ2VPYmplY3RDb2xsaXNzaW9uLnBvcHVsYXRlKHRoaXMuX2NoYW5nZV9vYmplY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2Vfb2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ1VuaWZpZWRDaGFuZ2VPYmplY3RDb2xsaXNzaW9uJywgW1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgb2JqLm90aGVyQ2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgICAgIG9iai5zZXRPdGhlckNoYW5nZXNGb3JDb2xsaXNzaW9uID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLm90aGVyQ2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvYmouZ2V0Q29sbGlzc2lvbnMgPSBmdW5jdGlvbihvbmx5QWNjZXB0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5vdGhlckNoYW5nZXMuZmlsdGVyKGZ1bmN0aW9uKG90aGVyQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25seUFjY2VwdGVkICYmICFvdGhlckNoYW5nZS5hY2NlcHRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAob3RoZXJDaGFuZ2UuaWQgIT09IG9iai5pZCAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG90aGVyQ2hhbmdlLmxpbmVfZnJvbSA+PSBvYmoubGluZV9mcm9tICYmIG90aGVyQ2hhbmdlLmxpbmVfZnJvbSA8IG9iai5saW5lX3RvKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvdGhlckNoYW5nZS5saW5lX3RvID4gb2JqLmxpbmVfZnJvbSAmJiBvdGhlckNoYW5nZS5saW5lX3RvIDw9IG9iai5saW5lX3RvKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvdGhlckNoYW5nZS5saW5lX2Zyb20gPCBvYmoubGluZV9mcm9tICYmIG90aGVyQ2hhbmdlLmxpbmVfdG8gPiBvYmoubGluZV90bylcbiAgICAgICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9iai5nZXRBY2NlcHRlZENvbGxpc3Npb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmouZ2V0Q29sbGlzc2lvbnMoKS5maWx0ZXIoZnVuY3Rpb24oY29sbGlkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGlkaW5nLmFjY2VwdGVkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9iai5zZXRBY2NlcHRlZCA9IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmdldEFjY2VwdGVkQ29sbGlzc2lvbnMoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvYmouYWNjZXB0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvYmoucmVqZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLnNhdmVTdGF0dXMoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9iai5zZXRSZWplY3RlZCA9IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBvYmoucmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvYmouYWNjZXB0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLnNhdmVTdGF0dXMoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4ucnVuKFtcbiAgICAnTW90aW9uJyxcbiAgICAnQ2F0ZWdvcnknLFxuICAgICdXb3JrZmxvdycsXG4gICAgJ01vdGlvblN0YXRlJyxcbiAgICAnTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24nLFxuICAgICdTdWJtaXR0ZXInLFxuICAgIGZ1bmN0aW9uKE1vdGlvbiwgQ2F0ZWdvcnksIFdvcmtmbG93LCBNb3Rpb25TdGF0ZSwgTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24sIFN1Ym1pdHRlcikge31cbl0pXG5cblxuLy8gTWFyayBhbGwgbW90aW9uIHdvcmtmbG93IHN0YXRlIHN0cmluZ3MgZm9yIHRyYW5zbGF0aW9uIGluIEphdmFTY3JpcHQuXG4vLyAoc2VlIG1vdGlvbnMvc2lnbmFscy5weSlcbi5jb25maWcoW1xuICAgICdnZXR0ZXh0JyxcbiAgICBmdW5jdGlvbiAoZ2V0dGV4dCkge1xuICAgICAgICAvLyB3b3JrZmxvdyAxXG4gICAgICAgIGdldHRleHQoJ1NpbXBsZSBXb3JrZmxvdycpO1xuICAgICAgICBnZXR0ZXh0KCdzdWJtaXR0ZWQnKTtcbiAgICAgICAgZ2V0dGV4dCgnYWNjZXB0ZWQnKTtcbiAgICAgICAgZ2V0dGV4dCgnQWNjZXB0Jyk7XG4gICAgICAgIGdldHRleHQoJ0FjY2VwdGFuY2UnKTtcbiAgICAgICAgZ2V0dGV4dCgncmVqZWN0ZWQnKTtcbiAgICAgICAgZ2V0dGV4dCgnUmVqZWN0Jyk7XG4gICAgICAgIGdldHRleHQoJ1JlamVjdGlvbicpO1xuICAgICAgICBnZXR0ZXh0KCdub3QgZGVjaWRlZCcpO1xuICAgICAgICBnZXR0ZXh0KCdEbyBub3QgZGVjaWRlJyk7XG4gICAgICAgIGdldHRleHQoJ05vIGRlY2lzaW9uJyk7XG4gICAgICAgIC8vIHdvcmtmbG93IDJcbiAgICAgICAgZ2V0dGV4dCgnQ29tcGxleCBXb3JrZmxvdycpO1xuICAgICAgICBnZXR0ZXh0KCdwdWJsaXNoZWQnKTtcbiAgICAgICAgZ2V0dGV4dCgncGVybWl0dGVkJyk7XG4gICAgICAgIGdldHRleHQoJ1Blcm1pdCcpO1xuICAgICAgICBnZXR0ZXh0KCdQZXJtaXNzaW9uJyk7XG4gICAgICAgIGdldHRleHQoJ2FjY2VwdGVkJyk7XG4gICAgICAgIGdldHRleHQoJ0FjY2VwdCcpO1xuICAgICAgICBnZXR0ZXh0KCdBY2NlcHRhbmNlJyk7XG4gICAgICAgIGdldHRleHQoJ3JlamVjdGVkJyk7XG4gICAgICAgIGdldHRleHQoJ1JlamVjdCcpO1xuICAgICAgICBnZXR0ZXh0KCdSZWplY3Rpb24nKTtcbiAgICAgICAgZ2V0dGV4dCgnd2l0aGRyYXdlZCcpO1xuICAgICAgICBnZXR0ZXh0KCdXaXRoZHJhdycpO1xuICAgICAgICBnZXR0ZXh0KCdhZGpvdXJuZWQnKTtcbiAgICAgICAgZ2V0dGV4dCgnQWRqb3VybicpO1xuICAgICAgICBnZXR0ZXh0KCdBZGpvdXJubWVudCcpO1xuICAgICAgICBnZXR0ZXh0KCdub3QgY29uY2VybmVkJyk7XG4gICAgICAgIGdldHRleHQoJ0RvIG5vdCBjb25jZXJuJyk7XG4gICAgICAgIGdldHRleHQoJ05vIGNvbmNlcm5tZW50Jyk7XG4gICAgICAgIGdldHRleHQoJ3JlZmVyZWQgdG8gY29tbWl0dGVlJyk7XG4gICAgICAgIGdldHRleHQoJ1JlZmVyIHRvIGNvbW1pdHRlZScpO1xuICAgICAgICBnZXR0ZXh0KCdSZWZlcnJhbCB0byBjb21taXR0ZWUnKTtcbiAgICAgICAgZ2V0dGV4dCgnbmVlZHMgcmV2aWV3Jyk7XG4gICAgICAgIGdldHRleHQoJ05lZWRzIHJldmlldycpO1xuICAgICAgICBnZXR0ZXh0KCdyZWplY3RlZCAobm90IGF1dGhvcml6ZWQpJyk7XG4gICAgICAgIGdldHRleHQoJ1JlamVjdCAobm90IGF1dGhvcml6ZWQpJyk7XG4gICAgICAgIGdldHRleHQoJ1JlamVjdGlvbiAobm90IGF1dGhvcml6ZWQpJyk7XG4gICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmFuZ3VsYXIubW9kdWxlKCdPcGVuU2xpZGVzQXBwLm1vdGlvbnMuY3N2JywgW10pXG5cbi5mYWN0b3J5KCdNb3Rpb25Dc3ZFeHBvcnQnLCBbXG4gICAgJyRmaWx0ZXInLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0NvbmZpZycsXG4gICAgJ0NzdkRvd25sb2FkJyxcbiAgICAnbGluZU51bWJlcmluZ1NlcnZpY2UnLFxuICAgIGZ1bmN0aW9uICgkZmlsdGVyLCBnZXR0ZXh0Q2F0YWxvZywgQ29uZmlnLCBDc3ZEb3dubG9hZCwgbGluZU51bWJlcmluZ1NlcnZpY2UpIHtcbiAgICAgICAgdmFyIG1ha2VIZWFkZXJsaW5lID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGhlYWRlcmxpbmUgPSBbJ0lkZW50aWZpZXInLCAnVGl0bGUnXTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuaW5jbHVkZS50ZXh0KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVybGluZS5wdXNoKCdUZXh0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zLmluY2x1ZGUucmVhc29uKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVybGluZS5wdXNoKCdSZWFzb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMuaW5jbHVkZS5zdWJtaXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVybGluZS5wdXNoKCdTdWJtaXR0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRlcmxpbmUucHVzaCgnQ2F0ZWdvcnknKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuaW5jbHVkZS5vcmlnaW4pIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJsaW5lLnB1c2goJ09yaWdpbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5pbmNsdWRlLm1vdGlvbkJsb2NrKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVybGluZS5wdXNoKCdNb3Rpb24gYmxvY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfLm1hcChoZWFkZXJsaW5lLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXhwb3J0OiBmdW5jdGlvbiAobW90aW9ucywgcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF8uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVJlY29tbWVuZGF0aW9uTW9kZTogQ29uZmlnLmdldCgnbW90aW9uc19yZWNvbW1lbmRhdGlvbl90ZXh0X21vZGUnKS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pdHRlcnM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb25CbG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb21tZW5kYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmZpbGVuYW1lID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdtb3Rpb25zJykgKyAnLmNzdic7XG4gICAgICAgICAgICAgICAgaWYgKCFfLmluY2x1ZGVzKFsnb3JpZ2luYWwnLCAnY2hhbmdlZCcsICdhZ3JlZWQnXSwgcGFyYW1zLmNoYW5nZVJlY29tbWVuZGF0aW9uTW9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNoYW5nZVJlY29tbWVuZGF0aW9uTW9kZSA9ICdvcmlnaW5hbCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNzdlJvd3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIG1ha2VIZWFkZXJsaW5lKHBhcmFtcylcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChtb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gbW90aW9uLmdldFRleHRCeU1vZGUocGFyYW1zLmNoYW5nZVJlY29tbWVuZGF0aW9uTW9kZSwgbnVsbCwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gW107XG4gICAgICAgICAgICAgICAgICAgIC8vIElkZW50aWZpZXIgYW5kIHRpdGxlXG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCdcIicgKyBtb3Rpb24uaWRlbnRpZmllciAhPT0gbnVsbCA/IG1vdGlvbi5pZGVudGlmaWVyIDogJycgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goJ1wiJyArIG1vdGlvbi5nZXRUaXRsZSgpICsgJ1wiJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGV4dFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmluY2x1ZGUudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goJ1wiJyArIHRleHQgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlYXNvblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmluY2x1ZGUucmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgnXCInICsgbW90aW9uLmdldFJlYXNvbigpICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTdWJtaXR0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaW5jbHVkZS5zdWJtaXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VibWl0dGVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKCRmaWx0ZXIoJ29yZGVyQnknKShtb3Rpb24uc3VibWl0dGVycywgJ3dlaWdodCcpLCBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1c2VyX3Nob3J0X25hbWUgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIudXNlci50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlci51c2VyLmZpcnN0X25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIudXNlci5sYXN0X25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VibWl0dGVycy5wdXNoKHVzZXJfc2hvcnRfbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCdcIicgKyBzdWJtaXR0ZXJzLmpvaW4oJzsgJykgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhdGVnb3J5XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXRlZ29yeSA9IG1vdGlvbi5jYXRlZ29yeSA/IG1vdGlvbi5jYXRlZ29yeS5uYW1lIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCdcIicgKyBjYXRlZ29yeSArICdcIicpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9yaWdpblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmluY2x1ZGUub3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgnXCInICsgbW90aW9uLm9yaWdpbiArICdcIicpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTW90aW9uIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaW5jbHVkZS5tb3Rpb25CbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrVGl0bGUgPSBtb3Rpb24ubW90aW9uQmxvY2sgPyBtb3Rpb24ubW90aW9uQmxvY2sudGl0bGUgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCdcIicgKyBibG9ja1RpdGxlICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjc3ZSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBDc3ZEb3dubG9hZChjc3ZSb3dzLCBwYXJhbXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvd25sb2FkRXhhbXBsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjc3ZSb3dzID0gW21ha2VIZWFkZXJsaW5lKHsgaW5jbHVkZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pdHRlcnM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb25CbG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb21tZW5kYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH19KSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhhbXBsZSBlbnRyaWVzXG4gICAgICAgICAgICAgICAgICAgIFsnQTEnLCAnVGl0bGUgMScsICdUZXh0IDEnLCAnUmVhc29uIDEnLCAnU3VibWl0dGVyIEEnLCAnQ2F0ZWdvcnkgQScsICdMYXN0IFllYXIgQ29uZmVyZW5jZSBBJywgJ0Jsb2NrIEEnXSxcbiAgICAgICAgICAgICAgICAgICAgWydCMScsICdUaXRsZSAyJywgJ1RleHQgMicsICdSZWFzb24gMicsICdTdWJtaXR0ZXIgQicsICdDYXRlZ29yeSBCJywgJycsICdCbG9jayBBJ10sXG4gICAgICAgICAgICAgICAgICAgIFsnJyAgLCAnVGl0bGUgMycsICdUZXh0IDMnLCAnJywgJycsICcnLCAnJywgJyddLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgQ3N2RG93bmxvYWQoY3N2Um93cywgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdtb3Rpb25zLWV4YW1wbGUnKSArICcuY3N2Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdBbWVuZG1lbnRDc3ZFeHBvcnQnLCBbXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnQ3N2RG93bmxvYWQnLFxuICAgICdsaW5lTnVtYmVyaW5nU2VydmljZScsXG4gICAgZnVuY3Rpb24gKGdldHRleHRDYXRhbG9nLCBDc3ZEb3dubG9hZCwgbGluZU51bWJlcmluZ1NlcnZpY2UpIHtcbiAgICAgICAgdmFyIG1ha2VIZWFkZXJsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhlYWRlcmxpbmUgPSBbJ0lkZW50aWZpZXInLCAnU3VibWl0dGVycycsICdDYXRlZ29yeScsICdNb3Rpb24gYmxvY2snLFxuICAgICAgICAgICAgICAgICdMZWFkbW90aW9uJywgJ0xpbmUnLCAnT2xkIHRleHQnLCAnTmV3IHRleHQnXTtcbiAgICAgICAgICAgIHJldHVybiBfLm1hcChoZWFkZXJsaW5lLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXhwb3J0OiBmdW5jdGlvbiAoYW1lbmRtZW50cykge1xuICAgICAgICAgICAgICAgIHZhciBjc3ZSb3dzID0gW1xuICAgICAgICAgICAgICAgICAgICBtYWtlSGVhZGVybGluZSgpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goYW1lbmRtZW50cywgZnVuY3Rpb24gKGFtZW5kbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gW107XG4gICAgICAgICAgICAgICAgICAgIC8vIElkZW50aWZpZXIgYW5kIHRpdGxlXG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCdcIicgKyBhbWVuZG1lbnQuaWRlbnRpZmllciAhPT0gbnVsbCA/IGFtZW5kbWVudC5pZGVudGlmaWVyIDogJycgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VibWl0dGVyc1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VibWl0dGVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goYW1lbmRtZW50LnN1Ym1pdHRlcnMsIGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1c2VyX3Nob3J0X25hbWUgPSBbdXNlci50aXRsZSwgdXNlci5maXJzdF9uYW1lLCB1c2VyLmxhc3RfbmFtZV0uam9pbignICcpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pdHRlcnMucHVzaCh1c2VyX3Nob3J0X25hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goJ1wiJyArIHN1Ym1pdHRlcnMuam9pbignOyAnKSArICdcIicpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhdGVnb3J5XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXRlZ29yeSA9IGFtZW5kbWVudC5jYXRlZ29yeSA/IGFtZW5kbWVudC5jYXRlZ29yeS5uYW1lIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCdcIicgKyBjYXRlZ29yeSArICdcIicpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdGlvbiBibG9ja1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tUaXRsZSA9IGFtZW5kbWVudC5tb3Rpb25CbG9jayA/IGFtZW5kbWVudC5tb3Rpb25CbG9jay50aXRsZSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgnXCInICsgYmxvY2tUaXRsZSArICdcIicpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIExlYWQgbW90aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWFkbW90aW9uID0gYW1lbmRtZW50LmdldFBhcmVudE1vdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVhZG1vdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlYWRtb3Rpb25UaXRsZSA9IGxlYWRtb3Rpb24uaWRlbnRpZmllciA/IGxlYWRtb3Rpb24uaWRlbnRpZmllciArICc6ICcgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYWRtb3Rpb25UaXRsZSArPSBsZWFkbW90aW9uLmdldFRpdGxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgnXCInICsgbGVhZG1vdGlvblRpdGxlICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgnXCJcIicpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlZCBwYXJhZ3JhcGhcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFtZW5kbWVudC5pc1BhcmFncmFwaEJhc2VkQW1lbmRtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGdldCBvbGQgYW5kIG5ldyBwYXJhZ3JhcGhMaW5lLiBSZXNvbHZlIHRvZG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIG1vdGlvbi5nZXRBbWVuZG1lbnRQYXJhZ3JhcGhzTGluZXNCeU1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwX29sZCA9IGFtZW5kbWVudC5nZXRBbWVuZG1lbnRQYXJhZ3JhcGhzTGluZXNCeU1vZGUoJ29yaWdpbmFsJywgbnVsbCwgZmFsc2UpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgcF9uZXcgPSBhbWVuZG1lbnQuZ2V0QW1lbmRtZW50UGFyYWdyYXBoc0xpbmVzQnlNb2RlKCdjaGFuZ2VkJywgbnVsbCwgZmFsc2UpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVTdHIgPSBwX29sZC5kaWZmTGluZUZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocF9vbGQuZGlmZkxpbmVUbyAhPSBwX29sZC5kaWZmTGluZUZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVN0ciArPSAnLScgKyBwX29sZC5kaWZmTGluZVRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goJ1wiJyArIGxpbmVTdHIgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcm93LnB1c2goJ1wiJyArIHBfb2xkLnRleHQuaHRtbCArICdcIicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9yb3cucHVzaCgnXCInICsgcF9uZXcudGV4dC5odG1sICsgJ1wiJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kOiBFeHBvcnQgdGhlIGZ1bGwgcGFyYWdyYXBocyBpbnN0ZWFkIG9mIGNoYW5nZWQgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCdcIicgKyBhbWVuZG1lbnQuZ2V0QW1lbmRtZW50UGFyYWdyYXBoc0J5TW9kZSgnb3JpZ2luYWwnLCBudWxsLCBmYWxzZSlbMF0udGV4dCArICdcIicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goJ1wiJyArIGFtZW5kbWVudC5nZXRBbWVuZG1lbnRQYXJhZ3JhcGhzQnlNb2RlKCdjaGFuZ2VkJywgbnVsbCwgZmFsc2UpWzBdLnRleHQgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCdcIlwiJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgnXCJcIicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goJ1wiJyArIGFtZW5kbWVudC5nZXRUZXh0KCkgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNzdlJvd3MucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIENzdkRvd25sb2FkKGNzdlJvd3MsICdhbWVuZG1lbnRzLWV4cG9ydC5jc3YnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAubW90aW9ucy5kaWZmJywgWydPcGVuU2xpZGVzQXBwLm1vdGlvbnMubGluZU51bWJlcmluZyddKVxuXG4uc2VydmljZSgnZGlmZlNlcnZpY2UnLCBbXG4gICAgJ2xpbmVOdW1iZXJpbmdTZXJ2aWNlJyxcbiAgICAnJGNhY2hlRmFjdG9yeScsXG4gICAgZnVuY3Rpb24gKGxpbmVOdW1iZXJpbmdTZXJ2aWNlLCAkY2FjaGVGYWN0b3J5KSB7XG4gICAgICAgIHZhciBFTEVNRU5UX05PREUgPSAxLFxuICAgICAgICAgICAgVEVYVF9OT0RFID0gMyxcbiAgICAgICAgICAgIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuICAgICAgICB2YXIgZGlmZkNhY2hlID0gJGNhY2hlRmFjdG9yeSgnZGlmZi5zZXJ2aWNlJyk7XG5cbiAgICAgICAgdGhpcy5UWVBFX1JFUExBQ0VNRU5UID0gMDtcbiAgICAgICAgdGhpcy5UWVBFX0lOU0VSVElPTiA9IDE7XG4gICAgICAgIHRoaXMuVFlQRV9ERUxFVElPTiA9IDI7XG4gICAgICAgIHRoaXMuVFlQRV9PVEhFUiA9IDM7XG5cbiAgICAgICAgdGhpcy5nZXRMaW5lTnVtYmVyTm9kZSA9IGZ1bmN0aW9uKGZyYWdtZW50LCBsaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQucXVlcnlTZWxlY3Rvcignb3MtbGluZWJyZWFrLm9zLWxpbmUtbnVtYmVyLmxpbmUtbnVtYmVyLScgKyBsaW5lTnVtYmVyKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9nZXRGaXJzdExpbmVOdW1iZXJOb2RlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdPUy1MSU5FQlJFQUsnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ09TLUxJTkVCUkVBSycpO1xuICAgICAgICAgICAgaWYgKGZvdW5kLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQuaXRlbSgwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ2V0TGFzdExpbmVOdW1iZXJOb2RlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdPUy1MSU5FQlJFQUsnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ09TLUxJTkVCUkVBSycpO1xuICAgICAgICAgICAgaWYgKGZvdW5kLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQuaXRlbShmb3VuZC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fZ2V0Tm9kZUNvbnRleHRUcmFjZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gW10sXG4gICAgICAgICAgICAgICAgY3Vyck5vZGUgPSBub2RlO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJOb2RlKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC51bnNoaWZ0KGN1cnJOb2RlKTtcbiAgICAgICAgICAgICAgICBjdXJyTm9kZSA9IGN1cnJOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9pc0ZpcnN0Tm9uZW1wdHlDaGlsZCA9IGZ1bmN0aW9uKG5vZGUsIGNoaWxkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXNbaV0gPT09IGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlICE9PSBURVhUX05PREUgfHwgbm9kZS5jaGlsZE5vZGVzW2ldLm5vZGVWYWx1ZS5tYXRjaCgvXFxTLykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBZGRzIGVsZW1lbnRzIGxpa2UgPE9TLUxJTkVCUkVBSyBjbGFzcz1cIm9zLWxpbmUtbnVtYmVyIGxpbmUtbnVtYmVyLTIzXCIgZGF0YS1saW5lLW51bWJlcj1cIjIzXCIvPlxuICAgICAgICB0aGlzLl9pbnNlcnRJbnRlcm5hbExpbmVNYXJrZXJzID0gZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdPUy1MSU5FQlJFQUsnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBkdXBsaWNhdGUgY2FsbHNcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGluZU51bWJlcnMgPSBmcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzcGFuLm9zLWxpbmUtbnVtYmVyJyksXG4gICAgICAgICAgICAgICAgbGluZU1hcmtlciwgbWF4TGluZU51bWJlcjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lTnVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbnNlcnRCZWZvcmUgPSBsaW5lTnVtYmVyc1tpXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0QmVmb3JlLnBhcmVudE5vZGUubm9kZVR5cGUgIT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNGaXJzdE5vbmVtcHR5Q2hpbGQoaW5zZXJ0QmVmb3JlLnBhcmVudE5vZGUsIGluc2VydEJlZm9yZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlID0gaW5zZXJ0QmVmb3JlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmVNYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdPUy1MSU5FQlJFQUsnKTtcbiAgICAgICAgICAgICAgICBsaW5lTWFya2VyLnNldEF0dHJpYnV0ZSgnZGF0YS1saW5lLW51bWJlcicsIGxpbmVOdW1iZXJzW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1saW5lLW51bWJlcicpKTtcbiAgICAgICAgICAgICAgICBsaW5lTWFya2VyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBsaW5lTnVtYmVyc1tpXS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpO1xuICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsaW5lTWFya2VyLCBpbnNlcnRCZWZvcmUpO1xuICAgICAgICAgICAgICAgIG1heExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyc1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGluZS1udW1iZXInKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIG9uZSBtb3JlIFwiZmFrZVwiIGxpbmUgbnVtYmVyIGF0IHRoZSBlbmQgYW5kIGJlZ2lubmluZywgc28gd2UgY2FuIHNlbGVjdCB0aGUgbGFzdCBsaW5lIGFzIHdlbGxcbiAgICAgICAgICAgIGxpbmVNYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdPUy1MSU5FQlJFQUsnKTtcbiAgICAgICAgICAgIGxpbmVNYXJrZXIuc2V0QXR0cmlidXRlKCdkYXRhLWxpbmUtbnVtYmVyJywgKHBhcnNlSW50KG1heExpbmVOdW1iZXIpICsgMSkpO1xuICAgICAgICAgICAgbGluZU1hcmtlci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ29zLWxpbmUtbnVtYmVyIGxpbmUtbnVtYmVyLScgKyAocGFyc2VJbnQobWF4TGluZU51bWJlcikgKyAxKSk7XG4gICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChsaW5lTWFya2VyKTtcblxuICAgICAgICAgICAgbGluZU1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ09TLUxJTkVCUkVBSycpO1xuICAgICAgICAgICAgbGluZU1hcmtlci5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGluZS1udW1iZXInLCAnMCcpO1xuICAgICAgICAgICAgbGluZU1hcmtlci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ29zLWxpbmUtbnVtYmVyIGxpbmUtbnVtYmVyLTAnKTtcbiAgICAgICAgICAgIGZyYWdtZW50Lmluc2VydEJlZm9yZShsaW5lTWFya2VyLCBmcmFnbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBAVE9ETyBDaGVjayBpZiB0aGlzIGlzIGFjdHVhbGx5IG5lY2Vzc2FyeVxuICAgICAgICB0aGlzLl9pbnNlcnRJbnRlcm5hbExpTnVtYmVycyA9IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQucXVlcnlTZWxlY3RvckFsbCgnTElbb3MtbGktbnVtYmVyXScpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGR1cGxpY2F0ZSBjYWxsc1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvbHMgPSBmcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdPTCcpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2wgPSBvbHNbaV0sXG4gICAgICAgICAgICAgICAgICAgIGxpTm8gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2wuY2hpbGROb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2wuY2hpbGROb2Rlc1tqXS5ub2RlTmFtZSA9PSAnTEknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaU5vKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbC5jaGlsZE5vZGVzW2pdLnNldEF0dHJpYnV0ZSgnb3MtbGktbnVtYmVyJywgbGlObyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fYWRkU3RhcnRUb09sSWZOZWNlc3NhcnkgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RMaU5vID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBmaXJzdExpTm8gPT09IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZVtpXS5ub2RlTmFtZSA9PSAnTEknKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTm8gPSBub2RlLmNoaWxkTm9kZVtpXS5nZXRBdHRyaWJ1dGUoJ29sLWxpLW51bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZU5vKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdExpTm8gPSBwYXJzZUludChsaW5lTm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0TGlObyA+IDEpIHtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnc3RhcnQnLCBmaXJzdExpTm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2lzV2l0aGluTnRoTElPZk9MID0gZnVuY3Rpb24ob2xOb2RlLCBkZXNjZW5kYW50Tm9kZSkge1xuICAgICAgICAgICAgdmFyIG50aExJT2ZPTCA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoZGVzY2VuZGFudE5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChkZXNjZW5kYW50Tm9kZS5wYXJlbnROb2RlID09PSBvbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc0JlZm9yZU9sID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgIWZvdW5kTWU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sTm9kZS5jaGlsZE5vZGVzW2ldID09PSBkZXNjZW5kYW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvbE5vZGUuY2hpbGROb2Rlc1tpXS5ub2RlTmFtZSA9PT0gJ0xJJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc0JlZm9yZU9sKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbnRoTElPZk9MID0gbGlzQmVmb3JlT2wgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZXNjZW5kYW50Tm9kZSA9IGRlc2NlbmRhbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnRoTElPZk9MO1xuICAgICAgICB9O1xuXG4gICAgICAgLypcbiAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gICAgICAgICogMDogdGhlIG1vc3Qgc3BlY2lmaWMgRE9NLW5vZGUgdGhhdCBjb250YWlucyBib3RoIGxpbmUgbnVtYmVyc1xuICAgICAgICAqIDE6IHRoZSBjb250ZXh0IG9mIG5vZGUxIChhbiBhcnJheSBvZiBkb20tZWxlbWVudHM7IDAgaXMgdGhlIGRvY3VtZW50IGZyYWdtZW50KVxuICAgICAgICAqIDI6IHRoZSBjb250ZXh0IG9mIG5vZGUyIChhbiBhcnJheSBvZiBkb20tZWxlbWVudHM7IDAgaXMgdGhlIGRvY3VtZW50IGZyYWdtZW50KVxuICAgICAgICAqIDM6IHRoZSBpbmRleCBvZiBbMF0gaW4gdGhlIHR3byBhcnJheXNcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ2V0Q29tbW9uQW5jZXN0b3IgPSBmdW5jdGlvbihub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgICAgIHZhciB0cmFjZTEgPSB0aGlzLl9nZXROb2RlQ29udGV4dFRyYWNlKG5vZGUxKSxcbiAgICAgICAgICAgICAgICB0cmFjZTIgPSB0aGlzLl9nZXROb2RlQ29udGV4dFRyYWNlKG5vZGUyKSxcbiAgICAgICAgICAgICAgICBjb21tb25BbmNlc3RvciA9IG51bGwsXG4gICAgICAgICAgICAgICAgY29tbW9uSW5kZXggPSBudWxsLFxuICAgICAgICAgICAgICAgIGNoaWxkVHJhY2UxID0gW10sXG4gICAgICAgICAgICAgICAgY2hpbGRUcmFjZTIgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFjZTEubGVuZ3RoICYmIGkgPCB0cmFjZTIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2UxW2ldID09IHRyYWNlMltpXSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tb25BbmNlc3RvciA9IHRyYWNlMVtpXTtcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IGNvbW1vbkluZGV4ICsgMTsgaSA8IHRyYWNlMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkVHJhY2UxLnB1c2godHJhY2UxW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IGNvbW1vbkluZGV4ICsgMTsgaSA8IHRyYWNlMi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkVHJhY2UyLnB1c2godHJhY2UyW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ2NvbW1vbkFuY2VzdG9yJzogY29tbW9uQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgJ3RyYWNlMScgOiBjaGlsZFRyYWNlMSxcbiAgICAgICAgICAgICAgICAndHJhY2UyJyA6IGNoaWxkVHJhY2UyLFxuICAgICAgICAgICAgICAgICdpbmRleCc6IGNvbW1vbkluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3NlcmlhbGl6ZVRhZyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgLy8gRnJhZ21lbnRzIGFyZSBvbmx5IHBsYWNlaG9sZGVycyBhbmQgZG8gbm90IGhhdmUgYW4gSFRNTCByZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBodG1sID0gJzwnICsgbm9kZS5ub2RlTmFtZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIubmFtZSAhPT0gJ29zLWxpLW51bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnICcgKyBhdHRyLm5hbWUgKyAnPVwiJyArIGF0dHIudmFsdWUgKyAnXCInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh0bWwgKz0gJz4nO1xuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fc2VyaWFsaXplRG9tID0gZnVuY3Rpb24obm9kZSwgc3RyaXBMaW5lTnVtYmVycykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLm5vZGVWYWx1ZS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJpcExpbmVOdW1iZXJzICYmIChcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyaW5nU2VydmljZS5faXNPc0xpbmVOdW1iZXJOb2RlKG5vZGUpIHx8IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLl9pc09zTGluZUJyZWFrTm9kZShub2RlKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ09TLUxJTkVCUkVBSycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ0JSJykge1xuICAgICAgICAgICAgICAgIHZhciBiciA9ICc8QlInO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGJyICs9IFwiIFwiICsgYXR0ci5uYW1lICsgXCI9XFxcIlwiICsgYXR0ci52YWx1ZSArIFwiXFxcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYnIgKyAnPic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBodG1sID0gdGhpcy5fc2VyaWFsaXplVGFnKG5vZGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBub2RlLmNoaWxkTm9kZXNbaV0ubm9kZVZhbHVlLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpcExpbmVOdW1iZXJzIHx8ICghbGluZU51bWJlcmluZ1NlcnZpY2UuX2lzT3NMaW5lTnVtYmVyTm9kZShub2RlLmNoaWxkTm9kZXNbaV0pICYmICFsaW5lTnVtYmVyaW5nU2VydmljZS5faXNPc0xpbmVCcmVha05vZGUobm9kZS5jaGlsZE5vZGVzW2ldKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSB0aGlzLl9zZXJpYWxpemVEb20obm9kZS5jaGlsZE5vZGVzW2ldLCBzdHJpcExpbmVOdW1iZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzwvJyArIG5vZGUubm9kZU5hbWUgKyAnPic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRhdGlvbiBoaW50OiB0aGUgZmlyc3QgZWxlbWVudCBvZiBcInRvQ2hpbGRUcmFjZVwiIGFycmF5IG5lZWRzIHRvIGJlIGEgY2hpbGQgZWxlbWVudCBvZiBcIm5vZGVcIlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2VyaWFsaXplUGFydGlhbERvbVRvQ2hpbGQgPSBmdW5jdGlvbihub2RlLCB0b0NoaWxkVHJhY2UsIHN0cmlwTGluZU51bWJlcnMpIHtcbiAgICAgICAgICAgIGlmIChsaW5lTnVtYmVyaW5nU2VydmljZS5faXNPc0xpbmVOdW1iZXJOb2RlKG5vZGUpIHx8IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLl9pc09zTGluZUJyZWFrTm9kZShub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnT1MtTElORUJSRUFLJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGh0bWwgPSB0aGlzLl9zZXJpYWxpemVUYWcobm9kZSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBmb3VuZCA9IGZhbHNlOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiAhZm91bmQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXNbaV0gPT09IHRvQ2hpbGRUcmFjZVswXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmdUcmFjZSA9IHRvQ2hpbGRUcmFjZTtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nVHJhY2Uuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5lTnVtYmVyaW5nU2VydmljZS5faXNPc0xpbmVOdW1iZXJOb2RlKG5vZGUuY2hpbGROb2Rlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gdGhpcy5fc2VyaWFsaXplUGFydGlhbERvbVRvQ2hpbGQobm9kZS5jaGlsZE5vZGVzW2ldLCByZW1haW5pbmdUcmFjZSwgc3RyaXBMaW5lTnVtYmVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gbm9kZS5jaGlsZE5vZGVzW2ldLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0cmlwTGluZU51bWJlcnMgfHwgKCFsaW5lTnVtYmVyaW5nU2VydmljZS5faXNPc0xpbmVOdW1iZXJOb2RlKG5vZGUuY2hpbGROb2Rlc1tpXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAhbGluZU51bWJlcmluZ1NlcnZpY2UuX2lzT3NMaW5lQnJlYWtOb2RlKG5vZGUuY2hpbGROb2Rlc1tpXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9IHRoaXMuX3NlcmlhbGl6ZURvbShub2RlLmNoaWxkTm9kZXNbaV0sIHN0cmlwTGluZU51bWJlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkluY29uc2lzdGVuY3kgb3IgaW52YWxpZCBjYWxsIG9mIHRoaXMgZnVuY3Rpb24gZGV0ZWN0ZWQgKHRvKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudGF0aW9uIGhpbnQ6IHRoZSBmaXJzdCBlbGVtZW50IG9mIFwidG9DaGlsZFRyYWNlXCIgYXJyYXkgbmVlZHMgdG8gYmUgYSBjaGlsZCBlbGVtZW50IG9mIFwibm9kZVwiXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zZXJpYWxpemVQYXJ0aWFsRG9tRnJvbUNoaWxkID0gZnVuY3Rpb24obm9kZSwgZnJvbUNoaWxkVHJhY2UsIHN0cmlwTGluZU51bWJlcnMpIHtcbiAgICAgICAgICAgIGlmIChsaW5lTnVtYmVyaW5nU2VydmljZS5faXNPc0xpbmVOdW1iZXJOb2RlKG5vZGUpIHx8IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLl9pc09zTGluZUJyZWFrTm9kZShub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnT1MtTElORUJSRUFLJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGh0bWwgPSAnJztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBmb3VuZCA9IGZhbHNlOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlc1tpXSA9PT0gZnJvbUNoaWxkVHJhY2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nVHJhY2UgPSBmcm9tQ2hpbGRUcmFjZTtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nVHJhY2Uuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5lTnVtYmVyaW5nU2VydmljZS5faXNPc0xpbmVOdW1iZXJOb2RlKG5vZGUuY2hpbGROb2Rlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gdGhpcy5fc2VyaWFsaXplUGFydGlhbERvbUZyb21DaGlsZChub2RlLmNoaWxkTm9kZXNbaV0sIHJlbWFpbmluZ1RyYWNlLCBzdHJpcExpbmVOdW1iZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9IG5vZGUuY2hpbGROb2Rlc1tpXS5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0cmlwTGluZU51bWJlcnMgfHwgKCFsaW5lTnVtYmVyaW5nU2VydmljZS5faXNPc0xpbmVOdW1iZXJOb2RlKG5vZGUuY2hpbGROb2Rlc1tpXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIWxpbmVOdW1iZXJpbmdTZXJ2aWNlLl9pc09zTGluZUJyZWFrTm9kZShub2RlLmNoaWxkTm9kZXNbaV0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gdGhpcy5fc2VyaWFsaXplRG9tKG5vZGUuY2hpbGROb2Rlc1tpXSwgc3RyaXBMaW5lTnVtYmVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IFwiSW5jb25zaXN0ZW5jeSBvciBpbnZhbGlkIGNhbGwgb2YgdGhpcyBmdW5jdGlvbiBkZXRlY3RlZCAoZnJvbSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPC8nICsgbm9kZS5ub2RlTmFtZSArICc+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAgICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5odG1sVG9GcmFnbWVudCA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgICAgd2hpbGUgKGRpdi5jaGlsZEVsZW1lbnRDb3VudCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGRpdi5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgICAgIGRpdi5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGEgPGxpPiB3aXRoIGEgb3Mtc3BsaXQtYmVmb3JlLWNsYXNzIChzZXQgYnkgZXh0cmFjdFJhbmdlQnlMaW5lTnVtYmVycykgaXMgZWRpdGVkIHdoZW4gY3JlYXRpbmcgYVxuICAgICAgICAgKiBjaGFuZ2UgcmVjb21tZW5kYXRpb24gYW5kIGlzIHNwbGl0IGFnYWluIGluIENLRWRpdG9yLCB0aGUgc2Vjb25kIGxpc3QgaXRlbXMgYWxzbyBnZXRzIHRoYXQgY2xhc3MuXG4gICAgICAgICAqIFRoaXMgaXMgbm90IGNvcnJlY3QgaG93ZXZlciwgYXMgdGhlIHNlY29uZCBvbmUgYWN0dWFsbHkgaXMgYSBuZXcgbGlzdCBpdGVtLiBTbyB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBhZ2Fpbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVtb3ZlRHVwbGljYXRlQ2xhc3Nlc0luc2VydGVkQnlDa2VkaXRvciA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuaHRtbFRvRnJhZ21lbnQoaHRtbCk7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBmcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaS5vcy1zcGxpdC1iZWZvcmUnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzRmlyc3ROb25lbXB0eUNoaWxkKGl0ZW1zW2ldLnBhcmVudE5vZGUsIGl0ZW1zW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNTU0NsYXNzKGl0ZW1zW2ldLCAnb3Mtc3BsaXQtYmVmb3JlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZURvbShmcmFnbWVudCwgZmFsc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBIVE1MIHNuaXBwZXQgYmV0d2VlbiB0d28gZ2l2ZW4gbGluZSBudW1iZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBIaW50OlxuICAgICAgICAgKiAtIFRoZSBsYXN0IGxpbmUgKHRvTGluZSkgaXMgbm90IGluY2x1ZGVkIGFueW1vcmUsIGFzIHRoZSBudW1iZXIgcmVmZXJzIHRvIHRoZSBsaW5lIGJyZWFraW5nIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgICAgICAgKiAtIGlmIHRvTGluZSA9PT0gbnVsbCwgdGhlbiBldmVyeXRoaW5nIGZyb20gZnJvbUxpbmUgdG8gdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgaXMgcmV0dXJuZWRcbiAgICAgICAgICpcbiAgICAgICAgICogSW4gYWRkaXRpb24gdG8gdGhlIEhUTUwgc25pcHBldCwgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBpcyBwcm92aWRlZCByZWdhcmRpbmcgdGhlIG1vc3Qgc3BlY2lmaWMgRE9NIGVsZW1lbnRcbiAgICAgICAgICogdGhhdCBjb250YWlucyB0aGUgd2hvbGUgc2VjdGlvbiBzcGVjaWZpZWQgYnkgdGhlIGxpbmUgbnVtYmVycyAobGlrZSBhIFAtZWxlbWVudCBpZiBvbmx5IG9uZSBwYXJhZ3JhcGggaXMgc2VsZWN0ZWRcbiAgICAgICAgICogb3IgdGhlIG1vc3Qgb3V0ZXIgRElWLCBpZiBtdWx0aXBsZSBzZWN0aW9ucyBzZWxlY3RlZCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBpcyBtZWFudCB0byByZW5kZXIgdGhlIHNuaXBwZXQgY29ycmVjdGx5IHdpdGhvdXQgcHJvZHVjaW5nIGJyb2tlbiBIVE1MXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSByZXR1cm4gb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgICAgICogLSBodG1sOiBUaGUgSFRNTCBiZXR3ZWVuIHRoZSB0d28gbGluZSBudW1iZXJzLlxuICAgICAgICAgKiAgICAgICAgIExpbmUgbnVtYmVycyBhbmQgYXV0b21hdGljYWxseSBzZXQgbGluZSBicmVha3MgYXJlIHN0cmlwcGVkLlxuICAgICAgICAgKiAgICAgICAgIEFsbCBIVE1MIHRhZ3MgYXJlIGNvbnZlcnRlZCB0byB1cHBlcmNhc2VcbiAgICAgICAgICogICAgICAgICAoZS5nLiBMaW5lIDI8L0xJPjxMST5MaW5lMzwvTEk+PExJPkxpbmUgNCA8YnI+KVxuICAgICAgICAgKiAtIGFuY2VzdG9yOiB0aGUgbW9zdCBzcGVjaWZpYyBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBIVE1MIHNuaXBwZXQgKGUuZy4gYSBVTCwgaWYgc2V2ZXJhbCBMSXMgYXJlIHNlbGVjdGVkKVxuICAgICAgICAgKiAtIG91dGVyQ29udGV4dFN0YXJ0OiBBbiBIVE1MIHN0cmluZyB0aGF0IG9wZW5zIGFsbCBuZWNlc3NhcnkgdGFncyB0byBnZXQgdGhlIGJyb3dzZXIgaW50byB0aGUgcmVuZGVyaW5nIG1vZGVcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGFuY2VzdG9yIGVsZW1lbnQgKGUuZy4gPERJVj48VUw+IGluIHRoZSBjYXNlIG9mIHRoZSBtdWx0aXBsZSBMSXMpXG4gICAgICAgICAqIC0gb3V0ZXJDb250ZWN0RW5kOiAgIEFuIEhUTUwgc3RyaW5nIHRoYXQgY2xvc2VzIGFsbCBuZWNlc3NhcnkgdGFncyBmcm9tIHRoZSBhbmNlc3RvciBlbGVtZW50IChlLmcuIDwvVUw+PC9ESVY+XG4gICAgICAgICAqIC0gaW5uZXJDb250ZXh0U3RhcnQ6IEEgc3RyaW5nIHRoYXQgb3BlbnMgYWxsIG5lY2Vzc2FyeSB0YWdzIGJldHdlZW4gdGhlIGFuY2VzdG9yXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWxlY3Rpb24gKGUuZy4gPExJPilcbiAgICAgICAgICogLSBpbm5lckNvbnRleHRFbmQ6ICAgQSBzdHJpbmcgdGhhdCBjbG9zZXMgYWxsIHRhZ3MgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgc2VsZWN0aW9uIHRvIHRoZSBhbmNlc3RvciAoZS5nLiA8L0xJPilcbiAgICAgICAgICogLSBwcmV2aW91c0h0bWw6ICAgICAgVGhlIEhUTUwgYmVmb3JlIHRoZSBzZWxlY3RlZCBhcmVhIGJlZ2lucyAoaW5jbHVkaW5nIGxpbmUgbnVtYmVycylcbiAgICAgICAgICogLSBwcmV2aW91c0h0bWxFbmRTbmlwcGV0OiBBIEhUTUwgc25pcHBldCB0aGF0IGNsb3NlcyBhbGwgb3BlbiB0YWdzIGZyb20gcHJldmlvdXNIdG1sXG4gICAgICAgICAqIC0gZm9sbG93aW5nSHRtbDogICAgIFRoZSBIVE1MIGFmdGVyIHRoZSBzZWxlY3RlZCBhcmVhXG4gICAgICAgICAqIC0gZm9sbG93aW5nSHRtbFN0YXJ0U25pcHBldDogQSBIVE1MIHNuaXBwZXQgdGhhdCBvcGVucyBhbGwgSFRNTCB0YWdzIG5lY2Vzc2FyeSB0byByZW5kZXIgXCJmb2xsb3dpbmdIdG1sXCJcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogSW4gc29tZSBjYXNlcywgdGhlIHJldHVybmVkIEhUTUwgdGFncyByZWNlaXZlIGFkZGl0aW9uYWwgQ1NTIGNsYXNzZXMsIHByb3ZpZGluZyBpbmZvcm1hdGlvbiBib3RoIGZvclxuICAgICAgICAgKiByZW5kZXJpbmcgaXQgYW5kIGZvciBtZXJnaW5nIGl0IGFnYWluIGNvcnJlY3RseS5cbiAgICAgICAgICogLSBvcy1zcGxpdC0qOiAgICAgICAgVGhlc2UgY2xhc3NlcyBhcmUgc2V0IGZvciBhbGwgSFRNTCBUYWdzIHRoYXQgaGF2ZSBiZWVuIHNwbGl0IGludG8gdHdvIGJ5IHRoaXMgcHJvY2VzcyxcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgZS5nLiBpZiB0aGUgZnJvbUxpbmUtIG9yIHRvTGluZS1saW5lLWJyZWFrIHdhcyBzb21ld2hlcmUgaW4gdGhlIG1pZGRsZSBvZiB0aGlzIHRhZy5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgSWYgYSB0YWcgaXMgc3BsaXQsIHRoZSBmaXJzdCBvbmUgcmVjZWl2ZXMgXCJvcy1zcGxpdC1hZnRlclwiLCBhbmQgdGhlIHNlY29uZCBvbmUgXCJvcy1zcGxpdC1iZWZvcmVcIi5cbiAgICAgICAgICogRm9yIGV4YW1wbGUsIGZvciB0aGUgZm9sbG93aW5nIHN0cmluZyA8cD5MaW5lIDE8YnI+TGluZSAyPGJyPkxpbmUgMzwvcD46XG4gICAgICAgICAqIC0gZXh0cmFjdGluZyBsaW5lIDEgdG8gMiByZXN1bHRzIGluIDxwIGNsYXNzPVwib3Mtc3BsaXQtYWZ0ZXJcIj5MaW5lIDE8L3A+XG4gICAgICAgICAqIC0gZXh0cmFjdGluZyBsaW5lIDIgdG8gMyByZXN1bHRzIGluIDxwIGNsYXNzPVwib3Mtc3BsaXQtYWZ0ZXIgb3Mtc3BsaXQtYmVmb3JlXCI+TGluZSAyPC9wPlxuICAgICAgICAgKiAtIGV4dHJhY3RpbmcgbGluZSAzIHRvIG51bGwvNCByZXN1bHRzIGluIDxwIGNsYXNzPVwib3Mtc3BsaXQtYmVmb3JlXCI+TGluZSAzPC9wPlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHRyYWN0UmFuZ2VCeUxpbmVOdW1iZXJzID0gZnVuY3Rpb24oaHRtbEluLCBmcm9tTGluZSwgdG9MaW5lKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGh0bWxJbikgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0ludmFsaWQgY2FsbCAtIGV4dHJhY3RSYW5nZUJ5TGluZU51bWJlcnMgZXhwZWN0cyBhIHN0cmluZyBhcyBmaXJzdCBhcmd1bWVudCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IGZyb21MaW5lICsgXCItXCIgKyB0b0xpbmUgKyBcIi1cIiArIGxpbmVOdW1iZXJpbmdTZXJ2aWNlLmRqYjJoYXNoKGh0bWxJbiksXG4gICAgICAgICAgICAgICAgY2FjaGVkID0gZGlmZkNhY2hlLmdldChjYWNoZUtleSk7XG5cbiAgICAgICAgICAgIGlmICghYW5ndWxhci5pc1VuZGVmaW5lZChjYWNoZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gdGhpcy5odG1sVG9GcmFnbWVudChodG1sSW4pO1xuXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRJbnRlcm5hbExpbmVNYXJrZXJzKGZyYWdtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2luc2VydEludGVybmFsTGlOdW1iZXJzKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGlmICh0b0xpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJuYWxMaW5lTWFya2VycyA9IGZyYWdtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ09TLUxJTkVCUkVBSycpO1xuICAgICAgICAgICAgICAgIHRvTGluZSA9IHBhcnNlSW50KGludGVybmFsTGluZU1hcmtlcnNbaW50ZXJuYWxMaW5lTWFya2Vycy5sZW5ndGggLSAxXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWxpbmUtbnVtYmVyXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZyb21MaW5lTm9kZSA9IHRoaXMuZ2V0TGluZU51bWJlck5vZGUoZnJhZ21lbnQsIGZyb21MaW5lKSxcbiAgICAgICAgICAgICAgICB0b0xpbmVOb2RlID0gKHRvTGluZSA/IHRoaXMuZ2V0TGluZU51bWJlck5vZGUoZnJhZ21lbnQsIHRvTGluZSkgOiBudWxsKSxcbiAgICAgICAgICAgICAgICBhbmNlc3RvckRhdGEgPSB0aGlzLl9nZXRDb21tb25BbmNlc3Rvcihmcm9tTGluZU5vZGUsIHRvTGluZU5vZGUpO1xuXG4gICAgICAgICAgICB2YXIgZnJvbUNoaWxkVHJhY2VSZWwgPSBhbmNlc3RvckRhdGEudHJhY2UxLFxuICAgICAgICAgICAgICAgIGZyb21DaGlsZFRyYWNlQWJzID0gdGhpcy5fZ2V0Tm9kZUNvbnRleHRUcmFjZShmcm9tTGluZU5vZGUpLFxuICAgICAgICAgICAgICAgIHRvQ2hpbGRUcmFjZVJlbCA9IGFuY2VzdG9yRGF0YS50cmFjZTIsXG4gICAgICAgICAgICAgICAgdG9DaGlsZFRyYWNlQWJzID0gdGhpcy5fZ2V0Tm9kZUNvbnRleHRUcmFjZSh0b0xpbmVOb2RlKSxcbiAgICAgICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yRGF0YS5jb21tb25BbmNlc3RvcixcbiAgICAgICAgICAgICAgICBodG1sT3V0ID0gJycsXG4gICAgICAgICAgICAgICAgb3V0ZXJDb250ZXh0U3RhcnQgPSAnJyxcbiAgICAgICAgICAgICAgICBvdXRlckNvbnRleHRFbmQgPSAnJyxcbiAgICAgICAgICAgICAgICBpbm5lckNvbnRleHRTdGFydCA9ICcnLFxuICAgICAgICAgICAgICAgIGlubmVyQ29udGV4dEVuZCA9ICcnLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzSHRtbEVuZFNuaXBwZXQgPSAnJyxcbiAgICAgICAgICAgICAgICBmb2xsb3dpbmdIdG1sU3RhcnRTbmlwcGV0ID0gJycsXG4gICAgICAgICAgICAgICAgZmFrZU9sLCBvZmZzZXQ7XG5cbiAgICAgICAgICAgIGZyb21DaGlsZFRyYWNlQWJzLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNIdG1sID0gdGhpcy5fc2VyaWFsaXplUGFydGlhbERvbVRvQ2hpbGQoZnJhZ21lbnQsIGZyb21DaGlsZFRyYWNlQWJzLCBmYWxzZSk7XG4gICAgICAgICAgICB0b0NoaWxkVHJhY2VBYnMuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBmb2xsb3dpbmdIdG1sID0gdGhpcy5fc2VyaWFsaXplUGFydGlhbERvbUZyb21DaGlsZChmcmFnbWVudCwgdG9DaGlsZFRyYWNlQWJzLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIHZhciBjdXJyTm9kZSA9IGZyb21MaW5lTm9kZSxcbiAgICAgICAgICAgICAgICBpc1NwbGl0ID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyck5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNGaXJzdE5vbmVtcHR5Q2hpbGQoY3Vyck5vZGUucGFyZW50Tm9kZSwgY3Vyck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzU3BsaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTcGxpdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENTU0NsYXNzKGN1cnJOb2RlLnBhcmVudE5vZGUsICdvcy1zcGxpdC1iZWZvcmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJOb2RlLm5vZGVOYW1lICE9PSAnT1MtTElORUJSRUFLJykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0h0bWxFbmRTbmlwcGV0ICs9ICc8LycgKyBjdXJyTm9kZS5ub2RlTmFtZSArICc+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3Vyck5vZGUgPSBjdXJyTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyTm9kZSA9IHRvTGluZU5vZGU7XG4gICAgICAgICAgICBpc1NwbGl0ID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyck5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNGaXJzdE5vbmVtcHR5Q2hpbGQoY3Vyck5vZGUucGFyZW50Tm9kZSwgY3Vyck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzU3BsaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTcGxpdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENTU0NsYXNzKGN1cnJOb2RlLnBhcmVudE5vZGUsICdvcy1zcGxpdC1hZnRlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3Vyck5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZSA9PT0gJ09MJykge1xuICAgICAgICAgICAgICAgICAgICBmYWtlT2wgPSBjdXJyTm9kZS5wYXJlbnROb2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IChjdXJyTm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZShcInN0YXJ0XCIpID8gcGFyc2VJbnQoY3Vyck5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoXCJzdGFydFwiKSkgLSAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIGZha2VPbC5zZXRBdHRyaWJ1dGUoJ3N0YXJ0JywgKHRoaXMuX2lzV2l0aGluTnRoTElPZk9MKGN1cnJOb2RlLnBhcmVudE5vZGUsIHRvTGluZU5vZGUpICsgb2Zmc2V0KS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9sbG93aW5nSHRtbFN0YXJ0U25pcHBldCA9IHRoaXMuX3NlcmlhbGl6ZVRhZyhmYWtlT2wpICsgZm9sbG93aW5nSHRtbFN0YXJ0U25pcHBldDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb2xsb3dpbmdIdG1sU3RhcnRTbmlwcGV0ID0gdGhpcy5fc2VyaWFsaXplVGFnKGN1cnJOb2RlLnBhcmVudE5vZGUpICsgZm9sbG93aW5nSHRtbFN0YXJ0U25pcHBldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3Vyck5vZGUgPSBjdXJyTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlzU3BsaXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJvbUNoaWxkVHJhY2VSZWwubGVuZ3RoICYmICFmb3VuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21DaGlsZFRyYWNlUmVsW2ldLm5vZGVOYW1lID09PSAnT1MtTElORUJSRUFLJykge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0ZpcnN0Tm9uZW1wdHlDaGlsZChmcm9tQ2hpbGRUcmFjZVJlbFtpXSwgZnJvbUNoaWxkVHJhY2VSZWxbaSArIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTcGxpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21DaGlsZFRyYWNlUmVsW2ldLm5vZGVOYW1lID09PSAnT0wnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWtlT2wgPSBmcm9tQ2hpbGRUcmFjZVJlbFtpXS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gKGZyb21DaGlsZFRyYWNlUmVsW2ldLmdldEF0dHJpYnV0ZShcInN0YXJ0XCIpID8gcGFyc2VJbnQoZnJvbUNoaWxkVHJhY2VSZWxbaV0uZ2V0QXR0cmlidXRlKFwic3RhcnRcIikpIC0gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFrZU9sLnNldEF0dHJpYnV0ZSgnc3RhcnQnLCAob2Zmc2V0ICsgdGhpcy5faXNXaXRoaW5OdGhMSU9mT0woZnJvbUNoaWxkVHJhY2VSZWxbaV0sIGZyb21MaW5lTm9kZSkpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJDb250ZXh0U3RhcnQgKz0gdGhpcy5fc2VyaWFsaXplVGFnKGZha2VPbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IChmcm9tQ2hpbGRUcmFjZVJlbC5sZW5ndGggLSAxKSAmJiBpc1NwbGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDU1NDbGFzcyhmcm9tQ2hpbGRUcmFjZVJlbFtpXSwgJ29zLXNwbGl0LWJlZm9yZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJDb250ZXh0U3RhcnQgKz0gdGhpcy5fc2VyaWFsaXplVGFnKGZyb21DaGlsZFRyYWNlUmVsW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9DaGlsZFRyYWNlUmVsLmxlbmd0aCAmJiAhZm91bmQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0b0NoaWxkVHJhY2VSZWxbaV0ubm9kZU5hbWUgPT09ICdPUy1MSU5FQlJFQUsnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbm5lckNvbnRleHRFbmQgPSAnPC8nICsgdG9DaGlsZFRyYWNlUmVsW2ldLm5vZGVOYW1lICsgJz4nICsgaW5uZXJDb250ZXh0RW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbmNlc3Rvci5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2VzdG9yLmNoaWxkTm9kZXNbaV0gPT09IGZyb21DaGlsZFRyYWNlUmVsWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUNoaWxkVHJhY2VSZWwuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaHRtbE91dCArPSB0aGlzLl9zZXJpYWxpemVQYXJ0aWFsRG9tRnJvbUNoaWxkKGFuY2VzdG9yLmNoaWxkTm9kZXNbaV0sIGZyb21DaGlsZFRyYWNlUmVsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFuY2VzdG9yLmNoaWxkTm9kZXNbaV0gPT09IHRvQ2hpbGRUcmFjZVJlbFswXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0b0NoaWxkVHJhY2VSZWwuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaHRtbE91dCArPSB0aGlzLl9zZXJpYWxpemVQYXJ0aWFsRG9tVG9DaGlsZChhbmNlc3Rvci5jaGlsZE5vZGVzW2ldLCB0b0NoaWxkVHJhY2VSZWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZm91bmQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbE91dCArPSB0aGlzLl9zZXJpYWxpemVEb20oYW5jZXN0b3IuY2hpbGROb2Rlc1tpXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyTm9kZSA9IGFuY2VzdG9yO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyck5vZGUubm9kZU5hbWUgPT09ICdPTCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFrZU9sID0gY3Vyck5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gKGN1cnJOb2RlLmdldEF0dHJpYnV0ZShcInN0YXJ0XCIpID8gcGFyc2VJbnQoY3Vyck5vZGUuZ2V0QXR0cmlidXRlKFwic3RhcnRcIikpIC0gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBmYWtlT2wuc2V0QXR0cmlidXRlKCdzdGFydCcsICh0aGlzLl9pc1dpdGhpbk50aExJT2ZPTChjdXJyTm9kZSwgZnJvbUxpbmVOb2RlKSArIG9mZnNldCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIG91dGVyQ29udGV4dFN0YXJ0ID0gdGhpcy5fc2VyaWFsaXplVGFnKGZha2VPbCkgKyBvdXRlckNvbnRleHRTdGFydDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRlckNvbnRleHRTdGFydCA9IHRoaXMuX3NlcmlhbGl6ZVRhZyhjdXJyTm9kZSkgKyBvdXRlckNvbnRleHRTdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ZXJDb250ZXh0RW5kICs9ICc8LycgKyBjdXJyTm9kZS5ub2RlTmFtZSArICc+JztcbiAgICAgICAgICAgICAgICBjdXJyTm9kZSA9IGN1cnJOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgICAgICAgJ2h0bWwnOiBodG1sT3V0LFxuICAgICAgICAgICAgICAgICdhbmNlc3Rvcic6IGFuY2VzdG9yLFxuICAgICAgICAgICAgICAgICdvdXRlckNvbnRleHRTdGFydCc6IG91dGVyQ29udGV4dFN0YXJ0LFxuICAgICAgICAgICAgICAgICdvdXRlckNvbnRleHRFbmQnOiBvdXRlckNvbnRleHRFbmQsXG4gICAgICAgICAgICAgICAgJ2lubmVyQ29udGV4dFN0YXJ0JzogaW5uZXJDb250ZXh0U3RhcnQsXG4gICAgICAgICAgICAgICAgJ2lubmVyQ29udGV4dEVuZCc6IGlubmVyQ29udGV4dEVuZCxcbiAgICAgICAgICAgICAgICAncHJldmlvdXNIdG1sJzogcHJldmlvdXNIdG1sLFxuICAgICAgICAgICAgICAgICdwcmV2aW91c0h0bWxFbmRTbmlwcGV0JzogcHJldmlvdXNIdG1sRW5kU25pcHBldCxcbiAgICAgICAgICAgICAgICAnZm9sbG93aW5nSHRtbCc6IGZvbGxvd2luZ0h0bWwsXG4gICAgICAgICAgICAgICAgJ2ZvbGxvd2luZ0h0bWxTdGFydFNuaXBwZXQnOiBmb2xsb3dpbmdIdG1sU3RhcnRTbmlwcGV0XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkaWZmQ2FjaGUucHV0KGNhY2hlS2V5LCByZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCB0YWtlcyB0aGUgaHRtbC1hdHRyaWJ1dGUgZnJvbSBhbiBleHRyYWN0UmFuZ2VCeUxpbmVOdW1iZXJzKCktbWV0aG9kLFxuICAgICAgICAgKiB3cmFwcyBpdCB3aXRoIHRoZSBjb250ZXh0IGFuZCBhZGRzIGxpbmUgbnVtYmVycy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9ybWF0RGlmZldpdGhMaW5lTnVtYmVycyA9IGZ1bmN0aW9uKGRpZmYsIGxpbmVMZW5ndGgsIGZpcnN0TGluZSkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSBkaWZmLm91dGVyQ29udGV4dFN0YXJ0ICsgZGlmZi5pbm5lckNvbnRleHRTdGFydCArIGRpZmYuaHRtbCArIGRpZmYuaW5uZXJDb250ZXh0RW5kICsgZGlmZi5vdXRlckNvbnRleHRFbmQ7XG4gICAgICAgICAgICB0ZXh0ID0gbGluZU51bWJlcmluZ1NlcnZpY2UuaW5zZXJ0TGluZU51bWJlcnModGV4dCwgbGluZUxlbmd0aCwgbnVsbCwgbnVsbCwgZmlyc3RMaW5lKTtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoaXMgaXMgYSB3b3JrYXJkb3VuIHRvIHByZXZlbnQgdGhlIGxhc3Qgd29yZCBvZiB0aGUgaW5zZXJ0ZWQgdGV4dCBmcm9tIGFjY2lkZW50bHkgYmVpbmcgbWVyZ2VkIHdpdGggdGhlXG4gICAgICAgICAqIGZpcnN0IHdvcmQgb2YgdGhlIGZvbGxvd2luZyBsaW5lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGhhcHBlbnMgYXMgdHJhaWxpbmcgc3BhY2VzIGluIHRoZSBjaGFuZ2UgcmVjb21tZW5kYXRpb24ncyB0ZXh0IGFyZSBmcmVxdWVudGx5IHN0cmlwcGVkLFxuICAgICAgICAgKiB3aGljaCBpcyBwcmV0dHkgbmFzdHkgaWYgdGhlIG9yaWdpbmFsIHRleHQgZ29lcyBvbiBhZnRlciB0aGUgYWZmZWN0ZWQgbGluZS4gU28gd2UgaW5zZXJ0IGEgc3BhY2VcbiAgICAgICAgICogaWYgdGhlIG9yaWdpbmFsIGxpbmUgZW5kcyB3aXRoIG9uZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luc2VydERhbmdsaW5nU3BhY2UgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdENoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2VsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdENoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUgJiYgIWxhc3RDaGlsZC5ub2RlVmFsdWUubWF0Y2goL1tcXFNdLykgJiYgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRleHQgbm9kZSBvbmx5IGNvbnRhaW5zIHdoaXRlc3BhY2VzLCBjaGFuY2VzIGFyZSBoaWdoIGl0J3MganVzdCBzcGFjZSBiZXR3ZWVuIGJsb2NrIGVsbWVlbnRzLFxuICAgICAgICAgICAgICAgICAgICAvLyBsaWtlIGEgbGluZSBicmVhayBiZXR3ZWVuIDwvTEk+IGFuZCA8L1VMPlxuICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGFzdENoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RDaGlsZC5ub2RlVmFsdWUgPT09ICcnIHx8IGxhc3RDaGlsZC5ub2RlVmFsdWUuc3Vic3RyKC0xKSAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGQubm9kZVZhbHVlICs9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc2VydERhbmdsaW5nU3BhY2UobGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLypcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbnMgbWVyZ2VzIHRvIGFycmF5cyBvZiBub2Rlcy4gVGhlIGxhc3QgZWxlbWVudCBvZiBub2RlczEgYW5kIHRoZSBmaXJzdCBlbGVtZW50IG9mIG5vZGVzMlxuICAgICAgICAgKiBhcmUgbWVyZ2VkLCBpZiB0aGV5IGFyZSBvZiB0aGUgc2FtZSB0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIGRvbmUgcmVjdXJzaXZlbHkgdW50aWwgYSBURU1QTEFURS1UYWcgaXMgaXMgZm91bmQsIHdoaWNoIHdhcyBpbnNlcnRlZCBpbiB0aGlzLnJlcGxhY2VMaW5lcy5cbiAgICAgICAgICogVXNpbmcgYSBURU1QTEFURS1UYWcgaXMgYSByYXRoZXIgZGlydHkgaGFjaywgYXMgaXQgaXMgYWxsb3dlZCBpbnNpZGUgb2YgYW55IG90aGVyIGVsZW1lbnQsIGluY2x1ZGluZyA8dWw+LlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVwbGFjZUxpbmVzTWVyZ2VOb2RlQXJyYXlzID0gZnVuY3Rpb24obm9kZXMxLCBub2RlczIpIHtcbiAgICAgICAgICAgIGlmIChub2RlczEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlczIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlczEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2gobm9kZXMxW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxhc3ROb2RlID0gbm9kZXMxW25vZGVzMS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICBmaXJzdE5vZGUgPSBub2RlczJbMF07XG4gICAgICAgICAgICBpZiAobGFzdE5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSAmJiBmaXJzdE5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdUZXh0Tm9kZSA9IGxhc3ROb2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFzdE5vZGUubm9kZVZhbHVlICsgZmlyc3ROb2RlLm5vZGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2gobmV3VGV4dE5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0Tm9kZS5ub2RlTmFtZSA9PT0gZmlyc3ROb2RlLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBsYXN0Tm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobGFzdE5vZGUubm9kZU5hbWUpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsYXN0Tm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gbGFzdE5vZGUuYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgI3RleHQgbm9kZXMgaW5zaWRlIG9mIExpc3QgZWxlbWVudHMgKE9ML1VMKSwgYXMgdGhleSBhcmUgY29uZnVzaW5nXG4gICAgICAgICAgICAgICAgdmFyIGxhc3RDaGlsZHJlbiwgZmlyc3RDaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBpZiAobGFzdE5vZGUubm9kZU5hbWUgPT09ICdPTCcgfHwgbGFzdE5vZGUubm9kZU5hbWUgPT09ICdVTCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdENoaWxkcmVuID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpcnN0Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb2RlLmNoaWxkTm9kZXNbaV0ubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Q2hpbGRyZW4ucHVzaChmaXJzdE5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxhc3ROb2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0Tm9kZS5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGRyZW4ucHVzaChsYXN0Tm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDaGlsZHJlbiA9IGxhc3ROb2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q2hpbGRyZW4gPSBmaXJzdE5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9yZXBsYWNlTGluZXNNZXJnZU5vZGVBcnJheXMobGFzdENoaWxkcmVuLCBmaXJzdENoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5hcHBlbmRDaGlsZChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3V0LnB1c2gobmV3Tm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0Tm9kZS5ub2RlTmFtZSAhPT0gJ1RFTVBMQVRFJykge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChsYXN0Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaXJzdE5vZGUubm9kZU5hbWUgIT09ICdURU1QTEFURScpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goZmlyc3ROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBub2RlczIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChub2RlczJbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbm9ybWFsaXplSHRtbEZvckRpZmYgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBhbGwgSFRNTCB0YWdzIHRvIHVwcGVyY2FzZSwgYnV0IGxlYXZlIHRoZSB2YWx1ZXMgb2YgYXR0cmlidXRlcyB1bmNoYW5nZWRcbiAgICAgICAgICAgIC8vIEFsbCBhdHRyaWJ1dGVzIGFuZCBDU1MgY2xhc3MgbmFtZXMgIGFyZSBzb3J0ZWQgYWxwaGFiZXRpY2FsbHlcbiAgICAgICAgICAgIC8vIElmIGFuIGF0dHJpYnV0ZSBpcyBlbXB0eSwgaXQgaXMgcmVtb3ZlZFxuICAgICAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvPChcXC8/W2Etel0qKSggW14+XSopPz4vaWcsIGZ1bmN0aW9uIChodG1sLCB0YWcsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnTm9ybWFsaXplZCA9IHRhZy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzTGlzdCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzTWF0Y2hlciA9IC8oIFteXCInPV0qKSg9ICooKFtcIiddKSguKj8pXFw0KSk/L2dpLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaDtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gYXR0cmlidXRlc01hdGNoZXIuZXhlYyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ck5vcm1hbGl6ZWQgPSBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJWYWx1ZSA9IG1hdGNoWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ck5vcm1hbGl6ZWQgPT09ICcgQ0xBU1MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJWYWx1ZSA9IGF0dHJWYWx1ZS5zcGxpdCgnICcpLnNvcnQoKS5qb2luKCcgJykucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJOb3JtYWxpemVkICs9IFwiPVwiICsgbWF0Y2hbNF0gKyBhdHRyVmFsdWUgKyBtYXRjaFs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyVmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc0xpc3QucHVzaChhdHRyTm9ybWFsaXplZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChtYXRjaCk7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXNMaXN0LnNvcnQoKS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWdOb3JtYWxpemVkICsgYXR0cmlidXRlcyArIFwiPlwiO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IHtcbiAgICAgICAgICAgICAgICAnJm5ic3A7JzogJyAnLFxuICAgICAgICAgICAgICAgICcmbmRhc2g7JzogJy0nLFxuICAgICAgICAgICAgICAgICcmYXVtbDsnOiAnw6QnLFxuICAgICAgICAgICAgICAgICcmb3VtbDsnOiAnw7YnLFxuICAgICAgICAgICAgICAgICcmdXVtbDsnOiAnw7wnLFxuICAgICAgICAgICAgICAgICcmQXVtbDsnOiAnw4QnLFxuICAgICAgICAgICAgICAgICcmT3VtbDsnOiAnw5YnLFxuICAgICAgICAgICAgICAgICcmVXVtbDsnOiAnw5wnLFxuICAgICAgICAgICAgICAgICcmc3psaWc7JzogJ8OfJyxcbiAgICAgICAgICAgICAgICAnJmJkcXVvOyc6ICfigJ4nLFxuICAgICAgICAgICAgICAgICcmbGRxdW87JzogJ+KAnCcsXG4gICAgICAgICAgICAgICAgJyZidWxsOyc6ICfigKInLFxuICAgICAgICAgICAgICAgICcmc2VjdDsnOiAnwqcnLFxuICAgICAgICAgICAgICAgICcmZWFjdXRlOyc6ICfDqScsXG4gICAgICAgICAgICAgICAgJyZldXJvOyc6ICfigqwnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKC9cXHMrPFxcL1A+L2dpLCAnPC9QPicpLnJlcGxhY2UoL1xccys8XFwvRElWPi9naSwgJzwvRElWPicpLnJlcGxhY2UoL1xccys8XFwvTEk+L2dpLCAnPC9MST4nKTtcbiAgICAgICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoL1xccys8TEk+L2dpLCAnPExJPicpLnJlcGxhY2UoLzxcXC9MST5cXHMrL2dpLCAnPC9MST4nKTtcbiAgICAgICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoL1xcdTAwQTAvZywgJyAnKTtcbiAgICAgICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoL1xcdTIwMTMvZywgJy0nKTtcbiAgICAgICAgICAgIGZvciAodmFyIGVudCBpbiBlbnRpdGllcykge1xuICAgICAgICAgICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UobmV3IFJlZ0V4cChlbnQsICdnJyksIGVudGl0aWVzW2VudF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOZXdsaW5lIGNoYXJhY3RlcnM6IGFmdGVyIGNsb3NpbmcgYmxvY2stbGV2ZWwtZWxlbWVudHMsIGJ1dCBub3QgYWZ0ZXIgQlIgKHdoaWNoIGlzIGlubGluZSlcbiAgICAgICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoLyg8YnIgKlxcLz8+KVxcbi9naSwgXCIkMVwiKTtcbiAgICAgICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoL1sgXFxuXFx0XSsvZ2ksICcgJyk7XG4gICAgICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKC8oPFxcLyhkaXZ8cHx1bHxsaXxibG9ja3F1b3RlPik+KSAvZ2ksIFwiJDFcXG5cIik7XG5cbiAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2dldEFsbE5leHRTaWJsaW5ncyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2dldEFsbFByZXZTaWJsaW5nc1JldmVyc2VkID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICAgICAgICB3aGlsZSAoZWxlbWVudC5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcmV0dXJucyB0aGUgbGluZSBudW1iZXIgcmFuZ2UgaW4gd2hpY2ggY2hhbmdlcyAoaW5zZXJ0aW9ucywgZGVsZXRpb25zKSBhcmUgZW5jb3VudGVyZWQuXG4gICAgICAgICAqIEFzIGluIGV4dHJhY3RSYW5nZUJ5TGluZU51bWJlcnMoKSwgXCJ0b1wiIHJlZmVycyB0byB0aGUgbGluZSBicmVha2luZyBlbGVtZW50IGF0IHRoZSBlbmQsIGkuZS4gdGhlIHN0YXJ0IG9mIHRoZSBmb2xsb3dpbmcgbGluZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGRpZmZIdG1sXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRldGVjdEFmZmVjdGVkTGluZVJhbmdlID0gZnVuY3Rpb24gKGRpZmZIdG1sKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBsaW5lTnVtYmVyaW5nU2VydmljZS5kamIyaGFzaChkaWZmSHRtbCksXG4gICAgICAgICAgICAgICAgY2FjaGVkID0gZGlmZkNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgICAgICBpZiAoIWFuZ3VsYXIuaXNVbmRlZmluZWQoY2FjaGVkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuaHRtbFRvRnJhZ21lbnQoZGlmZkh0bWwpO1xuXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRJbnRlcm5hbExpbmVNYXJrZXJzKGZyYWdtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2luc2VydEludGVybmFsTGlOdW1iZXJzKGZyYWdtZW50KTtcblxuICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSBmcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnMsIGRlbCwgLmluc2VydCwgLmRlbGV0ZScpLFxuICAgICAgICAgICAgICAgIGZpcnN0Q2hhbmdlID0gY2hhbmdlcy5pdGVtKDApLFxuICAgICAgICAgICAgICAgIGxhc3RDaGFuZ2UgPSBjaGFuZ2VzLml0ZW0oY2hhbmdlcy5sZW5ndGggLSAxKSxcbiAgICAgICAgICAgICAgICBpLCBqO1xuXG4gICAgICAgICAgICBpZiAoIWZpcnN0Q2hhbmdlIHx8ICFsYXN0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIG5vIGNoYW5nZXNcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZpcnN0VHJhY2UgPSB0aGlzLl9nZXROb2RlQ29udGV4dFRyYWNlKGZpcnN0Q2hhbmdlKSxcbiAgICAgICAgICAgICAgICBsYXN0TGluZU51bWJlckJlZm9yZSA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGogPSBmaXJzdFRyYWNlLmxlbmd0aCAtIDE7IGogPj0gMCAmJiBsYXN0TGluZU51bWJlckJlZm9yZSA9PT0gbnVsbDsgai0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZTaWJsaW5ncyA9IHRoaXMuX2dldEFsbFByZXZTaWJsaW5nc1JldmVyc2VkKGZpcnN0VHJhY2Vbal0pO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcmV2U2libGluZ3MubGVuZ3RoICYmIGxhc3RMaW5lTnVtYmVyQmVmb3JlID09PSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExpbmVOdW1iZXJCZWZvcmUgPSB0aGlzLl9nZXRMYXN0TGluZU51bWJlck5vZGUocHJldlNpYmxpbmdzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYXN0VHJhY2UgPSB0aGlzLl9nZXROb2RlQ29udGV4dFRyYWNlKGxhc3RDaGFuZ2UpLFxuICAgICAgICAgICAgICAgIGZpcnN0TGluZU51bWJlckFmdGVyID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoaiA9IGxhc3RUcmFjZS5sZW5ndGggLSAxOyBqID49IDAgJiYgZmlyc3RMaW5lTnVtYmVyQWZ0ZXIgPT09IG51bGw7IGotLSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0U2libGluZ3MgPSB0aGlzLl9nZXRBbGxOZXh0U2libGluZ3MobGFzdFRyYWNlW2pdKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV4dFNpYmxpbmdzLmxlbmd0aCAmJiBmaXJzdExpbmVOdW1iZXJBZnRlciA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TGluZU51bWJlckFmdGVyID0gdGhpcy5fZ2V0Rmlyc3RMaW5lTnVtYmVyTm9kZShuZXh0U2libGluZ3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgIFwiZnJvbVwiOiBwYXJzZUludChsYXN0TGluZU51bWJlckJlZm9yZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWxpbmUtbnVtYmVyXCIpKSxcbiAgICAgICAgICAgICAgICBcInRvXCI6IHBhcnNlSW50KGZpcnN0TGluZU51bWJlckFmdGVyLmdldEF0dHJpYnV0ZShcImRhdGEtbGluZS1udW1iZXJcIikpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkaWZmQ2FjaGUucHV0KGNhY2hlS2V5LCByYW5nZSk7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgLmRlbGV0ZS1ub2RlcyBhbmQgPGRlbD4tVGFncyAoaW5jbHVkaW5nIGNvbnRlbnQpXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIC5pbnNlcnQtY2xhc3NlcyBhbmQgdGhlIHdyYXBwaW5nIDxpbnM+LVRhZ3MgKHdoaWxlIG1haW50YWluaW5nIGNvbnRlbnQpXG4gICAgICAgICAqIEBwYXJhbSBodG1sXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpZmZIdG1sVG9GaW5hbFRleHQgPSBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmh0bWxUb0ZyYWdtZW50KGh0bWwpO1xuXG4gICAgICAgICAgICB2YXIgZGVsTm9kZXMgPSBmcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZGVsZXRlLCBkZWwnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWxOb2Rlc1tpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRlbE5vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluc05vZGVzID0gZnJhZ21lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5zJyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5zTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5zID0gaW5zTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlucy5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gaW5zLmNoaWxkTm9kZXMuaXRlbSgwKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBpbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5zZXJ0Tm9kZXMgPSBmcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaW5zZXJ0Jyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwO2kgPCBpbnNlcnROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ1NTQ2xhc3MoaW5zZXJ0Tm9kZXNbaV0sICdpbnNlcnQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZURvbShmcmFnbWVudCwgZmFsc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbE9sZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbE5ld1xuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXRlY3RSZXBsYWNlbWVudFR5cGUgPSBmdW5jdGlvbiAoaHRtbE9sZCwgaHRtbE5ldykge1xuICAgICAgICAgICAgaHRtbE9sZCA9IHRoaXMuX25vcm1hbGl6ZUh0bWxGb3JEaWZmKGh0bWxPbGQpO1xuICAgICAgICAgICAgaHRtbE5ldyA9IHRoaXMuX25vcm1hbGl6ZUh0bWxGb3JEaWZmKGh0bWxOZXcpO1xuXG4gICAgICAgICAgICBpZiAoaHRtbE9sZCA9PT0gaHRtbE5ldykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRZUEVfUkVQTEFDRU1FTlQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpLCBmb3VuZERpZmY7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBmb3VuZERpZmYgPSBmYWxzZTsgaSA8IGh0bWxPbGQubGVuZ3RoICYmIGkgPCBodG1sTmV3Lmxlbmd0aCAmJiBmb3VuZERpZmYgPT09IGZhbHNlOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaHRtbE9sZFtpXSAhPT0gaHRtbE5ld1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZERpZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlbWFpbmRlck9sZCA9IGh0bWxPbGQuc3Vic3RyKGkgLSAxKSxcbiAgICAgICAgICAgICAgICByZW1haW5kZXJOZXcgPSBodG1sTmV3LnN1YnN0cihpIC0gMSksXG4gICAgICAgICAgICAgICAgdHlwZSA9IHRoaXMuVFlQRV9SRVBMQUNFTUVOVDtcblxuICAgICAgICAgICAgaWYgKHJlbWFpbmRlck9sZC5sZW5ndGggPiByZW1haW5kZXJOZXcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbWFpbmRlck9sZC5zdWJzdHIocmVtYWluZGVyT2xkLmxlbmd0aCAtIHJlbWFpbmRlck5ldy5sZW5ndGgpID09PSByZW1haW5kZXJOZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHRoaXMuVFlQRV9ERUxFVElPTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlbWFpbmRlck9sZC5sZW5ndGggPCByZW1haW5kZXJOZXcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbWFpbmRlck5ldy5zdWJzdHIocmVtYWluZGVyTmV3Lmxlbmd0aCAtIHJlbWFpbmRlck9sZC5sZW5ndGgpID09PSByZW1haW5kZXJPbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHRoaXMuVFlQRV9JTlNFUlRJT047XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9sZEh0bWxcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0hUTUxcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21MaW5lXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0xpbmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVwbGFjZUxpbmVzID0gZnVuY3Rpb24gKG9sZEh0bWwsIG5ld0hUTUwsIGZyb21MaW5lLCB0b0xpbmUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5leHRyYWN0UmFuZ2VCeUxpbmVOdW1iZXJzKG9sZEh0bWwsIGZyb21MaW5lLCB0b0xpbmUpLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzSHRtbCA9IGRhdGEucHJldmlvdXNIdG1sICsgJzxURU1QTEFURT48L1RFTVBMQVRFPicgKyBkYXRhLnByZXZpb3VzSHRtbEVuZFNuaXBwZXQsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNGcmFnbWVudCA9IHRoaXMuaHRtbFRvRnJhZ21lbnQocHJldmlvdXNIdG1sKSxcbiAgICAgICAgICAgICAgICBmb2xsb3dpbmdIdG1sID0gZGF0YS5mb2xsb3dpbmdIdG1sU3RhcnRTbmlwcGV0ICsgJzxURU1QTEFURT48L1RFTVBMQVRFPicgKyBkYXRhLmZvbGxvd2luZ0h0bWwsXG4gICAgICAgICAgICAgICAgZm9sbG93aW5nRnJhZ21lbnQgPSB0aGlzLmh0bWxUb0ZyYWdtZW50KGZvbGxvd2luZ0h0bWwpLFxuICAgICAgICAgICAgICAgIG5ld0ZyYWdtZW50ID0gdGhpcy5odG1sVG9GcmFnbWVudChuZXdIVE1MKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuaHRtbC5sZW5ndGggPiAwICYmIGRhdGEuaHRtbC5zdWJzdHIoLTEpID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnNlcnREYW5nbGluZ1NwYWNlKG5ld0ZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1lcmdlZCA9IHRoaXMuX3JlcGxhY2VMaW5lc01lcmdlTm9kZUFycmF5cyhwcmV2aW91c0ZyYWdtZW50LmNoaWxkTm9kZXMsIG5ld0ZyYWdtZW50LmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgbWVyZ2VkID0gdGhpcy5fcmVwbGFjZUxpbmVzTWVyZ2VOb2RlQXJyYXlzKG1lcmdlZCwgZm9sbG93aW5nRnJhZ21lbnQuY2hpbGROb2Rlcyk7XG5cbiAgICAgICAgICAgIHZhciBtZXJnZWRGcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVyZ2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkRnJhZ21lbnQuYXBwZW5kQ2hpbGQobWVyZ2VkW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZvcmdvdHRlblRlbXBsYXRlcyA9IG1lcmdlZEZyYWdtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJURU1QTEFURVwiKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmb3Jnb3R0ZW5UZW1wbGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBmb3Jnb3R0ZW5UZW1wbGF0ZXNbaV07XG4gICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmb3Jnb3R0ZW5TcGxpdENsYXNzZXMgPSBtZXJnZWRGcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9zLXNwbGl0LWJlZm9yZSwgLm9zLXNwbGl0LWFmdGVyXCIpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGZvcmdvdHRlblNwbGl0Q2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ1NTQ2xhc3MoZm9yZ290dGVuU3BsaXRDbGFzc2VzW2ldLCAnb3Mtc3BsaXQtYmVmb3JlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDU1NDbGFzcyhmb3Jnb3R0ZW5TcGxpdENsYXNzZXNbaV0sICdvcy1zcGxpdC1hZnRlcicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplRG9tKG1lcmdlZEZyYWdtZW50LCB0cnVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFkZENTU0NsYXNzID0gZnVuY3Rpb24gKG5vZGUsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICAgICAgICBjbGFzc2VzID0gKGNsYXNzZXMgPyBjbGFzc2VzLnNwbGl0KCcgJykgOiBbXSk7XG4gICAgICAgICAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbGFzc2VzLmpvaW4oJyAnKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZW1vdmVDU1NDbGFzcyA9IGZ1bmN0aW9uIChub2RlLCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpLFxuICAgICAgICAgICAgICAgIG5ld0NsYXNzZXMgPSBbXTtcbiAgICAgICAgICAgIGNsYXNzZXMgPSAoY2xhc3NlcyA/IGNsYXNzZXMuc3BsaXQoJyAnKSA6IFtdKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjbGFzc2VzW2ldICE9PSBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKGNsYXNzZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdDbGFzc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBuZXdDbGFzc2VzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hZGREaWZmTWFya3VwID0gZnVuY3Rpb24gKG9yaWdpbmFsSFRNTCwgbmV3SFRNTCwgZnJvbUxpbmUsIHRvTGluZSwgZGlmZkZvcm1hdHRlckNiKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZXh0cmFjdFJhbmdlQnlMaW5lTnVtYmVycyhvcmlnaW5hbEhUTUwsIGZyb21MaW5lLCB0b0xpbmUpLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzSHRtbCA9IGRhdGEucHJldmlvdXNIdG1sICsgJzxURU1QTEFURT48L1RFTVBMQVRFPicgKyBkYXRhLnByZXZpb3VzSHRtbEVuZFNuaXBwZXQsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNGcmFnbWVudCA9IHRoaXMuaHRtbFRvRnJhZ21lbnQocHJldmlvdXNIdG1sKSxcbiAgICAgICAgICAgICAgICBmb2xsb3dpbmdIdG1sID0gZGF0YS5mb2xsb3dpbmdIdG1sU3RhcnRTbmlwcGV0ICsgJzxURU1QTEFURT48L1RFTVBMQVRFPicgKyBkYXRhLmZvbGxvd2luZ0h0bWwsXG4gICAgICAgICAgICAgICAgZm9sbG93aW5nRnJhZ21lbnQgPSB0aGlzLmh0bWxUb0ZyYWdtZW50KGZvbGxvd2luZ0h0bWwpLFxuICAgICAgICAgICAgICAgIG5ld0ZyYWdtZW50ID0gdGhpcy5odG1sVG9GcmFnbWVudChuZXdIVE1MKSxcbiAgICAgICAgICAgICAgICBvbGRIVE1MID0gZGF0YS5vdXRlckNvbnRleHRTdGFydCArIGRhdGEuaW5uZXJDb250ZXh0U3RhcnQgKyBkYXRhLmh0bWwgK1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmlubmVyQ29udGV4dEVuZCArIGRhdGEub3V0ZXJDb250ZXh0RW5kLFxuICAgICAgICAgICAgICAgIG9sZEZyYWdtZW50ID0gdGhpcy5odG1sVG9GcmFnbWVudChvbGRIVE1MKSxcbiAgICAgICAgICAgICAgICBlbDtcblxuICAgICAgICAgICAgdmFyIGRpZmZGcmFnbWVudCA9IGRpZmZGb3JtYXR0ZXJDYihvbGRGcmFnbWVudCwgbmV3RnJhZ21lbnQpO1xuXG4gICAgICAgICAgICB2YXIgbWVyZ2VkRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICB3aGlsZSAocHJldmlvdXNGcmFnbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBwcmV2aW91c0ZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNGcmFnbWVudC5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgbWVyZ2VkRnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGRpZmZGcmFnbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBkaWZmRnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBkaWZmRnJhZ21lbnQucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgIG1lcmdlZEZyYWdtZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChmb2xsb3dpbmdGcmFnbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBmb2xsb3dpbmdGcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGZvbGxvd2luZ0ZyYWdtZW50LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICBtZXJnZWRGcmFnbWVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmb3Jnb3R0ZW5UZW1wbGF0ZXMgPSBtZXJnZWRGcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiVEVNUExBVEVcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmdvdHRlblRlbXBsYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGVsID0gZm9yZ290dGVuVGVtcGxhdGVzW2ldO1xuICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplRG9tKG1lcmdlZEZyYWdtZW50LCB0cnVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRhcHRlZCBmcm9tIGh0dHA6Ly9lam9obi5vcmcvcHJvamVjdHMvamF2YXNjcmlwdC1kaWZmLWFsZ29yaXRobS9cbiAgICAgICAgICogYnkgSm9obiBSZXNpZywgTUlUIExpY2Vuc2VcbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gb2xkQXJyXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IG5ld0FyclxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGlmZiA9IGZ1bmN0aW9uIChvbGRBcnIsIG5ld0Fycikge1xuICAgICAgICAgICAgdmFyIG5zID0ge30sXG4gICAgICAgICAgICAgICAgb3MgPSB7fSxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5zW25ld0FycltpXV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgbnNbbmV3QXJyW2ldXSA9IHtyb3dzOiBbXSwgbzogbnVsbH07XG4gICAgICAgICAgICAgICAgbnNbbmV3QXJyW2ldXS5yb3dzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvbGRBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAob3Nbb2xkQXJyW2ldXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBvc1tvbGRBcnJbaV1dID0ge3Jvd3M6IFtdLCBuOiBudWxsfTtcbiAgICAgICAgICAgICAgICBvc1tvbGRBcnJbaV1dLnJvd3MucHVzaChpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpIGluIG5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5zW2ldLnJvd3MubGVuZ3RoID09PSAxICYmIHR5cGVvZihvc1tpXSkgIT09IFwidW5kZWZpbmVkXCIgJiYgb3NbaV0ucm93cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3QXJyW25zW2ldLnJvd3NbMF1dID0ge3RleHQ6IG5ld0Fycltuc1tpXS5yb3dzWzBdXSwgcm93OiBvc1tpXS5yb3dzWzBdfTtcbiAgICAgICAgICAgICAgICAgICAgb2xkQXJyW29zW2ldLnJvd3NbMF1dID0ge3RleHQ6IG9sZEFycltvc1tpXS5yb3dzWzBdXSwgcm93OiBuc1tpXS5yb3dzWzBdfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXdBcnIubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0FycltpXS50ZXh0ICE9PSBudWxsICYmIG5ld0FycltpICsgMV0udGV4dCA9PT0gdW5kZWZpbmVkICYmIG5ld0FycltpXS5yb3cgKyAxIDwgb2xkQXJyLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBvbGRBcnJbbmV3QXJyW2ldLnJvdyArIDFdLnRleHQgPT09IHVuZGVmaW5lZCAmJiBuZXdBcnJbaSArIDFdID09IG9sZEFycltuZXdBcnJbaV0ucm93ICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3QXJyW2kgKyAxXSA9IHt0ZXh0OiBuZXdBcnJbaSArIDFdLCByb3c6IG5ld0FycltpXS5yb3cgKyAxfTtcbiAgICAgICAgICAgICAgICAgICAgb2xkQXJyW25ld0FycltpXS5yb3cgKyAxXSA9IHt0ZXh0OiBvbGRBcnJbbmV3QXJyW2ldLnJvdyArIDFdLCByb3c6IGkgKyAxfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IG5ld0Fyci5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0FycltpXS50ZXh0ICE9PSBudWxsICYmIG5ld0FycltpIC0gMV0udGV4dCA9PT0gdW5kZWZpbmVkICYmIG5ld0FycltpXS5yb3cgPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIG9sZEFycltuZXdBcnJbaV0ucm93IC0gMV0udGV4dCA9PT0gdW5kZWZpbmVkICYmIG5ld0FycltpIC0gMV0gPT0gb2xkQXJyW25ld0FycltpXS5yb3cgLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdBcnJbaSAtIDFdID0ge3RleHQ6IG5ld0FycltpIC0gMV0sIHJvdzogbmV3QXJyW2ldLnJvdyAtIDF9O1xuICAgICAgICAgICAgICAgICAgICBvbGRBcnJbbmV3QXJyW2ldLnJvdyAtIDFdID0ge3RleHQ6IG9sZEFycltuZXdBcnJbaV0ucm93IC0gMV0sIHJvdzogaSAtIDF9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtvOiBvbGRBcnIsIG46IG5ld0Fycn07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fdG9rZW5pemVIdG1sID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgdmFyIHNwbGl0QXJyYXlFbnRyaWVzRW1iZWRTZXBhcmF0b3IgPSBmdW5jdGlvbiAoYXJyLCBieSwgcHJlcGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdBcnIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldWzBdID09PSAnPCcgJiYgKGJ5ID09PSBcIiBcIiB8fCBieSA9PT0gXCJcXG5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHNwbGl0IEhUTUwgdGFnc1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gYXJyW2ldLnNwbGl0KGJ5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydHNbMF0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Fyci5wdXNoKHBhcnRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Fyci5wdXNoKGJ5ICsgcGFydHNbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHBhcnRzLmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdBcnIucHVzaChwYXJ0c1tqXSArIGJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdBcnIucHVzaChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdBcnI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHNwbGl0QXJyYXlFbnRyaWVzU3BsaXRTZXBhcmF0b3IgPSBmdW5jdGlvbiAoYXJyLCBieSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdBcnIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldWzBdID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Fyci5wdXNoKGFycltpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBhcnJbaV0uc3BsaXQoYnkpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdBcnIucHVzaChieSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdBcnIucHVzaChwYXJ0c1tqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0FycjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgYXJyID0gc3BsaXRBcnJheUVudHJpZXNFbWJlZFNlcGFyYXRvcihbc3RyXSwgJzwnLCB0cnVlKTtcbiAgICAgICAgICAgIGFyciA9IHNwbGl0QXJyYXlFbnRyaWVzRW1iZWRTZXBhcmF0b3IoYXJyLCAnPicsIGZhbHNlKTtcbiAgICAgICAgICAgIGFyciA9IHNwbGl0QXJyYXlFbnRyaWVzU3BsaXRTZXBhcmF0b3IoYXJyLCBcIiBcIik7XG4gICAgICAgICAgICBhcnIgPSBzcGxpdEFycmF5RW50cmllc1NwbGl0U2VwYXJhdG9yKGFyciwgXCIuXCIpO1xuICAgICAgICAgICAgYXJyID0gc3BsaXRBcnJheUVudHJpZXNTcGxpdFNlcGFyYXRvcihhcnIsIFwiLFwiKTtcbiAgICAgICAgICAgIGFyciA9IHNwbGl0QXJyYXlFbnRyaWVzU3BsaXRTZXBhcmF0b3IoYXJyLCBcIiFcIik7XG4gICAgICAgICAgICBhcnIgPSBzcGxpdEFycmF5RW50cmllc1NwbGl0U2VwYXJhdG9yKGFyciwgXCItXCIpO1xuICAgICAgICAgICAgYXJyID0gc3BsaXRBcnJheUVudHJpZXNFbWJlZFNlcGFyYXRvcihhcnIsIFwiXFxuXCIsIGZhbHNlKTtcblxuICAgICAgICAgICAgdmFyIGFycldpdGhvdXRFbXB0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycltpXSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyV2l0aG91dEVtcHRlcy5wdXNoKGFycltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXJyV2l0aG91dEVtcHRlcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9sZFN0clxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3U3RyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kaWZmU3RyaW5nID0gZnVuY3Rpb24gKG9sZFN0ciwgbmV3U3RyKSB7XG4gICAgICAgICAgICBvbGRTdHIgPSB0aGlzLl9ub3JtYWxpemVIdG1sRm9yRGlmZihvbGRTdHIucmVwbGFjZSgvXFxzKyQvLCAnJykucmVwbGFjZSgvXlxccysvLCAnJykpO1xuICAgICAgICAgICAgbmV3U3RyID0gdGhpcy5fbm9ybWFsaXplSHRtbEZvckRpZmYobmV3U3RyLnJlcGxhY2UoL1xccyskLywgJycpLnJlcGxhY2UoL15cXHMrLywgJycpKTtcblxuICAgICAgICAgICAgdmFyIG91dCA9IHRoaXMuX2RpZmYodGhpcy5fdG9rZW5pemVIdG1sKG9sZFN0ciksIHRoaXMuX3Rva2VuaXplSHRtbChuZXdTdHIpKTtcblxuICAgICAgICAgICAgLy8gVGhpcyBmaXhlcyB0aGUgcHJvYmxlbSB0ZXN0ZWQgYnkgXCJkb2VzIG5vdCBsb3NlIHdvcmRzIHdoZW4gY2hhbmdlcyBhcmUgbW92ZWQgWC13aXNlXCJcbiAgICAgICAgICAgIHZhciBsYXN0Um93ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIHogPSAwOyB6IDwgb3V0Lm4ubGVuZ3RoOyB6KyspIHtcbiAgICAgICAgICAgICAgICBpZiAob3V0Lm5bel0ucm93ICYmIG91dC5uW3pdLnJvdyA+IGxhc3RSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFJvdyA9IG91dC5uW3pdLnJvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG91dC5uW3pdLnJvdyAmJiBvdXQublt6XS5yb3cgPCBsYXN0Um93KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5vW291dC5uW3pdLnJvd10gPSBvdXQub1tvdXQublt6XS5yb3ddLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIG91dC5uW3pdID0gb3V0Lm5bel0udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdHIgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgIGlmIChvdXQubi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3V0Lm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9ICc8ZGVsPicgKyBvdXQub1tpXSArIFwiPC9kZWw+XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3V0Lm5bMF0udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0Lm8ubGVuZ3RoICYmIG91dC5vW2tdLnRleHQgPT09IHVuZGVmaW5lZDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJzxkZWw+JyArIG91dC5vW2tdICsgXCI8L2RlbD5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjdXJyT2xkUm93ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3V0Lm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5uW2ldLnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5uW2ldICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICc8aW5zPicgKyBvdXQubltpXSArIFwiPC9pbnM+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0Lm5baV0ucm93IDwgY3Vyck9sZFJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICc8aW5zPicgKyBvdXQubltpXS50ZXh0ICsgXCI8L2lucz5cIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmUgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGkgKyAxKSA8IG91dC5uLmxlbmd0aCAmJiBvdXQubltpICsgMV0ucm93ICE9PSB1bmRlZmluZWQgJiYgb3V0Lm5baSArIDFdLnJvdyA+IG91dC5uW2ldLnJvdyArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gb3V0Lm5baV0ucm93ICsgMTsgbiA8IG91dC5uW2kgKyAxXS5yb3c7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm9bbl0udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmUgKz0gJzxkZWw+JyArIG91dC5vW25dICsgXCI8L2RlbD5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZSArPSAnPGRlbD4nICsgb3V0Lm9bbl0udGV4dCArIFwiPC9kZWw+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBvdXQubltpXS5yb3cgKyAxOyBqIDwgb3V0Lm8ubGVuZ3RoICYmIG91dC5vW2pdLnRleHQgPT09IHVuZGVmaW5lZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZSArPSAnPGRlbD4nICsgb3V0Lm9bal0gKyBcIjwvZGVsPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBvdXQubltpXS50ZXh0ICsgcHJlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyT2xkUm93ID0gb3V0Lm5baV0ucm93O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrL2csICcnKS5yZXBsYWNlKC9cXHMrJC9nLCAnJykucmVwbGFjZSgvIHsyLH0vZywgJyAnKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lzVmFsaWRJbmxpbmVIdG1sID0gZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIEhUTUwgdGFncywgd2UgYXNzdW1lIGl0J3MgdmFsaWQgYW5kIHNraXAgZnVydGhlciBjaGVja3NcbiAgICAgICAgICAgIGlmICghaHRtbC5tYXRjaCgvPFtePl0qPi8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGNoZWNrIGlmIHRoaXMgaXMgYSB2YWxpZCBIVE1MIHRoYXQgY2xvc2VzIGFsbCBpdHMgdGFncyBhZ2FpbiB1c2luZyB0aGUgaW5uZXJIVE1MLUhhY2sgdG8gY29ycmVjdFxuICAgICAgICAgICAgLy8gdGhlIHN0cmluZyBhbmQgY2hlY2sgaWYgdGhlIG51bWJlciBvZiBIVE1MIHRhZ3MgY2hhbmdlcyBieSB0aGlzXG4gICAgICAgICAgICB2YXIgZG9jID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBkb2MuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICAgIHZhciB0YWdzQmVmb3JlID0gKGh0bWwubWF0Y2goLzwvZykgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciB0YWdzQ29ycmVjdGVkID0gKGRvYy5pbm5lckhUTUwubWF0Y2goLzwvZykgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0YWdzQmVmb3JlICE9PSB0YWdzQ29ycmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIEhUTUwgaGFzIGNoYW5nZWQgPT4gaXQgd2FzIG5vdCB2YWxpZFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW55IGJsb2NrIGVsZW1lbnQgaW5zaWRlLCB3ZSBjb25zaWRlciBpdCBhcyBicm9rZW4sIGFzIHRoaXMgc3RyaW5nIHdpbGwgYmUgZGlzcGxheWVkXG4gICAgICAgICAgICAvLyBpbnNpZGUgb2YgPGlucz4vPGRlbD4gdGFnc1xuICAgICAgICAgICAgaWYgKGh0bWwubWF0Y2goLzwoZGl2fHB8dWx8bGl8YmxvY2txdW90ZSlcXFcvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RpZmZEZXRlY3RCcm9rZW5EaWZmSHRtbCA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgIC8vIElmIG90aGVyIEhUTUwgdGFncyBhcmUgY29udGFpbmVkIHdpdGhpbiBJTlMvREVMIChlLmcuIFwiPGlucz5UZXN0PC9wPjwvaW5zPlwiKSwgbGV0J3MgYmV0dGVyIGJlIGNhdXRpb3VzXG4gICAgICAgICAgICAvLyBUaGUgXCIhIShmb3VuZD0uLi4pXCItY29uc3RydWN0aW9uIGlzIG9ubHkgdXNlZCB0byBtYWtlIGpzaGludCBoYXBweSA6KVxuICAgICAgICAgICAgdmFyIGZpbmREZWwgPSAvPGRlbD4oLio/KTxcXC9kZWw+L2dpLFxuICAgICAgICAgICAgICAgIGZpbmRJbnMgPSAvPGlucz4oLio/KTxcXC9pbnM+L2dpLFxuICAgICAgICAgICAgICAgIGZvdW5kLCBpbm5lcjtcbiAgICAgICAgICAgIHdoaWxlICghIShmb3VuZCA9IGZpbmREZWwuZXhlYyhodG1sKSkpIHtcbiAgICAgICAgICAgICAgICBpbm5lciA9IGZvdW5kWzFdLnJlcGxhY2UoLzxicltePl0qPi9naSwgJycpO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lci5tYXRjaCgvPFtePl0qPi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICghIShmb3VuZCA9IGZpbmRJbnMuZXhlYyhodG1sKSkpIHtcbiAgICAgICAgICAgICAgICBpbm5lciA9IGZvdW5kWzFdLnJlcGxhY2UoLzxicltePl0qPi9naSwgJycpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNWYWxpZElubGluZUh0bWwoaW5uZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm9uIG9mIHRoZSBjb25kaXRpb25zIHVwIHRvIG5vdyBpcyBtZXQsIHdlIGNvbnNpZGVyIHRoZSBkaWZmIGFzIGJlaW5nIHNhbmVcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9kaWZmUGFyYWdyYXBocyA9IGZ1bmN0aW9uKG9sZFRleHQsIG5ld1RleHQsIGxpbmVMZW5ndGgsIGZpcnN0TGluZU51bWJlcikge1xuICAgICAgICAgICAgdmFyIG9sZFRleHRXaXRoQnJlYWtzLCBuZXdUZXh0V2l0aEJyZWFrcywgY3VyckNoaWxkO1xuXG4gICAgICAgICAgICBpZiAobGluZUxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb2xkVGV4dFdpdGhCcmVha3MgPSBsaW5lTnVtYmVyaW5nU2VydmljZS5pbnNlcnRMaW5lTnVtYmVyc05vZGUob2xkVGV4dCwgbGluZUxlbmd0aCwgbnVsbCwgZmlyc3RMaW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICBuZXdUZXh0V2l0aEJyZWFrcyA9IGxpbmVOdW1iZXJpbmdTZXJ2aWNlLmluc2VydExpbmVOdW1iZXJzTm9kZShuZXdUZXh0LCBsaW5lTGVuZ3RoLCBudWxsLCBmaXJzdExpbmVOdW1iZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbGRUZXh0V2l0aEJyZWFrcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIG9sZFRleHRXaXRoQnJlYWtzLmlubmVySFRNTCA9IG9sZFRleHQ7XG4gICAgICAgICAgICAgICAgbmV3VGV4dFdpdGhCcmVha3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBuZXdUZXh0V2l0aEJyZWFrcy5pbm5lckhUTUwgPSBuZXdUZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZFRleHRXaXRoQnJlYWtzLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyQ2hpbGQgPSBvbGRUZXh0V2l0aEJyZWFrcy5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyQ2hpbGQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcERlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RlbCcpO1xuICAgICAgICAgICAgICAgICAgICBvbGRUZXh0V2l0aEJyZWFrcy5pbnNlcnRCZWZvcmUod3JhcERlbCwgY3VyckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkVGV4dFdpdGhCcmVha3MucmVtb3ZlQ2hpbGQoY3VyckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgd3JhcERlbC5hcHBlbmRDaGlsZChjdXJyQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ1NTQ2xhc3MoY3VyckNoaWxkLCAnZGVsZXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNvbG9yU3R5bGVzKGN1cnJDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ld1RleHRXaXRoQnJlYWtzLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyQ2hpbGQgPSBuZXdUZXh0V2l0aEJyZWFrcy5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyQ2hpbGQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcElucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucycpO1xuICAgICAgICAgICAgICAgICAgICBuZXdUZXh0V2l0aEJyZWFrcy5pbnNlcnRCZWZvcmUod3JhcElucywgY3VyckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3VGV4dFdpdGhCcmVha3MucmVtb3ZlQ2hpbGQoY3VyckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgd3JhcElucy5hcHBlbmRDaGlsZChjdXJyQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ1NTQ2xhc3MoY3VyckNoaWxkLCAnaW5zZXJ0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNvbG9yU3R5bGVzKGN1cnJDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWVyZ2VkRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgICAgICAgICAgZWw7XG4gICAgICAgICAgICB3aGlsZSAob2xkVGV4dFdpdGhCcmVha3MuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGVsID0gb2xkVGV4dFdpdGhCcmVha3MuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBvbGRUZXh0V2l0aEJyZWFrcy5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgbWVyZ2VkRnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG5ld1RleHRXaXRoQnJlYWtzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBlbCA9IG5ld1RleHRXaXRoQnJlYWtzLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgbmV3VGV4dFdpdGhCcmVha3MucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgIG1lcmdlZEZyYWdtZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZURvbShtZXJnZWRGcmFnbWVudCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hZGRDU1NDbGFzc1RvRmlyc3RUYWcgPSBmdW5jdGlvbiAoaHRtbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKC88W2Etel1bXj5dKj4vaSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoLm1hdGNoKC9jbGFzcz1bXCInXVthLXowLTkgXy1dKltcIiddL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaC5yZXBsYWNlKC9jbGFzcz1bXCInXShbYS16MC05IF8tXSopW1wiJ10vaSwgZnVuY3Rpb24gKG1hdGNoMiwgcHJldmlvdXNDbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjbGFzcz1cXFwiXCIgKyBwcmV2aW91c0NsYXNzZXMgKyBcIiBcIiArIGNsYXNzTmFtZSArIFwiXFxcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2guc3Vic3RyaW5nKDAsIG1hdGNoLmxlbmd0aCAtIDEpICsgXCIgY2xhc3M9XFxcIlwiICsgY2xhc3NOYW1lICsgXCJcXFwiPlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2FkZENsYXNzVG9MYXN0Tm9kZSA9IGZ1bmN0aW9uIChodG1sLCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICB2YXIgZm91bmRMYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAhZm91bmRMYXN0OyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlc1tpXS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NlcyA9IG5vZGUuY2hpbGROb2Rlc1tpXS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGROb2Rlc1tpXS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBjbGFzc2VzLnNvcnQoKS5qb2luKCcgJykucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZExhc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlLmlubmVySFRNTDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiByZW1vdmVzIGNvbG9yLUF0dHJpYnV0ZXMgZnJvbSB0aGUgc3R5bGVzIG9mIHRoaXMgbm9kZSBvciBhIGRlc2NlbmRhbnQsXG4gICAgICAgICAqIGFzIHRoZXkgaW50ZXJmZXIgd2l0aCB0aGUgZ3JlZW4vcmVkIGNvbG9yIGluIEhUTUwgYW5kIFBERlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIG1vbWVudCwgaXQgaXMgc3VmZmljaWVudCB0byBkbyB0aGlzIG9ubHkgaW4gcGFyYWdyYXBoIGRpZmYgbW9kZSwgYXMgd2UgZmFsbCBiYWNrIHRvIHRoaXMgbW9kZSBhbnl3YXlcbiAgICAgICAgICogb25jZSB3ZSBlbmNvdW50ZXIgU1BBTnMgb3Igb3RoZXIgdGFncyBpbnNpZGUgb2YgSU5TL0RFTC10YWdzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVtb3ZlQ29sb3JTdHlsZXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgaWYgKHN0eWxlcyAmJiBzdHlsZXMuaW5kZXhPZignY29sb3InKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlc05ldyA9IFtdO1xuICAgICAgICAgICAgICAgIHN0eWxlcy5zcGxpdCgnOycpLmZvckVhY2goZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZS5tYXRjaCgvXlxccypjb2xvclxccyo6L2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNOZXcucHVzaChzdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVzTmV3LmpvaW4oXCI7XCIpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZXNOZXcuam9pbihcIjtcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNvbG9yU3R5bGVzKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGZpeGVzIGEgdmVyeSBzcGVjaWZpYywgcmVhbGx5IHdlaXJkIGJ1ZyB0aGF0IGlzIHRlc3RlZCBpbiB0aGUgdGVzdCBjYXNlIFwiZG9lcyBub3QgYSBjaGFuZ2UgaW4gYSB2ZXJ5IHNwZWNpZmljIGNhc2VcIi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9ZGlmZlN0clxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9maXhXcm9uZ0NoYW5nZURldGVjdGlvbiA9IGZ1bmN0aW9uIChkaWZmU3RyKSB7XG4gICAgICAgICAgICBpZiAoZGlmZlN0ci5pbmRleE9mKCc8ZGVsPicpID09PSAtMSB8fCBkaWZmU3RyLmluZGV4T2YoJzxpbnM+JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmZTdHI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaW5kRGVsR3JvdXBGaW5kZXIgPSAvKD86PGRlbD4uKj88XFwvZGVsPikrL2dpLFxuICAgICAgICAgICAgICAgIGZvdW5kLFxuICAgICAgICAgICAgICAgIHJldHVyblN0ciA9IGRpZmZTdHI7XG5cbiAgICAgICAgICAgIHdoaWxlICghIShmb3VuZCA9IGZpbmREZWxHcm91cEZpbmRlci5leGVjKGRpZmZTdHIpKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWwgPSBmb3VuZFswXSxcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSByZXR1cm5TdHIuc3BsaXQoZGVsKTtcblxuICAgICAgICAgICAgICAgIHZhciBmaW5kSW5zR3JvdXBGaW5kZXIgPSAvXig/OjxpbnM+Lio/PFxcL2lucz4pKy9naSxcbiAgICAgICAgICAgICAgICAgICAgZm91bmRJbnMgPSBmaW5kSW5zR3JvdXBGaW5kZXIuZXhlYyhzcGxpdFsxXSk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kSW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnMgPSBmb3VuZEluc1swXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsU2hvcnRlbmVkID0gZGVsLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAvPGRlbD4oKDxCUiBDTEFTUz1cIm9zLWxpbmUtYnJlYWtcIj48XFwvZGVsPjxkZWw+KT8oPHNwYW5bXj5dK29zLWxpbmUtbnVtYmVyW14+XSs/PikoXFxzfDxcXC8/ZGVsPikqPFxcL3NwYW4+KTxcXC9kZWw+L2dpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICAgICAgKS5yZXBsYWNlKC88XFwvZGVsPjxkZWw+L2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc0NvbnYgPSBpbnMucmVwbGFjZSgvPGlucz4vZywgJzxkZWw+JykucmVwbGFjZSgvPFxcL2lucz4vZywgJzwvZGVsPicpLnJlcGxhY2UoLzxcXC9kZWw+PGRlbD4vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsU2hvcnRlbmVkLmluZGV4T2YoaW5zQ29udikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxTaG9ydGVuZWQgPSBkZWxTaG9ydGVuZWQucmVwbGFjZShpbnNDb252LCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsU2hvcnRlbmVkID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblN0ciA9IHJldHVyblN0ci5yZXBsYWNlKGRlbCArIGlucywgZGVsLnJlcGxhY2UoLzxkZWw+L2csICcnKS5yZXBsYWNlKC88XFwvZGVsPi9nLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblN0cjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBkaWZmIGJldHdlZW4gdHdvIHN0cmluZ3MgYW5kIHRyaWVzIHRvIGZpeCBwcm9ibGVtcyB3aXRoIHRoZSByZXN1bHRpbmcgSFRNTC5cbiAgICAgICAgICogSWYgbGluZUxlbmd0aCBhbmQgZmlyc3RMaW5lTnVtYmVyIGlzIGdpdmVuLCBsaW5lIG51bWJlcnMgd2lsbCBiZSByZXR1cm5lZCBlcyB3ZWxsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sT2xkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sTmV3XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lTGVuZ3RoIC0gb3B0aW9uYWxcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpcnN0TGluZU51bWJlciAtIG9wdGlvbmFsXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpZmYgPSBmdW5jdGlvbiAoaHRtbE9sZCwgaHRtbE5ldywgbGluZUxlbmd0aCwgZmlyc3RMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBsaW5lTGVuZ3RoICsgJyAnICsgZmlyc3RMaW5lTnVtYmVyICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcmluZ1NlcnZpY2UuZGpiMmhhc2goaHRtbE9sZCkgKyBsaW5lTnVtYmVyaW5nU2VydmljZS5kamIyaGFzaChodG1sTmV3KSxcbiAgICAgICAgICAgICAgICBjYWNoZWQgPSBkaWZmQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgICAgIGlmICghYW5ndWxhci5pc1VuZGVmaW5lZChjYWNoZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhpcyBmaXhlcyBhIHJlYWxseSBzdHJhbmdlIGFydGVmYWN0IHdpdGggdGhlIGRpZmYgdGhhdCBvY2N1cmVzIHVuZGVyIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgICAgICAgIC8vIC0gVGhlIGZpcnN0IHRhZyBvZiB0aGUgdHdvIHRleHRzIGlzIGlkZW50aWNhbCwgZS5nLiA8cD5cbiAgICAgICAgICAgIC8vIC0gQSBjaGFuZ2UgaGFwcGVucyBpbiB0aGUgbmV4dCB0YWcsIGUuZy4gaW5zZXJ0ZWQgdGV4dFxuICAgICAgICAgICAgLy8gLSBUaGUgZmlyc3QgdGFnIG9jY3VyZXMgYSBzZWNvbmQgdGltZSBpbiB0aGUgdGV4dCwgZS5nLiBhbm90aGVyIDxwPlxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjb25kaXRpb24sIHRoZSBmaXJzdCB0YWcgaXMgZGVsZXRlZCBmaXJzdCBhbmQgaW5zZXJ0ZWQgYWZ0ZXJ3YXJkcyBhZ2FpblxuICAgICAgICAgICAgLy8gVGVzdCBjYXNlOiBcImRvZXMgbm90IGJyZWFrIHdoZW4gYW4gaW5zZXJ0aW9uIGZvbGxvd2VzIGEgYmVnaW5uaW5nIHRhZyBvY2N1cmluZyB0d2ljZVwiXG4gICAgICAgICAgICAvLyBUaGUgd29yayBhcm91bmQgaW5zZXJ0cyB0byB0YWdzIGF0IHRoZSBiZWdpbm5pbmcgYW5kIHJlbW92ZXMgdGhlbSBhZnRlcndhcmRzIGFnYWluLFxuICAgICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIHRoaXMgc2l0dWF0aW9uIGRvZXMgbm90IGhhcHBlbiAoYW5kIHVzZXMgaW52aXNpYmxlIHBzZXVkby10YWdzIGluIGNhc2Ugc29tZXRoaW5nIGdvZXMgd3JvbmcpXG4gICAgICAgICAgICB2YXIgd29ya2Fyb3VuZFByZXBlbmQgPSBcIjxEVU1NWT48UFJFUEVORD5cIjtcblxuICAgICAgICAgICAgLy8gb3Mtc3BsaXQtYWZ0ZXIgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGZvciBkZXRlY3RpbmcgY2hhbmdlcyBpbiBwYXJhZ3JhcGhzLCBzbyB3ZSBzdHJpcCBpdCBoZXJlXG4gICAgICAgICAgICAvLyBhbmQgYWRkIGl0IGFmdGVyd2FyZHMuXG4gICAgICAgICAgICAvLyBXZSBvbmx5IGRvIHRoaXMgZm9yIFAgZm9yIG5vdywgYXMgZm9yIG1vcmUgY29tcGxleCB0eXBlcyBsaWtlIFVML0xJIHRoYXQgdGVuZCB0byBiZSBuZXN0ZW5kLFxuICAgICAgICAgICAgLy8gaW5mb3JtYXRpb24gd291bGQgZ2V0IGxvc3QgYnkgdGhpcyB0aGF0IHdlIHdpbGwgbmVlZCB0byByZWN1cnNpdmVseSBtZXJnZSBpdCBhZ2FpbiBsYXRlciBvbi5cbiAgICAgICAgICAgIHZhciBvbGRJc1NwbGl0QWZ0ZXIgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBuZXdJc1NwbGl0QWZ0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGh0bWxPbGQgPSBodG1sT2xkLnJlcGxhY2UoLyhcXHMqPHBbXj5dK2NsYXNzXFxzKj1cXHMqW1wiJ11bXlwiJ10qKW9zLXNwbGl0LWFmdGVyL2dpLCBmdW5jdGlvbihtYXRjaCwgYmVnaW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgb2xkSXNTcGxpdEFmdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVnaW5uaW5nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBodG1sTmV3ID0gaHRtbE5ldy5yZXBsYWNlKC8oXFxzKjxwW14+XStjbGFzc1xccyo9XFxzKltcIiddW15cIiddKilvcy1zcGxpdC1hZnRlci9naSwgZnVuY3Rpb24obWF0Y2gsIGJlZ2lubmluZykge1xuICAgICAgICAgICAgICAgIG5ld0lzU3BsaXRBZnRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlZ2lubmluZztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBQZXJmb3JtaW5nIHRoZSBhY3R1YWwgZGlmZlxuICAgICAgICAgICAgdmFyIHN0ciA9IHRoaXMuX2RpZmZTdHJpbmcod29ya2Fyb3VuZFByZXBlbmQgKyBodG1sT2xkLCB3b3JrYXJvdW5kUHJlcGVuZCArIGh0bWxOZXcpLFxuICAgICAgICAgICAgICAgIGRpZmZVbm5vcm1hbGl6ZWQgPSBzdHIucmVwbGFjZSgvXlxccysvZywgJycpLnJlcGxhY2UoL1xccyskL2csICcnKS5yZXBsYWNlKC8gezIsfS9nLCAnICcpO1xuXG5cbiAgICAgICAgICAgIGRpZmZVbm5vcm1hbGl6ZWQgPSB0aGlzLl9maXhXcm9uZ0NoYW5nZURldGVjdGlvbihkaWZmVW5ub3JtYWxpemVkKTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIDxkZWw+IHRhZ3MgdGhhdCBvbmx5IGRlbGV0ZSBsaW5lIG51bWJlcnNcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgcmVtb3ZpbmcgPC9kZWw+PGRlbD4gYXMgZG9uZSBpbiBvbmUgb2YgdGhlIG5leHQgc3RhdGVtZW50c1xuICAgICAgICAgICAgZGlmZlVubm9ybWFsaXplZCA9IGRpZmZVbm5vcm1hbGl6ZWQucmVwbGFjZShcbiAgICAgICAgICAgICAgICAvPGRlbD4oKDxCUiBDTEFTUz1cIm9zLWxpbmUtYnJlYWtcIj48XFwvZGVsPjxkZWw+KT8oPHNwYW5bXj5dK29zLWxpbmUtbnVtYmVyW14+XSs/PikoXFxzfDxcXC8/ZGVsPikqPFxcL3NwYW4+KTxcXC9kZWw+L2dpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGZvdW5kLHRhZyxicixzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoYnIgIT09IHVuZGVmaW5lZCA/IGJyIDogJycpICsgc3BhbiArICcgPC9zcGFuPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZGlmZlVubm9ybWFsaXplZCA9IGRpZmZVbm5vcm1hbGl6ZWQucmVwbGFjZSgvPFxcL2lucz48aW5zPi9naSwgJycpLnJlcGxhY2UoLzxcXC9kZWw+PGRlbD4vZ2ksICcnKTtcblxuICAgICAgICAgICAgLy8gTW92ZSB3aGl0ZXNwYWNlcyBhcm91bmQgaW5zZXJ0ZWQgUCdzIG91dCBvZiB0aGUgSU5TLXRhZ1xuICAgICAgICAgICAgZGlmZlVubm9ybWFsaXplZCA9IGRpZmZVbm5vcm1hbGl6ZWQucmVwbGFjZShcbiAgICAgICAgICAgICAgICAvPGlucz4oXFxzKikoPHAoIFtePl0qKT8+W1xcc1xcU10qPzxcXC9wPikoXFxzKik8XFwvaW5zPi9naW0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24obWF0Y2gsIHdoaXRlQmVmb3JlLCBpbm5lciwgdGFnSW5uZXIsIHdoaXRlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdoaXRlQmVmb3JlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPHAoIFtePl0qKT8+L2dpLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCArIFwiPGlucz5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPFxcL3A+L2dpLCBcIjwvaW5zPjwvcD5cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGVBZnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBGaXhlcyBIVE1MIHByb2R1Y2VkIGJ5IHRoZSBkaWZmIGxpa2UgdGhpczpcbiAgICAgICAgICAgIC8vIGZyb206IDxkZWw+PC9QPjwvZGVsPjxpbnM+IEluc2VydGVkIFRleHQ8L1A+XFxuPFA+TW9yZSBpbnNlcnRlZCB0ZXh0PC9QPjwvaW5zPlxuICAgICAgICAgICAgLy8gaW50bzogPGlucz4gSW5zZXJ0ZWQgVGV4dDwvaW5zPjwvUD5cXG48UD5Nb3JlIGluc2VydGVkIHRleHQ8L2lucz48L1A+XG4gICAgICAgICAgICBkaWZmVW5ub3JtYWxpemVkID0gZGlmZlVubm9ybWFsaXplZC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC88ZGVsPjxcXC9wPjxcXC9kZWw+PGlucz4oW1xcc1xcU10qPyk8XFwvcD48XFwvaW5zPi9naW0sXG4gICAgICAgICAgICAgICAgXCI8aW5zPiQxPC9pbnM+PC9wPlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGlmZlVubm9ybWFsaXplZCA9IGRpZmZVbm5vcm1hbGl6ZWQucmVwbGFjZShcbiAgICAgICAgICAgICAgICAvPGlucz5bXFxzXFxTXSo/PFxcL2lucz4vZ2ltLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaC5yZXBsYWNlKC8oPFxcL3A+XFxzKjxwPikvZ2ksIFwiPC9pbnM+JDE8aW5zPlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBJZiBvbmx5IGEgZmV3IGNoYXJhY3RlcnMgb2YgYSB3b3JkIGhhdmUgY2hhbmdlZCwgZG9uJ3QgZGlzcGxheSB0aGlzIGFzIGEgcmVwbGFjZW1lbnQgb2YgdGhlIHdob2xlIHdvcmQsXG4gICAgICAgICAgICAvLyBidXQgb25seSBvZiB0aGVzZSBzcGVjaWZpYyBjaGFyYWN0ZXJzXG4gICAgICAgICAgICBkaWZmVW5ub3JtYWxpemVkID0gZGlmZlVubm9ybWFsaXplZC5yZXBsYWNlKC88ZGVsPihbYS16MC05LF8tXSogPyk8XFwvZGVsPjxpbnM+KFthLXowLTksXy1dKiA/KTxcXC9pbnM+L2dpLCBmdW5jdGlvbiAoZm91bmQsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm91bmREaWZmID0gZmFsc2UsIGNvbW1vblN0YXJ0ID0gJycsIGNvbW1vbkVuZCA9ICcnLFxuICAgICAgICAgICAgICAgICAgICByZW1haW5kZXJPbGQgPSBvbGRUZXh0LCByZW1haW5kZXJOZXcgPSBuZXdUZXh0O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlbWFpbmRlck9sZC5sZW5ndGggPiAwICYmIHJlbWFpbmRlck5ldy5sZW5ndGggPiAwICYmICFmb3VuZERpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbWFpbmRlck9sZFswXSA9PT0gcmVtYWluZGVyTmV3WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tb25TdGFydCArPSByZW1haW5kZXJPbGRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5kZXJPbGQgPSByZW1haW5kZXJPbGQuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyTmV3ID0gcmVtYWluZGVyTmV3LnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kRGlmZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3VuZERpZmYgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVtYWluZGVyT2xkLmxlbmd0aCA+IDAgJiYgcmVtYWluZGVyTmV3Lmxlbmd0aCA+IDAgJiYgIWZvdW5kRGlmZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtYWluZGVyT2xkW3JlbWFpbmRlck9sZC5sZW5ndGggLSAxXSA9PT0gcmVtYWluZGVyTmV3W3JlbWFpbmRlck5ldy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uRW5kID0gcmVtYWluZGVyT2xkW3JlbWFpbmRlck9sZC5sZW5ndGggLSAxXSArIGNvbW1vbkVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlck5ldyA9IHJlbWFpbmRlck5ldy5zdWJzdHIoMCwgcmVtYWluZGVyTmV3Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyT2xkID0gcmVtYWluZGVyT2xkLnN1YnN0cigwLCByZW1haW5kZXJPbGQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZERpZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG91dCA9IGNvbW1vblN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChyZW1haW5kZXJPbGQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnPGRlbD4nICsgcmVtYWluZGVyT2xkICsgJzwvZGVsPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZW1haW5kZXJOZXcgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnPGlucz4nICsgcmVtYWluZGVyTmV3ICsgJzwvaW5zPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCArPSBjb21tb25FbmQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFJlcGxhY2Ugc3BhY2VzIGluIGxpbmUgbnVtYmVycyBieSAmbmJzcDtcbiAgICAgICAgICAgIGRpZmZVbm5vcm1hbGl6ZWQgPSBkaWZmVW5ub3JtYWxpemVkLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgLzxzcGFuW14+XStvcy1saW5lLW51bWJlcltePl0rPz5cXHMqPFxcL3NwYW4+L2dpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLz4gPFxcL3NwYW4vZ2ksIFwiPiZuYnNwOzwvc3BhblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG5cbiAgICAgICAgICAgIGlmIChkaWZmVW5ub3JtYWxpemVkLnN1YnN0cigwLCB3b3JrYXJvdW5kUHJlcGVuZC5sZW5ndGgpID09PSB3b3JrYXJvdW5kUHJlcGVuZCkge1xuICAgICAgICAgICAgICAgIGRpZmZVbm5vcm1hbGl6ZWQgPSBkaWZmVW5ub3JtYWxpemVkLnN1YnN0cmluZyh3b3JrYXJvdW5kUHJlcGVuZC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGlmZjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaWZmRGV0ZWN0QnJva2VuRGlmZkh0bWwoZGlmZlVubm9ybWFsaXplZCkpIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy5fZGlmZlBhcmFncmFwaHMoaHRtbE9sZCwgaHRtbE5ldywgbGluZUxlbmd0aCwgZmlyc3RMaW5lTnVtYmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZlVubm9ybWFsaXplZCA9IGRpZmZVbm5vcm1hbGl6ZWQucmVwbGFjZSgvPGlucz4uKj8oXFxuLio/KSo8XFwvaW5zPi9naSwgZnVuY3Rpb24gKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gZm91bmQucmVwbGFjZSgvPChkaXZ8cHxsaSlbXj5dKj4vZ2ksIGZ1bmN0aW9uKG1hdGNoKSB7IHJldHVybiBtYXRjaCArICc8aW5zPic7IH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZvdW5kLnJlcGxhY2UoLzxcXC8oZGl2fHB8bGkpW14+XSo+L2dpLCBmdW5jdGlvbihtYXRjaCkgeyByZXR1cm4gJzwvaW5zPicgKyBtYXRjaDsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkaWZmVW5ub3JtYWxpemVkID0gZGlmZlVubm9ybWFsaXplZC5yZXBsYWNlKC88ZGVsPi4qPyhcXG4uKj8pKjxcXC9kZWw+L2dpLCBmdW5jdGlvbiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBmb3VuZC5yZXBsYWNlKC88KGRpdnxwfGxpKVtePl0qPi9naSwgZnVuY3Rpb24obWF0Y2gpIHsgcmV0dXJuIG1hdGNoICsgJzxkZWw+JzsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gZm91bmQucmVwbGFjZSgvPFxcLyhkaXZ8cHxsaSlbXj5dKj4vZ2ksIGZ1bmN0aW9uKG1hdGNoKSB7IHJldHVybiAnPC9kZWw+JyArIG1hdGNoOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRpZmZVbm5vcm1hbGl6ZWQgPSBkaWZmVW5ub3JtYWxpemVkLnJlcGxhY2UoL148ZGVsPjxwPiguKik8XFwvcD48XFwvZGVsPiQvZ2ksIGZ1bmN0aW9uKG1hdGNoLCBpbm5lcikgeyByZXR1cm4gXCI8cD5cIiArIGlubmVyICsgXCI8L3A+XCI7IH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBub2RlLmlubmVySFRNTCA9IGRpZmZVbm5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICAgICAgZGlmZiA9IG5vZGUuaW5uZXJIVE1MO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVMZW5ndGggIT09IHVuZGVmaW5lZCAmJiBmaXJzdExpbmVOdW1iZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbGluZU51bWJlcmluZ1NlcnZpY2UuaW5zZXJ0TGluZU51bWJlcnNOb2RlKGRpZmYsIGxpbmVMZW5ndGgsIG51bGwsIGZpcnN0TGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPSBub2RlLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvbGRJc1NwbGl0QWZ0ZXIgfHwgbmV3SXNTcGxpdEFmdGVyKSB7XG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMuX2FkZENsYXNzVG9MYXN0Tm9kZShkaWZmLCBcIm9zLXNwbGl0LWFmdGVyXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaWZmQ2FjaGUucHV0KGNhY2hlS2V5LCBkaWZmKTtcbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICB9O1xuICAgIH1cbl0pO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5tb3Rpb25zLmRvY3gnLCBbJ09wZW5TbGlkZXNBcHAuY29yZS5kb2N4J10pXG5cbi5mYWN0b3J5KCdNb3Rpb25Eb2N4RXhwb3J0JywgW1xuICAgICckaHR0cCcsXG4gICAgJyRxJyxcbiAgICAnJGZpbHRlcicsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnQ29uZmlnJyxcbiAgICAnQ2F0ZWdvcnknLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0ZpbGVTYXZlcicsXG4gICAgJ2xpbmVOdW1iZXJpbmdTZXJ2aWNlJyxcbiAgICAnSHRtbDJEb2N4Q29udmVydGVyJyxcbiAgICAnTW90aW9uQ29tbWVudCcsXG4gICAgZnVuY3Rpb24gKCRodHRwLCAkcSwgJGZpbHRlciwgb3BlcmF0b3IsIENvbmZpZywgQ2F0ZWdvcnksIGdldHRleHRDYXRhbG9nLFxuICAgICAgICBGaWxlU2F2ZXIsIGxpbmVOdW1iZXJpbmdTZXJ2aWNlLCBIdG1sMkRvY3hDb252ZXJ0ZXIsIE1vdGlvbkNvbW1lbnQpIHtcblxuICAgICAgICB2YXIgUEFHRUJSRUFLID0gJzx3OnA+PHc6cj48dzpiciB3OnR5cGU9XCJwYWdlXCIgLz48L3c6cj48L3c6cD4nO1xuXG4gICAgICAgIHZhciBjb252ZXJ0ZXI7XG5cbiAgICAgICAgdmFyIGdldERhdGEgPSBmdW5jdGlvbiAobW90aW9ucywgcGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICAgICAgLy8gaGVhZGVyXG4gICAgICAgICAgICB2YXIgaGVhZGVybGluZTEgPSBbXG4gICAgICAgICAgICAgICAgQ29uZmlnLnRyYW5zbGF0ZShDb25maWcuZ2V0KCdnZW5lcmFsX2V2ZW50X25hbWUnKS52YWx1ZSksXG4gICAgICAgICAgICAgICAgQ29uZmlnLnRyYW5zbGF0ZShDb25maWcuZ2V0KCdnZW5lcmFsX2V2ZW50X2Rlc2NyaXB0aW9uJykudmFsdWUpXG4gICAgICAgICAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKCcg4oCTICcpO1xuICAgICAgICAgICAgdmFyIGhlYWRlcmxpbmUyID0gW1xuICAgICAgICAgICAgICAgIENvbmZpZy5nZXQoJ2dlbmVyYWxfZXZlbnRfbG9jYXRpb24nKS52YWx1ZSxcbiAgICAgICAgICAgICAgICBDb25maWcuZ2V0KCdnZW5lcmFsX2V2ZW50X2RhdGUnKS52YWx1ZVxuICAgICAgICAgICAgXS5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKTtcbiAgICAgICAgICAgIGRhdGEuaGVhZGVyID0gW2hlYWRlcmxpbmUxLCBoZWFkZXJsaW5lMl0uam9pbignXFxuJyk7XG5cbiAgICAgICAgICAgIC8vIG1vdGlvbiBjYXRhbG9nIHRpdGxlL3ByZWFtYmxlXG4gICAgICAgICAgICBkYXRhLnRpdGxlID0gQ29uZmlnLnRyYW5zbGF0ZShDb25maWcuZ2V0KCdtb3Rpb25zX2V4cG9ydF90aXRsZScpLnZhbHVlKTtcbiAgICAgICAgICAgIGRhdGEucHJlYW1ibGUgPSBDb25maWcuZ2V0KCdtb3Rpb25zX2V4cG9ydF9wcmVhbWJsZScpLnZhbHVlO1xuXG4gICAgICAgICAgICAvLyBjYXRlZ29yaWVzXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IGdldENhdGVnb3JpZXNEYXRhKG1vdGlvbnMpO1xuICAgICAgICAgICAgZGF0YS5oYXNfY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXMubGVuZ3RoID09PSAwID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICAgICAgZGF0YS5jYXRlZ29yaWVzX3RyYW5zbGF0aW9uID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdDYXRlZ29yaWVzJyk7XG4gICAgICAgICAgICBkYXRhLmNhdGVnb3JpZXMgPSBjYXRlZ29yaWVzO1xuICAgICAgICAgICAgZGF0YS5ub19jYXRlZ29yaWVzID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdObyBjYXRlZ29yaWVzIGF2YWlsYWJsZS4nKTtcbiAgICAgICAgICAgIGRhdGEucGFnZWJyZWFrX21haW4gPSBjYXRlZ29yaWVzLmxlbmd0aCA9PT0gMCA/ICcnIDogUEFHRUJSRUFLO1xuXG4gICAgICAgICAgICAvLyBtb3Rpb25zXG4gICAgICAgICAgICBkYXRhLnRhYmxlb2Zjb250ZW50c190cmFuc2xhdGlvbiA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnVGFibGUgb2YgY29udGVudHMnKTtcbiAgICAgICAgICAgIGRhdGEubW90aW9uc19saXN0ID0gZ2V0TW90aW9uU2hvcnREYXRhKG1vdGlvbnMsIHBhcmFtcyk7XG4gICAgICAgICAgICBkYXRhLm5vX21vdGlvbnMgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ05vIG1vdGlvbnMgYXZhaWxhYmxlLicpO1xuXG4gICAgICAgICAgICByZXR1cm4gJHEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBnZXRNb3Rpb25GdWxsRGF0YShtb3Rpb25zLCBwYXJhbXMpLnRoZW4oZnVuY3Rpb24gKG1vdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5tb3Rpb25zID0gbW90aW9uRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRDYXRlZ29yaWVzRGF0YSA9IGZ1bmN0aW9uIChtb3Rpb25zKSB7XG4gICAgICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IF8ubWFwKG1vdGlvbnMsIGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAobW90aW9uLmNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IG1vdGlvbi5jYXRlZ29yeS5wcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBtb3Rpb24uY2F0ZWdvcnkubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGNsZWFyIG91dCAndW5kZWZpbmVkJyBhbmQgbWFrZSB0aGUgY2F0ZWdvcmllcyB1bmlxdWUuXG4gICAgICAgICAgICBjYXRlZ29yaWVzID0gXy51bmlxQnkoXy5maWx0ZXIoY2F0ZWdvcmllcywgZnVuY3Rpb24oY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0ZWdvcnk7XG4gICAgICAgICAgICB9KSwgJ3ByZWZpeCcpO1xuICAgICAgICAgICAgdmFyIHNvcnRLZXkgPSBDb25maWcuZ2V0KCdtb3Rpb25zX2V4cG9ydF9jYXRlZ29yeV9zb3J0aW5nJykudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gXy5vcmRlckJ5KGNhdGVnb3JpZXMsIFtzb3J0S2V5XSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldE1vdGlvblNob3J0RGF0YSA9IGZ1bmN0aW9uIChtb3Rpb25zLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfLm1hcChtb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogbW90aW9uLmlkZW50aWZpZXIgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBtb3Rpb24uZ2V0VGl0bGVXaXRoQ2hhbmdlcyhwYXJhbXMuY2hhbmdlUmVjb21tZW5kYXRpb25Nb2RlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldE1vdGlvbkZ1bGxEYXRhID0gZnVuY3Rpb24gKG1vdGlvbnMsIHBhcmFtcykge1xuICAgICAgICAgICAgLy8gQWxsIHRyYW5zbGF0aW9uc1xuICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdNb3Rpb24nKSxcbiAgICAgICAgICAgICAgICBzZXF1ZW50aWFsX3RyYW5zbGF0aW9uID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTZXF1ZW50aWFsIG51bWJlcicpLFxuICAgICAgICAgICAgICAgIHN1Ym1pdHRlcnNfdHJhbnNsYXRpb24gPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1N1Ym1pdHRlcnMnKSxcbiAgICAgICAgICAgICAgICBzdGF0dXNfdHJhbnNsYXRpb24gPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1N0YXR1cycpLFxuICAgICAgICAgICAgICAgIHJlYXNvbl90cmFuc2xhdGlvbiA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnUmVhc29uJyksXG4gICAgICAgICAgICAgICAgY29tbWVudF90cmFuc2xhdGlvbiA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQ29tbWVudHMnKTtcbiAgICAgICAgICAgIHZhciBzZXF1ZW50aWFsX2VuYWJsZWQgPSBDb25maWcuZ2V0KCdtb3Rpb25zX2V4cG9ydF9zZXF1ZW50aWFsX251bWJlcicpLnZhbHVlO1xuICAgICAgICAgICAgLy8gcHJvbWlzZXMgZm9yIGNyZWF0ZSB0aGUgYWN0dWFsIG1vdGlvbiBkYXRhXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBfLm1hcChtb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gbW90aW9uLmdldFRpdGxlV2l0aENoYW5nZXMocGFyYW1zLmNoYW5nZVJlY29tbWVuZGF0aW9uTW9kZSk7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBwYXJhbXMuaW5jbHVkZS50ZXh0ID8gbW90aW9uLmdldFRleHRCeU1vZGUocGFyYW1zLmNoYW5nZVJlY29tbWVuZGF0aW9uTW9kZSwgbnVsbCwgbnVsbCwgZmFsc2UpIDogJyc7XG4gICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHBhcmFtcy5pbmNsdWRlLnJlYXNvbiA/IG1vdGlvbi5nZXRSZWFzb24oKSA6ICcnO1xuICAgICAgICAgICAgICAgIHZhciBjb21tZW50cyA9IGdldE1vdGlvbkNvbW1lbnRzKG1vdGlvbiwgcGFyYW1zLmluY2x1ZGVDb21tZW50cyk7XG5cbiAgICAgICAgICAgICAgICAvLyBEYXRhIGZvciBvbmUgbW90aW9ucy4gTXVzdCBpbmNsdWRlIHRyYW5zbGF0aW9ucywgLi4uXG4gICAgICAgICAgICAgICAgdmFyIG1vdGlvbkRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zbGF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBtb3Rpb25fdHJhbnNsYXRpb246IHRyYW5zbGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzZXF1ZW50aWFsX3RyYW5zbGF0aW9uOiBzZXF1ZW50aWFsX3RyYW5zbGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzdWJtaXR0ZXJzX3RyYW5zbGF0aW9uOiBzdWJtaXR0ZXJzX3RyYW5zbGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICByZWFzb25fdHJhbnNsYXRpb246IHJlYXNvbi5sZW5ndGggPT09IDAgPyAnJyA6IHJlYXNvbl90cmFuc2xhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzX3RyYW5zbGF0aW9uOiBzdGF0dXNfdHJhbnNsYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRfdHJhbnNsYXRpb246IGNvbW1lbnRzLmxlbmd0aCA9PT0gMCA/ICcnIDogY29tbWVudF90cmFuc2xhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVudGlhbF9lbmFibGVkOiBzZXF1ZW50aWFsX2VuYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIEFjdHVhbCBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlkOiBtb3Rpb24uaWQsXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IG1vdGlvbi5pZGVudGlmaWVyIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHN1Ym1pdHRlcnM6IHBhcmFtcy5pbmNsdWRlLnN1Ym1pdHRlcnMgPyBfLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZmlsdGVyKCdvcmRlckJ5JykobW90aW9uLnN1Ym1pdHRlcnMsICd3ZWlnaHQnKSwgZnVuY3Rpb24gKHN1Ym1pdHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VibWl0dGVyLnVzZXIuZ2V0X2Z1bGxfbmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICkuam9pbignLCAnKSA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IG1vdGlvbi5nZXRTdGF0ZU5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gTWlzY2VsbGFuZW91cyBzdHVmZlxuICAgICAgICAgICAgICAgICAgICBwcmVhbWJsZTogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKENvbmZpZy5nZXQoJ21vdGlvbnNfcHJlYW1ibGUnKS52YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VicmVhazogUEFHRUJSRUFLLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gY29udmVydGluZyBodG1sIHRvIGRvY3ggaXMgYXN5bmMsIHNvIHRleHQsIHJlYXNvbiBhbmQgY29tbWVudHMgYXJlIGluc2VydGVkIGhlcmUuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0UHJvbWlzZXMgPSBfLm1hcChjb21tZW50cywgZnVuY3Rpb24gKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0ZXIuaHRtbDJkb2N4KGNvbW1lbnQuY29tbWVudCkudGhlbihmdW5jdGlvbiAoY29tbWVudEFzRG9jeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuY29tbWVudCA9IGNvbW1lbnRBc0RvY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQcm9taXNlcy5wdXNoKGNvbnZlcnRlci5odG1sMmRvY3godGV4dCkudGhlbihmdW5jdGlvbiAodGV4dEFzRG9jeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uRGF0YS50ZXh0ID0gdGV4dEFzRG9jeDtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0UHJvbWlzZXMucHVzaChjb252ZXJ0ZXIuaHRtbDJkb2N4KHJlYXNvbikudGhlbihmdW5jdGlvbiAocmVhc29uQXNEb2N4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb25EYXRhLnJlYXNvbiA9IHJlYXNvbkFzRG9jeDtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAkcS5hbGwoY29udmVydFByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvbkRhdGEuY29tbWVudHMgPSBjb21tZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobW90aW9uRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZXNvbHZlLCBpZiBhbGwgbW90aW9uIGRhdGEgaXMgZmV0Y2hlZC5cbiAgICAgICAgICAgIHJldHVybiAkcShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIHBhZ2VicmVhayBvbiBsYXN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbZGF0YS5sZW5ndGggLSAxXS5wYWdlYnJlYWsgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldE1vdGlvbkNvbW1lbnRzID0gZnVuY3Rpb24gKG1vdGlvbiwgZmllbGRzSW5jbHVkZWQpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZHMgPSBNb3Rpb25Db21tZW50LmdldE5vU3BlY2lhbENvbW1lbnRzRmllbGRzKCk7XG4gICAgICAgICAgICB2YXIgY29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIF8uZm9yRWFjaChmaWVsZHNJbmNsdWRlZCwgZnVuY3Rpb24gKG9rLCBpZCkge1xuICAgICAgICAgICAgICAgIGlmIChvayAmJiBtb3Rpb24uY29tbWVudHNbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IGZpZWxkc1tpZF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZHNbaWRdLnB1YmxpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgKz0gJyAoJyArIGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnaW50ZXJuYWwnKSArICcpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IG1vdGlvbi5jb21tZW50c1tpZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LmluZGV4T2YoJzxwPicpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gJzxwPicgKyBjb21tZW50ICsgJzwvcD4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudDogY29tbWVudCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29tbWVudHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cG9ydDogZnVuY3Rpb24gKG1vdGlvbnMsIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlciA9IEh0bWwyRG9jeENvbnZlcnRlci5jcmVhdGVJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IF8uY2xvbmUocGFyYW1zIHx8IHt9KTsgLy8gQ2xvbmUgdGhpcyB0byBhdm9pZCBzaWRlZWZmZWN0cy5cbiAgICAgICAgICAgICAgICBfLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VSZWNvbW1lbmRhdGlvbk1vZGU6IENvbmZpZy5nZXQoJ21vdGlvbnNfcmVjb21tZW5kYXRpb25fdGV4dF9tb2RlJykudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXR0ZXJzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlQ29tbWVudHM6IHt9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5maWxlbmFtZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnbW90aW9ucycpICsgJy5kb2N4JztcbiAgICAgICAgICAgICAgICBpZiAoIV8uaW5jbHVkZXMoWydvcmlnaW5hbCcsICdjaGFuZ2VkJywgJ2FncmVlZCddLCBwYXJhbXMuY2hhbmdlUmVjb21tZW5kYXRpb25Nb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY2hhbmdlUmVjb21tZW5kYXRpb25Nb2RlID0gJ29yaWdpbmFsJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkaHR0cC5nZXQoJy9tb3Rpb25zL2RvY3h0ZW1wbGF0ZS8nKS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gd2luZG93LmF0b2Ioc3VjY2Vzcy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IG5ldyBEb2N4Z2VuKGNvbnRlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdldERhdGEobW90aW9ucywgcGFyYW1zKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2Muc2V0RGF0YShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5yZW5kZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHppcCA9IGRvYy5nZXRaaXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHppcCA9IGNvbnZlcnRlci51cGRhdGVaaXBGaWxlKHppcCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSB6aXAuZ2VuZXJhdGUoe3R5cGU6ICdibG9iJ30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgRmlsZVNhdmVyLnNhdmVBcyhvdXQsIHBhcmFtcy5maWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5tb3Rpb25zLmxpbmVOdW1iZXJpbmcnLCBbXSlcblxuLyoqXG4gKiBDdXJyZW50IGxpbWl0YXRpb25zIG9mIHRoaXMgaW1wbGVtZW50YXRpb246XG4gKlxuICogT25seSB0aGUgZm9sbG93aW5nIGlubGluZSBlbGVtZW50cyBhcmUgc3VwcG9ydGVkOlxuICogLSAnU1BBTicsICdBJywgJ0VNJywgJ1MnLCAnQicsICdJJywgJ1NUUk9ORycsICdVJywgJ0JJRycsICdTTUFMTCcsICdTVUInLCAnU1VQJywgJ1RUJ1xuICogLSAnSU5TJyBhbmQgJ0RFTCcgYXJlIHN1cHBvcnRlZCwgYnV0IGxpbmUgbnVtYmVyaW5nIGRvZXMgbm90IGFmZmVjdCB0aGUgY29udGVudCBvZiAnSU5TJy1lbGVtZW50c1xuICpcbiAqIE9ubHkgb3RoZXIgaW5saW5lIGVsZW1lbnRzIGFyZSBhbGxvd2VkIHdpdGhpbiBpbmxpbmUgZWxlbWVudHMuXG4gKiBObyBjb25zdHJ1Y3RzIGxpa2UgPGEuLi4+PGRpdj48L2Rpdj48L2E+IGFyZSBhbGxvd2VkLiBDU1MtYXR0cmlidXRlcyBsaWtlICdkaXNwbGF5OiBibG9jaycgYXJlIGlnbm9yZWQuXG4gKi9cblxuLnNlcnZpY2UoJ2xpbmVOdW1iZXJpbmdTZXJ2aWNlJywgW1xuICAgICckY2FjaGVGYWN0b3J5JyxcbiAgICBmdW5jdGlvbiAoJGNhY2hlRmFjdG9yeSkge1xuICAgICAgICB2YXIgRUxFTUVOVF9OT0RFID0gMSxcbiAgICAgICAgICAgIFRFWFRfTk9ERSA9IDM7XG5cbiAgICAgICAgLy8gQ291bnRzIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiB0aGUgY3VycmVudCBsaW5lLCBiZXlvbmQgc2luZ2Ugbm9kZXMuXG4gICAgICAgIC8vIE5lZWRzIHRvIGJlIHJlc2V0dGVkIGFmdGVyIGVhY2ggbGluZSBicmVhayBhbmQgYWZ0ZXIgZW50ZXJpbmcgYSBuZXcgYmxvY2sgbm9kZS5cbiAgICAgICAgdGhpcy5fY3VycmVudElubGluZU9mZnNldCA9IG51bGw7XG5cbiAgICAgICAgLy8gVGhlIGxhc3QgcG9zaXRpb24gb2YgYSBwb2ludCBzdWl0YWJsZSBmb3IgYnJlYWtpbmcgdGhlIGxpbmUuIG51bGwgb3IgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gICAgICAgIC8vIC0gbm9kZTogdGhlIG5vZGUgdGhhdCBjb250YWlucyB0aGUgcG9zaXRpb24uIEd1YXJhbnRlZWQgdG8gYmUgYSBUZXh0Tm9kZVxuICAgICAgICAvLyAtIG9mZnNldDogdGhlIG9mZnNldCBvZiB0aGUgYnJlYWtpbmcgY2hhcmFjdGVycyAobGlrZSB0aGUgc3BhY2UpXG4gICAgICAgIC8vIE5lZWRzIHRvIGJlIHJlc2V0dGVkIGFmdGVyIGVhY2ggbGluZSBicmVhayBhbmQgYWZ0ZXIgZW50ZXJpbmcgYSBuZXcgYmxvY2sgbm9kZS5cbiAgICAgICAgdGhpcy5fbGFzdElubGluZUJyZWFrYWJsZVBvaW50ID0gbnVsbDtcblxuICAgICAgICAvLyBUaGUgbGluZSBudW1iZXIgY291bnRlclxuICAgICAgICB0aGlzLl9jdXJyZW50TGluZU51bWJlciA9IG51bGw7XG5cbiAgICAgICAgLy8gSW5kaWNhdGVzIHRoYXQgd2UganVzdCBlbnRlcmVkIGEgYmxvY2sgZWxlbWVudCBhbmQgd2Ugd2FudCB0byBhZGQgYSBsaW5lIG51bWJlciB3aXRob3V0IGxpbmUgYnJlYWsgYXQgdGhlIGJlZ2lubmluZy5cbiAgICAgICAgdGhpcy5fcHJlcGVuZExpbmVOdW1iZXJUb0ZpcnN0VGV4dCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEEgd29ya2Fyb3VuZCB0byBwcmV2ZW50IGRvdWJsZSBsaW5lIG51bWJlcnNcbiAgICAgICAgdGhpcy5faWdub3JlTmV4dFJlZ3VsYXJMaW5lTnVtYmVyID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRGVjaWRlcyBpZiB0aGUgY29udGVudCBvZiBpbnNlcnRlZCBub2RlcyBzaG91bGQgY291bnQgYXMgd2VsbC4gVGhpcyBpcyB1c2VkIHNvIHdlIGNhbiB1c2UgdGhlIGFsZ29yaXRobSBvbiBhXG4gICAgICAgIC8vIHRleHQgd2l0aCBpbmxpbmUgZGlmZiBhbm5vdGF0aW9ucyBhbmQgZ2V0IHRoZSBzYW1lIGxpbmUgbnVtYmVyaW5nIGFzIHdpdGggdGhlIG9yaWdpbmFsIHRleHQgKHdoZW4gc2V0IHRvIGZhbHNlKVxuICAgICAgICB0aGlzLl9pZ25vcmVJbnNlcnRlZFRleHQgPSBmYWxzZTtcblxuICAgICAgICB2YXIgbGluZU51bWJlckNhY2hlID0gJGNhY2hlRmFjdG9yeSgnbGluZW51bWJlcmluZy5zZXJ2aWNlJyk7XG5cbiAgICAgICAgdGhpcy5kamIyaGFzaCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIGhhc2ggPSA1MzgxLCBjaGFyO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSArIGhhc2gpICsgY2hhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYXNoLnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5faXNJbmxpbmVFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpbmxpbmVFbGVtZW50cyA9IFtcbiAgICAgICAgICAgICAgICAnU1BBTicsICdBJywgJ0VNJywgJ1MnLCAnQicsICdJJywgJ1NUUk9ORycsICdVJywgJ0JJRycsICdTTUFMTCcsICdTVUInLCAnU1VQJywgJ1RUJywgJ0lOUycsICdERUwnLFxuICAgICAgICAgICAgICAgICdTVFJJS0UnXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuIChpbmxpbmVFbGVtZW50cy5pbmRleE9mKG5vZGUubm9kZU5hbWUpID4gLTEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2lzSWdub3JlZEJ5TGluZU51bWJlcmluZyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ0lOUycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faWdub3JlSW5zZXJ0ZWRUZXh0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc09zTGluZU51bWJlck5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2lzT3NMaW5lQnJlYWtOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpc0xpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIG5vZGUubm9kZU5hbWUgPT09ICdCUicgJiYgbm9kZS5oYXNBdHRyaWJ1dGUoJ2NsYXNzJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNsYXNzZXMuaW5kZXhPZignb3MtbGluZS1icmVhaycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNMaW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc0xpbmVCcmVhaztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9pc09zTGluZU51bWJlck5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIGlzTGluZU51bWJlciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIG5vZGUubm9kZU5hbWUgPT09ICdTUEFOJyAmJiBub2RlLmhhc0F0dHJpYnV0ZSgnY2xhc3MnKSkge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKCdvcy1saW5lLW51bWJlcicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNMaW5lTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNMaW5lTnVtYmVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2dldExpbmVOdW1iZXJOb2RlID0gZnVuY3Rpb24oZnJhZ21lbnQsIGxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudC5xdWVyeVNlbGVjdG9yKCcub3MtbGluZS1udW1iZXIubGluZS1udW1iZXItJyArIGxpbmVOdW1iZXIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2h0bWxUb0ZyYWdtZW50ID0gZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICB3aGlsZSAoZGl2LmNoaWxkRWxlbWVudENvdW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gZGl2LmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICAgICAgZGl2LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fZnJhZ21lbnRUb0h0bWwgPSBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICAgICAgd2hpbGUgKGZyYWdtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpdi5pbm5lckhUTUw7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlTGluZUJyZWFrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKTtcbiAgICAgICAgICAgIGJyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnb3MtbGluZS1icmVhaycpO1xuICAgICAgICAgICAgcmV0dXJuIGJyO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZUxpbmVOdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faWdub3JlTmV4dFJlZ3VsYXJMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faWdub3JlTmV4dFJlZ3VsYXJMaW5lTnVtYmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IHRoaXMuX2N1cnJlbnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmVOdW1iZXIrKztcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdjbGFzcycsICdvcy1saW5lLW51bWJlciBsaW5lLW51bWJlci0nICsgbGluZU51bWJlcik7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1saW5lLW51bWJlcicsIGxpbmVOdW1iZXIgKyAnJyk7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICBub2RlLmlubmVySFRNTCA9ICcmbmJzcDsnOyAvLyBQcmV2ZW50IGNrZWRpdG9yIGZyb20gc3RyaXBwaW5nIG91dCBlbXB0eSBzcGFuJ3NcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGxpdHMgYSBURVhUX05PREUgaW50byBhbiBhcnJheSBvZiBURVhUX05PREVzIGFuZCBCUi1FbGVtZW50cyBzZXBhcmF0aW5nIHRoZW0gaW50byBsaW5lcy5cbiAgICAgICAgICogRWFjaCBsaW5lIGhhcyBhIG1heGltdW0gbGVuZ3RoIG9mICdsZW5ndGgnLCB3aXRoIG9uZSBleGNlcHRpb246IHNwYWNlcyBhcmUgYWNjZXB0ZWQgdG8gZXhjZWVkIHRoZSBsZW5ndGguXG4gICAgICAgICAqIE90aGVyd2lzZSB0aGUgc3RyaW5nIGlzIHNwbGl0IGJ5IHRoZSBsYXN0IHNwYWNlIG9yIGRhc2ggaW4gdGhlIGxpbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAqIEBwYXJhbSBsZW5ndGhcbiAgICAgICAgICogQHBhcmFtIGhpZ2hsaWdodFxuICAgICAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGV4dE5vZGVUb0xpbmVzID0gZnVuY3Rpb24gKG5vZGUsIGxlbmd0aCwgaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW10sXG4gICAgICAgICAgICAgICAgY3VyckxpbmVTdGFydCA9IDAsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgZmlyc3RUZXh0Tm9kZSA9IHRydWUsXG4gICAgICAgICAgICAgICAgc2VydmljZSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYWRkTGluZSA9IGZ1bmN0aW9uICh0ZXh0LCBoaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhpZ2hsaWdodCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0ID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaXJzdFRleHROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHQgPT09IHNlcnZpY2UuX2N1cnJlbnRMaW5lTnVtYmVyIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdjbGFzcycsICdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuaW5uZXJIVE1MID0gdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaXJzdFRleHROb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZpY2UuX2N1cnJlbnRMaW5lTnVtYmVyID09PSBoaWdobGlnaHQgJiYgaGlnaGxpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5pbm5lckhUTUwgPSB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKHNlcnZpY2UuX2NyZWF0ZUxpbmVCcmVhaygpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZpY2UuX2N1cnJlbnRMaW5lTnVtYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChzZXJ2aWNlLl9jcmVhdGVMaW5lTnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBhZGRMaW5lYnJlYWtUb1ByZXZpb3VzTm9kZSA9IGZ1bmN0aW9uIChub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RUZXh0ID0gbm9kZS5ub2RlVmFsdWUuc3Vic3RyKDAsIG9mZnNldCArIDEpLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRUZXh0ID0gbm9kZS5ub2RlVmFsdWUuc3Vic3RyKG9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lQnJlYWsgPSBzZXJ2aWNlLl9jcmVhdGVMaW5lQnJlYWsoKTtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3ROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZmlyc3RUZXh0KTtcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGZpcnN0Tm9kZSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsaW5lQnJlYWssIG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlLl9jdXJyZW50TGluZU51bWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlcnZpY2UuX2NyZWF0ZUxpbmVOdW1iZXIoKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUubm9kZVZhbHVlID0gc2Vjb25kVGV4dDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVWYWx1ZSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyBpZiBhIHByZXZpb3VzIGlubGluZSBlbGVtZW50IGV4YWN0bHkgc3RyZXRjaGVzIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudElubGluZU9mZnNldCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goc2VydmljZS5fY3JlYXRlTGluZUJyZWFrKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudExpbmVOdW1iZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKHNlcnZpY2UuX2NyZWF0ZUxpbmVOdW1iZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudElubGluZU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RJbmxpbmVCcmVha2FibGVQb2ludCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9wcmVwZW5kTGluZU51bWJlclRvRmlyc3RUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pZ25vcmVOZXh0UmVndWxhckxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lnbm9yZU5leHRSZWd1bGFyTGluZU51bWJlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlcnZpY2UuX2N1cnJlbnRMaW5lTnVtYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChzZXJ2aWNlLl9jcmVhdGVMaW5lTnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXBlbmRMaW5lTnVtYmVyVG9GaXJzdFRleHQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lQnJlYWtBdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50SW5saW5lT2Zmc2V0ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RJbmxpbmVCcmVha2FibGVQb2ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVCcmVha0F0ID0gdGhpcy5fbGFzdElubGluZUJyZWFrYWJsZVBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lQnJlYWtBdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25vZGUnOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb2Zmc2V0JzogaSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lQnJlYWtBdCAhPT0gbnVsbCAmJiAobm9kZS5ub2RlVmFsdWVbaV0gIT09ICcgJyAmJiBub2RlLm5vZGVWYWx1ZVtpXSAhPT0gXCJcXG5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lQnJlYWtBdC5ub2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGxhc3QgcG9zc2libGUgYnJlYWtpbmcgcG9pbnQgaXMgaW4gdGhpcyB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyckxpbmUgPSBub2RlLm5vZGVWYWx1ZS5zdWJzdHJpbmcoY3VyckxpbmVTdGFydCwgbGluZUJyZWFrQXQub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkTGluZShjdXJyTGluZSwgaGlnaGxpZ2h0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJMaW5lU3RhcnQgPSBsaW5lQnJlYWtBdC5vZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmxpbmVPZmZzZXQgPSBpIC0gbGluZUJyZWFrQXQub2Zmc2V0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0SW5saW5lQnJlYWthYmxlUG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbGFzdCBwb3NzaWJsZSBicmVha2luZyBwb2ludCB3YXMgbm90IGluIHRoaXMgdGV4dCBub3QsIGJ1dCBvbmUgd2UgaGF2ZSBhbHJlYWR5IHBhc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1haW5kZXJPZlByZXYgPSBsaW5lQnJlYWtBdC5ub2RlLm5vZGVWYWx1ZS5sZW5ndGggLSBsaW5lQnJlYWtBdC5vZmZzZXQgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZExpbmVicmVha1RvUHJldmlvdXNOb2RlKGxpbmVCcmVha0F0Lm5vZGUsIGxpbmVCcmVha0F0Lm9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5saW5lT2Zmc2V0ID0gaSArIHJlbWFpbmRlck9mUHJldjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0SW5saW5lQnJlYWthYmxlUG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVmFsdWVbaV0gPT09ICcgJyB8fCBub2RlLm5vZGVWYWx1ZVtpXSA9PT0gJy0nIHx8IG5vZGUubm9kZVZhbHVlW2ldID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0SW5saW5lQnJlYWthYmxlUG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25vZGUnOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvZmZzZXQnOiBpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudElubGluZU9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RMaW5lID0gYWRkTGluZShub2RlLm5vZGVWYWx1ZS5zdWJzdHJpbmcoY3VyckxpbmVTdGFydCksIGhpZ2hsaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RJbmxpbmVCcmVha2FibGVQb2ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0SW5saW5lQnJlYWthYmxlUG9pbnQubm9kZSA9IGxhc3RMaW5lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZXMgbGluZSBicmVha2luZyBhbmQgbGluZSBudW1iZXJpbmcgbWFya3VwIGJlZm9yZSBpbmxpbmUgZWxlbWVudHNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGlubmVyTm9kZVxuICAgICAgICAgKiBAcGFyYW0gb3V0ZXJOb2RlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tb3ZlTGVhZGluZ0xpbmVCcmVha3NUb091dGVyTm9kZSA9IGZ1bmN0aW9uIChpbm5lck5vZGUsIG91dGVyTm9kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5saW5lRWxlbWVudChpbm5lck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzT3NMaW5lQnJlYWtOb2RlKGlubmVyTm9kZS5maXJzdENoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnIgPSBpbm5lck5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJOb2RlLnJlbW92ZUNoaWxkKGJyKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJOb2RlLmFwcGVuZENoaWxkKGJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzT3NMaW5lTnVtYmVyTm9kZShpbm5lck5vZGUuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwYW4gPSBpbm5lck5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJOb2RlLnJlbW92ZUNoaWxkKHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICBvdXRlck5vZGUuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2xlbmd0aE9mRmlyc3RJbmxpbmVXb3JkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5maXJzdENoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBub2RlLmZpcnN0Q2hpbGQubm9kZVZhbHVlLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRzWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aE9mRmlyc3RJbmxpbmVXb3JkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5faW5zZXJ0TGluZU51bWJlcnNUb0lubGluZU5vZGUgPSBmdW5jdGlvbiAobm9kZSwgbGVuZ3RoLCBoaWdobGlnaHQpIHtcbiAgICAgICAgICAgIHZhciBvbGRDaGlsZHJlbiA9IFtdLCBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG9sZENoaWxkcmVuLnB1c2gobm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZENoaWxkcmVuW2ldLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IHRoaXMuX3RleHROb2RlVG9MaW5lcyhvbGRDaGlsZHJlbltpXSwgbGVuZ3RoLCBoaWdobGlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChyZXRbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvbGRDaGlsZHJlbltpXS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdHdvcmQgPSB0aGlzLl9sZW5ndGhPZkZpcnN0SW5saW5lV29yZChvbGRDaGlsZHJlbltpXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGVuZ3RoID0gKCh0aGlzLl9jdXJyZW50SW5saW5lT2Zmc2V0ICsgZmlyc3R3b3JkKSA+IGxlbmd0aCAmJiB0aGlzLl9jdXJyZW50SW5saW5lT2Zmc2V0ID4gMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGVuZ3RoICYmIHRoaXMuX2lzSW5saW5lRWxlbWVudChvbGRDaGlsZHJlbltpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmxpbmVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdElubGluZUJyZWFrYWJsZVBvaW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlTGluZUJyZWFrKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRMaW5lTnVtYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVMaW5lTnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkTm9kZSA9IHRoaXMuX2luc2VydExpbmVOdW1iZXJzVG9Ob2RlKG9sZENoaWxkcmVuW2ldLCBsZW5ndGgsIGhpZ2hsaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vdmVMZWFkaW5nTGluZUJyZWFrc1RvT3V0ZXJOb2RlKGNoYW5nZWROb2RlLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjaGFuZ2VkTm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gbm9kZVR5cGU6ICcgKyBpICsgJzogJyArIG9sZENoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fY2FsY0Jsb2NrTm9kZUxlbmd0aCA9IGZ1bmN0aW9uIChub2RlLCBvbGRMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuZXdMZW5ndGggPSBvbGRMZW5ndGg7XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUubm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdMSSc6XG4gICAgICAgICAgICAgICAgICAgIG5ld0xlbmd0aCAtPSA1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdCTE9DS1FVT1RFJzpcbiAgICAgICAgICAgICAgICAgICAgbmV3TGVuZ3RoIC09IDIwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdESVYnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdHBhZCA9IHN0eWxlcy5zcGxpdChcInBhZGRpbmctbGVmdDpcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdHBhZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdHBhZCA9IHBhcnNlSW50KGxlZnRwYWRbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgKz0gbGVmdHBhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodHBhZCA9IHN0eWxlcy5zcGxpdChcInBhZGRpbmctcmlnaHQ6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0cGFkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodHBhZCA9IHBhcnNlSW50KHJpZ2h0cGFkWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nICs9IHJpZ2h0cGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVuZ3RoIC09IChwYWRkaW5nIC8gNSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnSDEnOlxuICAgICAgICAgICAgICAgICAgICBuZXdMZW5ndGggKj0gMC42NjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnSDInOlxuICAgICAgICAgICAgICAgICAgICBuZXdMZW5ndGggKj0gMC43NTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnSDMnOlxuICAgICAgICAgICAgICAgICAgICBuZXdMZW5ndGggKj0gMC44NTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG5ld0xlbmd0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5faW5zZXJ0TGluZU51bWJlcnNUb0Jsb2NrTm9kZSA9IGZ1bmN0aW9uIChub2RlLCBsZW5ndGgsIGhpZ2hsaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudElubGluZU9mZnNldCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9sYXN0SW5saW5lQnJlYWthYmxlUG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcHJlcGVuZExpbmVOdW1iZXJUb0ZpcnN0VGV4dCA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciBvbGRDaGlsZHJlbiA9IFtdLCBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG9sZENoaWxkcmVuLnB1c2gobm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZENoaWxkcmVuW2ldLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRDaGlsZHJlbltpXS5ub2RlVmFsdWUubWF0Y2goL1xcUy8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGl0ZSBzcGFjZSBub2RlcyBiZXR3ZWVuIGJsb2NrIGVsZW1lbnRzIHNob3VsZCBiZSBpZ25vcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldklzQmxvY2sgPSAoaSA+IDAgJiYgIXRoaXMuX2lzSW5saW5lRWxlbWVudChvbGRDaGlsZHJlbltpIC0gMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0SXNCbG9jayA9IChpIDwgb2xkQ2hpbGRyZW4ubGVuZ3RoIC0gMSAmJiAhdGhpcy5faXNJbmxpbmVFbGVtZW50KG9sZENoaWxkcmVuW2kgKyAxXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcmV2SXNCbG9jayAmJiBuZXh0SXNCbG9jaykgfHwgKGkgPT09IDAgJiYgbmV4dElzQmxvY2spIHx8IChpID09PSBvbGRDaGlsZHJlbi5sZW5ndGggLSAxICYmIHByZXZJc0Jsb2NrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQob2xkQ2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLl90ZXh0Tm9kZVRvTGluZXMob2xkQ2hpbGRyZW5baV0sIGxlbmd0aCwgaGlnaGxpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQocmV0W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2xkQ2hpbGRyZW5baV0ubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3R3b3JkID0gdGhpcy5fbGVuZ3RoT2ZGaXJzdElubGluZVdvcmQob2xkQ2hpbGRyZW5baV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3Zlcmxlbmd0aCA9ICgodGhpcy5fY3VycmVudElubGluZU9mZnNldCArIGZpcnN0d29yZCkgPiBsZW5ndGggJiYgdGhpcy5fY3VycmVudElubGluZU9mZnNldCA+IDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3Zlcmxlbmd0aCAmJiB0aGlzLl9pc0lubGluZUVsZW1lbnQob2xkQ2hpbGRyZW5baV0pICYmICF0aGlzLl9pc0lnbm9yZWRCeUxpbmVOdW1iZXJpbmcob2xkQ2hpbGRyZW5baV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5saW5lT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RJbmxpbmVCcmVha2FibGVQb2ludCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZUxpbmVCcmVhaygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50TGluZU51bWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlTGluZU51bWJlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZE5vZGUgPSB0aGlzLl9pbnNlcnRMaW5lTnVtYmVyc1RvTm9kZShvbGRDaGlsZHJlbltpXSwgbGVuZ3RoLCBoaWdobGlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlTGVhZGluZ0xpbmVCcmVha3NUb091dGVyTm9kZShjaGFuZ2VkTm9kZSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hhbmdlZE5vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdVbmtub3duIG5vZGVUeXBlOiAnICsgaSArICc6ICcgKyBvbGRDaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmxpbmVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fbGFzdElubGluZUJyZWFrYWJsZVBvaW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3ByZXBlbmRMaW5lTnVtYmVyVG9GaXJzdFRleHQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faWdub3JlTmV4dFJlZ3VsYXJMaW5lTnVtYmVyID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2luc2VydExpbmVOdW1iZXJzVG9Ob2RlID0gZnVuY3Rpb24gKG5vZGUsIGxlbmd0aCwgaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1RoaXMgbWV0aG9kIG1heSBvbmx5IGJlIGNhbGxlZCBmb3IgRUxFTUVOVC1ub2RlczogJyArIG5vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSWdub3JlZEJ5TGluZU51bWJlcmluZyhub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50SW5saW5lT2Zmc2V0ID09PSAwICYmIHRoaXMuX2N1cnJlbnRMaW5lTnVtYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTnVtYmVyTm9kZSA9IHRoaXMuX2NyZWF0ZUxpbmVOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVOdW1iZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmluc2VydEJlZm9yZShsaW5lTnVtYmVyTm9kZSwgbm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lnbm9yZU5leHRSZWd1bGFyTGluZU51bWJlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzSW5saW5lRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnRMaW5lTnVtYmVyc1RvSW5saW5lTm9kZShub2RlLCBsZW5ndGgsIGhpZ2hsaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBuZXdMZW5ndGggPSB0aGlzLl9jYWxjQmxvY2tOb2RlTGVuZ3RoKG5vZGUsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydExpbmVOdW1iZXJzVG9CbG9ja05vZGUobm9kZSwgbmV3TGVuZ3RoLCBoaWdobGlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3N0cmlwTGluZU51bWJlcnMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNPc0xpbmVCcmVha05vZGUobm9kZS5jaGlsZE5vZGVzW2ldKSB8fCB0aGlzLl9pc09zTGluZU51bWJlck5vZGUobm9kZS5jaGlsZE5vZGVzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIG5ld2xpbmUgY2hhcmFjdGVyIGZvbGxvd3MgYSBsaW5lIGJyZWFrLCBpdCdzIGJlZW4gdmVyeSBsaWtlbHkgaW5zZXJ0ZWQgYnkgdGhlIFdZU0lXWUctZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gKGkgKyAxKSAmJiBub2RlLmNoaWxkTm9kZXNbaSArIDFdLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXNbaSArIDFdLm5vZGVWYWx1ZVswXSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGROb2Rlc1tpICsgMV0ubm9kZVZhbHVlID0gXCIgXCIgKyBub2RlLmNoaWxkTm9kZXNbaSArIDFdLm5vZGVWYWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RyaXBMaW5lTnVtYmVycyhub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9ub2Rlc1RvSHRtbCA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbm9kZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvb3QuaW5uZXJIVE1MO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGxpbmVMZW5ndGhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gaGlnaGxpZ2h0IC0gb3B0aW9uYWxcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gZmlyc3RMaW5lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluc2VydExpbmVOdW1iZXJzTm9kZSA9IGZ1bmN0aW9uIChodG1sLCBsaW5lTGVuZ3RoLCBoaWdobGlnaHQsIGZpcnN0TGluZSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZpbmcgbmV3bGluZXMgYWZ0ZXIgQlJzLCBhcyB0aGV5IGxlYWQgdG8gcHJvYmxlbXMgbGlrZSAjMzQxMFxuICAgICAgICAgICAgaWYgKGh0bWwpIHtcbiAgICAgICAgICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKC8oPGJyW14+XSo+KVtcXG5cXHJdKy9naSwgJyQxJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICByb290LmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmxpbmVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fbGFzdElubGluZUJyZWFrYWJsZVBvaW50ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChmaXJzdExpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZU51bWJlciA9IHBhcnNlSW50KGZpcnN0TGluZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lTnVtYmVyID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoaWdobGlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQgPSBwYXJzZUludChoaWdobGlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJlcGVuZExpbmVOdW1iZXJUb0ZpcnN0VGV4dCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pZ25vcmVOZXh0UmVndWxhckxpbmVOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lnbm9yZUluc2VydGVkVGV4dCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnRMaW5lTnVtYmVyc1RvTm9kZShyb290LCBsaW5lTGVuZ3RoLCBoaWdobGlnaHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZUxlbmd0aFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxudWxsfSBoaWdobGlnaHQgLSBvcHRpb25hbFxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlyc3RMaW5lXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluc2VydExpbmVOdW1iZXJzID0gZnVuY3Rpb24gKGh0bWwsIGxpbmVMZW5ndGgsIGhpZ2hsaWdodCwgY2FsbGJhY2ssIGZpcnN0TGluZSkge1xuICAgICAgICAgICAgdmFyIG5ld0h0bWwsIG5ld1Jvb3Q7XG5cbiAgICAgICAgICAgIGlmIChoaWdobGlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FjaGluZyB2ZXJzaW9ucyB3aXRoIGhpZ2hsaWdodGVkIGxpbmUgbnVtYmVycyBpcyBwcm9iYWJseSBub3Qgd29ydGggaXRcbiAgICAgICAgICAgICAgICBuZXdSb290ID0gdGhpcy5pbnNlcnRMaW5lTnVtYmVyc05vZGUoaHRtbCwgbGluZUxlbmd0aCwgaGlnaGxpZ2h0LCBmaXJzdExpbmUpO1xuICAgICAgICAgICAgICAgIG5ld0h0bWwgPSBuZXdSb290LmlubmVySFRNTDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0TGluZVN0ciA9IChmaXJzdExpbmUgPT09IHVuZGVmaW5lZCB8fCBmaXJzdExpbmUgPT09IG51bGwgPyAnJyA6IGZpcnN0TGluZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLmRqYjJoYXNoKGZpcnN0TGluZVN0ciArIFwiLVwiICsgbGluZUxlbmd0aC50b1N0cmluZygpICsgaHRtbCk7XG4gICAgICAgICAgICAgICAgbmV3SHRtbCA9IGxpbmVOdW1iZXJDYWNoZS5nZXQoY2FjaGVLZXkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNVbmRlZmluZWQobmV3SHRtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Um9vdCA9IHRoaXMuaW5zZXJ0TGluZU51bWJlcnNOb2RlKGh0bWwsIGxpbmVMZW5ndGgsIG51bGwsIGZpcnN0TGluZSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0h0bWwgPSBuZXdSb290LmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlckNhY2hlLnB1dChjYWNoZUtleSwgbmV3SHRtbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3SHRtbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVMZW5ndGhcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBjb3VudEluc2VydGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluc2VydExpbmVCcmVha3NXaXRob3V0TnVtYmVycyA9IGZ1bmN0aW9uIChodG1sLCBsaW5lTGVuZ3RoLCBjb3VudEluc2VydGVkKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgcm9vdC5pbm5lckhUTUwgPSBodG1sO1xuXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5saW5lT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RJbmxpbmVCcmVha2FibGVQb2ludCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZU51bWJlciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9wcmVwZW5kTGluZU51bWJlclRvRmlyc3RUZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lnbm9yZU5leHRSZWd1bGFyTGluZU51bWJlciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faWdub3JlSW5zZXJ0ZWRUZXh0ID0gIWNvdW50SW5zZXJ0ZWQ7XG5cbiAgICAgICAgICAgIHZhciBuZXdSb290ID0gdGhpcy5faW5zZXJ0TGluZU51bWJlcnNUb05vZGUocm9vdCwgbGluZUxlbmd0aCwgbnVsbCk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdSb290LmlubmVySFRNTDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RyaXBMaW5lTnVtYmVycyA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgcm9vdC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgICAgdGhpcy5fc3RyaXBMaW5lTnVtYmVycyhyb290KTtcbiAgICAgICAgICAgIHJldHVybiByb290LmlubmVySFRNTDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgICAgICogICAgICAgICAge1wiZnJvbVwiOiAyMywgXCJ0b1wiOiA0Mn0gOyBcInRvXCIgcmVmZXJzIHRvIHRoZSBsaW5lIGJyZWFraW5nIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgbGFzdCBsaW5lLFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaS5lLiB0aGUgbGluZSBudW1iZXIgb2YgdGhlIGZvbGxvd2luZyBsaW5lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldExpbmVOdW1iZXJSYW5nZSA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLl9odG1sVG9GcmFnbWVudChodG1sKSxcbiAgICAgICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJmcm9tXCI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIFwidG9cIjogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbGluZU51bWJlcnMgPSBmcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcub3MtbGluZS1udW1iZXInKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZU51bWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGxpbmVOdW1iZXJzLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgdmFyIG51bWJlciA9IHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1saW5lLW51bWJlclwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPT09IG51bGwgfHwgbnVtYmVyIDwgcmFuZ2UuZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5mcm9tID0gbnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UudG8gPT09IG51bGwgfHwgKG51bWJlciArIDEpID4gcmFuZ2UudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UudG8gPSBudW1iZXIgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0SGVhZGluZ3NXaXRoTGluZU51bWJlcnMgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gdGhpcy5faHRtbFRvRnJhZ21lbnQoaHRtbCksXG4gICAgICAgICAgICAgICAgaGVhZGluZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBoZWFkaW5nTm9kZXMgPSBmcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdoMSwgaDIsIGgzLCBoNCwgaDUsIGg2Jyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRpbmdOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBoZWFkaW5nID0gaGVhZGluZ05vZGVzLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVudW1iZXJzID0gaGVhZGluZy5xdWVyeVNlbGVjdG9yQWxsKCcub3MtbGluZS1udW1iZXInKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZW51bWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtYmVyID0gcGFyc2VJbnQobGluZW51bWJlcnMuaXRlbSgwKS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWxpbmUtbnVtYmVyXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImxpbmVOdW1iZXJcIjogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJsZXZlbFwiOiBwYXJzZUludChoZWFkaW5nLm5vZGVOYW1lLnN1YnN0cigxKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogaGVhZGluZy5pbm5lclRleHQucmVwbGFjZSgvXlxccy8sIFwiXCIpLnJlcGxhY2UoL1xccyQvLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGVhZGluZ3Muc29ydChmdW5jdGlvbihoZWFkaW5nMSwgaGVhZGluZzIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGluZzEubGluZU51bWJlciA8IGhlYWRpbmcyLmxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkaW5nMS5saW5lTnVtYmVyID4gaGVhZGluZzIubGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gICAgICAgICAqIEByZXR1cm5zIHthcnJheX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NwbGl0Tm9kZVRvUGFyYWdyYXBocyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IG5vZGUuY2hpbGROb2Rlcy5pdGVtKGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVOYW1lID09PSAnVUwnIHx8IGNoaWxkTm9kZS5ub2RlTmFtZSA9PT0gJ09MJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLmdldEF0dHJpYnV0ZShcInN0YXJ0XCIpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHBhcnNlSW50KGNoaWxkTm9kZS5nZXRBdHRyaWJ1dGUoXCJzdGFydFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZE5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5jaGlsZE5vZGVzLml0ZW0oaikubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BhcmVudCA9IGNoaWxkTm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlTmFtZSA9PT0gJ09MJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcmVudC5zZXRBdHRyaWJ1dGUoJ3N0YXJ0Jywgc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyZW50LmFwcGVuZENoaWxkKGNoaWxkTm9kZS5jaGlsZE5vZGVzLml0ZW0oaikuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobmV3UGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGxpdHRpbmcgdGhlIHRleHQgaW50byBwYXJhZ3JhcGhzOlxuICAgICAgICAgKiAtIEVhY2ggcm9vdC1sZXZlbC1lbGVtZW50IGlzIGNvbnNpZGVyZWQgYXMgYSBwYXJhZ3JhcGguXG4gICAgICAgICAqICAgSW5saW5lLWVsZW1lbnRzIGF0IHJvb3QtbGV2ZWwgYXJlIG5vdCBleHBlY3RlZCBhbmQgdHJlYXRlZCBhcyBibG9jayBlbGVtZW50cy5cbiAgICAgICAgICogICBUZXh0LW5vZGVzIGF0IHJvb3QtbGV2ZWwgYXJlIG5vdCBleHBlY3RlZCBhbmQgaWdub3JlZC4gRXZlcnkgdGV4dCBuZWVkcyB0byBiZSB3cmFwcGVkIGUuZy4gYnkgPHA+IG9yIDxkaXY+LlxuICAgICAgICAgKiAtIElmIGEgVUwgb3IgT0wgaXMgZW5jb3VudGVyZWQsIHBhcmFncmFwaHMgYXJlIGRlZmluZWQgYnkgdGhlIGNoaWxkLUxJLWVsZW1lbnRzLlxuICAgICAgICAgKiAgIExpc3QgaXRlbXMgb2YgbmVzdGVkIGxpc3RzIGFyZSBub3QgY29uc2lkZXJlZCBhcyBhIHBhcmFncmFwaCBvZiB0aGVpciBvd24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zcGxpdFRvUGFyYWdyYXBocyA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLl9odG1sVG9GcmFnbWVudChodG1sKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zcGxpdE5vZGVUb1BhcmFncmFwaHMoZnJhZ21lbnQpLm1hcChmdW5jdGlvbihub2RlKSB7IHJldHVybiBub2RlLm91dGVySFRNTDsgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYXZlcnNlcyB1cCB0aGUgRE9NIHRyZWUgdW50aWwgaXQgZmluZHMgYSBub2RlIHdpdGggYSBuZXh0U2libGluZywgdGhlbiByZXR1cm5zIHRoYXQgc2libGluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZmluZE5leHRBdW50Tm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5kTmV4dEF1bnROb2RlKG5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2hpZ2hsaWdodFVudGlsTmV4dExpbmUgPSBmdW5jdGlvbihsaW5lTnVtYmVyTm9kZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gbGluZU51bWJlck5vZGUsXG4gICAgICAgICAgICAgICAgZm91bmROZXh0TGluZU51bWJlciA9IGZhbHNlO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIHdhc0hpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdjbGFzcycsICdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBjdXJyZW50Tm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgd2FzSGlnaGxpZ2h0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdhc0hpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCAmJiAhdGhpcy5faXNPc0xpbmVOdW1iZXJOb2RlKGN1cnJlbnROb2RlKSAmJiAhd2FzSGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudE5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHRoaXMuX2ZpbmROZXh0QXVudE5vZGUoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc09zTGluZU51bWJlck5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kTmV4dExpbmVOdW1iZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKCFmb3VuZE5leHRMaW5lTnVtYmVyICYmIGN1cnJlbnROb2RlICE9PSBudWxsKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVOdW1iZXJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oaWdobGlnaHRMaW5lID0gZnVuY3Rpb24gKGh0bWwsIGxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIGxpbmVOdW1iZXIgPSBwYXJzZUludChsaW5lTnVtYmVyKTtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuX2h0bWxUb0ZyYWdtZW50KGh0bWwpLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXJOb2RlID0gdGhpcy5fZ2V0TGluZU51bWJlck5vZGUoZnJhZ21lbnQsIGxpbmVOdW1iZXIpO1xuXG4gICAgICAgICAgICBpZiAobGluZU51bWJlck5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRVbnRpbE5leHRMaW5lKGxpbmVOdW1iZXJOb2RlKTtcbiAgICAgICAgICAgICAgICBodG1sID0gdGhpcy5fZnJhZ21lbnRUb0h0bWwoZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfTtcbiAgICB9XG5dKTtcblxuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5tb3Rpb25zLm1vdGlvbkJsb2NrUHJvamVjdG9yJywgW10pXG5cblxuLy8gTW90aW9uQmxvY2sgcHJvamVjdG9yIGVsZW1lbnRzXG5cbi5jb25maWcoW1xuICAgICdzbGlkZXNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oc2xpZGVzUHJvdmlkZXIpIHtcbiAgICAgICAgc2xpZGVzUHJvdmlkZXIucmVnaXN0ZXJTbGlkZSgnbW90aW9ucy9tb3Rpb24tYmxvY2snLCB7XG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ3N0YXRpYy90ZW1wbGF0ZXMvbW90aW9ucy9zbGlkZV9tb3Rpb25fYmxvY2suaHRtbCcsXG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdTbGlkZU1vdGlvbkJsb2NrQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnTW90aW9uJyxcbiAgICAnTW90aW9uQmxvY2snLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgTW90aW9uLCBNb3Rpb25CbG9jaykge1xuICAgICAgICAvLyBBdHRlbnRpb24hIEVhY2ggb2JqZWN0IHRoYXQgaXMgdXNlZCBoZXJlIGhhcyB0byBiZSBkZWFsdCBvbiBzZXJ2ZXIgc2lkZS5cbiAgICAgICAgLy8gQWRkIGl0IHRvIHRoZSBjb3Jlc3BvbmRpbmcgZ2V0X3JlcXVpcmVtZW50cyBtZXRob2Qgb2YgdGhlIFByb2plY3RvckVsZW1lbnRcbiAgICAgICAgLy8gY2xhc3MuXG4gICAgICAgIHZhciBpZCA9ICRzY29wZS5lbGVtZW50LmlkO1xuICAgICAgICBNb3Rpb25CbG9jay5iaW5kT25lKGlkLCAkc2NvcGUsICdtb3Rpb25CbG9jaycpO1xuXG4gICAgICAgIC8vIFJldHVybnMgYSBzaG9ydGVuZWQgbW90aW9uIHRpdGxlLiBJZiB0aGUgdGl0bGUgaXMgbG9uZ2VyIHRoZW4gbWF4TGVuZ3RoLCBpdCBpc1xuICAgICAgICAvLyBzcGxpdCBhdCB0aGUgbGFzdCB3aGl0ZXNwYWNlIHRoYXQgaXMgaW4gbWF4TGVuZ3RoLiBUaHJlZSBkb3RzIGFyZSBhZGRlZCB0aGVuLlxuICAgICAgICAkc2NvcGUuZ2V0U2hvcnRUaXRsZSA9IGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBtYXhMZW5ndGggPSA0MDtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IG1vdGlvbi5nZXRUaXRsZSgpO1xuXG4gICAgICAgICAgICBpZiAodGl0bGUubGVuZ3RoIDw9IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aXRsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluZCBsYXN0IHdoaXRlc3BhY2UgdGhhdCBpcyBiZWZvcmUgbWF4TGVuZ3RoLiBTcGxpdCB0aGUgdGl0bGVcbiAgICAgICAgICAgIC8vIHRoZXJlIGFuZCBhcHBlbmQgZG90cy5cbiAgICAgICAgICAgIHZhciB3aGl0ZXNwYWNlSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4TGVuZ3RoKzE7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aXRsZVtpXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2VJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAod2hpdGVzcGFjZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGp1c3Qgb25lIGxvbmcgd29yZC4uIHNwbGl0IGl0IDovXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpdGxlLnN1YnN0cigwLCBtYXhMZW5ndGgpICsgJy4uLic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aXRsZS5zdWJzdHIoMCwgd2hpdGVzcGFjZUluZGV4KSArICcuLi4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5tb3Rpb25zLm1vdGlvbkJsb2NrJywgW10pXG5cblxuLy8gTW90aW9uQmxvY2sgbW9kZWxcblxuLmZhY3RvcnkoJ01vdGlvbkJsb2NrJywgW1xuICAgICdEUycsXG4gICAgJ2pzRGF0YU1vZGVsJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgZnVuY3Rpb24oRFMsIGpzRGF0YU1vZGVsLCBnZXR0ZXh0KSB7XG4gICAgICAgIHZhciBuYW1lID0gJ21vdGlvbnMvbW90aW9uLWJsb2NrJztcbiAgICAgICAgcmV0dXJuIERTLmRlZmluZVJlc291cmNlKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB1c2VDbGFzczoganNEYXRhTW9kZWwsXG4gICAgICAgICAgICB2ZXJib3NlTmFtZTogZ2V0dGV4dCgnTW90aW9uIGJsb2NrJyksXG4gICAgICAgICAgICBtZXRob2RzOiB7XG4gICAgICAgICAgICAgICAgZ2V0UmVzb3VyY2VOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0QWdlbmRhVGl0bGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWxhdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBiZWxvbmdzVG86IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FnZW5kYS9pdGVtJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxLZXk6ICdhZ2VuZGFfaXRlbV9pZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAnYWdlbmRhX2l0ZW0nLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYXNNYW55OiB7XG4gICAgICAgICAgICAgICAgICAgICdtb3Rpb25zL21vdGlvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRmllbGQ6ICdtb3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmVpZ25LZXk6ICdtb3Rpb25fYmxvY2tfaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3NQcm90ZWN0ZWRSZWxhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5ydW4oWydNb3Rpb25CbG9jaycsIGZ1bmN0aW9uKE1vdGlvbkJsb2NrKSB7fV0pXG5cbi8vIE1vdGlvbkJsb2NrIHZpZXdzIChsaXN0IHZpZXcsIGNyZWF0ZSBkaWFsb2csIHVwZGF0ZSBkaWFsb2cpXG4uZmFjdG9yeSgnTW90aW9uQmxvY2tGb3JtJywgW1xuICAgICckaHR0cCcsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdBZ2VuZGEnLFxuICAgICdBZ2VuZGFUcmVlJyxcbiAgICAnU2hvd0FzQWdlbmRhSXRlbUZpZWxkJyxcbiAgICBmdW5jdGlvbiAoJGh0dHAsIG9wZXJhdG9yLCBnZXR0ZXh0Q2F0YWxvZywgQWdlbmRhLCBBZ2VuZGFUcmVlLCBTaG93QXNBZ2VuZGFJdGVtRmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIEdldCBuZ0RpYWxvZyBjb25maWd1cmF0aW9uLlxuICAgICAgICAgICAgZ2V0RGlhbG9nOiBmdW5jdGlvbiAobW90aW9uQmxvY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJ3N0YXRpYy90ZW1wbGF0ZXMvbW90aW9ucy9tb3Rpb24tYmxvY2stZm9ybS5odG1sJyxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogKG1vdGlvbkJsb2NrKSA/ICdNb3Rpb25CbG9ja1VwZGF0ZUN0cmwnIDogJ01vdGlvbkJsb2NrQ3JlYXRlQ3RybCcsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ25nZGlhbG9nLXRoZW1lLWRlZmF1bHQgd2lkZS1mb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VCeUVzY2FwZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlEb2N1bWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvbkJsb2NrSWQ6IGZ1bmN0aW9uICgpIHtyZXR1cm4gbW90aW9uQmxvY2sgPyBtb3Rpb25CbG9jay5pZCA6IHZvaWQgMDt9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEdldCBhbmd1bGFyLWZvcm1seSBmaWVsZHMuXG4gICAgICAgICAgICBnZXRGb3JtRmllbGRzOiBmdW5jdGlvbiAoaXNDcmVhdGVGb3JtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1GaWVsZHMgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ3RpdGxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdUaXRsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIC8vIHNob3cgYXMgYWdlbmRhIGl0ZW0gKyBwYXJlbnQgaXRlbVxuICAgICAgICAgICAgICAgIGlmIChpc0NyZWF0ZUZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybUZpZWxkcy5wdXNoKFNob3dBc0FnZW5kYUl0ZW1GaWVsZCgnbW90aW9ucy5jYW5fbWFuYWdlJykpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtRmllbGRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnYWdlbmRhX3BhcmVudF9pZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2VsZWN0LXNpbmdsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdQYXJlbnQgaXRlbScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IEFnZW5kYVRyZWUuZ2V0RmxhdFRyZWUoQWdlbmRhLmdldEFsbCgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZ09wdGlvbnM6ICdpdGVtLmlkIGFzIGl0ZW0uZ2V0TGlzdFZpZXdUaXRsZSgpIGZvciBpdGVtIGluIHRvLm9wdGlvbnMgfCBub3RzZWxmIDogbW9kZWwuYWdlbmRhX2l0ZW1faWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1NlbGVjdCBhIHBhcmVudCBpdGVtIC4uLicpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTogIW9wZXJhdG9yLmhhc1Blcm1zKCdhZ2VuZGEuY2FuX21hbmFnZScpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtRmllbGRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdNb3Rpb25CbG9ja0xpc3RDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICduZ0RpYWxvZycsXG4gICAgJ01vdGlvbkJsb2NrJyxcbiAgICAnTW90aW9uQmxvY2tGb3JtJyxcbiAgICAnUHJvamVjdG9yJyxcbiAgICAnUHJvamVjdGlvbkRlZmF1bHQnLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsIG5nRGlhbG9nLCBNb3Rpb25CbG9jaywgTW90aW9uQmxvY2tGb3JtLCBQcm9qZWN0b3IsIFByb2plY3Rpb25EZWZhdWx0KSB7XG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb2plY3Rvci5sYXN0TW9kaWZpZWQoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb2plY3Rpb25kZWZhdWx0ID0gUHJvamVjdGlvbkRlZmF1bHQuZmlsdGVyKHtuYW1lOiAnbW90aW9uQmxvY2tzJ30pWzBdO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rpb25kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlZmF1bHRQcm9qZWN0b3JJZCA9IHByb2plY3Rpb25kZWZhdWx0LnByb2plY3Rvcl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFR3by13YXkgZGF0YSBiaW5kaW5nIGZvciBhbGwgTW90aW9uQmxvY2sgaW5zdGFuY2VzLlxuICAgICAgICBNb3Rpb25CbG9jay5iaW5kQWxsKHt9LCAkc2NvcGUsICdtb3Rpb25CbG9ja3MnKTtcblxuICAgICAgICAvLyBEaWFsb2cgd2l0aCBhIGZvcm0gdG8gY3JlYXRlIG9yIHVwZGF0ZSBhIE1vdGlvbkJsb2NrIGluc3RhbmNlLlxuICAgICAgICAkc2NvcGUub3BlbkZvcm1EaWFsb2cgPSBmdW5jdGlvbiAobW90aW9uQmxvY2spIHtcbiAgICAgICAgICAgIG5nRGlhbG9nLm9wZW4oTW90aW9uQmxvY2tGb3JtLmdldERpYWxvZyhtb3Rpb25CbG9jaykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENvbmZpcm0gZGlhbG9nIHRvIGRlbGV0ZSBhIE1vdGlvbkJsb2NrIGluc3RhbmNlLlxuICAgICAgICAkc2NvcGUuZGVsZXRlID0gZnVuY3Rpb24gKG1vdGlvbkJsb2NrKSB7XG4gICAgICAgICAgICBNb3Rpb25CbG9jay5kZXN0cm95KG1vdGlvbkJsb2NrLmlkKTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignTW90aW9uQmxvY2tEZXRhaWxDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckaHR0cCcsXG4gICAgJ25nRGlhbG9nJyxcbiAgICAnTW90aW9uJyxcbiAgICAnTW90aW9uQmxvY2tGb3JtJyxcbiAgICAnTW90aW9uQmxvY2snLFxuICAgICdtb3Rpb25CbG9ja0lkJyxcbiAgICAnUHJvamVjdG9yJyxcbiAgICAnUHJvamVjdGlvbkRlZmF1bHQnLFxuICAgICdXZWJwYWdlVGl0bGUnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0Vycm9yTWVzc2FnZScsXG4gICAgZnVuY3Rpb24oJHNjb3BlLCAkaHR0cCwgbmdEaWFsb2csIE1vdGlvbiwgTW90aW9uQmxvY2tGb3JtLCBNb3Rpb25CbG9jaywgbW90aW9uQmxvY2tJZCwgUHJvamVjdG9yLFxuICAgICAgICBQcm9qZWN0aW9uRGVmYXVsdCwgV2VicGFnZVRpdGxlLCBnZXR0ZXh0Q2F0YWxvZywgRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1vdGlvbkJsb2NrLmxhc3RNb2RpZmllZChtb3Rpb25CbG9ja0lkKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLm1vdGlvbkJsb2NrID0gTW90aW9uQmxvY2suZ2V0KG1vdGlvbkJsb2NrSWQpO1xuICAgICAgICAgICAgV2VicGFnZVRpdGxlLnVwZGF0ZVRpdGxlKGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnTW90aW9uIGJsb2NrJykgKyAnICcgK1xuICAgICAgICAgICAgICAgICRzY29wZS5tb3Rpb25CbG9jay5hZ2VuZGFfaXRlbS5nZXRUaXRsZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIE1vdGlvbi5iaW5kQWxsKHt9LCAkc2NvcGUsICdtb3Rpb25zJyk7XG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb2plY3Rvci5sYXN0TW9kaWZpZWQoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb2plY3Rpb25kZWZhdWx0ID0gUHJvamVjdGlvbkRlZmF1bHQuZmlsdGVyKHtuYW1lOiAnbW90aW9uQmxvY2tzJ30pWzBdO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rpb25kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlZmF1bHRQcm9qZWN0b3JJZCA9IHByb2plY3Rpb25kZWZhdWx0LnByb2plY3Rvcl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS5vcGVuRGlhbG9nID0gZnVuY3Rpb24gKG1vdGlvbkJsb2NrKSB7XG4gICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKE1vdGlvbkJsb2NrRm9ybS5nZXREaWFsb2cobW90aW9uQmxvY2spKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmZvbGxvd1JlY29tbWVuZGF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRodHRwLnBvc3QoJy9yZXN0L21vdGlvbnMvbW90aW9uLWJsb2NrLycgKyBtb3Rpb25CbG9ja0lkICsgJy9mb2xsb3dfcmVjb21tZW5kYXRpb25zLycpLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSB7IHR5cGU6ICdzdWNjZXNzJywgbXNnOiBzdWNjZXNzLmRhdGEuZGV0YWlsLCBzaG93OiB0cnVlIH07XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5kZWxldGUgPSBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICBtb3Rpb24ubW90aW9uX2Jsb2NrX2lkID0gbnVsbDtcbiAgICAgICAgICAgIG1vdGlvbi50aXRsZSA9IG1vdGlvbi5nZXRUaXRsZSgtMSk7XG4gICAgICAgICAgICBtb3Rpb24udGV4dCA9IG1vdGlvbi5nZXRUZXh0KC0xKTtcbiAgICAgICAgICAgIG1vdGlvbi5yZWFzb24gPSBtb3Rpb24uZ2V0UmVhc29uKC0xKTtcbiAgICAgICAgICAgIE1vdGlvbi5zYXZlKG1vdGlvbik7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ01vdGlvbkJsb2NrQ3JlYXRlQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnTW90aW9uQmxvY2snLFxuICAgICdNb3Rpb25CbG9ja0Zvcm0nLFxuICAgICdDb25maWcnLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgTW90aW9uQmxvY2ssIE1vdGlvbkJsb2NrRm9ybSwgQ29uZmlnKSB7XG4gICAgICAgIC8vIFByZXBhcmUgZm9ybS5cbiAgICAgICAgJHNjb3BlLm1vZGVsID0ge1xuICAgICAgICAgICAgYWdlbmRhX3R5cGU6IHBhcnNlSW50KENvbmZpZy5nZXQoJ2FnZW5kYV9uZXdfaXRlbXNfZGVmYXVsdF92aXNpYmlsaXR5JykudmFsdWUpLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdldCBhbGwgZm9ybSBmaWVsZHMuXG4gICAgICAgICRzY29wZS5mb3JtRmllbGRzID0gTW90aW9uQmxvY2tGb3JtLmdldEZvcm1GaWVsZHModHJ1ZSk7XG5cbiAgICAgICAgLy8gU2F2ZSBmb3JtLlxuICAgICAgICAkc2NvcGUuc2F2ZSA9IGZ1bmN0aW9uIChtb3Rpb25CbG9jaykge1xuICAgICAgICAgICAgTW90aW9uQmxvY2suY3JlYXRlKG1vdGlvbkJsb2NrKS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZVRoaXNEaWFsb2coKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlIGluIGVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gZSArICc6ICcgKyBlcnJvci5kYXRhW2VdICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IHt0eXBlOiAnZGFuZ2VyJywgbXNnOiBtZXNzYWdlLCBzaG93OiB0cnVlfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdNb3Rpb25CbG9ja1VwZGF0ZUN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRzdGF0ZScsXG4gICAgJ01vdGlvbkJsb2NrJyxcbiAgICAnTW90aW9uQmxvY2tGb3JtJyxcbiAgICAnbW90aW9uQmxvY2tJZCcsXG4gICAgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGUsIE1vdGlvbkJsb2NrLCBNb3Rpb25CbG9ja0Zvcm0sIG1vdGlvbkJsb2NrSWQpIHtcbiAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge307XG5cbiAgICAgICAgLy8gUHJlcGFyZSBmb3JtLiBTZXQgaW5pdGlhbCB2YWx1ZXMgYnkgY3JlYXRpbmcgYSBkZWVwIGNvcHkgb2ZcbiAgICAgICAgLy8gbW90aW9uQmxvY2sgb2JqZWN0IHNvIGxpc3QvZGV0YWlsIHZpZXcgaXMgbm90IHVwZGF0ZWQgd2hpbGUgZWRpdGluZy5cbiAgICAgICAgdmFyIG1vdGlvbkJsb2NrID0gTW90aW9uQmxvY2suZ2V0KG1vdGlvbkJsb2NrSWQpO1xuICAgICAgICAkc2NvcGUubW9kZWwgPSBhbmd1bGFyLmNvcHkobW90aW9uQmxvY2spO1xuXG4gICAgICAgIC8vIEdldCBhbGwgZm9ybSBmaWVsZHMuXG4gICAgICAgICRzY29wZS5mb3JtRmllbGRzID0gTW90aW9uQmxvY2tGb3JtLmdldEZvcm1GaWVsZHMoKTtcblxuICAgICAgICAvLyBTYXZlIGZvcm0uXG4gICAgICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24gKG1vdGlvbkJsb2NrKSB7XG4gICAgICAgICAgICAvLyBpbmplY3QgdGhlIGNoYW5nZWQgbW90aW9uQmxvY2sgKGNvcHkpIG9iamVjdCBiYWNrIGludG8gRFMgc3RvcmVcbiAgICAgICAgICAgIE1vdGlvbkJsb2NrLmluamVjdChtb3Rpb25CbG9jayk7XG4gICAgICAgICAgICAvLyBzYXZlIGNoYW5nZWQgbW90aW9uQmxvY2sgb2JqZWN0IG9uIHNlcnZlclxuICAgICAgICAgICAgTW90aW9uQmxvY2suY3JlYXRlKG1vdGlvbkJsb2NrKS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZVRoaXNEaWFsb2coKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIGVycm9yOiByZXZlcnQgYWxsIGNoYW5nZXMgYnkgcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICAvLyAocmVmcmVzaCkgb3JpZ2luYWwgbW90aW9uQmxvY2sgb2JqZWN0IGZyb20gc2VydmVyXG4gICAgICAgICAgICAgICAgICAgIE1vdGlvbkJsb2NrLnJlZnJlc2gobW90aW9uQmxvY2spOyAgLy8gVE9ETzogV2h5IGRvIHdlIG5lZWQgYSByZWZyZXNoIGhlcmU/XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUgaW4gZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBlICsgJzogJyArIGVycm9yLmRhdGFbZV0gKyAnICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge3R5cGU6ICdkYW5nZXInLCBtc2c6IG1lc3NhZ2UsIHNob3c6IHRydWV9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAubW90aW9ucy5tb3Rpb25zZXJ2aWNlcycsIFsnT3BlblNsaWRlc0FwcC5tb3Rpb25zJywgJ09wZW5TbGlkZXNBcHAubW90aW9ucy5saW5lTnVtYmVyaW5nJ10pXG5cbi8qIEdlbmVyaWMgaW5saW5lIGVkaXRpbmcgZmFjdG9yeS5cbiAqXG4gKiBnZXRPcmlnaW5hbERhdGE6IEZ1bmN0aW9uIHRoYXQgc2hvdWxkIHJldHVybiB0aGUgZWRpdG9yIGRhdGEuIFRoZSBlZGl0b3Igb2JqZWN0IGlzIHBhc3NlZC5cbiAqIHNhdmVEYXRhOiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGl0aCB0aGUgZWRpdG9yIG9iamVjdCBhcyBhcmd1bWVudC4gVGhpcyBmdW5jdGlvblxuICogICAgICBzaG91bGQgcHJlcGFyZSB0aGUgc2F2ZS4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgdGhlIHNhdmUgcHJvY2VzcyB3b24ndCBiZVxuICogICAgICBjb250aW51ZWQuIEVsc2UgYSBwYXRjaCByZXF1ZXN0IGlzIHNlbmQuXG4gKi9cbi5mYWN0b3J5KCdNb3Rpb25JbmxpbmVFZGl0aW5nJywgW1xuICAgICdNb3Rpb24nLFxuICAgICckdGltZW91dCcsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICBmdW5jdGlvbiAoTW90aW9uLCAkdGltZW91dCwgZ2V0dGV4dENhdGFsb2cpIHtcbiAgICAgICAgdmFyIGNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24gKCRzY29wZSwgbW90aW9uLCBzZWxlY3RvciwgdmVyc2lvbmluZywgY2tlZGl0b3JPcHRpb25zLCBnZXRPcmlnaW5hbERhdGEsIHNhdmVEYXRhKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2hhbmdlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNFZGl0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHJpdmlhbENoYW5nZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxIdG1sOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNrZWRpdG9yT3B0aW9ucy5yZWFkT25seSA9IHRydWU7XG5cbiAgICAgICAgICAgIG9iai5zZXRWZXJzaW9uID0gZnVuY3Rpb24gKF9tb3Rpb24sIHZlcnNpb25JZCkge1xuICAgICAgICAgICAgICAgIG1vdGlvbiA9IF9tb3Rpb247IC8vIElmIHRoaXMgaXMgbm90IHVwZGF0ZWQsXG4gICAgICAgICAgICAgICAgb2JqLm9yaWdpbmFsSHRtbCA9IG1vdGlvbi5nZXRUZXh0V2l0aExpbmVCcmVha3ModmVyc2lvbklkKTtcbiAgICAgICAgICAgICAgICBvYmouY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChvYmouZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5lZGl0b3Iuc2V0UmVhZE9ubHkodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iai5lZGl0b3Iuc2V0RGF0YShvYmoub3JpZ2luYWxIdG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvYmouZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG9iai5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9iai5pc0VkaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBja2VkaXRvck9wdGlvbnMubGFuZ3VhZ2UgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbGFuZ3VhZ2UnKTtcbiAgICAgICAgICAgICAgICBvYmouZWRpdG9yID0gQ0tFRElUT1IuaW5saW5lKHNlbGVjdG9yLCBja2VkaXRvck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIG9iai5lZGl0b3Iub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmVkaXRvci5nZXREYXRhKCkgIT09IG9iai5vcmlnaW5hbEh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9iai5yZXZlcnQoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9iai5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChvYmouZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5lZGl0b3Iuc2V0UmVhZE9ubHkodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iai5lZGl0b3Iuc2V0RGF0YShvYmoub3JpZ2luYWxIdG1sLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmVkaXRvci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBvYmouY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBvYmouaXNFZGl0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gc2V0cyBlZGl0b3IgY29udGVudCB0byB0aGUgaW5pdGlhbCBtb3Rpb24gc3RhdGVcbiAgICAgICAgICAgIG9iai5yZXZlcnQgPSBmdW5jdGlvbihvcmlnaW5hbERhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqLmVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICBvYmoub3JpZ2luYWxIdG1sID0gZ2V0T3JpZ2luYWxEYXRhKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIG9iai5lZGl0b3Iuc2V0RGF0YShcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldE9yaWdpbmFsRGF0YShvYmopLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLm9yaWdpbmFsSHRtbCA9IG9iai5lZGl0b3IuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5lZGl0b3Iuc2V0UmVhZE9ubHkoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmVkaXRvci5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9iai5zYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghc2F2ZURhdGEob2JqKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmouZGlzYWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIE1vdGlvbi5pbmplY3QobW90aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBjaGFuZ2UgbW90aW9uIG9iamVjdCBvbiBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgTW90aW9uLnNhdmUobW90aW9uLCB7bWV0aG9kOiAnUEFUQ0gnfSkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnNpb25pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNob3dWZXJzaW9uKG1vdGlvbi5nZXRWZXJzaW9uKC0xKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5yZXZlcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGVycm9yOiByZXZlcnQgYWxsIGNoYW5nZXMgYnkgcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChyZWZyZXNoKSBvcmlnaW5hbCBtb3Rpb24gb2JqZWN0IGZyb20gc2VydmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTW90aW9uLnJlZnJlc2gobW90aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoucmV2ZXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlIGluIGVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBlICsgJzogJyArIGVycm9yLmRhdGFbZV0gKyAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IHt0eXBlOiAnZGFuZ2VyJywgbXNnOiBtZXNzYWdlLCBzaG93OiB0cnVlfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlSW5zdGFuY2U6IGNyZWF0ZUluc3RhbmNlXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ01vdGlvbkNvbW1lbnRzSW5saW5lRWRpdGluZycsIFtcbiAgICAnTW90aW9uSW5saW5lRWRpdGluZycsXG4gICAgJ0VkaXRvcicsXG4gICAgZnVuY3Rpb24gKE1vdGlvbklubGluZUVkaXRpbmcsIEVkaXRvcikge1xuICAgICAgICB2YXIgY3JlYXRlSW5zdGFuY2VzID0gZnVuY3Rpb24gKCRzY29wZSwgbW90aW9uKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudHNJbmxpbmVFZGl0aW5nID0ge1xuICAgICAgICAgICAgICAgIGVkaXRvcnM6IHt9LCAvLyBNYXAgY29tbWVudCBpZCB0byBlZGl0b3IgaW5zdGFuY2UuXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBFZGl0b3IuZ2V0T3B0aW9ucygnaW5saW5lJywgJ1lPZmZzZXQnKTtcbiAgICAgICAgICAgIF8uZm9yRWFjaFJpZ2h0KCRzY29wZS5ub1NwZWNpYWxDb21tZW50c0ZpZWxkcywgZnVuY3Rpb24gKGZpZWxkLCBpZCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmxpbmVFZGl0aW5nID0gTW90aW9uSW5saW5lRWRpdGluZy5jcmVhdGVJbnN0YW5jZSgkc2NvcGUsIG1vdGlvbixcbiAgICAgICAgICAgICAgICAgICAgJ3ZpZXctb3JpZ2luYWwtY29tbWVudC1pbmxpbmUtZWRpdG9yLScgKyBpZCwgZmFsc2UsIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb3Rpb25bJ2NvbW1lbnRfJyArIGlkXTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb25bJ2NvbW1lbnRfJyArIGlkXSA9IG9iai5lZGl0b3IuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb21tZW50c0lubGluZUVkaXRpbmcuZWRpdG9yc1tpZF0gPSBpbmxpbmVFZGl0aW5nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb21tZW50c0lubGluZUVkaXRpbmcuc2F2ZVRvb2xiYXJWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLnNvbWUoY29tbWVudHNJbmxpbmVFZGl0aW5nLmVkaXRvcnMsIGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuY2hhbmdlZCAmJiBpbnN0YW5jZS5hY3RpdmU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29tbWVudHNJbmxpbmVFZGl0aW5nLmFjdGl2ZSA9IGZ1bmN0aW9uIChjb21tZW50SWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWVudHNJbmxpbmVFZGl0aW5nLmVkaXRvcnNbY29tbWVudElkXS5hY3RpdmU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29tbWVudHNJbmxpbmVFZGl0aW5nLnNhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNvbW1lbnRzSW5saW5lRWRpdGluZy5lZGl0b3JzLCBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbW1lbnRzSW5saW5lRWRpdGluZy5yZXZlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNvbW1lbnRzSW5saW5lRWRpdGluZy5lZGl0b3JzLCBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucmV2ZXJ0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29tbWVudHNJbmxpbmVFZGl0aW5nLmVuYWJsZSA9IGZ1bmN0aW9uIChjb21tZW50SWQpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50c0lubGluZUVkaXRpbmcuZWRpdG9yc1tjb21tZW50SWRdLmVuYWJsZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbW1lbnRzSW5saW5lRWRpdGluZy5kaXNhYmxlID0gZnVuY3Rpb24gKGNvbW1lbnRJZCkge1xuICAgICAgICAgICAgICAgIGNvbW1lbnRzSW5saW5lRWRpdGluZy5lZGl0b3JzW2NvbW1lbnRJZF0uZGlzYWJsZSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnRzSW5saW5lRWRpdGluZztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZUluc3RhbmNlczogY3JlYXRlSW5zdGFuY2VzLFxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdDaGFuZ2VSZWNvbW1lbmRhdGlvbkNyZWF0ZScsIFtcbiAgICAnbmdEaWFsb2cnLFxuICAgICdDaGFuZ2VSZWNvbW1lbmRhdGlvblRpdGxlRm9ybScsXG4gICAgJ0NoYW5nZVJlY29tbWVuZGF0aW9uVGV4dEZvcm0nLFxuICAgIGZ1bmN0aW9uKG5nRGlhbG9nLCBDaGFuZ2VSZWNvbW1lbmRhdGlvblRpdGxlRm9ybSwgQ2hhbmdlUmVjb21tZW5kYXRpb25UZXh0Rm9ybSkge1xuICAgICAgICB2YXIgTU9ERV9JTkFDVElWRSA9IDAsXG4gICAgICAgICAgICBNT0RFX1NFTEVDVElOR19GUk9NID0gMSxcbiAgICAgICAgICAgIE1PREVfU0VMRUNUSU5HX1RPID0gMixcblxuICAgICAgICAgICAgVElUTEVfRFVNTVlfTElORV9OVU1CRVIgPSAwO1xuXG4gICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICBtb2RlOiBNT0RFX0lOQUNUSVZFLFxuICAgICAgICAgICAgbGluZUZyb206IDEsXG4gICAgICAgICAgICBsaW5lVG86IDIsXG4gICAgICAgICAgICBodG1sOiAnJyxcbiAgICAgICAgICAgIHJldmlld2luZ0h0bWw6ICcnXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyICRzY29wZSwgbW90aW9uLCB2ZXJzaW9uO1xuXG4gICAgICAgIG9iai5fZ2V0QWZmZWN0ZWRMaW5lTnVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VSZWNvbW1lbmRhdGlvbnMgPSBtb3Rpb24uZ2V0VGV4dENoYW5nZVJlY29tbWVuZGF0aW9ucyh2ZXJzaW9uLmlkKSxcbiAgICAgICAgICAgICAgICBhZmZlY3RlZExpbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZVJlY29tbWVuZGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VSZWNvbW1lbmRhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGNoYW5nZS5saW5lX2Zyb207IGogPCBjaGFuZ2UubGluZV90bzsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkTGluZXMucHVzaChqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWZmZWN0ZWRMaW5lcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzdGFydENyZWF0aW5nIGlzIGNhbGxlZCByaWdodCBhdCB0aGUgYmVnaW5uaW5nIGFmdGVyIHRoZSB1c2VycyBpbnRlcmFjdHMgd2l0aCB0aGUgdGV4dCBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyBhbGwgbmVjZXNzYXJ5IG5vZGVzIGhhdmUgYmVlbiBpbml0aWFsaXplZFxuICAgICAgICBvYmouc3RhcnRDcmVhdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvYmoubW9kZSA+IE1PREVfU0VMRUNUSU5HX0ZST00gfHwgIW1vdGlvbi5pc0FsbG93ZWQoJ2Nhbl9tYW5hZ2UnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJChcIi50dF9jaGFuZ2VfcmVjb21tZW5kYXRpb25fY3JlYXRlX2hlbHBcIikucmVtb3ZlQ2xhc3MoXCJvcGVuZWRcIik7XG4gICAgICAgICAgICB2YXIgJGxpbmVOdW1iZXJzID0gJChcIi5tb3Rpb24tdGV4dC1vcmlnaW5hbCAub3MtbGluZS1udW1iZXJcIiksXG4gICAgICAgICAgICAgICAgJHRpdGxlID0gJChcIi5tb3Rpb24tdGl0bGUgLmNoYW5nZS10aXRsZVwiKTtcbiAgICAgICAgICAgIGlmICgkbGluZU51bWJlcnMuZmlsdGVyKFwiLnNlbGVjdGFibGVcIikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgb2JqLm1vZGUgPSBNT0RFX1NFTEVDVElOR19GUk9NO1xuICAgICAgICAgICAgICAgIHZhciBhbHJlYWR5QWZmZWN0ZWRMaW5lcyA9IG9iai5fZ2V0QWZmZWN0ZWRMaW5lTnVtYmVycygpO1xuICAgICAgICAgICAgICAgICRsaW5lTnVtYmVycy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIgPSAkdGhpcy5kYXRhKFwibGluZS1udW1iZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5QWZmZWN0ZWRMaW5lcy5pbmRleE9mKGxpbmVOdW1iZXIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcInNlbGVjdGFibGVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeUFmZmVjdGVkTGluZXMuaW5kZXhPZihUSVRMRV9EVU1NWV9MSU5FX05VTUJFUikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aXRsZS5hZGRDbGFzcyhcInNlbGVjdGFibGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG9iai5jYW5jZWxDcmVhdGluZyA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyICR0YXJnZXQgPSAkKGV2LnRhcmdldCksXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBcIi5saW5lLW51bWJlcnMtb3V0c2lkZSAub3MtbGluZS1udW1iZXIuc2VsZWN0YWJsZVwiO1xuICAgICAgICAgICAgaWYgKCEkdGFyZ2V0LmlzKHF1ZXJ5KSAmJiAkdGFyZ2V0LnBhcmVudHMocXVlcnkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG9iai5tb2RlID0gTU9ERV9JTkFDVElWRTtcbiAgICAgICAgICAgICAgICBvYmoubGluZUZyb20gPSAwO1xuICAgICAgICAgICAgICAgIG9iai5saW5lVG8gPSAwO1xuICAgICAgICAgICAgICAgICQoXCIubW90aW9uLXRleHQtb3JpZ2luYWwgLm9zLWxpbmUtbnVtYmVyXCIpLnJlbW92ZUNsYXNzKFwic2VsZWN0ZWQgc2VsZWN0YWJsZVwiKTtcbiAgICAgICAgICAgICAgICBvYmouc3RhcnRDcmVhdGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG9iai5zZXRGcm9tTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICBvYmoubW9kZSA9IE1PREVfU0VMRUNUSU5HX1RPO1xuICAgICAgICAgICAgb2JqLmxpbmVGcm9tID0gbGluZTtcblxuICAgICAgICAgICAgdmFyIGFscmVhZHlBZmZlY3RlZExpbmVzID0gb2JqLl9nZXRBZmZlY3RlZExpbmVOdW1iZXJzKCksXG4gICAgICAgICAgICAgICAgZm91bmRDb2xsaXNzaW9uID0gZmFsc2U7XG5cbiAgICAgICAgICAgICQoXCIubW90aW9uLXRleHQtb3JpZ2luYWwgLm9zLWxpbmUtbnVtYmVyXCIpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKCR0aGlzLmRhdGEoXCJsaW5lLW51bWJlclwiKSA+PSBsaW5lICYmICFmb3VuZENvbGxpc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlBZmZlY3RlZExpbmVzLmluZGV4T2YoJHRoaXMuZGF0YShcImxpbmUtbnVtYmVyXCIpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoXCJzZWxlY3RhYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcyhcInNlbGVjdGFibGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZENvbGxpc3Npb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcyhcInNlbGVjdGFibGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciB0dF9wb3MgPSAkKFwiLm1vdGlvbi10ZXh0LW9yaWdpbmFsIC5saW5lLW51bWJlci1cIiArIGxpbmUpLnBvc2l0aW9uKCkudG9wIC0gNDU7XG4gICAgICAgICAgICAkKFwiLnR0X2NoYW5nZV9yZWNvbW1lbmRhdGlvbl9jcmVhdGVfaGVscFwiKS5jc3MoXCJ0b3BcIiwgdHRfcG9zKS5hZGRDbGFzcyhcIm9wZW5lZFwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBvYmoudGl0bGVDbGlja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbmdEaWFsb2cub3BlbihDaGFuZ2VSZWNvbW1lbmRhdGlvblRpdGxlRm9ybS5nZXRDcmVhdGVEaWFsb2cobW90aW9uLCB2ZXJzaW9uKSk7XG5cbiAgICAgICAgICAgIG9iai5tb2RlID0gTU9ERV9JTkFDVElWRTtcbiAgICAgICAgICAgIG9iai5saW5lRnJvbSA9IDA7XG4gICAgICAgICAgICBvYmoubGluZVRvID0gMDtcbiAgICAgICAgICAgICQoXCIubW90aW9uLXRleHQtb3JpZ2luYWwgLm9zLWxpbmUtbnVtYmVyXCIpLnJlbW92ZUNsYXNzKFwic2VsZWN0ZWQgc2VsZWN0YWJsZVwiKTtcbiAgICAgICAgICAgIG9iai5zdGFydENyZWF0aW5nKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLnNldFRvTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICBpZiAobGluZSA8IG9iai5saW5lRnJvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iai5tb2RlID0gTU9ERV9JTkFDVElWRTtcbiAgICAgICAgICAgIG5nRGlhbG9nLm9wZW4oQ2hhbmdlUmVjb21tZW5kYXRpb25UZXh0Rm9ybS5nZXRDcmVhdGVEaWFsb2cobW90aW9uLCB2ZXJzaW9uLCBvYmoubGluZUZyb20sIGxpbmUgKyAxKSk7XG5cbiAgICAgICAgICAgIG9iai5saW5lRnJvbSA9IDA7XG4gICAgICAgICAgICBvYmoubGluZVRvID0gMDtcbiAgICAgICAgICAgICQoXCIubW90aW9uLXRleHQtb3JpZ2luYWwgLm9zLWxpbmUtbnVtYmVyXCIpLnJlbW92ZUNsYXNzKFwic2VsZWN0ZWQgc2VsZWN0YWJsZVwiKTtcbiAgICAgICAgICAgIG9iai5zdGFydENyZWF0aW5nKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLmxpbmVDbGlja2VkID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAob2JqLm1vZGUgPT09IE1PREVfSU5BQ1RJVkUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLm1vZGUgPT09IE1PREVfU0VMRUNUSU5HX0ZST00pIHtcbiAgICAgICAgICAgICAgICBvYmouc2V0RnJvbUxpbmUoJChldi50YXJnZXQpLmRhdGEoXCJsaW5lLW51bWJlclwiKSk7XG4gICAgICAgICAgICAgICAgJChldi50YXJnZXQpLmFkZENsYXNzKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iai5tb2RlID09PSBNT0RFX1NFTEVDVElOR19UTykge1xuICAgICAgICAgICAgICAgIG9iai5zZXRUb0xpbmUoJChldi50YXJnZXQpLmRhdGEoXCJsaW5lLW51bWJlclwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLm1vdXNlT3ZlciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKG9iai5tb2RlICE9PSBNT0RFX1NFTEVDVElOR19UTykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBob3ZlckxpbmUgPSAkKGV2LnRhcmdldCkuZGF0YShcImxpbmUtbnVtYmVyXCIpO1xuICAgICAgICAgICAgJChcIi5tb3Rpb24tdGV4dC1vcmlnaW5hbCAub3MtbGluZS1udW1iZXJcIikuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSAkKHRoaXMpLmRhdGEoXCJsaW5lLW51bWJlclwiKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZSA+PSBvYmoubGluZUZyb20gJiYgbGluZSA8PSBob3ZlckxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcInNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBvYmouc2V0VmVyc2lvbiA9IGZ1bmN0aW9uIChfbW90aW9uLCBfdmVyc2lvbikge1xuICAgICAgICAgICAgbW90aW9uID0gX21vdGlvbjtcbiAgICAgICAgICAgIHZlcnNpb24gPSBtb3Rpb24uZ2V0VmVyc2lvbihfdmVyc2lvbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLmVkaXRUZXh0RGlhbG9nID0gZnVuY3Rpb24oY2hhbmdlX3JlY29tbWVuZGF0aW9uKSB7XG4gICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKENoYW5nZVJlY29tbWVuZGF0aW9uVGV4dEZvcm0uZ2V0RWRpdERpYWxvZyhjaGFuZ2VfcmVjb21tZW5kYXRpb24pKTtcbiAgICAgICAgfTtcblxuICAgICAgICBvYmouZWRpdFRpdGxlRGlhbG9nID0gZnVuY3Rpb24oY2hhbmdlX3JlY29tbWVuZGF0aW9uKSB7XG4gICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKENoYW5nZVJlY29tbWVuZGF0aW9uVGl0bGVGb3JtLmdldEVkaXREaWFsb2coY2hhbmdlX3JlY29tbWVuZGF0aW9uKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLmluaXQgPSBmdW5jdGlvbiAoX3Njb3BlLCBfbW90aW9uKSB7XG4gICAgICAgICAgICAkc2NvcGUgPSBfc2NvcGU7XG4gICAgICAgICAgICBtb3Rpb24gPSBfbW90aW9uO1xuICAgICAgICAgICAgdmVyc2lvbiA9IG1vdGlvbi5nZXRWZXJzaW9uKCRzY29wZS52ZXJzaW9uKTtcblxuICAgICAgICAgICAgdmFyICRjb250ZW50ID0gJChcIiNjb250ZW50XCIpO1xuICAgICAgICAgICAgJGNvbnRlbnQub24oXCJjbGlja1wiLCBcIi5saW5lLW51bWJlcnMtb3V0c2lkZSAub3MtbGluZS1udW1iZXIuc2VsZWN0YWJsZVwiLCBvYmoubGluZUNsaWNrZWQpO1xuICAgICAgICAgICAgJGNvbnRlbnQub24oXCJjbGlja1wiLCBcIi5tb3Rpb24tdGl0bGUgLmNoYW5nZS10aXRsZS5zZWxlY3RhYmxlXCIsIG9iai50aXRsZUNsaWNrZWQpO1xuICAgICAgICAgICAgJGNvbnRlbnQub24oXCJjbGlja1wiLCBvYmouY2FuY2VsQ3JlYXRpbmcpO1xuICAgICAgICAgICAgJGNvbnRlbnQub24oXCJtb3VzZW92ZXJcIiwgXCIubGluZS1udW1iZXJzLW91dHNpZGUgLm9zLWxpbmUtbnVtYmVyLnNlbGVjdGFibGVcIiwgb2JqLm1vdXNlT3Zlcik7XG4gICAgICAgICAgICAkY29udGVudC5vbihcIm1vdXNlb3ZlclwiLCBcIi5tb3Rpb24tdGV4dC1vcmlnaW5hbCwgLm1vdGlvbi10aXRsZVwiLCBvYmouc3RhcnRDcmVhdGluZyk7XG5cbiAgICAgICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkc2NvcGUuY2hhbmdlX3JlY29tbWVuZGF0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5tb2RlID09PSBNT0RFX0lOQUNUSVZFIHx8IG9iai5tb2RlID09PSBNT0RFX1NFTEVDVElOR19GUk9NKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY2FsY3VsYXRlIHRoZSBhZmZlY3RlZCBsaW5lcyBzbyB3ZSBjYW5ub3Qgc2VsZWN0IGxpbmVzIGFmZmVjdGVkIGJ5IGEgcmVjb21tZW5kYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBoYXMganVzdCBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgJChcIi5tb3Rpb24tdGV4dC1vcmlnaW5hbCAub3MtbGluZS1udW1iZXJcIikucmVtb3ZlQ2xhc3MoXCJzZWxlY3RlZCBzZWxlY3RhYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICAkKFwiLm1vdGlvbi10aXRsZSAuY2hhbmdlLXRpdGxlXCIpLnJlbW92ZUNsYXNzKFwic2VsZWN0ZWQgc2VsZWN0YWJsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLnN0YXJ0Q3JlYXRpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJHNjb3BlLiRvbihcIiRkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvYmouZGVzdHJveSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJGNvbnRlbnQgPSAkKFwiI2NvbnRlbnRcIik7XG4gICAgICAgICAgICAkY29udGVudC5vZmYoXCJjbGlja1wiLCBcIi5saW5lLW51bWJlcnMtb3V0c2lkZSAub3MtbGluZS1udW1iZXIuc2VsZWN0YWJsZVwiLCBvYmoubGluZUNsaWNrZWQpO1xuICAgICAgICAgICAgJGNvbnRlbnQub2ZmKFwiY2xpY2tcIiwgXCIubW90aW9uLXRpdGxlIC5jaGFuZ2UtdGl0bGUuc2VsZWN0YWJsZVwiLCBvYmoudGl0bGVDbGlja2VkKTtcbiAgICAgICAgICAgICRjb250ZW50Lm9mZihcImNsaWNrXCIsIG9iai5jYW5jZWxDcmVhdGluZyk7XG4gICAgICAgICAgICAkY29udGVudC5vZmYoXCJtb3VzZW92ZXJcIiwgXCIubGluZS1udW1iZXJzLW91dHNpZGUgLm9zLWxpbmUtbnVtYmVyLnNlbGVjdGFibGVcIiwgb2JqLm1vdXNlT3Zlcik7XG4gICAgICAgICAgICAkY29udGVudC5vZmYoXCJtb3VzZW92ZXJcIiwgXCIubW90aW9uLXRleHQtb3JpZ2luYWwsIC5tb3Rpb24tdGl0bGVcIiwgb2JqLnN0YXJ0Q3JlYXRpbmcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ0NoYW5nZVJlY29tbWVuZGF0aW9uVmlldycsIFtcbiAgICAnTW90aW9uJyxcbiAgICAnTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24nLFxuICAgICdDb25maWcnLFxuICAgICdsaW5lTnVtYmVyaW5nU2VydmljZScsXG4gICAgJ2RpZmZTZXJ2aWNlJyxcbiAgICAnJGludGVydmFsJyxcbiAgICAnJHRpbWVvdXQnLFxuICAgIGZ1bmN0aW9uIChNb3Rpb24sIE1vdGlvbkNoYW5nZVJlY29tbWVuZGF0aW9uLCBDb25maWcsIGxpbmVOdW1iZXJpbmdTZXJ2aWNlLCBkaWZmU2VydmljZSwgJGludGVydmFsLCAkdGltZW91dCkge1xuICAgICAgICB2YXIgJHNjb3BlLCBtb3Rpb247XG5cbiAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICAgIG1vZGU6ICdvcmlnaW5hbCcsXG4gICAgICAgICAgICBjb250ZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLmRpZmZGb3JtYXR0ZXJDYiA9IGZ1bmN0aW9uIChjaGFuZ2UsIG9sZEZyYWdtZW50LCBuZXdGcmFnbWVudCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRGcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGlmZlNlcnZpY2UuYWRkQ1NTQ2xhc3Mob2xkRnJhZ21lbnQuY2hpbGROb2Rlc1tpXSwgJ2RlbGV0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ld0ZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkaWZmU2VydmljZS5hZGRDU1NDbGFzcyhuZXdGcmFnbWVudC5jaGlsZE5vZGVzW2ldLCAnaW5zZXJ0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWVyZ2VkRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgICAgICAgICAgZGlmZlNlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdTRUNUSU9OJyksXG4gICAgICAgICAgICAgICAgZWw7XG5cbiAgICAgICAgICAgIG1lcmdlZEZyYWdtZW50LmFwcGVuZENoaWxkKGRpZmZTZWN0aW9uKTtcbiAgICAgICAgICAgIGRpZmZTZWN0aW9uLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGlmZicpO1xuICAgICAgICAgICAgZGlmZlNlY3Rpb24uc2V0QXR0cmlidXRlKCdkYXRhLWNoYW5nZS1pZCcsIGNoYW5nZS5pZCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChvbGRGcmFnbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBvbGRGcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIG9sZEZyYWdtZW50LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICBkaWZmU2VjdGlvbi5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAobmV3RnJhZ21lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGVsID0gbmV3RnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBuZXdGcmFnbWVudC5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgZGlmZlNlY3Rpb24uYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkRnJhZ21lbnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLmRlbGV0ZSA9IGZ1bmN0aW9uIChjaGFuZ2VJZCkge1xuICAgICAgICAgICAgTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24uZGVzdHJveShjaGFuZ2VJZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLnJlamVjdEFsbENoYW5nZVJlY29tbWVuZGF0aW9ucyA9IGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VSZWNvbW1lbmRhdGlvbnMgPSBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbi5maWx0ZXIoe1xuICAgICAgICAgICAgICAgICd3aGVyZSc6IHsnbW90aW9uX3ZlcnNpb25faWQnOiB7Jz09JzogbW90aW9uLmFjdGl2ZV92ZXJzaW9ufX1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXy5mb3JFYWNoKGNoYW5nZVJlY29tbWVuZGF0aW9ucywgZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlLnJlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGFuZ2Uuc2F2ZVN0YXR1cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLnJlcG9zaXRpb25PcmlnaW5hbEFubm90YXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICRjaGFuZ2VSZWNvbW1lbmRhdGlvbkxpc3QgPSAkKCcuY2hhbmdlLXJlY29tbWVuZGF0aW9uLWxpc3QnKSxcbiAgICAgICAgICAgICAgICAkbGluZU51bWJlclJlZmVyZW5jZSA9ICQoJy5tb3Rpb24tdGV4dC1vcmlnaW5hbCcpO1xuXG4gICAgICAgICAgICAkY2hhbmdlUmVjb21tZW5kYXRpb25MaXN0LmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBsaW5lRnJvbSA9ICR0aGlzLmRhdGEoJ2xpbmUtZnJvbScpLFxuICAgICAgICAgICAgICAgICAgICBsaW5lVG8gPSAoJHRoaXMuZGF0YSgnbGluZS10bycpIC0gMSksXG4gICAgICAgICAgICAgICAgICAgICRsaW5lRnJvbSA9ICRsaW5lTnVtYmVyUmVmZXJlbmNlLmZpbmQoJy5saW5lLW51bWJlci0nICsgbGluZUZyb20pLFxuICAgICAgICAgICAgICAgICAgICAkbGluZVRvID0gJGxpbmVOdW1iZXJSZWZlcmVuY2UuZmluZCgnLmxpbmUtbnVtYmVyLScgKyBsaW5lVG8pLFxuICAgICAgICAgICAgICAgICAgICBmcm9tVG9wID0gJGxpbmVGcm9tLnBvc2l0aW9uKCkudG9wICsgMyxcbiAgICAgICAgICAgICAgICAgICAgdG9Ub3AgPSAkbGluZVRvLnBvc2l0aW9uKCkudG9wICsgMjAsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9ICh0b1RvcCAtIGZyb21Ub3ApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodCA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IDEwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vICRsaW5lRnJvbS5wb3NpdGlvbigpLnRvcCBzZWVtcyB0byBkZXBlbmQgb24gdGhlIHNjcm9sbGluZyBwb3NpdGlvbiB3aGVuIHRoZSBsaW5lIG51bWJlcnNcbiAgICAgICAgICAgICAgICAvLyBoYXZlIHBvc2l0aW9uOiBhYnNvbHV0ZS4gTWF5YmUgYSBidWcgaW4gdGhlIHVzZWQgdmVyc2lvbiBvZiBqUXVlcnk/XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjYW5jZWxzIHRoZSBlZmZlY3QuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBpZiAoJGxpbmVOdW1iZXJSZWZlcmVuY2UuaGFzQ2xhc3MoJ2xpbmUtbnVtYmVycy1vdXRzaWRlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbVRvcCArPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICR0aGlzLmNzcyh7ICd0b3AnOiBmcm9tVG9wLCAnaGVpZ2h0JzogaGVpZ2h0IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLmNvcHlUb01vZGlmaWVkRmluYWxWZXJzaW9uID0gZnVuY3Rpb24gKG1vdGlvbiwgdmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKCFtb3Rpb24uaXNBbGxvd2VkKCd1cGRhdGUnKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdObyBwZXJtaXNzaW9uIHRvIHVwZGF0ZSBtb3Rpb24nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb3Rpb24uY29weU1vZGlmaWVkRmluYWxWZXJzaW9uU3RyaXBwaW5nTGluZUJyZWFrcygpO1xuXG4gICAgICAgICAgICBNb3Rpb24uaW5qZWN0KG1vdGlvbik7XG4gICAgICAgICAgICAvLyBzYXZlIGNoYW5nZSBtb3Rpb24gb2JqZWN0IG9uIHNlcnZlclxuICAgICAgICAgICAgTW90aW9uLnNhdmUobW90aW9uLCB7bWV0aG9kOiAnUEFUQ0gnfSkudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBzYXZlIGVycm9yOiByZXZlcnQgYWxsIGNoYW5nZXMgYnkgcmVzdG9yZVxuICAgICAgICAgICAgICAgIC8vIChyZWZyZXNoKSBvcmlnaW5hbCBtb3Rpb24gb2JqZWN0IGZyb20gc2VydmVyXG4gICAgICAgICAgICAgICAgTW90aW9uLnJlZnJlc2gobW90aW9uKTtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGUgaW4gZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGUgKyAnOiAnICsgZXJyb3IuZGF0YVtlXSArICcgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge3R5cGU6ICdkYW5nZXInLCBtc2c6IG1lc3NhZ2UsIHNob3c6IHRydWV9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLmRlbGV0ZU1vZGlmaWVkRmluYWxWZXJzaW9uID0gZnVuY3Rpb24gKG1vdGlvbiwgdmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKCFtb3Rpb24uaXNBbGxvd2VkKCd1cGRhdGUnKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdObyBwZXJtaXNzaW9uIHRvIHVwZGF0ZSBtb3Rpb24nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1vdGlvbi5nZXRNb2RpZmllZEZpbmFsVmVyc2lvbih2ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbW90aW9uLm1vZGlmaWVkX2ZpbmFsX3ZlcnNpb24gPSAnJztcblxuICAgICAgICAgICAgTW90aW9uLmluamVjdChtb3Rpb24pO1xuICAgICAgICAgICAgLy8gc2F2ZSBjaGFuZ2UgbW90aW9uIG9iamVjdCBvbiBzZXJ2ZXJcbiAgICAgICAgICAgIE1vdGlvbi5zYXZlKG1vdGlvbiwge21ldGhvZDogJ1BBVENIJ30pLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUudmlld0NoYW5nZVJlY29tbWVuZGF0aW9ucy5tb2RlID0gJ2FncmVlZCc7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBzYXZlIGVycm9yOiByZXZlcnQgYWxsIGNoYW5nZXMgYnkgcmVzdG9yZVxuICAgICAgICAgICAgICAgIC8vIChyZWZyZXNoKSBvcmlnaW5hbCBtb3Rpb24gb2JqZWN0IGZyb20gc2VydmVyXG4gICAgICAgICAgICAgICAgTW90aW9uLnJlZnJlc2gobW90aW9uKTtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGUgaW4gZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGUgKyAnOiAnICsgZXJyb3IuZGF0YVtlXSArICcgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge3R5cGU6ICdkYW5nZXInLCBtc2c6IG1lc3NhZ2UsIHNob3c6IHRydWV9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLm5ld1ZlcnNpb25JbmNsdWRpbmdDaGFuZ2VzID0gZnVuY3Rpb24gKG1vdGlvbiwgdmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKCFtb3Rpb24uaXNBbGxvd2VkKCd1cGRhdGUnKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdObyBwZXJtaXNzaW9uIHRvIHVwZGF0ZSBtb3Rpb24nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3SHRtbCA9IG1vdGlvbi5nZXRUZXh0QnlNb2RlKCdhZ3JlZWQnKTtcbiAgICAgICAgICAgIG1vdGlvbi5zZXRUZXh0U3RyaXBwaW5nTGluZUJyZWFrcyhuZXdIdG1sKTtcblxuICAgICAgICAgICAgTW90aW9uLmluamVjdChtb3Rpb24pO1xuICAgICAgICAgICAgLy8gc2F2ZSBjaGFuZ2UgbW90aW9uIG9iamVjdCBvbiBzZXJ2ZXJcbiAgICAgICAgICAgIE1vdGlvbi5zYXZlKG1vdGlvbiwge21ldGhvZDogJ1BBVENIJ30pLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNob3dWZXJzaW9uKG1vdGlvbi5nZXRWZXJzaW9uKC0xKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBlcnJvcjogcmV2ZXJ0IGFsbCBjaGFuZ2VzIGJ5IHJlc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gKHJlZnJlc2gpIG9yaWdpbmFsIG1vdGlvbiBvYmplY3QgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgTW90aW9uLnJlZnJlc2gobW90aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSBpbiBlcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGUgKyAnOiAnICsgZXJyb3IuZGF0YVtlXSArICcgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSB7dHlwZTogJ2RhbmdlcicsIG1zZzogbWVzc2FnZSwgc2hvdzogdHJ1ZX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBvYmouc2Nyb2xsVG9EaWZmQm94ID0gZnVuY3Rpb24gKGNoYW5nZUlkKSB7XG4gICAgICAgICAgICBvYmoubW9kZSA9ICdkaWZmJztcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciAkZGlmZkJveCA9ICQoJy5kaWZmLWJveC0nICsgY2hhbmdlSWQpO1xuICAgICAgICAgICAgICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiAkZGlmZkJveC5vZmZzZXQoKS50b3AgLSA1MFxuICAgICAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgICB9LCAwLCBmYWxzZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gJHNjb3BlLmFtZW5kbWVudHNfY3JzIGhvbGRzIHRoZSBjaGFuZ2Ugb2JqZWN0cyBvZiBhbGwgY2hhbmdlIHJlY29tbWVuZGF0aW9ucyByZWdhcmRpbmcgdGhlIHRleHQsXG4gICAgICAgIC8vIGFuZCBhbGwgYW1lbmRtZW50cyB3aXRoIGEgXCJhY2NlcHRlZFwiLXJlY29tbWVuZGF0aW9uLCBvcmRlcmVkIGJ5IHRoZSBmaXJzdCBhZmZlY3RlZCBsaW5lIG51bWJlci5cbiAgICAgICAgb2JqLnNldF9hbWVuZG1lbnRzX2Nyc193YXRjaGVyID0gZnVuY3Rpb24oJHNjb3BlLCBtb3Rpb24pIHtcbiAgICAgICAgICAgICRzY29wZS5hbWVuZG1lbnRzX2NycyA9IFtdO1xuICAgICAgICAgICAgJHNjb3BlLmNoYW5nZV9yZWNvbW1lbmRhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICRzY29wZS5wYXJhZ3JhcGhfYW1lbmRtZW50cyA9IFtdO1xuICAgICAgICAgICAgJHNjb3BlLmhhc19wcm9wb3NlZF9jaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgICAgICAkc2NvcGUuY2hhbmdlZF92ZXJzaW9uX2hhc19jb2xsaXNzaW9ucyA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgcmVidWlsZF9hbWVuZG1lbnRzX2NycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYW1lbmRtZW50c19jcnMgPSAkc2NvcGUuY2hhbmdlX3JlY29tbWVuZGF0aW9ucy5tYXAoZnVuY3Rpb24gKGNyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjci5nZXRVbmlmaWVkQ2hhbmdlT2JqZWN0KCk7XG4gICAgICAgICAgICAgICAgfSkuY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUucGFyYWdyYXBoX2FtZW5kbWVudHMubWFwKGZ1bmN0aW9uIChhbWVuZG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbWVuZG1lbnQuZ2V0VW5pZmllZENoYW5nZU9iamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFtZW5kbWVudHNfY3JzLnNvcnQoZnVuY3Rpb24gKGNoYW5nZTEsIGNoYW5nZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZTEubGluZV9mcm9tID4gY2hhbmdlMi5saW5lX2Zyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZTEubGluZV9mcm9tIDwgY2hhbmdlMi5saW5lX2Zyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgYWxsIGNycyBhbmQgYW1lbmRtZW50cyBmb3IgY29sbGlzc2lvbiBkZXRlY3Rpb24uXG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKCRzY29wZS5hbWVuZG1lbnRzX2NycywgZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2Uuc2V0T3RoZXJDaGFuZ2VzRm9yQ29sbGlzc2lvbigkc2NvcGUuYW1lbmRtZW50c19jcnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmhhc19wcm9wb3NlZF9jaGFuZ2VzID0gKCRzY29wZS5hbWVuZG1lbnRzX2Nycy5sZW5ndGggPiAwKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuY2hhbmdlZF92ZXJzaW9uX2hhc19hY2NlcHRlZF9jb2xsaXNzaW9ucyA9ICgkc2NvcGUuYW1lbmRtZW50c19jcnMuZmluZChmdW5jdGlvbihjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjaGFuZ2UuZ2V0Q29sbGlzc2lvbnModHJ1ZSkubGVuZ3RoICE9PSAwKTtcbiAgICAgICAgICAgICAgICB9KSAhPT0gdW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgICAgIGlmIChvYmouY29udGV4dCA9PT0gJ3NpdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLmhhc19wcm9wb3NlZF9jaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2V0UHJvamVjdGlvbk1vZGUoJHNjb3BlLnByb2plY3Rpb25Nb2Rlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5oYXNfcHJvcG9zZWRfY2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRpc2FibGVNb3Rpb25JbmxpbmVFZGl0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24ubGFzdE1vZGlmaWVkKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNoYW5nZV9yZWNvbW1lbmRhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAkc2NvcGUudGl0bGVfY2hhbmdlX3JlY29tbWVuZGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbi5maWx0ZXIoe1xuICAgICAgICAgICAgICAgICAgICAnd2hlcmUnOiB7J21vdGlvbl92ZXJzaW9uX2lkJzogeyc9PSc6IG1vdGlvbi5hY3RpdmVfdmVyc2lvbn19XG4gICAgICAgICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UuaXNUZXh0UmVjb21tZW5kYXRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNoYW5nZV9yZWNvbW1lbmRhdGlvbnMucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UuaXNUaXRsZVJlY29tbWVuZGF0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS50aXRsZV9jaGFuZ2VfcmVjb21tZW5kYXRpb24gPSBjaGFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWJ1aWxkX2FtZW5kbWVudHNfY3JzKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1vdGlvbi5sYXN0TW9kaWZpZWQoKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5wYXJhZ3JhcGhfYW1lbmRtZW50cyA9IG1vdGlvbi5nZXRQYXJhZ3JhcGhCYXNlZEFtZW5kbWVudHNGb3JEaWZmVmlldygpO1xuICAgICAgICAgICAgICAgICAgICByZWJ1aWxkX2FtZW5kbWVudHNfY3JzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLnNldFZlcnNpb24gPSBmdW5jdGlvbiAoX21vdGlvbi8qLCBfdmVyc2lvbiovKSB7XG4gICAgICAgICAgICBtb3Rpb24gPSBfbW90aW9uO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9iai5pbml0UHJvamVjdG9yID0gZnVuY3Rpb24gKF9zY29wZSwgX21vdGlvbiwgdmlld01vZGUpIHtcbiAgICAgICAgICAgIG9iai5jb250ZXh0ID0gJ3Byb2plY3Rvcic7XG4gICAgICAgICAgICAkc2NvcGUgPSBfc2NvcGU7XG4gICAgICAgICAgICBtb3Rpb24gPSBfbW90aW9uO1xuXG4gICAgICAgICAgICBvYmouc2V0X2FtZW5kbWVudHNfY3JzX3dhdGNoZXIoJHNjb3BlLCBtb3Rpb24pO1xuICAgICAgICAgICAgb2JqLm1vZGUgPSB2aWV3TW9kZTtcbiAgICAgICAgfTtcblxuICAgICAgICBvYmouaW5pdFNpdGUgPSBmdW5jdGlvbiAoX3Njb3BlLCBfbW90aW9uLCB2aWV3TW9kZSkge1xuICAgICAgICAgICAgb2JqLmNvbnRleHQgPSAnc2l0ZSc7XG4gICAgICAgICAgICAkc2NvcGUgPSBfc2NvcGU7XG4gICAgICAgICAgICBtb3Rpb24gPSBfbW90aW9uO1xuXG4gICAgICAgICAgICBvYmouc2V0X2FtZW5kbWVudHNfY3JzX3dhdGNoZXIoJHNjb3BlLCBtb3Rpb24pO1xuXG4gICAgICAgICAgICAkc2NvcGUuJGV2YWxBc3luYyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvYmoucmVwb3NpdGlvbk9yaWdpbmFsQW5ub3RhdGlvbnMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJCgnLmNoYW5nZS1yZWNvbW1lbmRhdGlvbi1saXN0JykuY2hpbGRyZW4oKS5sZW5ndGg7XG4gICAgICAgICAgICB9LCBvYmoucmVwb3NpdGlvbk9yaWdpbmFsQW5ub3RhdGlvbnMpO1xuXG4gICAgICAgICAgICB2YXIgY2hlY2tHb3RvT3JpZ2luYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCRzY29wZS5hbWVuZG1lbnRzX2Nycy5sZW5ndGggPT09IDAgJiYgJHNjb3BlLnRpdGxlX2NoYW5nZV9yZWNvbW1lbmRhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvYmoubW9kZSA9ICdvcmlnaW5hbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkc2NvcGUuYW1lbmRtZW50c19jcnMubGVuZ3RoO1xuICAgICAgICAgICAgfSwgY2hlY2tHb3RvT3JpZ2luYWwpO1xuICAgICAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRzY29wZS50aXRsZV9jaGFuZ2VfcmVjb21tZW5kYXRpb247XG4gICAgICAgICAgICB9LCBjaGVja0dvdG9PcmlnaW5hbCk7XG5cbiAgICAgICAgICAgIHZhciBzaXplQ2hlY2tlckxhc3RTaXplID0gbnVsbCxcbiAgICAgICAgICAgICAgICBzaXplQ2hlY2tlckxhc3RDbGFzcyA9IG51bGwsXG4gICAgICAgICAgICAgICAgc2l6ZUNoZWNrZXIgPSAkaW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkaG9sZGVyID0gJChcIi5tb3Rpb24tdGV4dC1vcmlnaW5hbFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9ICRob2xkZXIuaGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzID0gJGhvbGRlci5hdHRyKFwiY2xhc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdIZWlnaHQgIT09IHNpemVDaGVja2VyTGFzdFNpemUgfHwgc2l6ZUNoZWNrZXJMYXN0Q2xhc3MgIT09IGNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVDaGVja2VyTGFzdFNpemUgPSBuZXdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplQ2hlY2tlckxhc3RDbGFzcyA9IGNsYXNzZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmoucmVwb3NpdGlvbk9yaWdpbmFsQW5ub3RhdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDEwMCwgMCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRpbnRlcnZhbC5jYW5jZWwoc2l6ZUNoZWNrZXIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG9iai5tb2RlID0gdmlld01vZGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5tb3Rpb25zLnBkZicsIFsnT3BlblNsaWRlc0FwcC5jb3JlLnBkZiddKVxuXG4uZmFjdG9yeSgnTW90aW9uQ29udGVudFByb3ZpZGVyJywgW1xuICAgICckcScsXG4gICAgJyRmaWx0ZXInLFxuICAgICdvcGVyYXRvcicsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnUERGTGF5b3V0JyxcbiAgICAnUGRmTWFrZUNvbnZlcnRlcicsXG4gICAgJ0ltYWdlQ29udmVydGVyJyxcbiAgICAnSFRNTFZhbGlkaXplcicsXG4gICAgJ0NhdGVnb3J5JyxcbiAgICAnQ29uZmlnJyxcbiAgICAnTW90aW9uJyxcbiAgICAnTW90aW9uQ29tbWVudCcsXG4gICAgJ01vdGlvblBvbGxEZWNpbWFsUGxhY2VzJyxcbiAgICAnT3BlblNsaWRlc1NldHRpbmdzJyxcbiAgICBmdW5jdGlvbigkcSwgJGZpbHRlciwgb3BlcmF0b3IsIGdldHRleHRDYXRhbG9nLCBQREZMYXlvdXQsIFBkZk1ha2VDb252ZXJ0ZXIsIEltYWdlQ29udmVydGVyLFxuICAgICAgICBIVE1MVmFsaWRpemVyLCBDYXRlZ29yeSwgQ29uZmlnLCBNb3Rpb24sIE1vdGlvbkNvbW1lbnQsIE1vdGlvblBvbGxEZWNpbWFsUGxhY2VzLCBPcGVuU2xpZGVzU2V0dGluZ3MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGVzIHRoZSBjb250ZW50IGFzIEpTIG9iamVjdHMgZm9yIE1vdGlvbnMgaW4gcGRmTWFrZSBjb250ZXh0XG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbihtb3Rpb24sIG1vdGlvblZlcnNpb24sIHBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0gXy5jbG9uZShwYXJhbXMgfHwge30pOyAvLyBDbG9uZSB0aGlzIHRvIGF2b2lkIHNpZGVlZmZlY3RzLlxuICAgICAgICAgICAgXy5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VSZWNvbW1lbmRhdGlvbk1vZGU6IENvbmZpZy5nZXQoJ21vdGlvbnNfcmVjb21tZW5kYXRpb25fdGV4dF9tb2RlJykudmFsdWUsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlck1vZGU6IENvbmZpZy5nZXQoJ21vdGlvbnNfZGVmYXVsdF9saW5lX251bWJlcmluZycpLnZhbHVlLFxuICAgICAgICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN1Ym1pdHRlcnM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZvdGluZ3Jlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbW90aW9uQmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVjb21tZW5kYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlQ29tbWVudHM6IHt9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBjb252ZXJ0ZXIsIGltYWdlTWFwID0ge307XG5cbiAgICAgICAgICAgIC8vIFF1ZXJ5IGFsbCBpbWFnZSBzb3VyY2VzIGZyb20gbW90aW9uIHRleHQgYW5kIHJlYXNvblxuICAgICAgICAgICAgdmFyIGdldEltYWdlU291cmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IG1vdGlvbi5nZXRUZXh0QnlNb2RlKHBhcmFtcy5jaGFuZ2VSZWNvbW1lbmRhdGlvbk1vZGUsIG51bGwpO1xuICAgICAgICAgICAgICAgIHZhciByZWFzb24gPSBtb3Rpb24uZ2V0UmVhc29uKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnRzID0gJyc7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKHBhcmFtcy5pbmNsdWRlQ29tbWVudHMsIGZ1bmN0aW9uIChvaywgaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9rICYmIG1vdGlvbi5jb21tZW50c1tpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzICs9IEhUTUxWYWxpZGl6ZXIudmFsaWRpemUobW90aW9uLmNvbW1lbnRzW2lkXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IEhUTUxWYWxpZGl6ZXIudmFsaWRpemUodGV4dCkgKyBIVE1MVmFsaWRpemVyLnZhbGlkaXplKG1vdGlvbi5nZXRSZWFzb24oKSkgKyBjb21tZW50cztcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChbXS5tYXApO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXAoJChjb250ZW50KS5maW5kKCdpbWcnKSwgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gdGl0bGVcbiAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gbW90aW9uLmlkZW50aWZpZXIgPyAnICcgKyBtb3Rpb24uaWRlbnRpZmllciA6ICcnO1xuICAgICAgICAgICAgdmFyIHRpdGxlUGxhaW4gPSBtb3Rpb24uZ2V0VGl0bGVXaXRoQ2hhbmdlcyhwYXJhbXMuY2hhbmdlUmVjb21tZW5kYXRpb25Nb2RlLCBtb3Rpb25WZXJzaW9uKTtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IFBERkxheW91dC5jcmVhdGVUaXRsZShnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ01vdGlvbicpICsgaWRlbnRpZmllciArICc6ICcgKyB0aXRsZVBsYWluKTtcblxuICAgICAgICAgICAgLy8gc3VidGl0bGUgYW5kIHNlcXVlbnRpYWwgbnVtYmVyXG4gICAgICAgICAgICB2YXIgc3VidGl0bGVMaW5lcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG1vdGlvbi5wYXJlbnRfaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50TW90aW9uID0gTW90aW9uLmdldChtb3Rpb24ucGFyZW50X2lkKTtcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZUxpbmVzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQW1lbmRtZW50IHRvIG1vdGlvbicpICsgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIChwYXJlbnRNb3Rpb24uaWRlbnRpZmllciA/IHBhcmVudE1vdGlvbi5pZGVudGlmaWVyIDogcGFyZW50TW90aW9uLmdldFRpdGxlKCkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChDb25maWcuZ2V0KCdtb3Rpb25zX2V4cG9ydF9zZXF1ZW50aWFsX251bWJlcicpLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc3VidGl0bGVMaW5lcy5wdXNoKGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnU2VxdWVudGlhbCBudW1iZXInKSArICc6ICcgK1xuICAgICAgICAgICAgICAgICAgICBtb3Rpb24uZ2V0U2VxdWVudGlhbE51bWJlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdWJ0aXRsZSA9IFBERkxheW91dC5jcmVhdGVTdWJ0aXRsZShzdWJ0aXRsZUxpbmVzKTtcblxuICAgICAgICAgICAgLy8gbWV0YSBkYXRhIHRhYmxlXG4gICAgICAgICAgICB2YXIgbWV0YVRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1ldGFUYWJsZUJvZHkgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIHN1Ym1pdHRlcnNcbiAgICAgICAgICAgICAgICB2YXIgc3VibWl0dGVycyA9IF8ubWFwKFxuICAgICAgICAgICAgICAgICAgICAkZmlsdGVyKCdvcmRlckJ5JykobW90aW9uLnN1Ym1pdHRlcnMsICd3ZWlnaHQnKSwgZnVuY3Rpb24gKHN1Ym1pdHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Ym1pdHRlci51c2VyLmdldF9mdWxsX25hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICkuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmluY2x1ZGUuc3VibWl0dGVycykge1xuICAgICAgICAgICAgICAgICAgICBtZXRhVGFibGVCb2R5LnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnU3VibWl0dGVycycpICsgJzonLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBbJ2JvbGQnLCAnZ3JleSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzdWJtaXR0ZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnZ3JleSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmluY2x1ZGUuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVRhYmxlQm9keS5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1N0YXRlJykgKyAnOicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFsnYm9sZCcsICdncmV5J11cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbW90aW9uLmdldFN0YXRlTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnZ3JleSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcmVjb21tZW5kYXRpb25cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmluY2x1ZGUucmVjb21tZW5kYXRpb24gJiYgbW90aW9uLmdldFJlY29tbWVuZGF0aW9uTmFtZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFUYWJsZUJvZHkucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogQ29uZmlnLmdldCgnbW90aW9uc19yZWNvbW1lbmRhdGlvbnNfYnknKS52YWx1ZSArICc6JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogWydib2xkJywgJ2dyZXknXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBtb3Rpb24uZ2V0UmVjb21tZW5kYXRpb25OYW1lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdncmV5J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjYXRlZ29yeVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaW5jbHVkZS5jYXRlZ29yeSAmJiBtb3Rpb24uY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVRhYmxlQm9keS5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0NhdGVnb3J5JykgKyAnOicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFsnYm9sZCcsICdncmV5J10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBtb3Rpb24uY2F0ZWdvcnkucHJlZml4ICsgJyAtICcgKyBtb3Rpb24uY2F0ZWdvcnkubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2dyZXknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdGlvbiBibG9ja1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaW5jbHVkZS5tb3Rpb25CbG9jayAmJiBtb3Rpb24ubW90aW9uQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVRhYmxlQm9keS5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ01vdGlvbiBibG9jaycpICsgJzonLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBbJ2JvbGQnLCAnZ3JleSddIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbW90aW9uLm1vdGlvbkJsb2NrLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnZ3JleSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5pbmNsdWRlLm9yaWdpbiAmJiBtb3Rpb24ub3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFUYWJsZUJvZHkucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdPcmlnaW4nKSArICc6JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogWydib2xkJywgJ2dyZXknXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG1vdGlvbi5vcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdncmV5J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB2b3RpbmcgcmVzdWx0XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5pbmNsdWRlLnZvdGluZ3Jlc3VsdCAmJiBtb3Rpb24ucG9sbHMubGVuZ3RoID4gMCAmJiBtb3Rpb24ucG9sbHNbMF0uaGFzX3ZvdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW4xID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW4yID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW4zID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1vdGlvbi5wb2xscy5tYXAoZnVuY3Rpb24ocG9sbCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2xsLmhhc192b3Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZvdGVudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW90aW9uLnBvbGxzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uMS5wdXNoKGluZGV4ICsgMSArICcuICcgKyBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1ZvdGUnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjIucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmVjaXNpb24gPSBNb3Rpb25Qb2xsRGVjaW1hbFBsYWNlcy5nZXRQbGFjZXMocG9sbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHllcyA9IHBvbGwuZ2V0Vm90ZShwb2xsLnllcywgJ3llcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjEucHVzaChnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1llcycpICsgJzonKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4yLnB1c2goJGZpbHRlcignbnVtYmVyJykoeWVzLnZhbHVlLCBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4zLnB1c2goeWVzLnBlcmNlbnRTdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vID0gcG9sbC5nZXRWb3RlKHBvbGwubm8sICdubycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjEucHVzaChnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ05vJykgKyAnOicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjIucHVzaCgkZmlsdGVyKCdudW1iZXInKShuby52YWx1ZSwgcHJlY2lzaW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uMy5wdXNoKG5vLnBlcmNlbnRTdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFic3RhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWJzdGFpbiA9IHBvbGwuZ2V0Vm90ZShwb2xsLmFic3RhaW4sICdhYnN0YWluJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uMS5wdXNoKGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQWJzdGFpbicpICsgJzonKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4yLnB1c2goJGZpbHRlcignbnVtYmVyJykoYWJzdGFpbi52YWx1ZSwgcHJlY2lzaW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uMy5wdXNoKGFic3RhaW4ucGVyY2VudFN0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdm90ZXMgdmFsaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9sbC52b3Rlc3ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZCA9IHBvbGwuZ2V0Vm90ZShwb2xsLnZvdGVzdmFsaWQsICd2b3Rlc3ZhbGlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjEucHVzaChnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1ZhbGlkIHZvdGVzJykgKyAnOicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4yLnB1c2goJGZpbHRlcignbnVtYmVyJykodmFsaWQudmFsdWUsIHByZWNpc2lvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4zLnB1c2godmFsaWQucGVyY2VudFN0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZvdGVzIGludmFsaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9sbC52b3Rlc3ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnZhbGlkID0gcG9sbC5nZXRWb3RlKHBvbGwudm90ZXNpbnZhbGlkLCAndm90ZXNpbnZhbGlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjEucHVzaChnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0ludmFsaWQgdm90ZXMnKSArICc6Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjIucHVzaCgkZmlsdGVyKCdudW1iZXInKShpbnZhbGlkLnZhbHVlLCBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uMy5wdXNoKGludmFsaWQucGVyY2VudFN0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZvdGVzIGNhc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9sbC52b3Rlc2Nhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhc3QgPSBwb2xsLmdldFZvdGUocG9sbC52b3Rlc2Nhc3QsICd2b3Rlc2Nhc3QnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uMS5wdXNoKGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnVm90ZXMgY2FzdCcpICsgJzonKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uMi5wdXNoKCRmaWx0ZXIoJ251bWJlcicpKGNhc3QudmFsdWUsIHByZWNpc2lvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4zLnB1c2goY2FzdC5wZXJjZW50U3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBtZXRhVGFibGVCb2R5LnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnVm90aW5nIHJlc3VsdCcpICsgJzonLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBbJ2JvbGQnLCAnZ3JleSddXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY29sdW1uMS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnYXV0bydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY29sdW1uMi5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6ICdyaWdodCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY29sdW1uMy5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6ICdyaWdodCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkdhcDogNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2dyZXknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHN1bW1hcnkgb2YgY2hhbmdlIHJlY29tbWVuZGF0aW9ucyAoZm9yIG1vdGlvbiBkaWZmIHZlcnNpb24gb25seSlcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmNoYW5nZVJlY29tbWVuZGF0aW9uTW9kZSA9PT0gJ2RpZmYnICYmIG1vdGlvbi5jaGFuZ2VSZWNvbW1lbmRhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5MaW5lTnVtYmVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uQ2hhbmdlVHlwZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goXy5vcmRlckJ5KG1vdGlvbi5jaGFuZ2VSZWNvbW1lbmRhdGlvbnMsIFsnbGluZV9mcm9tJ10pLCBmdW5jdGlvbihjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UuaXNUaXRsZVJlY29tbWVuZGF0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5MaW5lTnVtYmVycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1RpdGxlJykgKyAnOiAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGluZSBudW1iZXJzIGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UubGluZV9mcm9tID49IGNoYW5nZS5saW5lX3RvIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gY2hhbmdlLmxpbmVfZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gY2hhbmdlLmxpbmVfZnJvbSArICcgLSAnICsgKGNoYW5nZS5saW5lX3RvIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkxpbmVOdW1iZXJzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnTGluZScpICsgJyAnICsgbGluZSArICc6ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHR5cGUgY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLmdldFR5cGUobW90aW9uLmdldFZlcnNpb24obW90aW9uVmVyc2lvbikudGV4dCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5DaGFuZ2VUeXBlLnB1c2goZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKFwiUmVwbGFjZW1lbnRcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2UuZ2V0VHlwZShtb3Rpb24uZ2V0VmVyc2lvbihtb3Rpb25WZXJzaW9uKS50ZXh0KSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkNoYW5nZVR5cGUucHVzaChnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoXCJJbnNlcnRpb25cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2UuZ2V0VHlwZShtb3Rpb24uZ2V0VmVyc2lvbihtb3Rpb25WZXJzaW9uKS50ZXh0KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkNoYW5nZVR5cGUucHVzaChnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoXCJEZWxldGlvblwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZS5nZXRUeXBlKG1vdGlvbi5nZXRWZXJzaW9uKG1vdGlvblZlcnNpb24pLnRleHQpID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uQ2hhbmdlVHlwZS5wdXNoKGNoYW5nZS5vdGhlcl9kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBtZXRhVGFibGVCb2R5LnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnU3VtbWFyeSBvZiBjaGFuZ2UgcmVjb21tZW5kYXRpb25zJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFsnYm9sZCcsICdncmV5J11cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb2x1bW5MaW5lTnVtYmVycy5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnYXV0bydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY29sdW1uQ2hhbmdlVHlwZS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnYXV0bydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uR2FwOiA3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnZ3JleSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1ldGFUYWJsZUJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1aWxkIHRhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZWQgcGxhY2Vob2xkZXIgZm9yICdsYXlvdXQnIGZ1bmN0aW9ucyB3aGljaGUgYXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2VkIGJ5IGxpbmVXaXRkaC9saW5lQ29sb3IgZnVuY3Rpb24gaW4gcGZkLXdvcmtlci5qcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHBsYWNlaG9sZGVyIGFuZCB1cyBzdGF0aWMgdmFsdWVzIGZvciBMaW5lV2lkdGggYW5kIExpbmVDb2xvclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBwZGZtYWtlIGhhcyBmaXhlZCB0aGlzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0YVRhYmxlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aHM6IFsnMzUlJywnNjUlJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogbWV0YVRhYmxlQm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFswLCAwLCAwLCAyMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6ICd7e21vdGlvbi1wbGFjZWhvbGRlci10by1pbnNlcnQtZnVuY3Rpb25zLWhlcmV9fSdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmluY2x1ZGUubWV0YXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFUYWJsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gbW90aW9uIHRpdGxlXG4gICAgICAgICAgICB2YXIgbW90aW9uVGl0bGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmluY2x1ZGUubWV0YXRhYmxlICYmIHBhcmFtcy5pbmNsdWRlLnRleHQgJiYgIW1vdGlvbi5pc1BhcmFncmFwaEJhc2VkQW1lbmRtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aXRsZVBsYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdoZWFkaW5nMydcbiAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIG1vdGlvbiBwcmVhbWJsZVxuICAgICAgICAgICAgdmFyIG1vdGlvblByZWFtYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IENvbmZpZy50cmFuc2xhdGUoQ29uZmlnLmdldCgnbW90aW9uc19wcmVhbWJsZScpLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMCwgMTAsIDAsIDBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBlc2NhcGVIdG1sID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLyYvLCAnJmFtcDsnKS5yZXBsYWNlKC88LywgJyZsdDsnKS5yZXBsYWNlKC8+LywgJyZndDsnKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIG1vdGlvbiB0ZXh0ICh3aXRoIGxpbmUtbnVtYmVycylcbiAgICAgICAgICAgIHZhciBtb3Rpb25UZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmluY2x1ZGUudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW90aW9uVGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdGlvbi5pc1BhcmFncmFwaEJhc2VkQW1lbmRtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcmFncmFwaCBiYXNlZCBhbWVuZG1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWZmcyA9IG1vdGlvbi5nZXRBbWVuZG1lbnRQYXJhZ3JhcGhzTGluZXNEaWZmKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKG1vdGlvblByZWFtYmxlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChkaWZmcywgZnVuY3Rpb24gKGRpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uVGV4dENvbnRlbnQgKz0gZGlmZi50ZXh0UHJlICsgZGlmZi50ZXh0ICsgZGlmZi50ZXh0UG9zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uVGV4dENvbnRlbnQgKz0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdObyBjaGFuZ2VzIGF0IHRoZSB0ZXh0LicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVhZCBtb3Rpb24gb3Igbm9ybWFsIGFtZW5kbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKG1vdGlvblByZWFtYmxlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpdGxlQ2hhbmdlID0gbW90aW9uLmdldFRpdGxlQ2hhbmdlUmVjb21tZW5kYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuY2hhbmdlUmVjb21tZW5kYXRpb25Nb2RlID09PSAnZGlmZicgJiYgdGl0bGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb25UZXh0Q29udGVudCArPSAnPHA+PHN0cm9uZz4nICsgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdOZXcgdGl0bGUnKSArICc6PC9zdHJvbmc+ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVIdG1sKHRpdGxlQ2hhbmdlLnRleHQpICsgJzwvcD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uVGV4dENvbnRlbnQgKz0gbW90aW9uLmdldFRleHRCeU1vZGUocGFyYW1zLmNoYW5nZVJlY29tbWVuZGF0aW9uTW9kZSwgbW90aW9uVmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGNvbnZlcnRlci5jb252ZXJ0SFRNTChtb3Rpb25UZXh0Q29udGVudCwgcGFyYW1zLmxpbmVOdW1iZXJNb2RlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gbW90aW9uIHJlYXNvbiBoZWFkaW5nXG4gICAgICAgICAgICB2YXIgbW90aW9uUmVhc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5pbmNsdWRlLnJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhc29uID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3Rpb24uZ2V0UmVhc29uKG1vdGlvblZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb24ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogIGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnUmVhc29uJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdoZWFkaW5nMycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAyNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5saW5lTnVtYmVyTW9kZSA9PSAnb3V0c2lkZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9ICc4MCUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiBjb252ZXJ0ZXIuY29udmVydEhUTUwobW90aW9uLmdldFJlYXNvbihtb3Rpb25WZXJzaW9uKSwgJ25vbmUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIG1vdGlvbiBjb21tZW50cyBoYW5kbGluZ1xuICAgICAgICAgICAgdmFyIG1vdGlvbkNvbW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfLmtleXMocGFyYW1zLmluY2x1ZGVDb21tZW50cykubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZHMgPSBNb3Rpb25Db21tZW50LmdldE5vU3BlY2lhbENvbW1lbnRzRmllbGRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2gocGFyYW1zLmluY2x1ZGVDb21tZW50cywgZnVuY3Rpb24gKG9rLCBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9rICYmIG1vdGlvbi5jb21tZW50c1tpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBmaWVsZHNbaWRdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZHNbaWRdLnB1YmxpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSArPSAnICgnICsgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdpbnRlcm5hbCcpICsgJyknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnaGVhZGluZzMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDI1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goY29udmVydGVyLmNvbnZlcnRIVE1MKG1vdGlvbi5jb21tZW50c1tpZF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tZW50cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZXMgY29udGVudCBhcyBhIHBkZm1ha2UgY29uc3VtYWJsZVxuICAgICAgICAgICAgdmFyIGdldENvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBtZXRhVGFibGUoKSxcbiAgICAgICAgICAgICAgICAgICAgbW90aW9uVGl0bGUoKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuY29uY2F0KG1vdGlvblRleHQoKSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVhc29uID0gbW90aW9uUmVhc29uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2gocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnRzID0gbW90aW9uQ29tbWVudHMoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGNvbW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBnZXR0ZXJzXG4gICAgICAgICAgICB2YXIgZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW90aW9uLmdldFRpdGxlKG1vdGlvblZlcnNpb24pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldElkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW90aW9uLmlkZW50aWZpZXIgPyBtb3Rpb24uaWRlbnRpZmllciA6ICcnO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldElkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vdGlvbi5pZDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBnZXRDYXRlZ29yeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb3Rpb24uY2F0ZWdvcnk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZ2V0SW1hZ2VNYXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VNYXA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gJHEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIEltYWdlQ29udmVydGVyLnRvQmFzZTY0KGdldEltYWdlU291cmNlcygpKS50aGVuKGZ1bmN0aW9uIChfaW1hZ2VNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VNYXAgPSBfaW1hZ2VNYXA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRlciA9IFBkZk1ha2VDb252ZXJ0ZXIuY3JlYXRlSW5zdGFuY2UoX2ltYWdlTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb250ZW50OiBnZXRDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VGl0bGU6IGdldFRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SWRlbnRpZmllcjogZ2V0SWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldElkOiBnZXRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENhdGVnb3J5OiBnZXRDYXRlZ29yeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEltYWdlTWFwOiBnZXRJbWFnZU1hcCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVJbnN0YW5jZTogY3JlYXRlSW5zdGFuY2VcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnTW90aW9uUGFydGlhbENvbnRlbnRQcm92aWRlcicsIFtcbiAgICAnJHEnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0NvbmZpZycsXG4gICAgJ1BERkxheW91dCcsXG4gICAgJ1BkZk1ha2VDb252ZXJ0ZXInLFxuICAgICdJbWFnZUNvbnZlcnRlcicsXG4gICAgJ0hUTUxWYWxpZGl6ZXInLFxuICAgIGZ1bmN0aW9uICgkcSwgZ2V0dGV4dENhdGFsb2csIENvbmZpZywgUERGTGF5b3V0LCBQZGZNYWtlQ29udmVydGVyLCBJbWFnZUNvbnZlcnRlciwgSFRNTFZhbGlkaXplcikge1xuICAgICAgICAvKlxuICAgICAgICAgKiBjb250ZW50IHNob3VsZCBiZSBhbiBhcnJheSBvZiBjb250ZW50IGJsb2Nrcy4gRWFjaCBjb250ZW50IGlzIGFuIG9iamVjdCBwcm92aWRpbmcgYVxuICAgICAgICAgKiBoZWFkaW5nIGFuZCBhIHRleHQuIEUuZy5cbiAgICAgICAgICogW3toZWFkaW5nOiAnY29tbWVudDEnLCB0ZXh0OiAnPGh0bWwgaW4gaGVyZT4nfSwge2hlYWRpbmc6IC4uLn0sIC4uLl1cbiAgICAgICAgICogKi9cbiAgICAgICAgdmFyIGNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24gKG1vdGlvbiwgY29udGVudCkge1xuXG4gICAgICAgICAgICB2YXIgY29udmVydGVyLCBpbWFnZU1hcCA9IHt9O1xuXG4gICAgICAgICAgICAvLyBRdWVyeSBhbGwgaW1hZ2Ugc291cmNlcyBmcm9tIHRoZSBjb250ZW50XG4gICAgICAgICAgICB2YXIgZ2V0SW1hZ2VTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbWFnZVNvdXJjZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goY29udGVudCwgZnVuY3Rpb24gKGNvbnRlbnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IEhUTUxWYWxpZGl6ZXIudmFsaWRpemUoY29udGVudEJsb2NrLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZVNvdXJjZXMgPSBpbWFnZVNvdXJjZXMuY29uY2F0KF8ubWFwKCQoaHRtbCkuZmluZCgnaW1nJyksIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VTb3VyY2VzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gdGl0bGVcbiAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gbW90aW9uLmlkZW50aWZpZXIgPyAnICcgKyBtb3Rpb24uaWRlbnRpZmllciA6ICcnO1xuICAgICAgICAgICAgdmFyIHRpdGxlID0gUERGTGF5b3V0LmNyZWF0ZVRpdGxlKFxuICAgICAgICAgICAgICAgICAgICBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ01vdGlvbicpICsgaWRlbnRpZmllciArICc6ICcgKyBtb3Rpb24uZ2V0VGl0bGUoKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gc3VidGl0bGUgYW5kIHNlcXVlbnRpYWwgbnVtYmVyXG4gICAgICAgICAgICB2YXIgc3VidGl0bGVMaW5lcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG1vdGlvbi5wYXJlbnRfaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50TW90aW9uID0gTW90aW9uLmdldChtb3Rpb24ucGFyZW50X2lkKTtcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZUxpbmVzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQW1lbmRtZW50IHRvIG1vdGlvbicpICsgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIChwYXJlbnRNb3Rpb24uaWRlbnRpZmllciA/IHBhcmVudE1vdGlvbi5pZGVudGlmaWVyIDogcGFyZW50TW90aW9uLmdldFRpdGxlKCkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChDb25maWcuZ2V0KCdtb3Rpb25zX2V4cG9ydF9zZXF1ZW50aWFsX251bWJlcicpLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc3VidGl0bGVMaW5lcy5wdXNoKGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnU2VxdWVudGlhbCBudW1iZXInKSArICc6ICcgKyAgbW90aW9uLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdWJ0aXRsZSA9IFBERkxheW91dC5jcmVhdGVTdWJ0aXRsZShzdWJ0aXRsZUxpbmVzKTtcblxuICAgICAgICAgICAgLy8gbWV0YSBkYXRhIHRhYmxlXG4gICAgICAgICAgICB2YXIgbWV0YVRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1ldGFUYWJsZUJvZHkgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIHN1Ym1pdHRlcnNcbiAgICAgICAgICAgICAgICB2YXIgc3VibWl0dGVycyA9IF8ubWFwKG1vdGlvbi5zdWJtaXR0ZXJzLCBmdW5jdGlvbiAoc3VibWl0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJtaXR0ZXIudXNlci5nZXRfZnVsbF9uYW1lKCk7XG4gICAgICAgICAgICAgICAgfSkuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICBtZXRhVGFibGVCb2R5LnB1c2goW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1N1Ym1pdHRlcnMnKSArICc6JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBbJ2JvbGQnLCAnZ3JleSddLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzdWJtaXR0ZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdncmV5J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBzdGF0ZVxuICAgICAgICAgICAgICAgIG1ldGFUYWJsZUJvZHkucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnU3RhdGUnKSArICc6JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBbJ2JvbGQnLCAnZ3JleSddXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG1vdGlvbi5nZXRTdGF0ZU5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnZ3JleSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVjb21tZW5kYXRpb25cbiAgICAgICAgICAgICAgICBpZiAobW90aW9uLmdldFJlY29tbWVuZGF0aW9uTmFtZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFUYWJsZUJvZHkucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogQ29uZmlnLmdldCgnbW90aW9uc19yZWNvbW1lbmRhdGlvbnNfYnknKS52YWx1ZSArICc6JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogWydib2xkJywgJ2dyZXknXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBtb3Rpb24uZ2V0UmVjb21tZW5kYXRpb25OYW1lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdncmV5J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjYXRlZ29yeVxuICAgICAgICAgICAgICAgIGlmIChtb3Rpb24uY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVRhYmxlQm9keS5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0NhdGVnb3J5JykgKyAnOicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFsnYm9sZCcsICdncmV5J10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBtb3Rpb24uY2F0ZWdvcnkucHJlZml4ICsgJyAtICcgKyBtb3Rpb24uY2F0ZWdvcnkubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2dyZXknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGJ1aWxkIHRhYmxlXG4gICAgICAgICAgICAgICAgLy8gVXNlZCBwbGFjZWhvbGRlciBmb3IgJ2xheW91dCcgZnVuY3Rpb25zIHdoaWNoZSBhcmVcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlZCBieSBsaW5lV2l0ZGgvbGluZUNvbG9yIGZ1bmN0aW9uIGluIHBmZC13b3JrZXIuanMuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHBsYWNlaG9sZGVyIGFuZCB1cyBzdGF0aWMgdmFsdWVzIGZvciBMaW5lV2lkdGggYW5kIExpbmVDb2xvclxuICAgICAgICAgICAgICAgIC8vIGlmIHBkZm1ha2UgaGFzIGZpeGVkIHRoaXMuXG4gICAgICAgICAgICAgICAgdmFyIG1ldGFUYWJsZUpzb25TdHJpbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aHM6IFsnMzAlJywnNzAlJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBtZXRhVGFibGVCb2R5LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFswLCAwLCAwLCAyMF0sXG4gICAgICAgICAgICAgICAgICAgIGxheW91dDogJ3t7bW90aW9uLXBsYWNlaG9sZGVyLXRvLWluc2VydC1mdW5jdGlvbnMtaGVyZX19J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFUYWJsZUpzb25TdHJpbmc7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZ2V0Q29udGVudEJsb2NrRGF0YSA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gW107XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogIGJsb2NrLmhlYWRpbmcsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnaGVhZGluZzMnLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDI1LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChjb252ZXJ0ZXIuY29udmVydEhUTUwoYmxvY2sudGV4dCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gR2VuZXJhdGVzIGNvbnRlbnQgYXMgYSBwZGZtYWtlIGNvbnN1bWFibGVcbiAgICAgICAgICAgIHZhciBnZXRDb250ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBkZkNvbnRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgbWV0YVRhYmxlKCksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goY29udGVudCwgZnVuY3Rpb24gKGNvbnRlbnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBwZGZDb250ZW50LnB1c2goZ2V0Q29udGVudEJsb2NrRGF0YShjb250ZW50QmxvY2spKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGRmQ29udGVudDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBnZXRJbWFnZU1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VNYXA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gJHEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIEltYWdlQ29udmVydGVyLnRvQmFzZTY0KGdldEltYWdlU291cmNlcygpKS50aGVuKGZ1bmN0aW9uIChfaW1hZ2VNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VNYXAgPSBfaW1hZ2VNYXA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRlciA9IFBkZk1ha2VDb252ZXJ0ZXIuY3JlYXRlSW5zdGFuY2UoX2ltYWdlTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb250ZW50OiBnZXRDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SW1hZ2VNYXA6IGdldEltYWdlTWFwLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZUluc3RhbmNlOiBjcmVhdGVJbnN0YW5jZVxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdQb2xsQ29udGVudFByb3ZpZGVyJywgW1xuICAgICckcScsXG4gICAgJ1BERkxheW91dCcsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnQ29uZmlnJyxcbiAgICAnVXNlcicsXG4gICAgJ0ltYWdlQ29udmVydGVyJyxcbiAgICBmdW5jdGlvbigkcSwgUERGTGF5b3V0LCBnZXR0ZXh0Q2F0YWxvZywgQ29uZmlnLCBVc2VyLCBJbWFnZUNvbnZlcnRlcikge1xuICAgICAgICAvKipcbiAgICAgICAgKiBHZW5lcmF0ZXMgYSBjb250ZW50IHByb3ZpZGVyIGZvciBwb2xsc1xuICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSAtIHRpdGxlIG9mIHBvbGxcbiAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBpZiBvZiBwb2xsXG4gICAgICAgICovXG4gICAgICAgIHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uKHRpdGxlLCBpZCkge1xuXG4gICAgICAgICAgICB2YXIgbG9nb0JhbGxvdFBhcGVyVXJsID0gQ29uZmlnLmdldCgnbG9nb19wZGZfYmFsbG90X3BhcGVyJykudmFsdWUucGF0aDtcbiAgICAgICAgICAgIHZhciBpbWFnZU1hcCA9IHt9O1xuXG4gICAgICAgICAgICAvLyBQREYgaGVhZGVyXG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gQ29uZmlnLmdldCgnZ2VuZXJhbF9ldmVudF9uYW1lJykudmFsdWU7XG4gICAgICAgICAgICAgICAgY29sdW1ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDgsXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudDogJ2xlZnQnLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzYwJSdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGxvZ29cbiAgICAgICAgICAgICAgICBpZiAobG9nb0JhbGxvdFBhcGVyVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogbG9nb0JhbGxvdFBhcGVyVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZml0OiBbOTAsMjVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50OiAncmlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICc0MCUnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyM1NTUnLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMTAsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogWzMwLCAxMCwgMTAsIC0xMF0sIC8vIFtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21dXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IGNvbHVtbnMsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkdhcDogNVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogUmV0dXJucyBhIHNpbmdsZSBzZWN0aW9uIG9uIHRoZSBiYWxsb3QgcGFwZXJcbiAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGNyZWF0ZVNlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hlZXRlbmQgPSA0MDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGFjazogW1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdNb3Rpb24nKSArICcgJyArIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndGl0bGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2Rlc2NyaXB0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFBERkxheW91dC5jcmVhdGVCYWxsb3RFbnRyeShnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1llcycpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFBERkxheW91dC5jcmVhdGVCYWxsb3RFbnRyeShnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ05vJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUERGTGF5b3V0LmNyZWF0ZUJhbGxvdEVudHJ5KGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQWJzdGFpbicpKSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMCwgMCwgMCwgc2hlZXRlbmRdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogUmV0dXJucyBDb250ZW50IGZvciBzaW5nbGUgbW90aW9uXG4gICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBpZiBvZiBwb2xsXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGdldENvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhbW91bnQ7XG4gICAgICAgICAgICAgICAgdmFyIGFtb3VudF9tZXRob2QgPSBDb25maWcuZ2V0KCdtb3Rpb25zX3BkZl9iYWxsb3RfcGFwZXJzX3NlbGVjdGlvbicpLnZhbHVlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYW1vdW50X21ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnTlVNQkVSX09GX0FMTF9QQVJUSUNJUEFOVFMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudCA9IFVzZXIuZ2V0QWxsKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnTlVNQkVSX09GX0RFTEVHQVRFUyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBhc3N1bXB0aW9uIHRoYXQgREVMRUdBVEVTIGlzIGFsd2F5cyBncm91cCBpZCAyLiBUaGlzIG1heSBub3QgYmUgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cF9pZCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50ID0gVXNlci5maWx0ZXIoe3doZXJlOiB7J2dyb3Vwc19pZCc6IHtjb250YWluczpncm91cF9pZH0gfX0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NVU1RPTV9OVU1CRVInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudCA9IENvbmZpZy5nZXQoJ21vdGlvbnNfcGRmX2JhbGxvdF9wYXBlcnNfbnVtYmVyJykudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBub3QgaGFwcGVuLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmdWxscGFnZXMgPSBNYXRoLmZsb29yKGFtb3VudCAvIDgpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgZnVsbHBhZ2VzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyUm93czogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aHM6IFsnKicsICcqJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY3JlYXRlU2VjdGlvbigpLCBjcmVhdGVTZWN0aW9uKCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY3JlYXRlU2VjdGlvbigpLCBjcmVhdGVTZWN0aW9uKCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY3JlYXRlU2VjdGlvbigpLCBjcmVhdGVTZWN0aW9uKCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY3JlYXRlU2VjdGlvbigpLCBjcmVhdGVTZWN0aW9uKCldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlQnJlYWs6ICdhZnRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6IFBERkxheW91dC5nZXRCYWxsb3RMYXlvdXRMaW5lcygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93c3BlcnBhZ2U6IDRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFtb3VudCA9IGFtb3VudCAgLSAoZnVsbHBhZ2VzICogOCk7XG4gICAgICAgICAgICAgICAgaWYgKGFtb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxwYWdlYm9keSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYW1vdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbHBhZ2Vib2R5LnB1c2goW2NyZWF0ZVNlY3Rpb24oKSwgY3JlYXRlU2VjdGlvbigpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbW91bnQgLT0yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbW91bnQgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbHBhZ2Vib2R5LnB1c2goW2NyZWF0ZVNlY3Rpb24oKSwgJyddKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJSb3dzOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoczogWyc1MCUnLCAnNTAlJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogcGFydGlhbHBhZ2Vib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0OiBQREZMYXlvdXQuZ2V0QmFsbG90TGF5b3V0TGluZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3NwZXJwYWdlOiA0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBnZXRJbWFnZU1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VNYXA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gJHEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBpbWFnZVNvdXJjZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIGxvZ29CYWxsb3RQYXBlclVybCxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIEltYWdlQ29udmVydGVyLnRvQmFzZTY0KGltYWdlU291cmNlcykudGhlbihmdW5jdGlvbiAoX2ltYWdlTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlTWFwID0gX2ltYWdlTWFwO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbnRlbnQ6IGdldENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRJbWFnZU1hcDogZ2V0SW1hZ2VNYXAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZUluc3RhbmNlOiBjcmVhdGVJbnN0YW5jZVxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdNb3Rpb25DYXRhbG9nQ29udGVudFByb3ZpZGVyJywgW1xuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ1BERkxheW91dCcsXG4gICAgJ0NhdGVnb3J5JyxcbiAgICAnQ29uZmlnJyxcbiAgICBmdW5jdGlvbihnZXR0ZXh0Q2F0YWxvZywgUERGTGF5b3V0LCBDYXRlZ29yeSwgQ29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAqIENvbnN0cnVjdG9yXG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQHBhcmFtIHtvYmplY3R9IGFsbE1vdGlvbnMgLSBBIHNvcnRlZCBhcnJheSBvZiBhbGwgbW90aW9ucyB0byBwYXJzZVxuICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0aW5nIC0gVGhlIHdheSB0aGUgY2F0YWxvZyBoYXMgYmVlbiBzb3J0ZWQuIE5lY2Vzc2FyeSBmb3IgVG9DXG4gICAgICAgICovXG4gICAgICAgIHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uKGFsbE1vdGlvbnMsIHNvcnRpbmcpIHtcblxuICAgICAgICAgICAgdmFyIHRpdGxlID0gUERGTGF5b3V0LmNyZWF0ZVRpdGxlKFxuICAgICAgICAgICAgICAgIENvbmZpZy50cmFuc2xhdGUoQ29uZmlnLmdldCgnbW90aW9uc19leHBvcnRfdGl0bGUnKS52YWx1ZSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBjcmVhdGVQcmVhbWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmVhbWJsZVRleHQgPSBDb25maWcuZ2V0KCdtb3Rpb25zX2V4cG9ydF9wcmVhbWJsZScpLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChwcmVhbWJsZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHByZWFtYmxlVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcInByZWFtYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY3JlYXRlVE9Db250ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvYyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBleHBvcnRDYXRlZ29yeSA9IChzb3J0aW5nID09PSAnaWRlbnRpZmllcicgfHwgc29ydGluZyA9PT0gJ2NhdGVnb3J5LnByZWZpeCcpO1xuICAgICAgICAgICAgICAgIHZhciB1bmlxdWVDYXRlZ29yaWVzID0gZ2V0VW5pcXVlQ2F0ZWdvcmllcygpO1xuICAgICAgICAgICAgICAgIHZhciB0b2NUaXRsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdUYWJsZSBvZiBjb250ZW50cycpLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2hlYWRpbmcyJ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBhbGwgbW90aW9ucyBuZWVkIGEgcGFnZSBJRC4gV2UgdXNlIHRoZSBtb3Rpb24gaWRlbnRpZmllciBmb3IgdGhhdFxuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChhbGxNb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdGlvbi5nZXRDb250ZW50KClbMF0uaWQgPSAnJyttb3Rpb24uZ2V0SWQoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChleHBvcnRDYXRlZ29yeSAmJiB1bmlxdWVDYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG93biB0YWJsZSBwZXIgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhdFRvY0JvZHkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKHVuaXF1ZUNhdGVnb3JpZXMsIGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB0aGUgbmFtZSBvZiB0aGUgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYSB0YWJsZSBmb3IgY29ycmVjdCBhbGlnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdFRvY0JvZHkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2F0ZWdvcnkucHJlZml4ICsgJyAtICcgKyBjYXRlZ29yeS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3RvY0NhdGVnb3J5VGl0bGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0OiAnbm9Cb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9jQm9keSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGFsbE1vdGlvbnMsIGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW90aW9uLmdldENhdGVnb3J5KCkgJiYgY2F0ZWdvcnkubmFtZSA9PT0gbW90aW9uLmdldENhdGVnb3J5KCkubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2NCb2R5LnB1c2godG9jTGluZShtb3Rpb24sICd0b2NDYXRlZ29yeUVudHJ5JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2F0VG9jQm9keS5wdXNoKHRvY1RhYmxlKHRvY0JvZHkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9oYW5kbGUgdGhvdXNlIHdpdGhvdXQgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVuY2F0VG9jQm9keSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goYWxsTW90aW9ucywgZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb3Rpb24uZ2V0Q2F0ZWdvcnkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2F0VG9jQm9keS5wdXNoKHRvY0xpbmUobW90aW9uLCAndG9jRW50cnknKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgcHVzaCB0aGlzIGFycmF5IGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBlbnRyeVxuICAgICAgICAgICAgICAgICAgICBpZiAodW5jYXRUb2NCb2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdFRvY0JvZHkucHVzaCh0b2NUYWJsZSh1bmNhdFRvY0JvZHkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRvYy5wdXNoKGNhdFRvY0JvZHkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBjYXRlZ29yaWVzIGluIHRoZSBzYW1lIHRhYmxlXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2NCb2R5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChhbGxNb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2NCb2R5LnB1c2godG9jTGluZShtb3Rpb24sICd0b2NFbnRyeScpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRvYy5wdXNoKHRvY1RhYmxlKHRvY0JvZHkpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0b2NUaXRsZSxcbiAgICAgICAgICAgICAgICAgICAgdG9jLFxuICAgICAgICAgICAgICAgICAgICBQREZMYXlvdXQuYWRkUGFnZUJyZWFrKClcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlcyBhIG5ldyB0YWJsZSBvZiBjb250ZW50cyB0YWJsZSBib2R5XG4gICAgICAgICAgICB2YXIgdG9jVGFibGUgPSBmdW5jdGlvbiAodG9jQm9keSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aHM6IFsnYXV0bycsICcqJywgJ2F1dG8nXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHRvY0JvZHlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0OiAnbm9Cb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICd0b2NDYXRlZ29yeVNlY3Rpb24nXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGdlbmVyYXRlcyBhIGxpbmUgaW4gdGhlIHRvYyBhcyBsaXN0LW9iamVjdFxuICAgICAgICAgICAgdmFyIHRvY0xpbmUgPSBmdW5jdGlvbiAobW90aW9uLCBzdHlsZSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdENvbHVtbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKG1vdGlvbi5nZXRJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDb2x1bW4gPSBtb3Rpb24uZ2V0SWRlbnRpZmllcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBmaXJzdENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBtb3Rpb24uZ2V0VGl0bGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndG9jRW50cnknXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VSZWZlcmVuY2U6ICcnK21vdGlvbi5nZXRJZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICd0b2NFbnRyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6ICdyaWdodCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gcmV0dXJucyBhIGxpc3Qgb2YgdW5pcXVlIGNhdGVnb3J5IG5hbWVzXG4gICAgICAgICAgICAvLyBuZWNlc3NhcnkgdG8gY3JlYXRlIGEgVG9DIHdpdGggY2F0ZWdvcmllc1xuICAgICAgICAgICAgLy8gaWYgYSBtb3Rpb25zIHdpdGhvdXQgY2F0ZWdvcnkgaXMgZm91bmQsXG4gICAgICAgICAgICAvLyBhIGNvcnJlc3BvbmRpbmcgZW50cnkgc2hvdWxkIGJlIGFkZGVkIGFzd2VsbFxuICAgICAgICAgICAgdmFyIGdldFVuaXF1ZUNhdGVnb3JpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChhbGxNb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3Rpb24uZ2V0Q2F0ZWdvcnkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbW90aW9uLmdldENhdGVnb3J5KCkubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBtb3Rpb24uZ2V0Q2F0ZWdvcnkoKS5wcmVmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8udW5pcUJ5KGNhdGVnb3JpZXMsICduYW1lJyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyByZXR1cm5zIHRoZSBwdXJlIGNvbnRlbnQgb2YgdGhlIG1vdGlvbiwgcGFyc2VhYmxlIGJ5IHBkZm1ha2VcbiAgICAgICAgICAgIHZhciBnZXRDb250ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vdGlvbkNvbnRlbnQgPSBbXTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goYWxsTW90aW9ucywgZnVuY3Rpb24obW90aW9uLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW90aW9uQ29udGVudC5wdXNoKG1vdGlvbi5nZXRDb250ZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IDwgYWxsTW90aW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb25Db250ZW50LnB1c2goUERGTGF5b3V0LmFkZFBhZ2VCcmVhaygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gW107XG4gICAgICAgICAgICAgICAgLy8gcHJpbnQgZXh0cmEgZGF0YSAodGl0bGUsIHByZWFtYmxlLCBjYXRlZ29yaWVzLCB0b2MpIG9ubHkgZm9yIG1vcmUgdGhhbiAxIG1vdGlvblxuICAgICAgICAgICAgICAgIGlmIChhbGxNb3Rpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVQcmVhbWJsZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlVE9Db250ZW50KClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKG1vdGlvbkNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldEltYWdlTWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbWFnZU1hcCA9IHt9O1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChhbGxNb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChtb3Rpb24uZ2V0SW1hZ2VNYXAoKSwgZnVuY3Rpb24gKGRhdGEsIHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2VNYXBbcGF0aF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU1hcFtwYXRoXSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbWFnZU1hcDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2V0Q29udGVudDogZ2V0Q29udGVudCxcbiAgICAgICAgICAgICAgICBnZXRJbWFnZU1hcDogZ2V0SW1hZ2VNYXAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVJbnN0YW5jZTogY3JlYXRlSW5zdGFuY2VcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnQW1lbmRtZW50Q29udGVudFByb3ZpZGVyJywgW1xuICAgICckcScsXG4gICAgJ0ltYWdlQ29udmVydGVyJyxcbiAgICAnUGRmTWFrZUNvbnZlcnRlcicsXG4gICAgJ0hUTUxWYWxpZGl6ZXInLFxuICAgICdQREZMYXlvdXQnLFxuICAgICdDb25maWcnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgZnVuY3Rpb24gKCRxLCBJbWFnZUNvbnZlcnRlciwgUGRmTWFrZUNvbnZlcnRlciwgSFRNTFZhbGlkaXplciwgUERGTGF5b3V0LCBDb25maWcsIGdldHRleHRDYXRhbG9nKSB7XG4gICAgICAgIHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uIChtb3Rpb25zKSB7XG4gICAgICAgICAgICBtb3Rpb25zID0gXy5maWx0ZXIobW90aW9ucywgZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb3Rpb24ucGFyZW50X2lkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBjb252ZXJ0ZXIsIGltYWdlTWFwID0ge307XG5cbiAgICAgICAgICAgIC8vIFF1ZXJ5IGFsbCBpbWFnZSBzb3VyY2VzIGZyb20gbW90aW9uIHRleHQgYW5kIHJlYXNvblxuICAgICAgICAgICAgdmFyIGdldEltYWdlU291cmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChtb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gbW90aW9uLmdldFRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IG1vdGlvbi5nZXRSZWFzb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBIVE1MVmFsaWRpemVyLnZhbGlkaXplKHRleHQpICsgSFRNTFZhbGlkaXplci52YWxpZGl6ZShtb3Rpb24uZ2V0UmVhc29uKCkpO1xuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goJChjb250ZW50KS5maW5kKCdpbWcnKSwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZXMucHVzaChlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3JjJykpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy51bmlxKHNvdXJjZXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNyZWF0ZUJ1bmRsZUNvbnRlbnQgPSBmdW5jdGlvbiAoYnVuZGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uZmxhdHRlbihfLm1hcChidW5kbGUsIGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgZGlmZnMgYW5kIHRpdGxlIG9mIHRoZSBjaGFuZ2VkIG1vdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdGlvblRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IG1vdGlvbi5pZGVudGlmaWVyID8gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdNb3Rpb24nKSArICcgJyArIG1vdGlvbi5pZGVudGlmaWVyIDogbW90aW9uLmdldFRpdGxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3Rpb24uaXNQYXJhZ3JhcGhCYXNlZEFtZW5kbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgY2hhbmdlZCBwYXJ0c1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFncmFwaHMgPSBtb3Rpb24uZ2V0QW1lbmRtZW50UGFyYWdyYXBoc0xpbmVzRGlmZigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFncmFwaHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHV0IHRoZSBjaGFuZ2VkIGxpbmVzIGludG8gdGhlIGluZm8gY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwYXJhZ3JhcGhzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlICs9ICcgKCcgKyBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0xpbmUnKSArICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5kaWZmTGluZVRvID09PSBwLmRpZmZMaW5lRnJvbSArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgKz0gcC5kaWZmTGluZUZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgKz0gcC5kaWZmTGluZUZyb20gKyAnLScgKyBwLmRpZmZMaW5lVG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlICs9ICcpJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgZGlmZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvblRleHQgPSBwLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvblRleHQgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ05vIGNoYW5nZXMgYXQgdGhlIHRleHQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vICdub3JtYWwnIGFtZW5kbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uVGV4dCA9IG1vdGlvbi5nZXRUZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdoZWFkaW5nMycsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDE1LFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzdWJtaXR0ZXJzXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJtaXR0ZXJzID0gXy5tYXAobW90aW9uLnN1Ym1pdHRlcnMsIGZ1bmN0aW9uIChzdWJtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJtaXR0ZXIudXNlci5nZXRfZnVsbF9uYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1N1Ym1pdHRlcnMnKSArICc6ICcgKyBzdWJtaXR0ZXJzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTdGF0ZScpICsgJzogJyArIG1vdGlvbi5nZXRTdGF0ZU5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjb21tZW5kYXRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29tbWVuZGF0aW9uc19ieSA9IENvbmZpZy5nZXQoJ21vdGlvbnNfcmVjb21tZW5kYXRpb25zX2J5JykudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNvbW1lbmRhdGlvbiA9IG1vdGlvbi5nZXRSZWNvbW1lbmRhdGlvbk5hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29tbWVuZGF0aW9uc19ieSAmJiByZWNvbW1lbmRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiByZWNvbW1lbmRhdGlvbnNfYnkgKyAnOiAnICsgcmVjb21tZW5kYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmNvbmNhdChjb250ZW50LCBjb252ZXJ0ZXIuY29udmVydEhUTUwobW90aW9uVGV4dCwgJ291dHNpZGUnKSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldEJ1bmRsZUNvbnRlbnQgPSBmdW5jdGlvbiAoYnVuZGxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlYWRNb3Rpb24gPSBidW5kbGVbMF0uZ2V0UGFyZW50TW90aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gdGl0bGVcbiAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBsZWFkTW90aW9uLmlkZW50aWZpZXIgPyAnICcgKyBsZWFkTW90aW9uLmlkZW50aWZpZXIgOiAnJztcbiAgICAgICAgICAgICAgICB0aXRsZSArPSAnOiAnICsgbGVhZE1vdGlvbi5nZXRUaXRsZSgpO1xuICAgICAgICAgICAgICAgIHRpdGxlID0gUERGTGF5b3V0LmNyZWF0ZVRpdGxlKGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQW1lbmRtZW50cyB0byBtb3Rpb24nKSArIHRpdGxlKTtcblxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gW3RpdGxlXSxcbiAgICAgICAgICAgICAgICAgICAgZm91bmRBbWVuZG1lbnRzID0gW107XG5cbiAgICAgICAgICAgICAgICB2YXIgaGVhZGluZ3MgPSBsZWFkTW90aW9uLmdldFRleHRIZWFkaW5ncygpLm1hcChmdW5jdGlvbihoZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRpbmcuYW1lbmRtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGluZztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBidW5kbGUuZm9yRWFjaChmdW5jdGlvbihhbWVuZG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRpbmdJZHggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlcyA9IGFtZW5kbWVudC5nZXRBbWVuZG1lbnRQYXJhZ3JhcGhzQnlNb2RlKCdkaWZmJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbWVuZG1lbnRMaW5lTnVtYmVyID0gY2hhbmdlc1swXS5saW5lRnJvbTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRpbmdzW2ldLmxpbmVOdW1iZXIgPD0gYW1lbmRtZW50TGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRpbmdJZHggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFkaW5nSWR4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkaW5nc1toZWFkaW5nSWR4XS5hbWVuZG1lbnRzLnB1c2goYW1lbmRtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kQW1lbmRtZW50cy5wdXNoKGFtZW5kbWVudC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGhlYWRpbmdzLmZvckVhY2goZnVuY3Rpb24oaGVhZGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGluZy5hbWVuZG1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBoZWFkaW5nLnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogXCJoZWFkaW5nMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAyNSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBfLmNvbmNhdChjb250ZW50LCBjcmVhdGVCdW5kbGVDb250ZW50KGhlYWRpbmcuYW1lbmRtZW50cykpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGFtZW5kbWVudCB0aGF0IGRpZCBub3QgaGF2ZSBhIGhlYWRpbmcsIHdlIGFwcGVuZCBpdCBhdCB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgdmFyIG1pc3NlZEFtZW5kbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBidW5kbGUuZm9yRWFjaChmdW5jdGlvbihhbWVuZG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kQW1lbmRtZW50cy5pbmRleE9mKGFtZW5kbWVudC5pZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzZWRBbWVuZG1lbnRzLnB1c2goYW1lbmRtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChtaXNzZWRBbWVuZG1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IF8uY29uY2F0KGNvbnRlbnQsIGNyZWF0ZUJ1bmRsZUNvbnRlbnQobWlzc2VkQW1lbmRtZW50cykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gR2VuZXJhdGVzIGNvbnRlbnQgYXMgYSBwZGZtYWtlIGNvbnN1bWFibGVcbiAgICAgICAgICAgIHZhciBnZXRDb250ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGVzIGJ1bmRsZXMgb2YgbW90aW9ucy4gQWxsIG1vdGlvbnMgd2l0aCB0aGUgc2FtZSBwYXJlbnQgYXJlIGJ1bmRsZWQgdG9nZXRoZXJcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aW5nIHRoZSBvcmRlciwgaW4gd2hpY2ggdGhleSBhcmUgc29ydGVkLlxuICAgICAgICAgICAgICAgIC8vIG1vdGlvbkJ1bmRsZXMgaXMgYW4gYXJyYXkgY29udGFpbmluZyBBcnJheXMgb2YgbW90aW9ucyB3aXRoIHRoZSBzYW1lIHBhcmVudC5cbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SWQgPSBtb3Rpb25zWzBdLnBhcmVudF9pZDtcbiAgICAgICAgICAgICAgICB2YXIgbW90aW9uQnVuZGxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50QnVuZGxlID0gW107XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKG1vdGlvbnMsIGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdGlvbi5wYXJlbnRfaWQgPT09IHBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QnVuZGxlLnB1c2gobW90aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvbkJ1bmRsZXMucHVzaChjdXJyZW50QnVuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCdW5kbGUgPSBbbW90aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkID0gbW90aW9uLnBhcmVudF9pZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1vdGlvbkJ1bmRsZXMucHVzaChjdXJyZW50QnVuZGxlKTtcblxuICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIGFtZW5kbWVudCB0YWJsZSBmb3IgZWFjaCBtb3Rpb24gYnVuZGxlLlxuICAgICAgICAgICAgICAgIHJldHVybiBfLm1hcChtb3Rpb25CdW5kbGVzLCBmdW5jdGlvbiAoYnVuZGxlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGdldEJ1bmRsZUNvbnRlbnQoYnVuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbW90aW9uQnVuZGxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goUERGTGF5b3V0LmFkZFBhZ2VCcmVhaygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBnZXRJbWFnZU1hcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbWFnZU1hcDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiAkcShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIEltYWdlQ29udmVydGVyLnRvQmFzZTY0KGdldEltYWdlU291cmNlcygpKS50aGVuKGZ1bmN0aW9uIChfaW1hZ2VNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VNYXAgPSBfaW1hZ2VNYXA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRlciA9IFBkZk1ha2VDb252ZXJ0ZXIuY3JlYXRlSW5zdGFuY2UoX2ltYWdlTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb250ZW50OiBnZXRDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SW1hZ2VNYXA6IGdldEltYWdlTWFwLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVJbnN0YW5jZTogY3JlYXRlSW5zdGFuY2UsXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ01vdGlvblBkZkV4cG9ydCcsIFtcbiAgICAnJGh0dHAnLFxuICAgICckcScsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnQ29uZmlnJyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbicsXG4gICAgJ0hUTUxWYWxpZGl6ZXInLFxuICAgICdQZGZNYWtlQ29udmVydGVyJyxcbiAgICAnTW90aW9uQ29udGVudFByb3ZpZGVyJyxcbiAgICAnTW90aW9uQ2F0YWxvZ0NvbnRlbnRQcm92aWRlcicsXG4gICAgJ1BkZk1ha2VEb2N1bWVudFByb3ZpZGVyJyxcbiAgICAnUG9sbENvbnRlbnRQcm92aWRlcicsXG4gICAgJ1BkZk1ha2VCYWxsb3RQYXBlclByb3ZpZGVyJyxcbiAgICAnTW90aW9uUGFydGlhbENvbnRlbnRQcm92aWRlcicsXG4gICAgJ0FtZW5kbWVudENvbnRlbnRQcm92aWRlcicsXG4gICAgJ1BkZkNyZWF0ZScsXG4gICAgJ1BERkxheW91dCcsXG4gICAgJ1BlcnNvbmFsTm90ZU1hbmFnZXInLFxuICAgICdNb3Rpb25Db21tZW50JyxcbiAgICAnTWVzc2FnaW5nJyxcbiAgICAnRmlsZVNhdmVyJyxcbiAgICBmdW5jdGlvbiAoJGh0dHAsICRxLCBvcGVyYXRvciwgQ29uZmlnLCBnZXR0ZXh0Q2F0YWxvZywgTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24sIEhUTUxWYWxpZGl6ZXIsXG4gICAgICAgIFBkZk1ha2VDb252ZXJ0ZXIsIE1vdGlvbkNvbnRlbnRQcm92aWRlciwgTW90aW9uQ2F0YWxvZ0NvbnRlbnRQcm92aWRlciwgUGRmTWFrZURvY3VtZW50UHJvdmlkZXIsXG4gICAgICAgIFBvbGxDb250ZW50UHJvdmlkZXIsIFBkZk1ha2VCYWxsb3RQYXBlclByb3ZpZGVyLCBNb3Rpb25QYXJ0aWFsQ29udGVudFByb3ZpZGVyLCBBbWVuZG1lbnRDb250ZW50UHJvdmlkZXIsXG4gICAgICAgIFBkZkNyZWF0ZSwgUERGTGF5b3V0LCBQZXJzb25hbE5vdGVNYW5hZ2VyLCBNb3Rpb25Db21tZW50LCBNZXNzYWdpbmcsIEZpbGVTYXZlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0RG9jdW1lbnRQcm92aWRlcjogZnVuY3Rpb24gKG1vdGlvbnMsIHBhcmFtcywgc2luZ2xlTW90aW9uKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gXy5jbG9uZShwYXJhbXMgfHwge30pOyAvLyBDbG9uZSB0aGlzIHRvIGF2b2lkIHNpZGVlZmZlY3RzLlxuXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZU1vdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBfLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogbW90aW9ucy5hY3RpdmVfdmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1vdGlvbnMgPSBbbW90aW9uc107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9zYXZlIHRoZSBhcnJheXMgb2YgYWxsIG1vdGlvbnMgdG8gYW4gYXJyYXlcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gobW90aW9ucywgZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlTW90aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb24uY2hhbmdlUmVjb21tZW5kYXRpb25zID0gTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24uZmlsdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd2hlcmUnOiB7J21vdGlvbl92ZXJzaW9uX2lkJzogeyc9PSc6IHBhcmFtcy52ZXJzaW9ufX1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uLmNoYW5nZVJlY29tbWVuZGF0aW9ucyA9IE1vdGlvbkNoYW5nZVJlY29tbWVuZGF0aW9uLmZpbHRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3doZXJlJzogeydtb3Rpb25fdmVyc2lvbl9pZCc6IHsnPT0nOiBtb3Rpb24uYWN0aXZlX3ZlcnNpb259fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBtb3Rpb25Db250ZW50UHJvdmlkZXJBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBtb3Rpb25Db250ZW50UHJvdmlkZXJQcm9taXNlcyA9IF8ubWFwKG1vdGlvbnMsIGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnNpb24gPSAoc2luZ2xlTW90aW9uID8gcGFyYW1zLnZlcnNpb24gOiBtb3Rpb24uYWN0aXZlX3ZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTW90aW9uQ29udGVudFByb3ZpZGVyLmNyZWF0ZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvbiwgdmVyc2lvbiwgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICApLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnRQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvbkNvbnRlbnRQcm92aWRlckFycmF5LnB1c2goY29udGVudFByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAkcShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICRxLmFsbChtb3Rpb25Db250ZW50UHJvdmlkZXJQcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2N1bWVudFByb3ZpZGVyUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGVNb3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudFByb3ZpZGVyUHJvbWlzZSA9IFBkZk1ha2VEb2N1bWVudFByb3ZpZGVyLmNyZWF0ZUluc3RhbmNlKG1vdGlvbkNvbnRlbnRQcm92aWRlckFycmF5WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vdGlvbkNhdGFsb2dDb250ZW50UHJvdmlkZXIgPSBNb3Rpb25DYXRhbG9nQ29udGVudFByb3ZpZGVyLmNyZWF0ZUluc3RhbmNlKG1vdGlvbkNvbnRlbnRQcm92aWRlckFycmF5LCBwYXJhbXMuY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudFByb3ZpZGVyUHJvbWlzZSA9IFBkZk1ha2VEb2N1bWVudFByb3ZpZGVyLmNyZWF0ZUluc3RhbmNlKG1vdGlvbkNhdGFsb2dDb250ZW50UHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRQcm92aWRlclByb21pc2UudGhlbihmdW5jdGlvbiAoZG9jdW1lbnRQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZG9jdW1lbnRQcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4cG9ydDogZnVuY3Rpb24gKG1vdGlvbnMsIHBhcmFtcywgc2luZ2xlTW90aW9uKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICAgICAgICAgIHBhcmFtcy5maWxlbmFtZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnbW90aW9ucycpICsgJy5wZGYnO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RG9jdW1lbnRQcm92aWRlcihtb3Rpb25zLCBwYXJhbXMsIHNpbmdsZU1vdGlvbikudGhlbihcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGRvY3VtZW50UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBkZkNyZWF0ZS5kb3dubG9hZChkb2N1bWVudFByb3ZpZGVyLCBwYXJhbXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2luZy5hZGRNZXNzYWdlKGVycm9yLm1zZywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4cG9ydFppcDogZnVuY3Rpb24gKG1vdGlvbnMsIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlSWQgPSBNZXNzYWdpbmcuYWRkTWVzc2FnZSgnPGkgY2xhc3M9XCJmYSBmYS1zcGlubmVyIGZhLXB1bHNlIGZhLWxnIHNwYWNlci1yaWdodFwiPjwvaT4nICtcbiAgICAgICAgICAgICAgICAgICAgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdHZW5lcmF0aW5nIFBERnMgYW5kIFpJUCBhcmNoaXZlJykgKyAnIC4uLicsICdpbmZvJyk7XG4gICAgICAgICAgICAgICAgdmFyIHppcEZpbGVuYW1lID0gcGFyYW1zLmZpbGVuYW1lIHx8IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnbW90aW9ucycpICsgJy56aXAnO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5maWxlbmFtZSA9IHZvaWQgMDsgLy8gY2xlYXIgdGhpcywgc28gd2UgZG8gbm90IG92ZXJyaWRlIHRoZSBkZWZhdWx0IGZpbGVuYW1lcyBmb3IgZWFjaCBwZGYuXG5cbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHVzZWRGaWxlbmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgZG9jTWFwID0ge307XG4gICAgICAgICAgICAgICAgdmFyIGRvY1Byb21pc2VzID0gXy5tYXAobW90aW9ucywgZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IG1vdGlvbi5pZGVudGlmaWVyID8gJy0nICsgbW90aW9uLmlkZW50aWZpZXIgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdNb3Rpb24nKSArIGlkZW50aWZpZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGZpbGVuYW1lIGlzIGFscmVhZHkgaW4gdXNlLCB0cnkgdG8gYXBwZW5kIGEgbnVtYmVyIHRvIGl0IChsaWtlICcoMiknKVxuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pbmNsdWRlcyh1c2VkRmlsZW5hbWVzLCBmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZVdpdGhOdW1iZXIgPSBmaWxlbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKF8uaW5jbHVkZXModXNlZEZpbGVuYW1lcywgZmlsZW5hbWVXaXRoTnVtYmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lV2l0aE51bWJlciA9IGZpbGVuYW1lICsgJyAoJyArIGkgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZVdpdGhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlZEZpbGVuYW1lcy5wdXNoKGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUgKz0gJy5wZGYnO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgZG9jdW1lbnRQcm92aWRlciBmb3IgZXZlcnkgbW90aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXREb2N1bWVudFByb3ZpZGVyKG1vdGlvbiwgcGFyYW1zLCB0cnVlKS50aGVuKGZ1bmN0aW9uIChkb2N1bWVudFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jTWFwW2ZpbGVuYW1lXSA9IGRvY3VtZW50UHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJHEuYWxsKGRvY1Byb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgUGRmQ3JlYXRlLmdldEJhc2U2NEZyb21NdWx0aXBsZURvY3VtZW50cyhkb2NNYXApLnRoZW4oZnVuY3Rpb24gKHBkZk1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHppcCA9IG5ldyBKU1ppcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKHBkZk1hcCwgZnVuY3Rpb24gKGRhdGEsIGZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgemlwLmZpbGUoZmlsZW5hbWUsIGRhdGEsIHtiYXNlNjQ6IHRydWV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVzc2FnaW5nLmNyZWF0ZU9yRWRpdE1lc3NhZ2UobWVzc2FnZUlkLCAnPGkgY2xhc3M9XCJmYSBmYS1jaGVjayBmYS1sZyBzcGFjZXItcmlnaHRcIj48L2k+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdaSVAgc3VjY2Vzc2Z1bGx5IGdlbmVyYXRlZC4nKSwgJ3N1Y2Nlc3MnLCB7dGltZW91dDogMzAwMH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgemlwLmdlbmVyYXRlQXN5bmMoe3R5cGU6ICdibG9iJ30pLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaWxlU2F2ZXIuc2F2ZUFzKGNvbnRlbnQsIHppcEZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2luZy5jcmVhdGVPckVkaXRNZXNzYWdlKG1lc3NhZ2VJZCwgJzxpIGNsYXNzPVwiZmEgZmEtZXhjbGFtYXRpb24tdHJpYW5nbGUgZmEtbGcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NwYWNlci1yaWdodFwiPjwvaT4nICsgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdFcnJvciB3aGlsZSBnZW5lcmF0aW5nIFpJUCBmaWxlJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6IDxjb2RlPicgKyBlcnJvciArICc8L2NvZGU+JywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBNZXNzYWdpbmcuY3JlYXRlT3JFZGl0TWVzc2FnZShtZXNzYWdlSWQsIGVycm9yLm1zZywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlUG9sbFBkZjogZnVuY3Rpb24gKG1vdGlvbiwgdmVyc2lvbikge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IG1vdGlvbi5pZGVudGlmaWVyLnJlcGxhY2UoJyAnLCAnJyk7XG4gICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gbW90aW9uLmdldFRpdGxlKHZlcnNpb24pO1xuICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnTW90aW9uJykgKyAnLScgKyBpZCArICctJyArIGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnYmFsbG90LXBhcGVyJykgKyAnLnBkZic7XG4gICAgICAgICAgICAgICAgUG9sbENvbnRlbnRQcm92aWRlci5jcmVhdGVJbnN0YW5jZSh0aXRsZSwgaWQpLnRoZW4oZnVuY3Rpb24gKHBvbGxDb250ZW50UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvY3VtZW50UHJvdmlkZXIgPSBQZGZNYWtlQmFsbG90UGFwZXJQcm92aWRlci5jcmVhdGVJbnN0YW5jZShwb2xsQ29udGVudFByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgUGRmQ3JlYXRlLmRvd25sb2FkKGRvY3VtZW50UHJvdmlkZXIsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnaW5nLmFkZE1lc3NhZ2UoZXJyb3IubXNnLCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHBvcnRQZXJzb25hbE5vdGU6IGZ1bmN0aW9uIChtb3Rpb24sIGZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBlcnNvbmFsTm90ZSA9IFBlcnNvbmFsTm90ZU1hbmFnZXIuZ2V0Tm90ZShtb3Rpb24pO1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gW3tcbiAgICAgICAgICAgICAgICAgICAgaGVhZGluZzogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdQZXJzb25hbCBub3RlJyksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHBlcnNvbmFsTm90ZSA/IHBlcnNvbmFsTm90ZS5ub3RlIDogJycsXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgTW90aW9uUGFydGlhbENvbnRlbnRQcm92aWRlci5jcmVhdGVJbnN0YW5jZShtb3Rpb24sIGNvbnRlbnQpLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnRQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBQZGZNYWtlRG9jdW1lbnRQcm92aWRlci5jcmVhdGVJbnN0YW5jZShjb250ZW50UHJvdmlkZXIpLnRoZW4oZnVuY3Rpb24gKGRvY3VtZW50UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBkZkNyZWF0ZS5kb3dubG9hZChkb2N1bWVudFByb3ZpZGVyLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVzc2FnaW5nLmFkZE1lc3NhZ2UoZXJyb3IubXNnLCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2luZy5hZGRNZXNzYWdlKGVycm9yLm1zZywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhwb3J0Q29tbWVudDogZnVuY3Rpb24gKG1vdGlvbiwgY29tbWVudElkLCBmaWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IE1vdGlvbkNvbW1lbnQuZ2V0Tm9TcGVjaWFsQ29tbWVudHNGaWVsZHMoKVtjb21tZW50SWRdO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCAmJiBtb3Rpb24uY29tbWVudHNbY29tbWVudElkXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBmaWVsZC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkLnB1YmxpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgKz0gJyAoJyArIGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnaW50ZXJuYWwnKSArICcpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkaW5nOiB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG1vdGlvbi5jb21tZW50c1tjb21tZW50SWRdLFxuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgTW90aW9uUGFydGlhbENvbnRlbnRQcm92aWRlci5jcmVhdGVJbnN0YW5jZShtb3Rpb24sIGNvbnRlbnQpLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnRQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgUGRmTWFrZURvY3VtZW50UHJvdmlkZXIuY3JlYXRlSW5zdGFuY2UoY29udGVudFByb3ZpZGVyKS50aGVuKGZ1bmN0aW9uIChkb2N1bWVudFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUGRmQ3JlYXRlLmRvd25sb2FkKGRvY3VtZW50UHJvdmlkZXIsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2luZy5hZGRNZXNzYWdlKGVycm9yLm1zZywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdpbmcuYWRkTWVzc2FnZShlcnJvci5tc2csICdlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhwb3J0QW1lbmRtZW50czogZnVuY3Rpb24gKG1vdGlvbnMsIGZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgQW1lbmRtZW50Q29udGVudFByb3ZpZGVyLmNyZWF0ZUluc3RhbmNlKG1vdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnRQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBQZGZNYWtlRG9jdW1lbnRQcm92aWRlci5jcmVhdGVJbnN0YW5jZShjb250ZW50UHJvdmlkZXIpLnRoZW4oZnVuY3Rpb24gKGRvY3VtZW50UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBkZkNyZWF0ZS5kb3dubG9hZChkb2N1bWVudFByb3ZpZGVyLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAubW90aW9ucy5wcm9qZWN0b3InLCBbXG4gICAgJ09wZW5TbGlkZXNBcHAubW90aW9ucycsXG4gICAgJ09wZW5TbGlkZXNBcHAubW90aW9ucy5tb3Rpb25zZXJ2aWNlcycsXG4gICAgJ09wZW5TbGlkZXNBcHAubW90aW9ucy5tb3Rpb25CbG9ja1Byb2plY3RvcicsXG5dKVxuXG4uY29uZmlnKFtcbiAgICAnc2xpZGVzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKHNsaWRlc1Byb3ZpZGVyKSB7XG4gICAgICAgIHNsaWRlc1Byb3ZpZGVyLnJlZ2lzdGVyU2xpZGUoJ21vdGlvbnMvbW90aW9uJywge1xuICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL21vdGlvbnMvc2xpZGVfbW90aW9uLmh0bWwnLFxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignU2xpZGVNb3Rpb25DdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckdGltZW91dCcsXG4gICAgJ0NvbmZpZycsXG4gICAgJ01vdGlvbicsXG4gICAgJ01vdGlvbkNoYW5nZVJlY29tbWVuZGF0aW9uJyxcbiAgICAnQ2hhbmdlUmVjb21tZW5kYXRpb25WaWV3JyxcbiAgICAnVXNlcicsXG4gICAgJ05vdGlmeScsXG4gICAgJ1Byb2plY3RvcklEJyxcbiAgICAnTW90aW9uUG9sbERlY2ltYWxQbGFjZXMnLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgJHRpbWVvdXQsIENvbmZpZywgTW90aW9uLCBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbixcbiAgICAgICAgQ2hhbmdlUmVjb21tZW5kYXRpb25WaWV3LCBVc2VyLCBOb3RpZnksIFByb2plY3RvcklELCBNb3Rpb25Qb2xsRGVjaW1hbFBsYWNlcykge1xuICAgICAgICAvLyBBdHRlbnRpb24hIEVhY2ggb2JqZWN0IHRoYXQgaXMgdXNlZCBoZXJlIGhhcyB0byBiZSBkZWFsdCBvbiBzZXJ2ZXIgc2lkZS5cbiAgICAgICAgLy8gQWRkIGl0IHRvIHRoZSBjb3Jlc3BvbmRpbmcgZ2V0X3JlcXVpcmVtZW50cyBtZXRob2Qgb2YgdGhlIFByb2plY3RvckVsZW1lbnRcbiAgICAgICAgLy8gY2xhc3MuXG4gICAgICAgIHZhciBtb3Rpb25JZCA9ICRzY29wZS5lbGVtZW50LmlkO1xuICAgICAgICAkc2NvcGUubW9kZSA9ICRzY29wZS5lbGVtZW50Lm1vZGUgfHwgJ29yaWdpbmFsJztcbiAgICAgICAgJHNjb3BlLmxpbmVOdW1iZXJNb2RlID0gQ29uZmlnLmdldCgnbW90aW9uc19kZWZhdWx0X2xpbmVfbnVtYmVyaW5nJykudmFsdWU7XG5cbiAgICAgICAgdmFyIG5vdGlmeU5hbWVQcmVmaXggPSAncHJvamVjdG9yXycgKyBQcm9qZWN0b3JJRCgpICsgJ19tb3Rpb25fbGluZV8nO1xuICAgICAgICB2YXIgY2FsbGJhY2tJZCA9IE5vdGlmeS5yZWdpc3RlckNhbGxiYWNrKG5vdGlmeU5hbWVQcmVmaXggKyAncmVxdWVzdCcsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gcGFyYW1zLnBhcmFtcy5saW5lO1xuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHNjb3BlLmhpZ2hsaWdodCA9IGxpbmU7XG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmhpZ2hsaWdodCA9IDA7XG4gICAgICAgICAgICB9LCA0MDAwKTtcblxuICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IG51bGw7XG4gICAgICAgICAgICAkKCcubGluZS1udW1iZXItJyArIGxpbmUpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9ICQodGhpcykub2Zmc2V0KCkudG9wO1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUb3AgPT09IG51bGwgfHwgdG9wIDwgc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9IHRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3AgKz0gKC0kc2NvcGUuc2Nyb2xsKTsgLy8gQWRkIHRoZSAocmV2ZXJzZWQpIHNjcm9sbGluZyBvbnRvcFxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGwgPSBNYXRoLmZsb29yKChzY3JvbGxUb3AvMjUwKSAtIDAuMik7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSBwYXJhbXMuc2VuZGVyUmVwbHlDaGFubmVsTmFtZTtcbiAgICAgICAgICAgICAgICBOb3RpZnkubm90aWZ5KG5vdGlmeU5hbWVQcmVmaXggKyAnYW5zd2VyJywge3Njcm9sbDogc2Nyb2xsfSwgbnVsbCwgW2NoYW5uZWxdLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTm90aWZ5LmRlcmVnaXN0ZXJDYWxsYmFjayhjYWxsYmFja0lkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgVXNlci5iaW5kQWxsKHt9LCAkc2NvcGUsICd1c2VycycpO1xuXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1vdGlvbi5sYXN0TW9kaWZpZWQobW90aW9uSWQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUubW90aW9uID0gTW90aW9uLmdldChtb3Rpb25JZCk7XG4gICAgICAgICAgICAkc2NvcGUuYW1lbmRtZW50X2RpZmZfcGFyYWdyYXBocyA9ICRzY29wZS5tb3Rpb24uZ2V0QW1lbmRtZW50UGFyYWdyYXBoc0xpbmVzRGlmZigpO1xuICAgICAgICAgICAgJHNjb3BlLnZpZXdDaGFuZ2VSZWNvbW1lbmRhdGlvbnMuc2V0VmVyc2lvbigkc2NvcGUubW90aW9uLCAkc2NvcGUubW90aW9uLmFjdGl2ZV92ZXJzaW9uKTtcbiAgICAgICAgICAgIF8uZm9yRWFjaCgkc2NvcGUubW90aW9uLnBvbGxzLCBmdW5jdGlvbiAocG9sbCkge1xuICAgICAgICAgICAgICAgIE1vdGlvblBvbGxEZWNpbWFsUGxhY2VzLmdldFBsYWNlcyhwb2xsLCB0cnVlKS50aGVuKGZ1bmN0aW9uIChkZWNpbWFsUGxhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbkNhY2hlW3BvbGwuaWRdID0gZGVjaW1hbFBsYWNlcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcHJlY2lzaW9uQ2FjaGUgPSB7fTtcbiAgICAgICAgJHNjb3BlLmdldFBvbGxWb3Rlc1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChwb2xsKSB7XG4gICAgICAgICAgICBpZiAoIXByZWNpc2lvbkNhY2hlW3BvbGwuaWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJlY2lzaW9uQ2FjaGVbcG9sbC5pZF07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hhbmdlIHJlY29tbWVuZGF0aW9uIHZpZXdpbmdcbiAgICAgICAgJHNjb3BlLnZpZXdDaGFuZ2VSZWNvbW1lbmRhdGlvbnMgPSBDaGFuZ2VSZWNvbW1lbmRhdGlvblZpZXc7XG4gICAgICAgICRzY29wZS52aWV3Q2hhbmdlUmVjb21tZW5kYXRpb25zLmluaXRQcm9qZWN0b3IoJHNjb3BlLCBNb3Rpb24uZ2V0KG1vdGlvbklkKSwgJHNjb3BlLm1vZGUpO1xuICAgIH1cbl0pO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5tb3Rpb25zLnNpdGUnLCBbXG4gICAgJ09wZW5TbGlkZXNBcHAubW90aW9ucycsXG4gICAgJ09wZW5TbGlkZXNBcHAubW90aW9ucy5tb3Rpb25zZXJ2aWNlcycsXG4gICAgJ09wZW5TbGlkZXNBcHAucG9sbC5tYWpvcml0eScsXG4gICAgJ09wZW5TbGlkZXNBcHAuY29yZS5wZGYnLFxuICAgICdPcGVuU2xpZGVzQXBwLm1vdGlvbnMuZG9jeCcsXG4gICAgJ09wZW5TbGlkZXNBcHAubW90aW9ucy5wZGYnLFxuICAgICdPcGVuU2xpZGVzQXBwLm1vdGlvbnMuY3N2JyxcbiAgICAnT3BlblNsaWRlc0FwcC5tb3Rpb25zLndvcmtmbG93Jyxcbl0pXG5cbi5jb25maWcoW1xuICAgICdtYWluTWVudVByb3ZpZGVyJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgZnVuY3Rpb24gKG1haW5NZW51UHJvdmlkZXIsIGdldHRleHQpIHtcbiAgICAgICAgbWFpbk1lbnVQcm92aWRlci5yZWdpc3Rlcih7XG4gICAgICAgICAgICAndWlfc3JlZic6ICdtb3Rpb25zLm1vdGlvbi5saXN0JyxcbiAgICAgICAgICAgICdpbWdfY2xhc3MnOiAnZmlsZS10ZXh0JyxcbiAgICAgICAgICAgICd0aXRsZSc6IGdldHRleHQoJ01vdGlvbnMnKSxcbiAgICAgICAgICAgICd3ZWlnaHQnOiAzMDAsXG4gICAgICAgICAgICAncGVybSc6ICdtb3Rpb25zLmNhbl9zZWUnLFxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4uY29uZmlnKFtcbiAgICAnU2VhcmNoUHJvdmlkZXInLFxuICAgICdnZXR0ZXh0JyxcbiAgICBmdW5jdGlvbiAoU2VhcmNoUHJvdmlkZXIsIGdldHRleHQpIHtcbiAgICAgICAgU2VhcmNoUHJvdmlkZXIucmVnaXN0ZXIoe1xuICAgICAgICAgICAgJ3ZlcmJvc2VOYW1lJzogZ2V0dGV4dCgnTW90aW9ucycpLFxuICAgICAgICAgICAgJ2NvbGxlY3Rpb25OYW1lJzogJ21vdGlvbnMvbW90aW9uJyxcbiAgICAgICAgICAgICd1cmxEZXRhaWxTdGF0ZSc6ICdtb3Rpb25zLm1vdGlvbi5kZXRhaWwnLFxuICAgICAgICAgICAgJ3dlaWdodCc6IDMwMCxcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLmNvbmZpZyhbXG4gICAgJyRzdGF0ZVByb3ZpZGVyJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIsIGdldHRleHQpIHtcbiAgICAgICAgJHN0YXRlUHJvdmlkZXJcbiAgICAgICAgICAgIC5zdGF0ZSgnbW90aW9ucycsIHtcbiAgICAgICAgICAgICAgICB1cmw6ICcvbW90aW9ucycsXG4gICAgICAgICAgICAgICAgYWJzdHJhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHVpLXZpZXcvPlwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGdldHRleHQoJ01vdGlvbnMnKSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVBlcm06ICdtb3Rpb25zLmNhbl9zZWUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXRlKCdtb3Rpb25zLm1vdGlvbicsIHtcbiAgICAgICAgICAgICAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8dWktdmlldy8+XCIsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXRlKCdtb3Rpb25zLm1vdGlvbi5saXN0Jywge30pXG4gICAgICAgICAgICAuc3RhdGUoJ21vdGlvbnMubW90aW9uLmRldGFpbCcsIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1vdGlvbklkOiBbJyRzdGF0ZVBhcmFtcycsIGZ1bmN0aW9uKCRzdGF0ZVBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRzdGF0ZVBhcmFtcy5pZDtcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIHJlZGlyZWN0cyB0byBtb3Rpb24gZGV0YWlsIGFuZCBvcGVucyBtb3Rpb24gZWRpdCBmb3JtIGRpYWxvZywgdXNlcyBlZGl0IHVybCxcbiAgICAgICAgICAgIC8vIHVzZWQgYnkgdWktc3JlZiBsaW5rcyBmcm9tIGFnZW5kYSBvbmx5XG4gICAgICAgICAgICAvLyAoZnJvbSBtb3Rpb24gY29udHJvbGxlciB1c2UgTW90aW9uRm9ybSBmYWN0b3J5IGluc3RlYWQgdG8gb3BlbiBkaWFsb2cgaW4gZnJvbnQgb2ZcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgdmlldyB3aXRob3V0IHJlZGlyZWN0KVxuICAgICAgICAgICAgLnN0YXRlKCdtb3Rpb25zLm1vdGlvbi5kZXRhaWwudXBkYXRlJywge1xuICAgICAgICAgICAgICAgIG9uRW50ZXI6IFsnJHN0YXRlUGFyYW1zJywgJyRzdGF0ZScsICduZ0RpYWxvZycsICdNb3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigkc3RhdGVQYXJhbXMsICRzdGF0ZSwgbmdEaWFsb2csIE1vdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmdEaWFsb2cub3Blbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL21vdGlvbnMvbW90aW9uLWZvcm0uaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ01vdGlvblVwZGF0ZUN0cmwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ25nZGlhbG9nLXRoZW1lLWRlZmF1bHQgd2lkZS1mb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUJ5RXNjYXBlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUJ5RG9jdW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uSWQ6IGZ1bmN0aW9uICgpIHtyZXR1cm4gJHN0YXRlUGFyYW1zLmlkO30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVDbG9zZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnbW90aW9ucy5tb3Rpb24uZGV0YWlsJywge21vdGlvbjogJHN0YXRlUGFyYW1zLmlkfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdGF0ZSgnbW90aW9ucy5tb3Rpb24uc3VibWl0dGVycycsIHtcbiAgICAgICAgICAgICAgICB1cmw6ICcvc3VibWl0dGVycy97aWQ6aW50fScsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ01vdGlvblN1Ym1pdHRlckN0cmwnLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgbW90aW9uSWQ6IFsnJHN0YXRlUGFyYW1zJywgZnVuY3Rpb24oJHN0YXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHN0YXRlUGFyYW1zLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGdldHRleHQoJ1N1Ym1pdHRlcnMnKSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVBlcm06ICdtb3Rpb25zLmNhbl9tYW5hZ2UnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXRlKCdtb3Rpb25zLm1vdGlvbi5hbWVuZG1lbnQtbGlzdCcsIHtcbiAgICAgICAgICAgICAgICB1cmw6ICcve2lkOmludH0vYW1lbmRtZW50cycsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ01vdGlvbkFtZW5kbWVudExpc3RTdGF0ZUN0cmwnLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBtb3Rpb25JZDogbnVsbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgbW90aW9uSWQ6IFsnJHN0YXRlUGFyYW1zJywgZnVuY3Rpb24oJHN0YXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHN0YXRlUGFyYW1zLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXRlKCdtb3Rpb25zLm1vdGlvbi5hbGxhbWVuZG1lbnRzJywge1xuICAgICAgICAgICAgICAgIHVybDogJy9hbWVuZG1lbnRzJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3N0YXRpYy90ZW1wbGF0ZXMvbW90aW9ucy9tb3Rpb24tYW1lbmRtZW50LWxpc3QuaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ01vdGlvbkFtZW5kbWVudExpc3RTdGF0ZUN0cmwnLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgbW90aW9uSWQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdm9pZCAwOyB9LFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3RhdGUoJ21vdGlvbnMubW90aW9uLmltcG9ydCcsIHtcbiAgICAgICAgICAgICAgICB1cmw6ICcvaW1wb3J0JyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnTW90aW9uSW1wb3J0Q3RybCcsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy8gY2F0ZWdvcmllc1xuICAgICAgICAgICAgLnN0YXRlKCdtb3Rpb25zLmNhdGVnb3J5Jywge1xuICAgICAgICAgICAgICAgIHVybDogJy9jYXRlZ29yeScsXG4gICAgICAgICAgICAgICAgYWJzdHJhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHVpLXZpZXcvPlwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGdldHRleHQoJ0NhdGVnb3JpZXMnKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdGF0ZSgnbW90aW9ucy5jYXRlZ29yeS5saXN0Jywge30pXG4gICAgICAgICAgICAuc3RhdGUoJ21vdGlvbnMuY2F0ZWdvcnkuc29ydCcsIHtcbiAgICAgICAgICAgICAgICB1cmw6ICcvc29ydC97aWR9JyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnQ2F0ZWdvcnlTb3J0Q3RybCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdzdGF0aWMvdGVtcGxhdGVzL21vdGlvbnMvY2F0ZWdvcnktc29ydC5odG1sJyxcbiAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5SWQ6IFsnJHN0YXRlUGFyYW1zJywgZnVuY3Rpb24oJHN0YXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHN0YXRlUGFyYW1zLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIE1vdGlvbkJsb2NrXG4gICAgICAgICAgICAuc3RhdGUoJ21vdGlvbnMubW90aW9uQmxvY2snLCB7XG4gICAgICAgICAgICAgICAgdXJsOiAnL2Jsb2NrcycsXG4gICAgICAgICAgICAgICAgYWJzdHJhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6ICc8dWktdmlldy8+JyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXR0ZXh0KCdNb3Rpb24gYmxvY2tzJyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3RhdGUoJ21vdGlvbnMubW90aW9uQmxvY2subGlzdCcsIHt9KVxuICAgICAgICAgICAgLnN0YXRlKCdtb3Rpb25zLm1vdGlvbkJsb2NrLmRldGFpbCcsIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1vdGlvbkJsb2NrSWQ6IFsnJHN0YXRlUGFyYW1zJywgZnVuY3Rpb24oJHN0YXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHN0YXRlUGFyYW1zLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy8gcmVkaXJlY3RzIHRvIG1vdGlvbkJsb2NrIGRldGFpbCBhbmQgb3BlbnMgbW90aW9uQmxvY2sgZWRpdCBmb3JtIGRpYWxvZywgdXNlcyBlZGl0IHVybCxcbiAgICAgICAgICAgIC8vIHVzZWQgYnkgdWktc3JlZiBsaW5rcyBmcm9tIGFnZW5kYSBvbmx5XG4gICAgICAgICAgICAvLyAoZnJvbSBtb3Rpb25CbG9jayBjb250cm9sbGVyIHVzZSBNb3Rpb25CbG9ja0Zvcm0gZmFjdG9yeSBpbnN0ZWFkIHRvIG9wZW4gZGlhbG9nIGluIGZyb250XG4gICAgICAgICAgICAvLyBvZiBjdXJyZW50IHZpZXcgd2l0aG91dCByZWRpcmVjdClcbiAgICAgICAgICAgIC5zdGF0ZSgnbW90aW9ucy5tb3Rpb25CbG9jay5kZXRhaWwudXBkYXRlJywge1xuICAgICAgICAgICAgICAgIG9uRW50ZXI6IFsnJHN0YXRlUGFyYW1zJywgJyRzdGF0ZScsICduZ0RpYWxvZycsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCRzdGF0ZVBhcmFtcywgJHN0YXRlLCBuZ0RpYWxvZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmdEaWFsb2cub3Blbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL21vdGlvbnMvbW90aW9uLWJsb2NrLWZvcm0uaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ01vdGlvbkJsb2NrVXBkYXRlQ3RybCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmdkaWFsb2ctdGhlbWUtZGVmYXVsdCB3aWRlLWZvcm0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlQnlFc2NhcGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlQnlEb2N1bWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb25CbG9ja0lkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHN0YXRlUGFyYW1zLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVDbG9zZUNhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdtb3Rpb25zLm1vdGlvbkJsb2NrLmRldGFpbCcsIHttb3Rpb25CbG9jazogJHN0YXRlUGFyYW1zLmlkfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvLyBXb3JrZmxvd3MgYW5kIHN0YXRlc1xuICAgICAgICAgICAgLnN0YXRlKCdtb3Rpb25zLndvcmtmbG93Jywge1xuICAgICAgICAgICAgICAgIHVybDogJy93b3JrZmxvdycsXG4gICAgICAgICAgICAgICAgYWJzdHJhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6ICc8dWktdmlldy8+JyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXR0ZXh0KCdXb3JrZmxvd3MnKSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVBlcm06ICdtb3Rpb25zLmNhbl9tYW5hZ2UnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXRlKCdtb3Rpb25zLndvcmtmbG93Lmxpc3QnLCB7fSlcbiAgICAgICAgICAgIC5zdGF0ZSgnbW90aW9ucy53b3JrZmxvdy5kZXRhaWwnLCB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZToge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZmxvd0lkOiBbJyRzdGF0ZVBhcmFtcycsIGZ1bmN0aW9uKCRzdGF0ZVBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRzdGF0ZVBhcmFtcy5pZDtcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ0NoYW5nZVJlY29tbWVuZGF0aW9uVGl0bGVGb3JtJywgW1xuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0VkaXRvcicsXG4gICAgJ0NvbmZpZycsXG4gICAgZnVuY3Rpb24oZ2V0dGV4dENhdGFsb2cpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIG5nRGlhbG9nIGZvciBtb3Rpb24gZm9ybVxuICAgICAgICAgICAgZ2V0Q3JlYXRlRGlhbG9nOiBmdW5jdGlvbiAobW90aW9uLCB2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL21vdGlvbnMvY2hhbmdlLXJlY29tbWVuZGF0aW9uLWZvcm0uaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdDaGFuZ2VSZWNvbW1lbmRhdGlvblRpdGxlQ3JlYXRlQ3RybCcsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ25nZGlhbG9nLXRoZW1lLWRlZmF1bHQgd2lkZS1mb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VCeUVzY2FwZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlEb2N1bWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RWRpdERpYWxvZzogZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL21vdGlvbnMvY2hhbmdlLXJlY29tbWVuZGF0aW9uLWZvcm0uaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdDaGFuZ2VSZWNvbW1lbmRhdGlvblRpdGxlVXBkYXRlQ3RybCcsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ25nZGlhbG9nLXRoZW1lLWRlZmF1bHQgd2lkZS1mb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VCeUVzY2FwZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlEb2N1bWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gYW5ndWxhci1mb3JtbHkgZmllbGRzIGZvciBtb3Rpb24gZm9ybVxuICAgICAgICAgICAgZ2V0Rm9ybUZpZWxkczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0lkZW50aWZpZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnbW90aW9uX3ZlcnNpb25faWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ01vdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdOZXcgdGl0bGUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ0NoYW5nZVJlY29tbWVuZGF0aW9uVGV4dEZvcm0nLCBbXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnRWRpdG9yJyxcbiAgICAnQ29uZmlnJyxcbiAgICBmdW5jdGlvbihnZXR0ZXh0Q2F0YWxvZywgRWRpdG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBuZ0RpYWxvZyBmb3IgbW90aW9uIGZvcm1cbiAgICAgICAgICAgIGdldENyZWF0ZURpYWxvZzogZnVuY3Rpb24gKG1vdGlvbiwgdmVyc2lvbiwgbGluZUZyb20sIGxpbmVUbykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnc3RhdGljL3RlbXBsYXRlcy9tb3Rpb25zL2NoYW5nZS1yZWNvbW1lbmRhdGlvbi1mb3JtLmh0bWwnLFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnQ2hhbmdlUmVjb21tZW5kYXRpb25UZXh0Q3JlYXRlQ3RybCcsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ25nZGlhbG9nLXRoZW1lLWRlZmF1bHQgd2lkZS1mb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VCeUVzY2FwZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlEb2N1bWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lRnJvbTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVGcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVUbzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVUbztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RWRpdERpYWxvZzogZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL21vdGlvbnMvY2hhbmdlLXJlY29tbWVuZGF0aW9uLWZvcm0uaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdDaGFuZ2VSZWNvbW1lbmRhdGlvblRleHRVcGRhdGVDdHJsJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmdkaWFsb2ctdGhlbWUtZGVmYXVsdCB3aWRlLWZvcm0nLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUJ5RXNjYXBlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VCeURvY3VtZW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBhbmd1bGFyLWZvcm1seSBmaWVsZHMgZm9yIG1vdGlvbiBmb3JtXG4gICAgICAgICAgICBnZXRGb3JtRmllbGRzOiBmdW5jdGlvbiAobGluZV9mcm9tLCBsaW5lX3RvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnaWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnSWRlbnRpZmllcicpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtb3Rpb25fdmVyc2lvbl9pZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnTW90aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2xpbmVfZnJvbScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnRnJvbSBMaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2xpbmVfdG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1RvIExpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAndHlwZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmFkaW8tYnV0dG9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ1R5cGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnUmVwbGFjZW1lbnQnKSwgdmFsdWU6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdJbnNlcnRpb24nKSwgdmFsdWU6IDF9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdEZWxldGlvbicpLCB2YWx1ZTogMn0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ090aGVyJyksIHZhbHVlOiAzfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ290aGVyX2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdEZXNjcmlwdGlvbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVFeHByZXNzaW9uOiBcIm1vZGVsLnR5cGUgIT09IDNcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZWRpdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfZnJvbSA9PSBsaW5lX3RvIC0gMSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnVGV4dCBpbiBsaW5lICVmcm9tJScpLnJlcGxhY2UoLyVmcm9tJS8sIGxpbmVfZnJvbSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1RleHQgZnJvbSBsaW5lICVmcm9tJSB0byAldG8lJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJWZyb20lLywgbGluZV9mcm9tKS5yZXBsYWNlKC8ldG8lLywgbGluZV90byAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2tlZGl0b3JPcHRpb25zOiBFZGl0b3IuZ2V0T3B0aW9ucygpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi8vIFNlcnZpY2UgZm9yIGNob29zaW5nIHRoZSBwYXJhZ3JhcGggb2YgYSBnaXZlbiBtb3Rpb24gdGhhdCBpcyB0byBiZSBhbWVuZGVkXG4uZmFjdG9yeSgnQW1lbmRtZW50UGFyYWdyYXBoQ2hvb3NlRm9ybScsIFtcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBuZ0RpYWxvZyBmb3IgbW90aW9uIGZvcm1cbiAgICAgICAgICAgIGdldERpYWxvZzogZnVuY3Rpb24gKG1vdGlvbiwgc3VjY2Vzc0NiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL21vdGlvbnMvYW1lbmRtZW50LXBhcmFncmFwaC1jaG9vc2UtZm9ybS5odG1sJyxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ0FtZW5kbWVudFBhcmFncmFwaENob29zZUN0cmwnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICduZ2RpYWxvZy10aGVtZS1kZWZhdWx0IHdpZGUtZm9ybScsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlFc2NhcGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUJ5RG9jdW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdGlvbjsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYjogZnVuY3Rpb24oKSB7IHJldHVybiBzdWNjZXNzQ2I7IH0sXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi8vIFNlcnZpY2UgZm9yIGdlbmVyaWMgbW90aW9uIGZvcm0gKGNyZWF0ZSBhbmQgdXBkYXRlKVxuLmZhY3RvcnkoJ01vdGlvbkZvcm0nLCBbXG4gICAgJyRmaWx0ZXInLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnRWRpdG9yJyxcbiAgICAnTW90aW9uQ29tbWVudCcsXG4gICAgJ0NhdGVnb3J5JyxcbiAgICAnQ29uZmlnJyxcbiAgICAnTWVkaWFmaWxlJyxcbiAgICAnTW90aW9uQmxvY2snLFxuICAgICdUYWcnLFxuICAgICdVc2VyJyxcbiAgICAnV29ya2Zsb3cnLFxuICAgICdBZ2VuZGEnLFxuICAgICdBZ2VuZGFUcmVlJyxcbiAgICAnU2hvd0FzQWdlbmRhSXRlbUZpZWxkJyxcbiAgICBmdW5jdGlvbiAoJGZpbHRlciwgZ2V0dGV4dENhdGFsb2csIG9wZXJhdG9yLCBFZGl0b3IsIE1vdGlvbkNvbW1lbnQsIENhdGVnb3J5LCBDb25maWcsXG4gICAgICAgIE1lZGlhZmlsZSwgTW90aW9uQmxvY2ssIFRhZywgVXNlciwgV29ya2Zsb3csIEFnZW5kYSwgQWdlbmRhVHJlZSwgU2hvd0FzQWdlbmRhSXRlbUZpZWxkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBuZ0RpYWxvZyBmb3IgbW90aW9uIGZvcm1cbiAgICAgICAgICAgIC8vIElmIG1vdGlvbiBpcyBnaXZlbiBhbmQgbm90IG51bGwsIHdlJ3JlIGVkaXRpbmcgYW4gYWxyZWFkeSBleGlzdGluZyBtb3Rpb25cbiAgICAgICAgICAgIC8vIElmIHBhcmVudE1vdGlvbiBpcyBnaXZlLCB3ZSdyZSBkZWFsaW5nIHdpdGggYW4gYW1lbmRtZW50XG4gICAgICAgICAgICAvLyBJZiBwYXJhZ3JhcGhObyBpcyBnaXZlbiBhcyB3ZWxsLCB0aGUgYW1lbmRtZW50IGlzIHBhcmFncmFwaC1iYXNlZFxuICAgICAgICAgICAgLy8gSWYgcGFyYWdyYXBoVGV4dFByZSBpcyBnaXZlbiwgd2UncmUgY3JlYXRpbmcgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIGFub3RoZXIgcGFyYWdyYXBoLWJhc2VkIGFtZW5kbWVudFxuICAgICAgICAgICAgZ2V0RGlhbG9nOiBmdW5jdGlvbiAobW90aW9uLCBwYXJlbnRNb3Rpb24sIHBhcmFncmFwaE5vLCBwYXJhZ3JhcGhUZXh0UHJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL21vdGlvbnMvbW90aW9uLWZvcm0uaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IG1vdGlvbiA/ICdNb3Rpb25VcGRhdGVDdHJsJyA6ICdNb3Rpb25DcmVhdGVDdHJsJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmdkaWFsb2ctdGhlbWUtZGVmYXVsdCB3aWRlLWZvcm0nLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUJ5RXNjYXBlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VCeURvY3VtZW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uSWQ6IGZ1bmN0aW9uICgpIHtyZXR1cm4gbW90aW9uID8gbW90aW9uLmlkIDogdm9pZCAwO30sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRNb3Rpb246IGZ1bmN0aW9uICgpIHtyZXR1cm4gcGFyZW50TW90aW9uO30sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhZ3JhcGhObzogZnVuY3Rpb24gKCkge3JldHVybiBwYXJhZ3JhcGhObzt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWdyYXBoVGV4dFByZTogZnVuY3Rpb24gKCkge3JldHVybiBwYXJhZ3JhcGhUZXh0UHJlO31cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gYW5ndWxhci1mb3JtbHkgZmllbGRzIGZvciBtb3Rpb24gZm9ybVxuICAgICAgICAgICAgZ2V0Rm9ybUZpZWxkczogZnVuY3Rpb24gKGlzQ3JlYXRlRm9ybSwgaXNQYXJhZ3JhcGhCYXNlZEFtZW5kbWVudCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNQYXJhZ3JhcGhCYXNlZEFtZW5kbWVudCkgeyAvLyBjYXRjaCBudWxsIGFuZCB1bmRlZmluZWQuIEFuZ3VsYXIgZm9ybXkgZG9lc24ndCBsaWtlIHRoaXMuXG4gICAgICAgICAgICAgICAgICAgIGlzUGFyYWdyYXBoQmFzZWRBbWVuZG1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgd29ya2Zsb3dzID0gV29ya2Zsb3cuZ2V0QWxsKCk7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlcyA9IE1lZGlhZmlsZS5nZXRBbGxJbWFnZXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybUZpZWxkcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvcm1GaWVsZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0lkZW50aWZpZXInKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoaWRlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNDcmVhdGVGb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1GaWVsZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdzdWJtaXR0ZXJzX2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzZWxlY3QtbXVsdGlwbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnU3VibWl0dGVycycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IFVzZXIuZ2V0QWxsKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmdPcHRpb25zOiAnb3B0aW9uLmlkIGFzIG9wdGlvbi5mdWxsX25hbWUgZm9yIG9wdGlvbiBpbiB0by5vcHRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTZWxlY3Qgb3Igc2VhcmNoIGEgc3VibWl0dGVyIC4uLicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6ICFvcGVyYXRvci5oYXNQZXJtcygnbW90aW9ucy5jYW5fbWFuYWdlJylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9ybUZpZWxkcyA9IGZvcm1GaWVsZHMuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAndGl0bGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1RpdGxlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlOiBpc1BhcmFncmFwaEJhc2VkQW1lbmRtZW50ICYmIGlzQ3JlYXRlRm9ybVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxwIGNsYXNzPVwic3BhY2VyLXRvcC1sZyBuby1wYWRkaW5nXCI+JyArIENvbmZpZy50cmFuc2xhdGUoQ29uZmlnLmdldCgnbW90aW9uc19wcmVhbWJsZScpLnZhbHVlKSArICc8L3A+J1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlZGl0b3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnVGV4dCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhaXNQYXJhZ3JhcGhCYXNlZEFtZW5kbWVudCAvLyBEZWxldGluZyB0aGUgd2hvbGUgcGFyYWdyYXBoIGluIGFuIGFtZW5kbWVudCBzaG91bGQgYmUgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2tlZGl0b3JPcHRpb25zOiBFZGl0b3IuZ2V0T3B0aW9ucygpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ3JlYXNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZWRpdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1JlYXNvbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBja2VkaXRvck9wdGlvbnM6IEVkaXRvci5nZXRPcHRpb25zKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnZGlzYWJsZV92ZXJzaW9uaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdUcml2aWFsIGNoYW5nZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoXCJEb24ndCBjcmVhdGUgYSBuZXcgdmVyc2lvbi5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgIC8vIHNob3cgYXMgYWdlbmRhIGl0ZW0gKyBwYXJlbnQgaXRlbVxuICAgICAgICAgICAgICAgIGlmIChpc0NyZWF0ZUZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybUZpZWxkcy5wdXNoKFNob3dBc0FnZW5kYUl0ZW1GaWVsZCgnbW90aW9ucy5jYW5fbWFuYWdlJykpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtRmllbGRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnYWdlbmRhX3BhcmVudF9pZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2VsZWN0LXNpbmdsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdQYXJlbnQgaXRlbScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IEFnZW5kYVRyZWUuZ2V0RmxhdFRyZWUoQWdlbmRhLmdldEFsbCgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZ09wdGlvbnM6ICdpdGVtLmlkIGFzIGl0ZW0uZ2V0TGlzdFZpZXdUaXRsZSgpIGZvciBpdGVtIGluIHRvLm9wdGlvbnMgfCBub3RzZWxmIDogbW9kZWwuYWdlbmRhX2l0ZW1faWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1NlbGVjdCBhIHBhcmVudCBpdGVtIC4uLicpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTogIW9wZXJhdG9yLmhhc1Blcm1zKCdhZ2VuZGEuY2FuX21hbmFnZScpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdGlvbiBjb21tZW50c1xuICAgICAgICAgICAgICAgIGZvcm1GaWVsZHMgPSBmb3JtRmllbGRzLmNvbmNhdChNb3Rpb25Db21tZW50LmdldEZvcm1GaWVsZHMoKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBtb3JlXG4gICAgICAgICAgICAgICAgZm9ybUZpZWxkcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtb3JlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTaG93IGV4dGVuZGVkIGZpZWxkcycpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTogIW9wZXJhdG9yLmhhc1Blcm1zKCdtb3Rpb25zLmNhbl9tYW5hZ2UnKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxociBjbGFzcz1cInNtYWxsaHJcIj4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZUV4cHJlc3Npb246ICchbW9kZWwubW9yZSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gYXR0YWNobWVudHNcbiAgICAgICAgICAgICAgICBpZiAoTWVkaWFmaWxlLmdldEFsbCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybUZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F0dGFjaG1lbnRzX2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzZWxlY3QtbXVsdGlwbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQXR0YWNobWVudCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6ICRmaWx0ZXIoJ29yZGVyQnknKShNZWRpYWZpbGUuZ2V0QWxsKCksICd0aXRsZV9vcl9maWxlbmFtZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5nT3B0aW9uczogJ29wdGlvbi5pZCBhcyBvcHRpb24udGl0bGVfb3JfZmlsZW5hbWUgZm9yIG9wdGlvbiBpbiB0by5vcHRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTZWxlY3Qgb3Igc2VhcmNoIGFuIGF0dGFjaG1lbnQgLi4uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlRXhwcmVzc2lvbjogJyFtb2RlbC5tb3JlJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICBpZiAoQ2F0ZWdvcnkuZ2V0QWxsKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtRmllbGRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnY2F0ZWdvcnlfaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NlbGVjdC1zaW5nbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQ2F0ZWdvcnknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBDYXRlZ29yeS5nZXRBbGwoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZ09wdGlvbnM6ICdvcHRpb24uaWQgYXMgb3B0aW9uLm5hbWUgZm9yIG9wdGlvbiBpbiB0by5vcHRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTZWxlY3Qgb3Igc2VhcmNoIGEgY2F0ZWdvcnkgLi4uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlRXhwcmVzc2lvbjogJyFtb2RlbC5tb3JlJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbW90aW9uIGJsb2NrXG4gICAgICAgICAgICAgICAgaWYgKE1vdGlvbkJsb2NrLmdldEFsbCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybUZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ21vdGlvbl9ibG9ja19pZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2VsZWN0LXNpbmdsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdNb3Rpb24gYmxvY2snKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBNb3Rpb25CbG9jay5nZXRBbGwoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZ09wdGlvbnM6ICdvcHRpb24uaWQgYXMgb3B0aW9uLnRpdGxlIGZvciBvcHRpb24gaW4gdG8ub3B0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnU2VsZWN0IG9yIHNlYXJjaCBhIG1vdGlvbiBibG9jayAuLi4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVFeHByZXNzaW9uOiAnIW1vZGVsLm1vcmUnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvcmlnaW5cbiAgICAgICAgICAgICAgICBmb3JtRmllbGRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdvcmlnaW4nLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ09yaWdpbicpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXhwcmVzc2lvbjogJyFtb2RlbC5tb3JlJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHRhZ3NcbiAgICAgICAgICAgICAgICBpZiAoVGFnLmdldEFsbCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybUZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ3RhZ3NfaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NlbGVjdC1tdWx0aXBsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdUYWdzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogVGFnLmdldEFsbCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5nT3B0aW9uczogJ29wdGlvbi5pZCBhcyBvcHRpb24ubmFtZSBmb3Igb3B0aW9uIGluIHRvLm9wdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1NlbGVjdCBvciBzZWFyY2ggYSB0YWcgLi4uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlRXhwcmVzc2lvbjogJyFtb2RlbC5tb3JlJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydGVyc1xuICAgICAgICAgICAgICAgIGlmIChDb25maWcuZ2V0KCdtb3Rpb25zX21pbl9zdXBwb3J0ZXJzJykudmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1GaWVsZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdzdXBwb3J0ZXJzX2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzZWxlY3QtbXVsdGlwbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnU3VwcG9ydGVycycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IFVzZXIuZ2V0QWxsKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmdPcHRpb25zOiAnb3B0aW9uLmlkIGFzIG9wdGlvbi5mdWxsX25hbWUgZm9yIG9wdGlvbiBpbiB0by5vcHRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTZWxlY3Qgb3Igc2VhcmNoIGEgc3VwcG9ydGVyIC4uLicpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZUV4cHJlc3Npb246ICchbW9kZWwubW9yZSdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdvcmtmbG93c1xuICAgICAgICAgICAgICAgIGlmICh3b3JrZmxvd3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtRmllbGRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnd29ya2Zsb3dfaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NlbGVjdC1zaW5nbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnV29ya2Zsb3cnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zQXR0cjogJ2JzLW9wdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHdvcmtmbG93cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZ09wdGlvbnM6ICdvcHRpb24uaWQgYXMgb3B0aW9uLm5hbWUgfCB0cmFuc2xhdGUgZm9yIG9wdGlvbiBpbiB0by5vcHRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTZWxlY3Qgb3Igc2VhcmNoIGEgd29ya2Zsb3cgLi4uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlRXhwcmVzc2lvbjogJyFtb2RlbC5tb3JlJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1GaWVsZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ01vdGlvbkNvbW1lbnRGb3JtJywgW1xuICAgICdNb3Rpb25Db21tZW50JyxcbiAgICBmdW5jdGlvbiAoTW90aW9uQ29tbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gbmdEaWFsb2cgZm9yIG1vdGlvbiBjb21tZW50IGZvcm1cbiAgICAgICAgICAgIGdldERpYWxvZzogZnVuY3Rpb24gKG1vdGlvbiwgY29tbWVudEZpZWxkSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJ3N0YXRpYy90ZW1wbGF0ZXMvbW90aW9ucy9tb3Rpb24tY29tbWVudC1mb3JtLmh0bWwnLFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnTW90aW9uQ29tbWVudEN0cmwnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICduZ2RpYWxvZy10aGVtZS1kZWZhdWx0IHdpZGUtZm9ybScsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlFc2NhcGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUJ5RG9jdW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb25JZDogZnVuY3Rpb24gKCkge3JldHVybiBtb3Rpb24uaWQ7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRGaWVsZElkOiBmdW5jdGlvbiAoKSB7cmV0dXJuIGNvbW1lbnRGaWVsZElkO30sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBhbmd1bGFyLWZvcm1seSBmaWVsZHMgZm9yIG1vdGlvbiBjb21tZW50IGZvcm1cbiAgICAgICAgICAgIGdldEZvcm1GaWVsZHM6IGZ1bmN0aW9uIChjb21tZW50RmllbGRJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIE1vdGlvbkNvbW1lbnQuZ2V0Rm9ybUZpZWxkKGNvbW1lbnRGaWVsZElkKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdDYXRlZ29yeUZvcm0nLCBbXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICBmdW5jdGlvbiAoZ2V0dGV4dENhdGFsb2cpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldERpYWxvZzogZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL21vdGlvbnMvY2F0ZWdvcnktZm9ybS5odG1sJyxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogY2F0ZWdvcnkgPyAnQ2F0ZWdvcnlVcGRhdGVDdHJsJyA6ICdDYXRlZ29yeUNyZWF0ZUN0cmwnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICduZ2RpYWxvZy10aGVtZS1kZWZhdWx0IHdpZGUtZm9ybScsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlFc2NhcGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUJ5RG9jdW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeUlkOiBmdW5jdGlvbiAoKSB7cmV0dXJuIGNhdGVnb3J5ID8gY2F0ZWdvcnkuaWQgOiB2b2lkIDA7fSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Rm9ybUZpZWxkczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ3ByZWZpeCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnUHJlZml4JylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ25hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ05hbWUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi8vIFByb3ZpZGUgZ2VuZXJpYyBtb3Rpb25wb2xsIGZvcm0gZmllbGRzIGZvciBwb2xsIHVwZGF0ZSB2aWV3XG4uZmFjdG9yeSgnTW90aW9uUG9sbEZvcm0nLCBbXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICBmdW5jdGlvbiAoZ2V0dGV4dENhdGFsb2cpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldEZvcm1GaWVsZHM6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IE1hdGgucG93KDEwLCAtcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAneWVzJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdZZXMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnbm8nLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ05vJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2Fic3RhaW4nLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0Fic3RhaW4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAndm90ZXN2YWxpZCcsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnVmFsaWQgdm90ZXMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ3ZvdGVzaW52YWxpZCcsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnSW52YWxpZCB2b3RlcycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAndm90ZXNjYXN0JyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdWb3RlcyBjYXN0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdNb3Rpb25FeHBvcnRGb3JtJywgW1xuICAgICdvcGVyYXRvcicsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnQ29uZmlnJyxcbiAgICAnTW90aW9uQ29tbWVudCcsXG4gICAgZnVuY3Rpb24gKG9wZXJhdG9yLCBnZXR0ZXh0Q2F0YWxvZywgQ29uZmlnLCBNb3Rpb25Db21tZW50KSB7XG4gICAgICAgIHZhciBub1NwZWNpYWxDb21tZW50c0ZpZWxkcyA9IE1vdGlvbkNvbW1lbnQuZ2V0Tm9TcGVjaWFsQ29tbWVudHNGaWVsZHMoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldERpYWxvZzogZnVuY3Rpb24gKG1vdGlvbnMsIHBhcmFtcywgc2luZ2xlTW90aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL21vdGlvbnMvbW90aW9uLWV4cG9ydC1mb3JtLmh0bWwnLFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnTW90aW9uRXhwb3J0Q3RybCcsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ25nZGlhbG9nLXRoZW1lLWRlZmF1bHQgd2lkZS1mb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VCeUVzY2FwZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlEb2N1bWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvbnM6IGZ1bmN0aW9uICgpIHtyZXR1cm4gbW90aW9uczt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBmdW5jdGlvbiAoKSB7cmV0dXJuIHBhcmFtczt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2luZ2xlTW90aW9uOiBmdW5jdGlvbiAoKSB7cmV0dXJuIHNpbmdsZU1vdGlvbjt9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Rm9ybUZpZWxkczogZnVuY3Rpb24gKHNpbmdsZU1vdGlvbiwgbW90aW9ucywgZm9ybWF0Q2hhbmdlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnRzQXZhaWxhYmxlID0gXy5rZXlzKG5vU3BlY2lhbENvbW1lbnRzRmllbGRzKS5sZW5ndGggIT09IDA7XG4gICAgICAgICAgICAgICAgdmFyIHNvbWVNb3Rpb25zSGF2ZUFtZW5kbWVudHMgPSBfLnNvbWUobW90aW9ucywgZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW90aW9uLmhhc0FtZW5kbWVudHMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBpZiBhbWVuZG1lbnRzIGFtZW5kbWVudHMgYXJlIGFscmVhZHkgaW5jbHVkZWQuIFdlIG93dWRsIGhhdmUgdGhlbSB0d2ljZSwgaWYgdGhlIG9wdGlvbiBpcyBlbmFibGVkLlxuICAgICAgICAgICAgICAgIGlmIChDb25maWcuZ2V0KCdtb3Rpb25zX2FtZW5kbWVudHNfbWFpbl90YWJsZScpLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvbWVNb3Rpb25zSGF2ZUFtZW5kbWVudHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGdldE1ldGFJbmZvcm1hdGlvbk9wdGlvbnMgPSBmdW5jdGlvbiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1N1Ym1pdHRlcnMnKSwgaWQ6ICdzdWJtaXR0ZXJzJywgZGlzYWJsZWQ6IGRpc2FibGVkLnN1Ym1pdHRlcnN9LFxuICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnU3RhdGUnKSwgaWQ6ICdzdGF0ZScsIGRpc2FibGVkOiBkaXNhYmxlZC5zdGF0ZX0sXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChDb25maWcuZ2V0KCdtb3Rpb25zX3JlY29tbWVuZGF0aW9uc19ieScpLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnUmVjb21tZW5kYXRpb24nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlY29tbWVuZGF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQucmVjb21tZW5kYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLnNvbWUobW90aW9ucywgZnVuY3Rpb24gKG1vdGlvbikgeyByZXR1cm4gbW90aW9uLmNhdGVnb3J5OyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0NhdGVnb3J5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdjYXRlZ29yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLmNhdGVnb3J5LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uc29tZShtb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7IHJldHVybiBtb3Rpb24ubW90aW9uQmxvY2s7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnTW90aW9uIGJsb2NrJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdtb3Rpb25CbG9jaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLm1vdGlvbkJsb2NrLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uc29tZShtb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7IHJldHVybiBtb3Rpb24ub3JpZ2luOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ09yaWdpbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnb3JpZ2luJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQub3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnVm90aW5nIHJlc3VsdCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICd2b3RpbmdyZXN1bHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLnZvdGluZ1Jlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIXNpbmdsZU1vdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnZm9ybWF0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmFkaW8tYnV0dG9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0Zvcm1hdCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ1BERicsIHZhbHVlOiAncGRmJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0NTVicsIHZhbHVlOiAnY3N2J30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0RPQ1gnLCB2YWx1ZTogJ2RvY3gnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiBmb3JtYXRDaGFuZ2VDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc29tZU1vdGlvbnNIYXZlQW1lbmRtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdhbWVuZG1lbnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyYWRpby1idXR0b25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0FtZW5kbWVudHMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0luY2x1ZGUnKSwgdmFsdWU6IHRydWV9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdFeGNsdWRlJyksIHZhbHVlOiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3IuaGFzUGVybXMoJ21vdGlvbnMuY2FuX21hbmFnZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoLmFwcGx5KGZpZWxkcywgW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2xpbmVOdW1iZXJNb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmFkaW8tYnV0dG9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0xpbmUgbnVtYmVyaW5nJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ05vbmUnKSwgdmFsdWU6ICdub25lJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdpbmxpbmUnKSwgdmFsdWU6ICdpbmxpbmUnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ291dHNpZGUnKSwgdmFsdWU6ICdvdXRzaWRlJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlRXhwcmVzc2lvbjogXCJtb2RlbC5mb3JtYXQgIT09ICdwZGYnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2xpbmVOdW1iZXJNb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmFkaW8tYnV0dG9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0xpbmUgbnVtYmVyaW5nJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ05vbmUnKSwgdmFsdWU6ICdub25lJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdpbmxpbmUnKSwgdmFsdWU6ICdpbmxpbmUnLCBkaXNhYmxlZDogdHJ1ZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdvdXRzaWRlJyksIHZhbHVlOiAnb3V0c2lkZScsIGRpc2FibGVkOiB0cnVlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVFeHByZXNzaW9uOiBcIm1vZGVsLmZvcm1hdCA9PT0gJ3BkZidcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnY2hhbmdlUmVjb21tZW5kYXRpb25Nb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmFkaW8tYnV0dG9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0NoYW5nZSByZWNvbW1lbmRhdGlvbnMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnT3JpZ2luYWwgdmVyc2lvbicpLCB2YWx1ZTogJ29yaWdpbmFsJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdDaGFuZ2VkIHZlcnNpb24nKSwgdmFsdWU6ICdjaGFuZ2VkJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdEaWZmIHZlcnNpb24nKSwgdmFsdWU6ICdkaWZmJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdGaW5hbCB2ZXJzaW9uJyksIHZhbHVlOiAnbW9kaWZpZWRfYWdyZWVkJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlRXhwcmVzc2lvbjogXCJtb2RlbC5mb3JtYXQgIT09ICdwZGYnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NoYW5nZVJlY29tbWVuZGF0aW9uTW9kZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3JhZGlvLWJ1dHRvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdDaGFuZ2UgcmVjb21tZW5kYXRpb25zJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ09yaWdpbmFsIHZlcnNpb24nKSwgdmFsdWU6ICdvcmlnaW5hbCd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQ2hhbmdlZCB2ZXJzaW9uJyksIHZhbHVlOiAnY2hhbmdlZCd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnRGlmZiB2ZXJzaW9uJyksIHZhbHVlOiAnZGlmZicsIGRpc2FibGVkOiB0cnVlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0ZpbmFsIHZlcnNpb24nKSwgdmFsdWU6ICdtb2RpZmllZF9hZ3JlZWQnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVFeHByZXNzaW9uOiBcIm1vZGVsLmZvcm1hdCA9PT0gJ3BkZidcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnaW5jbHVkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94LWJ1dHRvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdDb250ZW50JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1RleHQnKSwgaWQ6ICd0ZXh0J30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdSZWFzb24nKSwgaWQ6ICdyZWFzb24nfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdpbmNsdWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gtYnV0dG9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ01ldGEgaW5mb3JtYXRpb24nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogZ2V0TWV0YUluZm9ybWF0aW9uT3B0aW9ucygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZUV4cHJlc3Npb246IFwibW9kZWwuZm9ybWF0ICE9PSAncGRmJ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdpbmNsdWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gtYnV0dG9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ01ldGEgaW5mb3JtYXRpb24nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogZ2V0TWV0YUluZm9ybWF0aW9uT3B0aW9ucyh7dm90aW5nUmVzdWx0OiB0cnVlfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlRXhwcmVzc2lvbjogXCJtb2RlbC5mb3JtYXQgIT09ICdjc3YnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnaW5jbHVkZUNvbW1lbnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gtYnV0dG9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0NvbW1lbnRzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IF8ubWFwKG5vU3BlY2lhbENvbW1lbnRzRmllbGRzLCBmdW5jdGlvbiAoZmllbGQsIGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZyhmaWVsZC5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVFeHByZXNzaW9uOiBcIm1vZGVsLmZvcm1hdCA9PT0gJ2NzdidcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2luZ2xlTW90aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ3BkZkZvcm1hdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmFkaW8tYnV0dG9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdQREYgZm9ybWF0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdPbmUgUERGJyksIHZhbHVlOiAncGRmJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ011bHRpcGxlIFBERnMgaW4gYSB6aXAgYXJjaXZlJyksIHZhbHVlOiAnemlwJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlRXhwcmVzc2lvbjogXCJtb2RlbC5mb3JtYXQgIT09ICdwZGYnXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignTW90aW9uRXhwb3J0Q3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnQ29uZmlnJyxcbiAgICAnTW90aW9uRXhwb3J0Rm9ybScsXG4gICAgJ01vdGlvblBkZkV4cG9ydCcsXG4gICAgJ01vdGlvbkNzdkV4cG9ydCcsXG4gICAgJ01vdGlvbkRvY3hFeHBvcnQnLFxuICAgICdtb3Rpb25zJyxcbiAgICAncGFyYW1zJyxcbiAgICAnc2luZ2xlTW90aW9uJyxcbiAgICBmdW5jdGlvbiAoJHNjb3BlLCBDb25maWcsIE1vdGlvbkV4cG9ydEZvcm0sIE1vdGlvblBkZkV4cG9ydCwgTW90aW9uQ3N2RXhwb3J0LFxuICAgICAgICAgICAgTW90aW9uRG9jeEV4cG9ydCwgbW90aW9ucywgcGFyYW1zLCBzaW5nbGVNb3Rpb24pIHtcbiAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHMgPSBNb3Rpb25FeHBvcnRGb3JtLmdldEZvcm1GaWVsZHMoc2luZ2xlTW90aW9uLCBtb3Rpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoJHNjb3BlLnBhcmFtcy5mb3JtYXQgIT09ICdwZGYnKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnBhcmFtcy5jaGFuZ2VSZWNvbW1lbmRhdGlvbk1vZGUgPSAnb3JpZ2luYWwnO1xuICAgICAgICAgICAgICAgICRzY29wZS5wYXJhbXMubGluZU51bWJlck1vZGUgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnBhcmFtcy5pbmNsdWRlLnZvdGluZ3Jlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCRzY29wZS5wYXJhbXMuZm9ybWF0ID09PSAnZG9jeCcpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUucGFyYW1zLmluY2x1ZGUuc3RhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUucGFyYW1zLmluY2x1ZGUuc3VibWl0dGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUucGFyYW1zLmluY2x1ZGUubW90aW9uQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUucGFyYW1zLmluY2x1ZGUub3JpZ2luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnBhcmFtcy5pbmNsdWRlLnJlY29tbWVuZGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRzY29wZS5wYXJhbXMuaW5jbHVkZS5zdGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnBhcmFtcy5pbmNsdWRlLm1vdGlvbkJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUucGFyYW1zLmluY2x1ZGUub3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUucGFyYW1zLmluY2x1ZGUucmVjb21tZW5kYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCRzY29wZS5wYXJhbXMuZm9ybWF0ID09PSAncGRmJykge1xuICAgICAgICAgICAgICAgICRzY29wZS5wYXJhbXMuaW5jbHVkZS5zdGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnBhcmFtcy5pbmNsdWRlLnZvdGluZ3Jlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAkc2NvcGUucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICBfLmRlZmF1bHRzKCRzY29wZS5wYXJhbXMsIHtcbiAgICAgICAgICAgIGZvcm1hdDogJ3BkZicsXG4gICAgICAgICAgICBwZGZGb3JtYXQ6ICdwZGYnLFxuICAgICAgICAgICAgY2hhbmdlUmVjb21tZW5kYXRpb25Nb2RlOiBDb25maWcuZ2V0KCdtb3Rpb25zX3JlY29tbWVuZGF0aW9uX3RleHRfbW9kZScpLnZhbHVlLFxuICAgICAgICAgICAgbGluZU51bWJlck1vZGU6IENvbmZpZy5nZXQoJ21vdGlvbnNfZGVmYXVsdF9saW5lX251bWJlcmluZycpLnZhbHVlLFxuICAgICAgICAgICAgYW1lbmRtZW50czogZmFsc2UsXG4gICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgdGV4dDogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZWFzb246IHRydWUsXG4gICAgICAgICAgICAgICAgc3RhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IHRydWUsXG4gICAgICAgICAgICAgICAgc3VibWl0dGVyczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2b3RpbmdyZXN1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbW90aW9uQmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlY29tbWVuZGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluY2x1ZGVDb21tZW50czoge30sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBbHdheXMgY2hhbmdlIHRoZSBtb2RlIGZyb20gYWdyZWVkIHRvIG1vZGlmaWVkX2FncmVlZC4gSWYgYSBtb3Rpb24gZG9lcyBub3QgaGF2ZSBhIG1vZGlmaWVkXG4gICAgICAgIC8vIGZpbmFsIHZlcnNpb24sIHRoZSBhZ3JlZWQgd2lsbCBiZSB0YWtlbi5cbiAgICAgICAgaWYgKCRzY29wZS5wYXJhbXMuY2hhbmdlUmVjb21tZW5kYXRpb25Nb2RlID09PSAnYWdyZWVkJykge1xuICAgICAgICAgICAgJHNjb3BlLnBhcmFtcy5jaGFuZ2VSZWNvbW1lbmRhdGlvbk1vZGUgPSAnbW9kaWZpZWRfYWdyZWVkJztcbiAgICAgICAgfVxuICAgICAgICAkc2NvcGUubW90aW9ucyA9IG1vdGlvbnM7XG4gICAgICAgICRzY29wZS5zaW5nbGVNb3Rpb24gPSBzaW5nbGVNb3Rpb247XG5cbiAgICAgICAgLy8gQWRkIGFtZW5kbWVudHMgdG8gbW90aW9ucy4gVGhlIGFtZW5kbWVudHMgYXJlIHNvcnRlZCBieSB0aGVpciBpZGVudGlmaWVyXG4gICAgICAgIHZhciBwcmVwYXJlQW1lbmRtZW50cyA9IGZ1bmN0aW9uIChtb3Rpb25zKSB7XG4gICAgICAgICAgICB2YXIgYWxsTW90aW9ucyA9IFtdO1xuICAgICAgICAgICAgXy5mb3JFYWNoKG1vdGlvbnMsIGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgICAgICBhbGxNb3Rpb25zLnB1c2gobW90aW9uKTtcbiAgICAgICAgICAgICAgICBhbGxNb3Rpb25zID0gYWxsTW90aW9ucy5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgIF8uc29ydEJ5KG1vdGlvbi5nZXRBbWVuZG1lbnRzKCksIGZ1bmN0aW9uIChhbWVuZG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbWVuZG1lbnQuaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWxsTW90aW9ucztcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuZXhwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCRzY29wZS5wYXJhbXMuYW1lbmRtZW50cykge1xuICAgICAgICAgICAgICAgIG1vdGlvbnMgPSBwcmVwYXJlQW1lbmRtZW50cyhtb3Rpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoJHNjb3BlLnBhcmFtcy5mb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdwZGYnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLnBhcmFtcy5wZGZGb3JtYXQgPT09ICdwZGYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBNb3Rpb25QZGZFeHBvcnQuZXhwb3J0KG1vdGlvbnMsICRzY29wZS5wYXJhbXMsIHNpbmdsZU1vdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBNb3Rpb25QZGZFeHBvcnQuZXhwb3J0WmlwKG1vdGlvbnMsICRzY29wZS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nzdic6XG4gICAgICAgICAgICAgICAgICAgIE1vdGlvbkNzdkV4cG9ydC5leHBvcnQobW90aW9ucywgJHNjb3BlLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvY3gnOlxuICAgICAgICAgICAgICAgICAgICBNb3Rpb25Eb2N4RXhwb3J0LmV4cG9ydChtb3Rpb25zLCAkc2NvcGUucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUuY2xvc2VUaGlzRGlhbG9nKCk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLy8gQ2FjaGUgZm9yIE1vdGlvblBvbGxEZXRhaWxDdHJsIHNvIHRoYXQgdXNlcnMgY2hvaWNlcyBhcmUga2VlcGVkIGR1cmluZyB1c2VyIGFjdGlvbnMgKGUuIGcuIHNhdmUgcG9sbCBmb3JtKS5cbi52YWx1ZSgnTW90aW9uUG9sbERldGFpbEN0cmxDYWNoZScsIHt9KVxuXG4vLyBDaGlsZCBjb250cm9sbGVyIG9mIE1vdGlvbkRldGFpbEN0cmwgZm9yIGVhY2ggc2luZ2xlIHBvbGwuXG4uY29udHJvbGxlcignTW90aW9uUG9sbERldGFpbEN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ01ham9yaXR5TWV0aG9kQ2hvaWNlcycsXG4gICAgJ0NvbmZpZycsXG4gICAgJ01vdGlvblBvbGxEZXRhaWxDdHJsQ2FjaGUnLFxuICAgICdNb3Rpb25Qb2xsRGVjaW1hbFBsYWNlcycsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgTWFqb3JpdHlNZXRob2RDaG9pY2VzLCBDb25maWcsIE1vdGlvblBvbGxEZXRhaWxDdHJsQ2FjaGUsIE1vdGlvblBvbGxEZWNpbWFsUGxhY2VzKSB7XG4gICAgICAgIC8vIERlZmluZSBjaG9pY2VzLlxuICAgICAgICAkc2NvcGUubWV0aG9kQ2hvaWNlcyA9IE1ham9yaXR5TWV0aG9kQ2hvaWNlcztcbiAgICAgICAgLy8gVE9ETzogR2V0ICRzY29wZS5iYXNlQ2hvaWNlcyBmcm9tIGNvbmZpZ192YXJpYWJsZXMucHkgd2l0aG91dCBjb3B5aW5nIHRoZW0uXG5cbiAgICAgICAgJHNjb3BlLnZvdGVzUHJlY2lzaW9uID0gTW90aW9uUG9sbERlY2ltYWxQbGFjZXMuZ2V0UGxhY2VzKCRzY29wZS5wb2xsKTtcblxuICAgICAgICAvLyBTZXR1cCBlbXB0eSBjYWNoZSB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICBpZiAodHlwZW9mIE1vdGlvblBvbGxEZXRhaWxDdHJsQ2FjaGVbJHNjb3BlLnBvbGwuaWRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgTW90aW9uUG9sbERldGFpbEN0cmxDYWNoZVskc2NvcGUucG9sbC5pZF0gPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAkc2NvcGUuY29uZmlnKCdtb3Rpb25zX3BvbGxfZGVmYXVsdF9tYWpvcml0eV9tZXRob2QnKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGZXRjaCB1c2VycyBjaG9pY2VzIGZyb20gY2FjaGUuXG4gICAgICAgICRzY29wZS5tZXRob2QgPSBNb3Rpb25Qb2xsRGV0YWlsQ3RybENhY2hlWyRzY29wZS5wb2xsLmlkXS5tZXRob2Q7XG5cbiAgICAgICAgLy8gRGVmaW5lIHJlc3VsdCBmdW5jdGlvbi5cbiAgICAgICAgJHNjb3BlLmlzUmVhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAkc2NvcGUucG9sbC5pc1JlYWNoZWQoJHNjb3BlLm1ldGhvZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGVmaW5lIHRlbXBsYXRlIGNvbnRyb2xsIGZ1bmN0aW9uXG4gICAgICAgICRzY29wZS5oaWRlTWFqb3JpdHlDYWxjdWxhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgJHNjb3BlLmlzUmVhY2hlZCgpID09PSAndW5kZWZpbmVkJyAmJiAkc2NvcGUubWV0aG9kICE9PSAnZGlzYWJsZWQnO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNhdmUgY3VycmVudCB2YWx1ZXMgdG8gY2FjaGUgb24gZGV0cm95IG9mIHRoaXMgY29udHJvbGxlci5cbiAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIE1vdGlvblBvbGxEZXRhaWxDdHJsQ2FjaGVbJHNjb3BlLnBvbGwuaWRdID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJHNjb3BlLm1ldGhvZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdNb3Rpb25MaXN0Q3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJHN0YXRlJyxcbiAgICAnJGh0dHAnLFxuICAgICdnZXR0ZXh0JyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdvcGVyYXRvcicsXG4gICAgJ25nRGlhbG9nJyxcbiAgICAnTW90aW9uRm9ybScsXG4gICAgJ01vdGlvbicsXG4gICAgJ01vdGlvbkNvbW1lbnQnLFxuICAgICdDYXRlZ29yeScsXG4gICAgJ0NvbmZpZycsXG4gICAgJ1RhZycsXG4gICAgJ1dvcmtmbG93JyxcbiAgICAnVXNlcicsXG4gICAgJ0FnZW5kYScsXG4gICAgJ01vdGlvbkJsb2NrJyxcbiAgICAnUHJvamVjdG9yJyxcbiAgICAnUHJvamVjdGlvbkRlZmF1bHQnLFxuICAgICdvc1RhYmxlRmlsdGVyJyxcbiAgICAnb3NUYWJsZVNvcnQnLFxuICAgICdvc1RhYmxlUGFnaW5hdGlvbicsXG4gICAgJ01vdGlvbkV4cG9ydEZvcm0nLFxuICAgICdNb3Rpb25QZGZFeHBvcnQnLFxuICAgICdQZXJzb25hbE5vdGVNYW5hZ2VyJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSwgJGh0dHAsIGdldHRleHQsIGdldHRleHRDYXRhbG9nLCBvcGVyYXRvciwgbmdEaWFsb2csIE1vdGlvbkZvcm0sIE1vdGlvbixcbiAgICAgICAgICAgICAgICBNb3Rpb25Db21tZW50LCBDYXRlZ29yeSwgQ29uZmlnLCBUYWcsIFdvcmtmbG93LCBVc2VyLCBBZ2VuZGEsIE1vdGlvbkJsb2NrLCBQcm9qZWN0b3IsXG4gICAgICAgICAgICAgICAgUHJvamVjdGlvbkRlZmF1bHQsIG9zVGFibGVGaWx0ZXIsIG9zVGFibGVTb3J0LCBvc1RhYmxlUGFnaW5hdGlvbiwgTW90aW9uRXhwb3J0Rm9ybSxcbiAgICAgICAgICAgICAgICBNb3Rpb25QZGZFeHBvcnQsIFBlcnNvbmFsTm90ZU1hbmFnZXIpIHtcbiAgICAgICAgQ2F0ZWdvcnkuYmluZEFsbCh7fSwgJHNjb3BlLCAnY2F0ZWdvcmllcycpO1xuICAgICAgICBNb3Rpb25CbG9jay5iaW5kQWxsKHt9LCAkc2NvcGUsICdtb3Rpb25CbG9ja3MnKTtcbiAgICAgICAgVGFnLmJpbmRBbGwoe30sICRzY29wZSwgJ3RhZ3MnKTtcbiAgICAgICAgV29ya2Zsb3cuYmluZEFsbCh7fSwgJHNjb3BlLCAnd29ya2Zsb3dzJyk7XG4gICAgICAgIFVzZXIuYmluZEFsbCh7fSwgJHNjb3BlLCAndXNlcnMnKTtcbiAgICAgICAgUHJvamVjdG9yLmJpbmRBbGwoe30sICRzY29wZSwgJ3Byb2plY3RvcnMnKTtcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvamVjdG9yLmxhc3RNb2RpZmllZCgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJvamVjdGlvbmRlZmF1bHQgPSBQcm9qZWN0aW9uRGVmYXVsdC5maWx0ZXIoe25hbWU6ICdtb3Rpb25zJ30pWzBdO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rpb25kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlZmF1bHRQcm9qZWN0b3JJZCA9IHByb2plY3Rpb25kZWZhdWx0LnByb2plY3Rvcl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1vdGlvbi5sYXN0TW9kaWZpZWQoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gZ2V0IGFsbCBtYWluIG1vdGlvbnMgYW5kIG9yZGVyIGJ5IGlkZW50aWZpZXIgKGFmdGVyIGN1c3RvbSBvcmRlcmluZylcbiAgICAgICAgICAgIHZhciBtb3Rpb25zO1xuICAgICAgICAgICAgaWYgKENvbmZpZy5nZXQoJ21vdGlvbnNfYW1lbmRtZW50c19tYWluX3RhYmxlJykudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtb3Rpb25zID0gTW90aW9uLmdldEFsbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3Rpb25zID0gTW90aW9uLmZpbHRlcih7cGFyZW50X2lkOiB1bmRlZmluZWR9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJHNjb3BlLm1vdGlvbnMgPSBfLm9yZGVyQnkobW90aW9ucywgWydpZGVudGlmaWVyJ10pO1xuICAgICAgICAgICAgXy5mb3JFYWNoKCRzY29wZS5tb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgTW90aW9uQ29tbWVudC5wb3B1bGF0ZUZpZWxkcyhtb3Rpb24pO1xuICAgICAgICAgICAgICAgIG1vdGlvbi5wZXJzb25hbE5vdGUgPSBQZXJzb25hbE5vdGVNYW5hZ2VyLmdldE5vdGUobW90aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBGb3IgZmlsdGVyaW5nLCB3ZSBjYW5ub3QgZmlsdGVyIGZvciAucGVyc29uYWxOb3RlLnN0YXJcbiAgICAgICAgICAgICAgICBtb3Rpb24uc3RhciA9IG1vdGlvbi5wZXJzb25hbE5vdGUgPyBtb3Rpb24ucGVyc29uYWxOb3RlLnN0YXIgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICBtb3Rpb24uaGFzUGVyc29uYWxOb3RlID0gbW90aW9uLnBlcnNvbmFsTm90ZSA/ICEhbW90aW9uLnBlcnNvbmFsTm90ZS5ub3RlIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKG1vdGlvbi5zdGFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW90aW9uLnN0YXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzY29wZS5jb2xsZWN0U3RhdGVzQW5kUmVjb21tZW5kYXRpb25zKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcblxuICAgICAgICAvLyBNb3Rpb24gY29tbWVudHNcbiAgICAgICAgJHNjb3BlLm5vU3BlY2lhbENvbW1lbnRzRmllbGRzID0gTW90aW9uQ29tbWVudC5nZXROb1NwZWNpYWxDb21tZW50c0ZpZWxkcygpO1xuICAgICAgICAkc2NvcGUuc2hvd0NvbW1lbnRzRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF8ua2V5cygkc2NvcGUubm9TcGVjaWFsQ29tbWVudHNGaWVsZHMpLmxlbmd0aCA+IDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY29sbGVjdCBhbGwgc3RhdGVzIGFuZCBhbGwgcmVjb21tZW5kYXRpb25zIG9mIGFsbCB3b3JrZmxvd3NcbiAgICAgICAgJHNjb3BlLmNvbGxlY3RTdGF0ZXNBbmRSZWNvbW1lbmRhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IElmIGl0IGlzIHRoZSBmaXJzdCB0aW1lIHVwZGF0ZWQsIHVwZGF0ZSB0aGUgc3RhdGUgZmlsdGVyLlxuICAgICAgICAgICAgLy8gVGhpcyBjYXVzZXMgdG8gc2V0IHRoZSBkb25lL3VuZG9uZSBzdGF0ZXMgY29ycmVjdCBvbiBwYWdlIGxvYWQuXG4gICAgICAgICAgICB2YXIgZG9TdGF0ZUZpbHRlclVwZGF0ZSA9ICEkc2NvcGUuc3RhdGVzO1xuICAgICAgICAgICAgJHNjb3BlLnN0YXRlcyA9IFtdO1xuICAgICAgICAgICAgJHNjb3BlLnJlY29tbWVuZGF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdmFyIHdvcmtmbG93cyA9ICRzY29wZS5jb2xsZWN0QWxsVXNlZFdvcmtmbG93cygpO1xuICAgICAgICAgICAgXy5mb3JFYWNoKHdvcmtmbG93cywgZnVuY3Rpb24gKHdvcmtmbG93KSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtmbG93cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3b3JrZmxvd0hlYWRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcm5hbWU6IHdvcmtmbG93Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZmxvd0hlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnN0YXRlcy5wdXNoKHdvcmtmbG93SGVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlY29tbWVuZGF0aW9ucy5wdXNoKHdvcmtmbG93SGVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RFbmRTdGF0ZVNlZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goXy5vcmRlckJ5KHdvcmtmbG93LnN0YXRlcywgJ2lkJyksIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUubmV4dF9zdGF0ZXNfaWQubGVuZ3RoID09PSAwICYmICFmaXJzdEVuZFN0YXRlU2Vlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnN0YXRlcy5wdXNoKHtkaXZpZGVyOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEVuZFN0YXRlU2VlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnJlY29tbWVuZGF0aW9uX2xhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUucmVjb21tZW5kYXRpb25zLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkb1N0YXRlRmlsdGVyVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlU3RhdGVGaWx0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmNvbGxlY3RBbGxVc2VkV29ya2Zsb3dzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF8uZmlsdGVyKFdvcmtmbG93LmdldEFsbCgpLCBmdW5jdGlvbiAod29ya2Zsb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zb21lKCRzY29wZS5tb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb3Rpb24uc3RhdGUud29ya2Zsb3dfaWQgPT09IHdvcmtmbG93LmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLnN0YXRlRmlsdGVyID0gW107XG4gICAgICAgIHZhciB1cGRhdGVTdGF0ZUZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5zdGF0ZUZpbHRlciA9IF8uY2xvbmUoJHNjb3BlLmZpbHRlci5tdWx0aXNlbGVjdEZpbHRlcnMuc3RhdGUpO1xuXG4gICAgICAgICAgICB2YXIgZG9uZUluZGV4ID0gXy5pbmRleE9mKCRzY29wZS5zdGF0ZUZpbHRlciwgLTEpO1xuICAgICAgICAgICAgaWYgKGRvbmVJbmRleCA+IC0xKSB7IC8vIGNvbnRhaW5zIC0xIChkb25lKVxuICAgICAgICAgICAgICAgICRzY29wZS5zdGF0ZUZpbHRlci5zcGxpY2UoZG9uZUluZGV4LCAxKTsgLy8gcmVtb3ZlIC0xXG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKCRzY29wZS5zdGF0ZXMsIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLndvcmtmbG93SGVhZGVyICYmICFzdGF0ZS5kaXZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUubmV4dF9zdGF0ZXNfaWQubGVuZ3RoID09PSAwKSB7IC8vIGFkZCBhbGwgZG9uZSBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zdGF0ZUZpbHRlci5wdXNoKHN0YXRlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdW5kb25lSW5kZXggPSBfLmluZGV4T2YoJHNjb3BlLnN0YXRlRmlsdGVyLCAtMik7XG4gICAgICAgICAgICBpZiAodW5kb25lSW5kZXggPiAtMSkgeyAvLyBjb250YWlucyAtMiAodW5kb25lKVxuICAgICAgICAgICAgICAgICRzY29wZS5zdGF0ZUZpbHRlci5zcGxpY2UodW5kb25lSW5kZXgsIDEpOyAvLyByZW1vdmUgLTJcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goJHNjb3BlLnN0YXRlcywgZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUud29ya2Zsb3dIZWFkZXIgJiYgIXN0YXRlLmRpdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5uZXh0X3N0YXRlc19pZC5sZW5ndGggIT09IDApIHsgLy8gYWRkIGFsbCB1bmRvbmUgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3RhdGVGaWx0ZXIucHVzaChzdGF0ZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5zdGF0ZUZpbHRlciA9IF8udW5pcSgkc2NvcGUuc3RhdGVGaWx0ZXIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRoaXMgdmFsdWUgbWF5IGJlIG92ZXJyaXR0ZW4sIHNvIHRoZSBmaWx0ZXJzLCBzb3J0aW5nIGFuZCBwYWdpbmF0aW9uIGluIGFuXG4gICAgICAgIC8vIGRlcml2ZWQgdmlldyBhcmUgaW5kZXBlbmRlbnQgdG8gdGhpcyB2aWV3LlxuICAgICAgICB2YXIgb3NUYWJsZVByZWZpeCA9ICRzY29wZS5vc1RhYmxlUHJlZml4IHx8ICdNb3Rpb25UYWJsZSc7XG5cbiAgICAgICAgLy8gRmlsdGVyaW5nXG4gICAgICAgICRzY29wZS5maWx0ZXIgPSBvc1RhYmxlRmlsdGVyLmNyZWF0ZUluc3RhbmNlKG9zVGFibGVQcmVmaXggKyAnRmlsdGVyJyk7XG5cbiAgICAgICAgaWYgKCEkc2NvcGUuZmlsdGVyLmV4aXN0c1N0b3JhZ2VFbnRyeSgpKSB7XG4gICAgICAgICAgICAkc2NvcGUuZmlsdGVyLm11bHRpc2VsZWN0RmlsdGVycyA9IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogW10sXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IFtdLFxuICAgICAgICAgICAgICAgIG1vdGlvbkJsb2NrOiBbXSxcbiAgICAgICAgICAgICAgICB0YWc6IFtdLFxuICAgICAgICAgICAgICAgIHJlY29tbWVuZGF0aW9uOiBbXSxcbiAgICAgICAgICAgICAgICBjb21tZW50OiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAkc2NvcGUuZmlsdGVyLmJvb2xlYW5GaWx0ZXJzID0ge1xuICAgICAgICAgICAgICAgIGlzRmF2b3JpdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlWWVzOiBnZXR0ZXh0KCdNYXJrZWQgYXMgZmF2b3JpdGUnKSxcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlTm86IGdldHRleHQoJ05vdCBtYXJrZWQgYXMgZmF2b3JpdGUnKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhc1BlcnNvbmFsTm90ZToge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBjaG9pY2VZZXM6IGdldHRleHQoJ1BlcnNvbmFsIG5vdGUgc2V0JyksXG4gICAgICAgICAgICAgICAgICAgIGNob2ljZU5vOiBnZXR0ZXh0KCdQZXJzb25hbCBub3RlIG5vdCBzZXQnKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAkc2NvcGUuZmlsdGVyLnByb3BlcnR5TGlzdCA9IFsnaWRlbnRpZmllcicsICdvcmlnaW4nXTtcbiAgICAgICAgJHNjb3BlLmZpbHRlci5wcm9wZXJ0eUZ1bmN0aW9uTGlzdCA9IFtcbiAgICAgICAgICAgIGZ1bmN0aW9uIChtb3Rpb24pIHtyZXR1cm4gbW90aW9uLmdldFRpdGxlKCk7fSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChtb3Rpb24pIHtyZXR1cm4gbW90aW9uLmNhdGVnb3J5ID8gbW90aW9uLmNhdGVnb3J5Lm5hbWUgOiAnJzt9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKG1vdGlvbikge3JldHVybiBtb3Rpb24ubW90aW9uQmxvY2sgPyBtb3Rpb24ubW90aW9uQmxvY2submFtZSA6ICcnO30sXG4gICAgICAgICAgICBmdW5jdGlvbiAobW90aW9uKSB7cmV0dXJuIG1vdGlvbi5yZWNvbW1lbmRhdGlvbiA/IG1vdGlvbi5nZXRSZWNvbW1lbmRhdGlvbk5hbWUoKSA6ICcnO30sXG4gICAgICAgIF07XG4gICAgICAgICRzY29wZS5maWx0ZXIucHJvcGVydHlEaWN0ID0ge1xuICAgICAgICAgICAgJ3N1Ym1pdHRlcnMnOiBmdW5jdGlvbiAoc3VibWl0dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Ym1pdHRlci51c2VyLmdldF9zaG9ydF9uYW1lKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3N1cHBvcnRlcnMnOiBmdW5jdGlvbiAoc3VwcG9ydGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnRlci5nZXRfc2hvcnRfbmFtZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd0YWdzJzogZnVuY3Rpb24gKHRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YWcubmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5nZXRJdGVtSWQgPSB7XG4gICAgICAgICAgICBzdGF0ZTogZnVuY3Rpb24gKG1vdGlvbikge3JldHVybiBtb3Rpb24uc3RhdGVfaWQ7fSxcbiAgICAgICAgICAgIGNvbW1lbnQ6IGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgaWRzID0gW107XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKG1vdGlvbi5jb21tZW50cywgZnVuY3Rpb24gKGNvbW1lbnQsIGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhdGVnb3J5OiBmdW5jdGlvbiAobW90aW9uKSB7cmV0dXJuIG1vdGlvbi5jYXRlZ29yeV9pZDt9LFxuICAgICAgICAgICAgbW90aW9uQmxvY2s6IGZ1bmN0aW9uIChtb3Rpb24pIHtyZXR1cm4gbW90aW9uLm1vdGlvbl9ibG9ja19pZDt9LFxuICAgICAgICAgICAgdGFnOiBmdW5jdGlvbiAobW90aW9uKSB7cmV0dXJuIG1vdGlvbi50YWdzX2lkO30sXG4gICAgICAgICAgICByZWNvbW1lbmRhdGlvbjogZnVuY3Rpb24gKG1vdGlvbikge3JldHVybiBtb3Rpb24ucmVjb21tZW5kYXRpb25faWQ7fSxcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLm9wZXJhdGVTdGF0ZUZpbHRlciA9IGZ1bmN0aW9uIChpZCwgZGFuZ2VyKSB7XG4gICAgICAgICAgICAkc2NvcGUuZmlsdGVyLm9wZXJhdGVNdWx0aXNlbGVjdEZpbHRlcignc3RhdGUnLCBpZCwgZGFuZ2VyKTtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlRmlsdGVyKCk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5yZXNldEZpbHRlcnMgPSBmdW5jdGlvbiAoZGFuZ2VyKSB7XG4gICAgICAgICAgICAkc2NvcGUuZmlsdGVyLnJlc2V0KGRhbmdlcik7XG4gICAgICAgICAgICB1cGRhdGVTdGF0ZUZpbHRlcigpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBTb3J0aW5nXG4gICAgICAgICRzY29wZS5zb3J0ID0gb3NUYWJsZVNvcnQuY3JlYXRlSW5zdGFuY2Uob3NUYWJsZVByZWZpeCArICdTb3J0Jyk7XG4gICAgICAgIGlmICghJHNjb3BlLnNvcnQuY29sdW1uKSB7XG4gICAgICAgICAgICAkc2NvcGUuc29ydC5jb2x1bW4gPSAnaWRlbnRpZmllcic7XG4gICAgICAgIH1cbiAgICAgICAgJHNjb3BlLnNvcnRPcHRpb25zID0gW1xuICAgICAgICAgICAge25hbWU6ICdpZGVudGlmaWVyJyxcbiAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGdldHRleHQoJ0lkZW50aWZpZXInKX0sXG4gICAgICAgICAgICB7bmFtZTogJ2dldFRpdGxlKCknLFxuICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogZ2V0dGV4dCgnVGl0bGUnKX0sXG4gICAgICAgICAgICB7bmFtZTogJ3N1Ym1pdHRlcnNbMF0udXNlci5nZXRfc2hvcnRfbmFtZSgpJyxcbiAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGdldHRleHQoJ1N1Ym1pdHRlcnMnKX0sXG4gICAgICAgICAgICB7bmFtZTogJ2NhdGVnb3J5LicgKyBDb25maWcuZ2V0KCdtb3Rpb25zX2V4cG9ydF9jYXRlZ29yeV9zb3J0aW5nJykudmFsdWUsXG4gICAgICAgICAgICAgZGlzcGxheV9uYW1lOiBnZXR0ZXh0KCdDYXRlZ29yeScpfSxcbiAgICAgICAgICAgIHtuYW1lOiAnbW90aW9uQmxvY2sudGl0bGUnLFxuICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogZ2V0dGV4dCgnTW90aW9uIGJsb2NrJyl9LFxuICAgICAgICAgICAge25hbWU6ICdzdGF0ZS5uYW1lJyxcbiAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGdldHRleHQoJ1N0YXRlJyl9LFxuICAgICAgICAgICAge25hbWU6ICdsb2dfbWVzc2FnZXNbbG9nX21lc3NhZ2VzLmxlbmd0aC0xXS50aW1lJyxcbiAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGdldHRleHQoJ0NyZWF0aW9uIGRhdGUnKX0sXG4gICAgICAgICAgICB7bmFtZTogJ2xvZ19tZXNzYWdlc1swXS50aW1lJyxcbiAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGdldHRleHQoJ0xhc3QgbW9kaWZpZWQnKX0sXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gcGFnaW5hdGlvblxuICAgICAgICAkc2NvcGUucGFnaW5hdGlvbiA9IG9zVGFibGVQYWdpbmF0aW9uLmNyZWF0ZUluc3RhbmNlKG9zVGFibGVQcmVmaXggKyAnUGFnaW5hdGlvbicpO1xuXG4gICAgICAgICRzY29wZS5oYXNUYWcgPSBmdW5jdGlvbiAobW90aW9uLCB0YWcpIHtcbiAgICAgICAgICAgIHJldHVybiBfLmluZGV4T2YobW90aW9uLnRhZ3NfaWQsIHRhZy5pZCkgPiAtMTtcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuc2F2ZSA9IGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgIE1vdGlvbi5zYXZlKG1vdGlvbiwge21ldGhvZDogJ1BBVENIJ30pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBkZWxldGUgc2luZ2xlIG1vdGlvblxuICAgICAgICAkc2NvcGUuZGVsZXRlID0gZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgTW90aW9uLmRlc3Ryb3kobW90aW9uLmlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLnRvZ2dsZVRhZyA9IGZ1bmN0aW9uIChtb3Rpb24sIHRhZykge1xuICAgICAgICAgICAgaWYgKCRzY29wZS5oYXNUYWcobW90aW9uLCB0YWcpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlXG4gICAgICAgICAgICAgICAgbW90aW9uLnRhZ3NfaWQgPSBfLmZpbHRlcihtb3Rpb24udGFnc19pZCwgZnVuY3Rpb24gKHRhZ19pZCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWdfaWQgIT0gdGFnLmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3Rpb24udGFnc19pZC5wdXNoKHRhZy5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUuc2F2ZShtb3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUudG9nZ2xlQ2F0ZWdvcnkgPSBmdW5jdGlvbiAobW90aW9uLCBjYXRlZ29yeSkge1xuICAgICAgICAgICAgaWYgKG1vdGlvbi5jYXRlZ29yeV9pZCA9PSBjYXRlZ29yeS5pZCkge1xuICAgICAgICAgICAgICAgIG1vdGlvbi5jYXRlZ29yeV9pZCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vdGlvbi5jYXRlZ29yeV9pZCA9IGNhdGVnb3J5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHNjb3BlLnNhdmUobW90aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLnRvZ2dsZU1vdGlvbkJsb2NrID0gZnVuY3Rpb24gKG1vdGlvbiwgYmxvY2spIHtcbiAgICAgICAgICAgIGlmIChtb3Rpb24ubW90aW9uX2Jsb2NrX2lkID09IGJsb2NrLmlkKSB7XG4gICAgICAgICAgICAgICAgbW90aW9uLm1vdGlvbl9ibG9ja19pZCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vdGlvbi5tb3Rpb25fYmxvY2tfaWQgPSBibG9jay5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5zYXZlKG1vdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS50b2dnbGVTdGFyID0gZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgaWYgKG1vdGlvbi5wZXJzb25hbE5vdGUpIHtcbiAgICAgICAgICAgICAgICBtb3Rpb24ucGVyc29uYWxOb3RlLnN0YXIgPSAhbW90aW9uLnBlcnNvbmFsTm90ZS5zdGFyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3Rpb24ucGVyc29uYWxOb3RlID0ge3N0YXI6IHRydWV9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUGVyc29uYWxOb3RlTWFuYWdlci5zYXZlTm90ZShtb3Rpb24sIG1vdGlvbi5wZXJzb25hbE5vdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG9wZW4gbmV3L2VkaXQgZGlhbG9nXG4gICAgICAgICRzY29wZS5vcGVuRGlhbG9nID0gZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgbmdEaWFsb2cub3BlbihNb3Rpb25Gb3JtLmdldERpYWxvZyhtb3Rpb24pKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRXhwb3J0IGRpYWxvZ1xuICAgICAgICAkc2NvcGUub3BlbkV4cG9ydERpYWxvZyA9IGZ1bmN0aW9uIChtb3Rpb25zKSB7XG4gICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKE1vdGlvbkV4cG9ydEZvcm0uZ2V0RGlhbG9nKG1vdGlvbnMsICRzY29wZS5zb3J0KSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5wZGZFeHBvcnQgPSBmdW5jdGlvbiAobW90aW9ucykge1xuICAgICAgICAgICAgTW90aW9uUGRmRXhwb3J0LmV4cG9ydChtb3Rpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyAqKiogc2VsZWN0IG1vZGUgZnVuY3Rpb25zICoqKlxuICAgICAgICAkc2NvcGUuaXNTZWxlY3RNb2RlID0gZmFsc2U7XG4gICAgICAgIC8vIGNoZWNrIGFsbCBjaGVja2JveGVzIGZyb20gZmlsdGVyZWQgbW90aW9uc1xuICAgICAgICAkc2NvcGUuY2hlY2tBbGwgPSBmdW5jdGlvbiAobW90aW9ucykge1xuICAgICAgICAgICAgJHNjb3BlLnNlbGVjdGVkQWxsID0gISRzY29wZS5zZWxlY3RlZEFsbDtcbiAgICAgICAgICAgIF8uZm9yRWFjaChtb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgbW90aW9uLnNlbGVjdGVkID0gJHNjb3BlLnNlbGVjdGVkQWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHVuY2hlY2sgYWxsIGNoZWNrYm94ZXMgaWYgaXNTZWxlY3RNb2RlIGlzIGNsb3NlZFxuICAgICAgICAkc2NvcGUudW5jaGVja0FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghJHNjb3BlLmlzU2VsZWN0TW9kZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5zZWxlY3RlZEFsbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaCgkc2NvcGUubW90aW9ucywgZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtb3Rpb24uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNlbGVjdE1vZGVBY3Rpb24gPSBmdW5jdGlvbiAobW90aW9ucywgcHJlZGljYXRlKSB7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gobW90aW9ucywgZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChtb3Rpb24uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZGljYXRlKG1vdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2NvcGUuaXNTZWxlY3RNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAkc2NvcGUudW5jaGVja0FsbCgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBkZWxldGUgc2VsZWN0ZWQgbW90aW9uc1xuICAgICAgICAkc2NvcGUuZGVsZXRlTXVsdGlwbGUgPSBmdW5jdGlvbiAobW90aW9ucykge1xuICAgICAgICAgICAgc2VsZWN0TW9kZUFjdGlvbihtb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlbGV0ZShtb3Rpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHNldCBzdGF0dXMgZm9yIHNlbGVjdGVkIG1vdGlvbnNcbiAgICAgICAgJHNjb3BlLnNldFN0YXR1c011bHRpcGxlID0gZnVuY3Rpb24gKG1vdGlvbnMsIHN0YXRlSWQpIHtcbiAgICAgICAgICAgIHNlbGVjdE1vZGVBY3Rpb24obW90aW9ucywgZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgICAgICRodHRwLnB1dCgnL3Jlc3QvbW90aW9ucy9tb3Rpb24vJyArIG1vdGlvbi5pZCArICcvc2V0X3N0YXRlLycsIHsnc3RhdGUnOiBzdGF0ZUlkfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2V0IGNhdGVnb3J5IGZvciBzZWxlY3RlZCBtb3Rpb25zXG4gICAgICAgICRzY29wZS5zZXRDYXRlZ29yeU11bHRpcGxlID0gZnVuY3Rpb24gKG1vdGlvbnMsIGNhdGVnb3J5SWQpIHtcbiAgICAgICAgICAgIHNlbGVjdE1vZGVBY3Rpb24obW90aW9ucywgZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgICAgIG1vdGlvbi5jYXRlZ29yeV9pZCA9IGNhdGVnb3J5SWQgPT09ICdub19jYXRlZ29yeV9zZWxlY3RlZCcgPyBudWxsIDogY2F0ZWdvcnlJZDtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc2F2ZShtb3Rpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHNldCBzdGF0dXMgZm9yIHNlbGVjdGVkIG1vdGlvbnNcbiAgICAgICAgJHNjb3BlLnNldE1vdGlvbkJsb2NrTXVsdGlwbGUgPSBmdW5jdGlvbiAobW90aW9ucywgbW90aW9uQmxvY2tJZCkge1xuICAgICAgICAgICAgc2VsZWN0TW9kZUFjdGlvbihtb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgbW90aW9uLm1vdGlvbl9ibG9ja19pZCA9IG1vdGlvbkJsb2NrSWQgPT09ICdub19tb3Rpb25CbG9ja19zZWxlY3RlZCcgPyBudWxsIDogbW90aW9uQmxvY2tJZDtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc2F2ZShtb3Rpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ01vdGlvbkRldGFpbEN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRodHRwJyxcbiAgICAnJHRpbWVvdXQnLFxuICAgICckd2luZG93JyxcbiAgICAnJGZpbHRlcicsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnbmdEaWFsb2cnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ01vdGlvbkZvcm0nLFxuICAgICdBbWVuZG1lbnRQYXJhZ3JhcGhDaG9vc2VGb3JtJyxcbiAgICAnQ2hhbmdlUmVjb21tZW5kYXRpb25DcmVhdGUnLFxuICAgICdDaGFuZ2VSZWNvbW1lbmRhdGlvblZpZXcnLFxuICAgICdNb3Rpb25TdGF0ZUFuZFJlY29tbWVuZGF0aW9uUGFyc2VyJyxcbiAgICAnTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24nLFxuICAgICdNb3Rpb24nLFxuICAgICdNb3Rpb25Db21tZW50JyxcbiAgICAnQ2F0ZWdvcnknLFxuICAgICdNZWRpYWZpbGUnLFxuICAgICdUYWcnLFxuICAgICdVc2VyJyxcbiAgICAnV29ya2Zsb3cnLFxuICAgICdDb25maWcnLFxuICAgICdtb3Rpb25JZCcsXG4gICAgJ01vdGlvbklubGluZUVkaXRpbmcnLFxuICAgICdNb3Rpb25Db21tZW50c0lubGluZUVkaXRpbmcnLFxuICAgICdFZGl0b3InLFxuICAgICdQcm9qZWN0b3InLFxuICAgICdQcm9qZWN0aW9uRGVmYXVsdCcsXG4gICAgJ01vdGlvbkJsb2NrJyxcbiAgICAnTW90aW9uUGRmRXhwb3J0JyxcbiAgICAnUGVyc29uYWxOb3RlTWFuYWdlcicsXG4gICAgJ05vdGlmeScsXG4gICAgJ1dlYnBhZ2VUaXRsZScsXG4gICAgJ0VkaXRpbmdXYXJuaW5nJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsICRodHRwLCAkdGltZW91dCwgJHdpbmRvdywgJGZpbHRlciwgb3BlcmF0b3IsIG5nRGlhbG9nLCBnZXR0ZXh0Q2F0YWxvZyxcbiAgICAgICAgICAgIE1vdGlvbkZvcm0sIEFtZW5kbWVudFBhcmFncmFwaENob29zZUZvcm0sIENoYW5nZVJlY29tbWVuZGF0aW9uQ3JlYXRlLCBDaGFuZ2VSZWNvbW1lbmRhdGlvblZpZXcsXG4gICAgICAgICAgICBNb3Rpb25TdGF0ZUFuZFJlY29tbWVuZGF0aW9uUGFyc2VyLCBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbiwgTW90aW9uLCBNb3Rpb25Db21tZW50LFxuICAgICAgICAgICAgQ2F0ZWdvcnksIE1lZGlhZmlsZSwgVGFnLCBVc2VyLCBXb3JrZmxvdywgQ29uZmlnLCBtb3Rpb25JZCwgTW90aW9uSW5saW5lRWRpdGluZyxcbiAgICAgICAgICAgIE1vdGlvbkNvbW1lbnRzSW5saW5lRWRpdGluZywgRWRpdG9yLCBQcm9qZWN0b3IsIFByb2plY3Rpb25EZWZhdWx0LCBNb3Rpb25CbG9jayxcbiAgICAgICAgICAgIE1vdGlvblBkZkV4cG9ydCwgUGVyc29uYWxOb3RlTWFuYWdlciwgTm90aWZ5LCBXZWJwYWdlVGl0bGUsIEVkaXRpbmdXYXJuaW5nKSB7XG4gICAgICAgIHZhciBtb3Rpb24gPSBNb3Rpb24uZ2V0KG1vdGlvbklkKTtcbiAgICAgICAgQ2F0ZWdvcnkuYmluZEFsbCh7fSwgJHNjb3BlLCAnY2F0ZWdvcmllcycpO1xuICAgICAgICBNZWRpYWZpbGUuYmluZEFsbCh7fSwgJHNjb3BlLCAnbWVkaWFmaWxlcycpO1xuICAgICAgICBUYWcuYmluZEFsbCh7fSwgJHNjb3BlLCAndGFncycpO1xuICAgICAgICBVc2VyLmJpbmRBbGwoe30sICRzY29wZSwgJ3VzZXJzJyk7XG4gICAgICAgIFdvcmtmbG93LmJpbmRBbGwoe30sICRzY29wZSwgJ3dvcmtmbG93cycpO1xuICAgICAgICBNb3Rpb25CbG9jay5iaW5kQWxsKHt9LCAkc2NvcGUsICdtb3Rpb25CbG9ja3MnKTtcbiAgICAgICAgTW90aW9uLmJpbmRBbGwoe30sICRzY29wZSwgJ21vdGlvbnMnKTtcblxuXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb2plY3Rvci5sYXN0TW9kaWZpZWQoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLnByb2plY3RvcnMgPSBQcm9qZWN0b3IuZ2V0QWxsKCk7XG4gICAgICAgICAgICB2YXIgcHJvamVjdGlvbmRlZmF1bHQgPSBQcm9qZWN0aW9uRGVmYXVsdC5maWx0ZXIoe25hbWU6ICdtb3Rpb25zJ30pWzBdO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rpb25kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlZmF1bHRQcm9qZWN0b3JJZCA9IHByb2plY3Rpb25kZWZhdWx0LnByb2plY3Rvcl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1vdGlvbi5sYXN0TW9kaWZpZWQobW90aW9uSWQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUubW90aW9uID0gTW90aW9uLmdldChtb3Rpb25JZCk7XG4gICAgICAgICAgICAkc2NvcGUuYW1lbmRtZW50X2RpZmZfcGFyYWdyYXBocyA9ICRzY29wZS5tb3Rpb24uZ2V0QW1lbmRtZW50UGFyYWdyYXBoc0xpbmVzRGlmZigpO1xuICAgICAgICAgICAgTW90aW9uQ29tbWVudC5wb3B1bGF0ZUZpZWxkcygkc2NvcGUubW90aW9uKTtcbiAgICAgICAgICAgIGlmIChtb3Rpb24uY29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3RhdGVFeHRlbnNpb24gPSAkc2NvcGUubW90aW9uLmNvbW1lbnRzWyRzY29wZS5jb21tZW50RmllbGRGb3JTdGF0ZUlkXTtcbiAgICAgICAgICAgICAgICAkc2NvcGUucmVjb21tZW5kYXRpb25FeHRlbnNpb24gPSAkc2NvcGUubW90aW9uLmNvbW1lbnRzWyRzY29wZS5jb21tZW50RmllbGRGb3JSZWNvbW1lbmRhdGlvbklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5tb3Rpb24ucGVyc29uYWxOb3RlID0gUGVyc29uYWxOb3RlTWFuYWdlci5nZXROb3RlKCRzY29wZS5tb3Rpb24pO1xuICAgICAgICAgICAgJHNjb3BlLm5hdmlnYXRpb24uZXZhbHVhdGUoKTtcblxuICAgICAgICAgICAgdmFyIHdlYnBhZ2VUaXRsZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnTW90aW9uJykgKyAnICc7XG4gICAgICAgICAgICBpZiAoJHNjb3BlLm1vdGlvbi5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgd2VicGFnZVRpdGxlICs9ICRzY29wZS5tb3Rpb24uaWRlbnRpZmllciArICcgLSAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2VicGFnZVRpdGxlICs9ICRzY29wZS5tb3Rpb24uZ2V0VGl0bGUoKTtcbiAgICAgICAgICAgIFdlYnBhZ2VUaXRsZS51cGRhdGVUaXRsZSh3ZWJwYWdlVGl0bGUpO1xuXG4gICAgICAgICAgICAkc2NvcGUuY3JlYXRlQ2hhbmdlUmVjb21tZW5kYXRpb24uc2V0VmVyc2lvbihtb3Rpb24sIG1vdGlvbi5hY3RpdmVfdmVyc2lvbik7XG4gICAgICAgICAgICAkc2NvcGUudmlld0NoYW5nZVJlY29tbWVuZGF0aW9ucy5zZXRWZXJzaW9uKG1vdGlvbiwgbW90aW9uLmFjdGl2ZV92ZXJzaW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1vdGlvbi5sYXN0TW9kaWZpZWQoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLm1vdGlvbnMgPSBNb3Rpb24uZ2V0QWxsKCk7XG4gICAgICAgICAgICAkc2NvcGUuYW1lbmRtZW50cyA9IE1vdGlvbi5maWx0ZXIoe3BhcmVudF9pZDogbW90aW9uLmlkfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAkc2NvcGUucHJvamVjdGlvbk1vZGVzID0gW1xuICAgICAgICAgICAge21vZGU6ICdvcmlnaW5hbCcsXG4gICAgICAgICAgICBsYWJlbDogJ09yaWdpbmFsIHZlcnNpb24nfSxcbiAgICAgICAgICAgIHttb2RlOiAnY2hhbmdlZCcsXG4gICAgICAgICAgICBsYWJlbDogJ0NoYW5nZWQgdmVyc2lvbid9LFxuICAgICAgICAgICAge21vZGU6ICdkaWZmJyxcbiAgICAgICAgICAgIGxhYmVsOiAnRGlmZiB2ZXJzaW9uJ30sXG4gICAgICAgICAgICB7bW9kZTogJ2FncmVlZCcsXG4gICAgICAgICAgICBsYWJlbDogJ0ZpbmFsIHZlcnNpb24nfSxcbiAgICAgICAgICAgIHttb2RlOiAnbW9kaWZpZWRfYWdyZWVkJyxcbiAgICAgICAgICAgIGxhYmVsOiAnRmluYWwgcHJpbnQgdGVtcGxhdGUnfSxcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIG1vdGlvbkRlZmF1bHRSZWNvbW1lbmRhdGlvblRleHRNb2RlID0gQ29uZmlnLmdldCgnbW90aW9uc19yZWNvbW1lbmRhdGlvbl90ZXh0X21vZGUnKS52YWx1ZTtcbiAgICAgICAgLy8gQ2hhbmdlIHRvIHRoZSBtb2RpZmllZCBmaW5hbCB2ZXJzaW9uLCBpZiBleGlzdHNcbiAgICAgICAgaWYgKG1vdGlvbkRlZmF1bHRSZWNvbW1lbmRhdGlvblRleHRNb2RlID09PSAnYWdyZWVkJyAmJiBtb3Rpb24uZ2V0TW9kaWZpZWRGaW5hbFZlcnNpb24oKSkge1xuICAgICAgICAgICAgbW90aW9uRGVmYXVsdFJlY29tbWVuZGF0aW9uVGV4dE1vZGUgPSAnbW9kaWZpZWRfYWdyZWVkJztcbiAgICAgICAgfVxuICAgICAgICAkc2NvcGUucHJvamVjdGlvbk1vZGUgPSBfLmZpbmQoJHNjb3BlLnByb2plY3Rpb25Nb2RlcywgZnVuY3Rpb24gKG1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlLm1vZGUgPT0gbW90aW9uRGVmYXVsdFJlY29tbWVuZGF0aW9uVGV4dE1vZGU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobW90aW9uLmlzUHJvamVjdGVkKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbW9kZU1hcHBpbmcgPSBtb3Rpb24uaXNQcm9qZWN0ZWRXaXRoTW9kZSgpO1xuICAgICAgICAgICAgXy5mb3JFYWNoKCRzY29wZS5wcm9qZWN0aW9uTW9kZXMsIGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUubW9kZSA9PT0gbW9kZU1hcHBpbmdbMF0ubW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUucHJvamVjdGlvbk1vZGUgPSBtb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgICRzY29wZS5zZXRQcm9qZWN0aW9uTW9kZSA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgICAgICAgICAkc2NvcGUucHJvamVjdGlvbk1vZGUgPSBtb2RlO1xuICAgICAgICAgICAgdmFyIGlzUHJvamVjdGVkID0gbW90aW9uLmlzUHJvamVjdGVkV2l0aE1vZGUoKTtcbiAgICAgICAgICAgIGlmIChpc1Byb2plY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goaXNQcm9qZWN0ZWQsIGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBwaW5nLm1vZGUgIT0gbW9kZS5tb2RlKSB7IC8vIGNoYW5nZSB0aGUgbW9kZSBpZiBpdCBpcyBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvbi5wcm9qZWN0KG1hcHBpbmcucHJvamVjdG9ySWQsIG1vZGUubW9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmNvbW1lbnRzRmllbGRzID0gTW90aW9uQ29tbWVudC5nZXRDb21tZW50c0ZpZWxkcygpO1xuICAgICAgICAkc2NvcGUubm9TcGVjaWFsQ29tbWVudHNGaWVsZHMgPSBNb3Rpb25Db21tZW50LmdldE5vU3BlY2lhbENvbW1lbnRzRmllbGRzKCk7XG4gICAgICAgICRzY29wZS5jb21tZW50RmllbGRGb3JTdGF0ZUlkID0gTW90aW9uQ29tbWVudC5nZXRGaWVsZElkRm9yRmxhZygnZm9yU3RhdGUnKTtcbiAgICAgICAgJHNjb3BlLmNvbW1lbnRGaWVsZEZvclJlY29tbWVuZGF0aW9uSWQgPSBNb3Rpb25Db21tZW50LmdldEZpZWxkSWRGb3JGbGFnKCdmb3JSZWNvbW1lbmRhdGlvbicpO1xuICAgICAgICAkc2NvcGUudmVyc2lvbiA9IG1vdGlvbi5hY3RpdmVfdmVyc2lvbjtcbiAgICAgICAgJHNjb3BlLmlzQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgJHNjb3BlLmxpbmVOdW1iZXJNb2RlID0gQ29uZmlnLmdldCgnbW90aW9uc19kZWZhdWx0X2xpbmVfbnVtYmVyaW5nJykudmFsdWU7XG4gICAgICAgICRzY29wZS5zZXRMaW5lTnVtYmVyTW9kZSA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgICAgICAgICAgICRzY29wZS5saW5lTnVtYmVyTW9kZSA9IG1vZGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLnNob3dBbWVuZG1lbnRDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgICRzY29wZS5zZXRTaG93QW1lbmRtZW50Q29udGV4dCA9IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAkc2NvcGUuc2hvd0FtZW5kbWVudENvbnRleHQgPSAhJHNjb3BlLnNob3dBbWVuZG1lbnRDb250ZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtb3Rpb24ucGFyZW50X2lkKSB7XG4gICAgICAgICAgICBNb3Rpb24uYmluZE9uZShtb3Rpb24ucGFyZW50X2lkLCAkc2NvcGUsICdwYXJlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgICRzY29wZS5zY3JvbGxUb0xpbmUgPSAwO1xuICAgICAgICAkc2NvcGUuaGlnaGxpZ2h0ID0gMDtcbiAgICAgICAgJHNjb3BlLmxpbmVzRm9yUHJvamVjdG9yID0gZmFsc2U7XG4gICAgICAgICRzY29wZS5zY3JvbGxUb0FuZEhpZ2hsaWdodCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAkc2NvcGUuc2Nyb2xsVG9MaW5lID0gbGluZTtcbiAgICAgICAgICAgICRzY29wZS5oaWdobGlnaHQgPSBsaW5lO1xuXG4gICAgICAgICAgICAvLyBUaGUgc2FtZSBsaW5lIG51bWJlciBjYW4gb2NjdXIgdHdpY2UgaW4gZGlmZiB2aWV3OyB3ZSBzY3JvbGwgdG8gdGhlIGZpcnN0IG9uZSBpbiB0aGlzIGNhc2VcbiAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSBudWxsO1xuICAgICAgICAgICAgJCgnLmxpbmUtbnVtYmVyLScgKyBsaW5lKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0b3AgPSAkKHRoaXMpLm9mZnNldCgpLnRvcDtcbiAgICAgICAgICAgICAgICBpZiAodG9wID4gMCAmJiAoc2Nyb2xsVG9wID09PSBudWxsIHx8IHRvcCA8IHNjcm9sbFRvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gdG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgLy8gU2Nyb2xsIGxvY2FsOyA1MCBwaXhlbCBhYm92ZSB0aGUgbGluZSwgc28gaXQncyBub3QgY29tcGxldGVseSBzcXVlZXplZCB0byB0aGUgc2NyZWVuIGJvcmRlclxuICAgICAgICAgICAgICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgJ3Njcm9sbFRvcCc6IHNjcm9sbFRvcCAtIDUwXG4gICAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsaW5lIGhpZ2hsaWdodCBhZnRlciAyIHNlY29uZHMuXG4gICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaGlnaGxpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICB9LCAyMDAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJHNjb3BlLnNjcm9sbFByb2plY3RvclRvTGluZShsaW5lKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLnNjcm9sbFByb2plY3RvclRvTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICB2YXIgcHJvamVjdG9ySWRzID0gJHNjb3BlLm1vdGlvbi5pc1Byb2plY3RlZCgpO1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUubGluZXNGb3JQcm9qZWN0b3IgfHwgIWxpbmUgfHwgIXByb2plY3Rvcklkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvamVjdG9ySWQgPSBwcm9qZWN0b3JJZHNbMF07XG4gICAgICAgICAgICB2YXIgbm90aWZ5TmFtZVByZWZpeCA9ICdwcm9qZWN0b3JfJyArIHByb2plY3RvcklkICsgJ19tb3Rpb25fbGluZV8nO1xuXG4gICAgICAgICAgICAvLyByZWdpc3RlciBjYWxsYmFja1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrSWQgPSBOb3RpZnkucmVnaXN0ZXJDYWxsYmFjayhub3RpZnlOYW1lUHJlZml4ICsgJ2Fuc3dlcicsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBOb3RpZnkuZGVyZWdpc3RlckNhbGxiYWNrKGNhbGxiYWNrSWQpO1xuICAgICAgICAgICAgICAgICRodHRwLnBvc3QoJy9yZXN0L2NvcmUvcHJvamVjdG9yLycgKyBwcm9qZWN0b3JJZCArICcvc2V0X3Njcm9sbC8nLCBwYXJhbXMucGFyYW1zLnNjcm9sbCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUXVlcnkgYWxsIHByb2plY3RvcnNcbiAgICAgICAgICAgIE5vdGlmeS5ub3RpZnkobm90aWZ5TmFtZVByZWZpeCArICdyZXF1ZXN0Jywge2xpbmU6IGxpbmV9LCBudWxsLCBudWxsLCBbcHJvamVjdG9ySWRdKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLnRvZ2dsZUxpbmVzRm9yUHJvamVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLmxpbmVzRm9yUHJvamVjdG9yID0gISRzY29wZS5saW5lc0ZvclByb2plY3RvcjtcbiAgICAgICAgICAgICRzY29wZS5zY3JvbGxQcm9qZWN0b3JUb0xpbmUoJHNjb3BlLnNjcm9sbFRvTGluZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gb3BlbiBlZGl0IGRpYWxvZ1xuICAgICAgICAkc2NvcGUub3BlbkRpYWxvZyA9IGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgIGlmICgkc2NvcGUuaW5saW5lRWRpdGluZy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZGlzYWJsZU1vdGlvbklubGluZUVkaXRpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5nRGlhbG9nLm9wZW4oTW90aW9uRm9ybS5nZXREaWFsb2cobW90aW9uKSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgTW90aW9uLnNhdmUobW90aW9uLCB7bWV0aG9kOiAnUEFUQ0gnfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE5hdmlnYXRpb24gYnV0dG9uc1xuICAgICAgICAkc2NvcGUubmF2aWdhdGlvbiA9IHtcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vdGlvbnMgPSAkZmlsdGVyKCdvcmRlckJ5RW1wdHlMYXN0JykoTW90aW9uLmdldEFsbCgpLCAnaWRlbnRpZmllcicpO1xuICAgICAgICAgICAgICAgIHZhciB0aGlzSW5kZXggPSBfLmZpbmRJbmRleChtb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb3Rpb24uaWQgPT09ICRzY29wZS5tb3Rpb24uaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IG1vdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dE1vdGlvbiA9IHRoaXNJbmRleCA8IG1vdGlvbnMubGVuZ3RoLTEgPyBtb3Rpb25zW3RoaXNJbmRleCsxXSA6IF8uaGVhZChtb3Rpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzTW90aW9uID0gdGhpc0luZGV4ID4gMCA/IG1vdGlvbnNbdGhpc0luZGV4LTFdIDogXy5sYXN0KG1vdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gc3VwcG9ydFxuICAgICAgICAkc2NvcGUuc3VwcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRodHRwLnBvc3QoJy9yZXN0L21vdGlvbnMvbW90aW9uLycgKyBtb3Rpb24uaWQgKyAnL3N1cHBvcnQvJyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHVuc3VwcG9ydFxuICAgICAgICAkc2NvcGUudW5zdXBwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJGh0dHAuZGVsZXRlKCcvcmVzdC9tb3Rpb25zL21vdGlvbi8nICsgbW90aW9uLmlkICsgJy9zdXBwb3J0LycpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBvcGVuIGRpYWxvZyBmb3IgbmV3IGFtZW5kbWVudFxuICAgICAgICAkc2NvcGUubmV3QW1lbmRtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wZW5NYWluRGlhbG9nID0gZnVuY3Rpb24gKHBhcmFncmFwaE5vKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpYWxvZyA9IE1vdGlvbkZvcm0uZ2V0RGlhbG9nKG51bGwsIG1vdGlvbiwgcGFyYWdyYXBoTm8pO1xuICAgICAgICAgICAgICAgIGRpYWxvZy5zY29wZSA9ICRzY29wZTtcbiAgICAgICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKGRpYWxvZyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoQ29uZmlnLmdldCgnbW90aW9uc19hbWVuZG1lbnRzX3RleHRfbW9kZScpLnZhbHVlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgIHZhciBkaWFsb2cgPSBBbWVuZG1lbnRQYXJhZ3JhcGhDaG9vc2VGb3JtLmdldERpYWxvZygkc2NvcGUubW90aW9uLCBvcGVuTWFpbkRpYWxvZyk7XG4gICAgICAgICAgICAgICAgZGlhbG9nLnNjb3BlID0gJHNjb3BlO1xuICAgICAgICAgICAgICAgIG5nRGlhbG9nLm9wZW4oZGlhbG9nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3Blbk1haW5EaWFsb2coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZm9sbG93IHJlY29tbWVuZGF0aW9uXG4gICAgICAgICRzY29wZS5mb2xsb3dSZWNvbW1lbmRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRodHRwLnBvc3QoJy9yZXN0L21vdGlvbnMvbW90aW9uLycgKyBtb3Rpb24uaWQgKyAnL2ZvbGxvd19yZWNvbW1lbmRhdGlvbi8nLCB7XG4gICAgICAgICAgICAgICAgJ3JlY29tbWVuZGF0aW9uRXh0ZW5zaW9uJzogJHNjb3BlLnJlY29tbWVuZGF0aW9uRXh0ZW5zaW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdG9nZ2xlIGZ1bmN0aW9ucyBmb3IgbWV0YSBpbmZvcm1hdGlvblxuICAgICAgICAkc2NvcGUudG9nZ2xlQ2F0ZWdvcnkgPSBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIGlmICgkc2NvcGUubW90aW9uLmNhdGVnb3J5X2lkID09IGNhdGVnb3J5LmlkKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm1vdGlvbi5jYXRlZ29yeV9pZCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRzY29wZS5tb3Rpb24uY2F0ZWdvcnlfaWQgPSBjYXRlZ29yeS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5zYXZlKCRzY29wZS5tb3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUudG9nZ2xlTW90aW9uQmxvY2sgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgIGlmICgkc2NvcGUubW90aW9uLm1vdGlvbl9ibG9ja19pZCA9PSBibG9jay5pZCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5tb3Rpb24ubW90aW9uX2Jsb2NrX2lkID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm1vdGlvbi5tb3Rpb25fYmxvY2tfaWQgPSBibG9jay5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5zYXZlKCRzY29wZS5tb3Rpb24pO1xuXG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS50b2dnbGVUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgICBpZiAoXy5pbmRleE9mKCRzY29wZS5tb3Rpb24udGFnc19pZCwgdGFnLmlkKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlXG4gICAgICAgICAgICAgICAgJHNjb3BlLm1vdGlvbi50YWdzX2lkID0gXy5maWx0ZXIoJHNjb3BlLm1vdGlvbi50YWdzX2lkLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodGFnX2lkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWdfaWQgIT0gdGFnLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm1vdGlvbi50YWdzX2lkLnB1c2godGFnLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5zYXZlKCRzY29wZS5tb3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBzYXZlIGFkZGl0aW9uYWwgc3RhdGUgZmllbGRcbiAgICAgICAgJHNjb3BlLnNhdmVBZGRpdGlvbmFsU3RhdGVGaWVsZCA9IGZ1bmN0aW9uIChzdGF0ZUV4dGVuc2lvbikge1xuICAgICAgICAgICAgbW90aW9uWydjb21tZW50XycgKyAkc2NvcGUuY29tbWVudEZpZWxkRm9yU3RhdGVJZF0gPSBzdGF0ZUV4dGVuc2lvbjtcbiAgICAgICAgICAgICRzY29wZS5zYXZlKG1vdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHNhdmUgYWRkaXRpb25hbCByZWNvbW1lbmRhdGlvbiBmaWVsZFxuICAgICAgICAkc2NvcGUuc2F2ZUFkZGl0aW9uYWxSZWNvbW1lbmRhdGlvbkZpZWxkID0gZnVuY3Rpb24gKHJlY29tbWVuZGF0aW9uRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBtb3Rpb25bJ2NvbW1lbnRfJyArICRzY29wZS5jb21tZW50RmllbGRGb3JSZWNvbW1lbmRhdGlvbklkXSA9IHJlY29tbWVuZGF0aW9uRXh0ZW5zaW9uO1xuICAgICAgICAgICAgJHNjb3BlLnNhdmUobW90aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmFkZE1vdGlvblRvUmVjb21tZW5kYXRpb25GaWVsZCA9IGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgICRzY29wZS5yZWNvbW1lbmRhdGlvbkV4dGVuc2lvbiArPSBNb3Rpb25TdGF0ZUFuZFJlY29tbWVuZGF0aW9uUGFyc2VyLmZvcm1hdE1vdGlvbihtb3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBjcmVhdGUgcG9sbFxuICAgICAgICAkc2NvcGUuY3JlYXRlX3BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkaHR0cC5wb3N0KCcvcmVzdC9tb3Rpb25zL21vdGlvbi8nICsgbW90aW9uLmlkICsgJy9jcmVhdGVfcG9sbC8nLCB7fSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIG9wZW4gcG9sbCB1cGRhdGUgZGlhbG9nXG4gICAgICAgICRzY29wZS5vcGVuUG9sbERpYWxvZyA9IGZ1bmN0aW9uIChwb2xsLCB2b3RlTnVtYmVyKSB7XG4gICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJ3N0YXRpYy90ZW1wbGF0ZXMvbW90aW9ucy9tb3Rpb24tcG9sbC1mb3JtLmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdNb3Rpb25Qb2xsVXBkYXRlQ3RybCcsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmdkaWFsb2ctdGhlbWUtZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgY2xvc2VCeUVzY2FwZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2xvc2VCeURvY3VtZW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1vdGlvbnBvbGxJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbGwuaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHZvdGVOdW1iZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2b3RlTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRlbGV0ZSBwb2xsXG4gICAgICAgICRzY29wZS5kZWxldGVfcG9sbCA9IGZ1bmN0aW9uIChwb2xsKSB7XG4gICAgICAgICAgICBwb2xsLkRTRGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBzaG93IHNwZWNpZmljIHZlcnNpb25cbiAgICAgICAgJHNjb3BlLnNob3dWZXJzaW9uID0gZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgICAgICRzY29wZS52ZXJzaW9uID0gdmVyc2lvbi5pZDtcbiAgICAgICAgICAgICRzY29wZS5pbmxpbmVFZGl0aW5nLnNldFZlcnNpb24obW90aW9uLCB2ZXJzaW9uLmlkKTtcbiAgICAgICAgICAgICRzY29wZS5yZWFzb25JbmxpbmVFZGl0aW5nLnNldFZlcnNpb24obW90aW9uLCB2ZXJzaW9uLmlkKTtcbiAgICAgICAgICAgICRzY29wZS5jcmVhdGVDaGFuZ2VSZWNvbW1lbmRhdGlvbi5zZXRWZXJzaW9uKG1vdGlvbiwgdmVyc2lvbi5pZCk7XG4gICAgICAgICAgICAkc2NvcGUudmlld0NoYW5nZVJlY29tbWVuZGF0aW9ucy5zZXRWZXJzaW9uKG1vdGlvbiwgbW90aW9uLmFjdGl2ZV92ZXJzaW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcGVybWl0IHNwZWNpZmljIHZlcnNpb25cbiAgICAgICAgJHNjb3BlLnBlcm1pdFZlcnNpb24gPSBmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgJGh0dHAucHV0KCcvcmVzdC9tb3Rpb25zL21vdGlvbi8nICsgbW90aW9uLmlkICsgJy9tYW5hZ2VfdmVyc2lvbi8nLFxuICAgICAgICAgICAgICAgIHsndmVyc2lvbl9udW1iZXInOiB2ZXJzaW9uLnZlcnNpb25fbnVtYmVyfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5zaG93VmVyc2lvbih2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZGVsZXRlIHNwZWNpZmljIHZlcnNpb25cbiAgICAgICAgJHNjb3BlLmRlbGV0ZVZlcnNpb24gPSBmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgJGh0dHAuZGVsZXRlKCcvcmVzdC9tb3Rpb25zL21vdGlvbi8nICsgbW90aW9uLmlkICsgJy9tYW5hZ2VfdmVyc2lvbi8nLFxuICAgICAgICAgICAgICAgICAgICB7aGVhZGVyczogeydDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbid9LFxuICAgICAgICAgICAgICAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoe3ZlcnNpb25fbnVtYmVyOiB2ZXJzaW9uLnZlcnNpb25fbnVtYmVyfSl9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNob3dWZXJzaW9uKHtpZDogbW90aW9uLmFjdGl2ZV92ZXJzaW9ufSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjb21tZW50IGZpZWxkXG4gICAgICAgICRzY29wZS5jb21tZW50RmllbGRzQXZhaWxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF8ua2V5cygkc2NvcGUubm9TcGVjaWFsQ29tbWVudHNGaWVsZHMpLmxlbmd0aCA+IDA7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHBlcnNvbmFsIG5vdGVcbiAgICAgICAgLy8gRm9yIHBpbm5pbmcgdGhlIHBlcnNvbmFsIG5vdGUgY29udGFpbmVyIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSB3aWR0aCB3aXRoIEpTLiBXZVxuICAgICAgICAvLyBkbyBub3QgdXNlIGFuZ3VsYXIgaGVyZSwgYmVjYXVzZSBvbiBldmVyeSB3aW5kb3cgcmVzaXplIGEgZGlnaXN0IGN5Y2xlIHdvdWxkIHRyaWdnZXIuXG4gICAgICAgIC8vIFRoaXMgY29zdHMgdG9vIG11Y2ggcGVyZm9ybWFuY2UuIFdlIHVzZSBKUXVlcnkgaGVyZSwgYmVjYXVzZSBpdCBpcyBmYXN0IGZvciBET01cbiAgICAgICAgLy8gbWFuaXB1bGF0aW9uIGFuZCB2ZXJ5IHJlc3BvbnNpdmUuXG4gICAgICAgICRzY29wZS50b2dnbGVTdGFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCRzY29wZS5tb3Rpb24ucGVyc29uYWxOb3RlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm1vdGlvbi5wZXJzb25hbE5vdGUuc3RhciA9ICEkc2NvcGUubW90aW9uLnBlcnNvbmFsTm90ZS5zdGFyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUubW90aW9uLnBlcnNvbmFsTm90ZSA9IHtzdGFyOiB0cnVlfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFBlcnNvbmFsTm90ZU1hbmFnZXIuc2F2ZU5vdGUoJHNjb3BlLm1vdGlvbiwgJHNjb3BlLm1vdGlvbi5wZXJzb25hbE5vdGUpO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUucGVyc29uYWxOb3RlUGlubmVkID0gZmFsc2U7XG4gICAgICAgICRzY29wZS5waW5QZXJzb25hbE5vdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUucGVyc29uYWxOb3RlUGlubmVkID0gISRzY29wZS5wZXJzb25hbE5vdGVQaW5uZWQ7XG4gICAgICAgICAgICBpZiAoJHNjb3BlLnBlcnNvbmFsTm90ZVBpbm5lZCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZVBlcnNvbmFsTm90ZUNvbnRhaW5lcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKCcjcGVyc29uYWxOb3RlJykuY3NzKCd3aWR0aCcsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmdvdG9QZXJzb25hbE5vdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gJCgnI3BlcnNvbmFsTm90ZScpLm9mZnNldCgpO1xuICAgICAgICAgICAgJHdpbmRvdy5zY3JvbGxUbyhwb3MubGVmdCwgcG9zLnRvcCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXNpemVQZXJzb25hbE5vdGVDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoJHNjb3BlLnBlcnNvbmFsTm90ZVBpbm5lZCkge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9ICQoJyNtYWluLWNvbHVtbicpLndpZHRoKCkgLSA0MDsgLy8gU3VidHJhY3QgMngyMHB4IG1hcmdpblxuICAgICAgICAgICAgICAgICQoJyNwZXJzb25hbE5vdGUnKS5jc3MoJ3dpZHRoJywgd2lkdGggKyAncHgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJCh3aW5kb3cpLnJlc2l6ZShyZXNpemVQZXJzb25hbE5vdGVDb250YWluZXIpO1xuXG4gICAgICAgIC8vIElubGluZSBlZGl0aW5nIGZ1bmN0aW9uc1xuICAgICAgICAkc2NvcGUuaW5saW5lRWRpdGluZyA9IE1vdGlvbklubGluZUVkaXRpbmcuY3JlYXRlSW5zdGFuY2UoJHNjb3BlLCBtb3Rpb24sXG4gICAgICAgICAgICAndmlldy1vcmlnaW5hbC10ZXh0LWlubGluZS1lZGl0b3InLCB0cnVlLCBFZGl0b3IuZ2V0T3B0aW9ucygnaW5saW5lJyksXG4gICAgICAgICAgICBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vdGlvbi5nZXRUZXh0V2l0aExpbmVCcmVha3MoJHNjb3BlLnZlcnNpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICBtb3Rpb24uc2V0VGV4dFN0cmlwcGluZ0xpbmVCcmVha3Mob2JqLmVkaXRvci5nZXREYXRhKCkpO1xuICAgICAgICAgICAgICAgIG1vdGlvbi5kaXNhYmxlX3ZlcnNpb25pbmcgPSAob2JqLnRyaXZpYWxDaGFuZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgQ29uZmlnLmdldCgnbW90aW9uc19hbGxvd19kaXNhYmxlX3ZlcnNpb25pbmcnKS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgICRzY29wZS5yZWFzb25JbmxpbmVFZGl0aW5nID0gTW90aW9uSW5saW5lRWRpdGluZy5jcmVhdGVJbnN0YW5jZSgkc2NvcGUsIG1vdGlvbixcbiAgICAgICAgICAgICdyZWFzb24taW5saW5lLWVkaXRvcicsIHRydWUsIEVkaXRvci5nZXRPcHRpb25zKCdpbmxpbmUnKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW90aW9uLmdldFJlYXNvbigkc2NvcGUudmVyc2lvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIG1vdGlvbi5yZWFzb24gPSBvYmouZWRpdG9yLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICBtb3Rpb24uZGlzYWJsZV92ZXJzaW9uaW5nID0gKG9iai50cml2aWFsQ2hhbmdlICYmXG4gICAgICAgICAgICAgICAgICAgIENvbmZpZy5nZXQoJ21vdGlvbnNfYWxsb3dfZGlzYWJsZV92ZXJzaW9uaW5nJykudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICAkc2NvcGUubW9kaWZpZWRGaW5hbFZlcnNpb25JbmxpbmVFZGl0aW5nID0gTW90aW9uSW5saW5lRWRpdGluZy5jcmVhdGVJbnN0YW5jZSgkc2NvcGUsIG1vdGlvbixcbiAgICAgICAgICAgICd2aWV3LW1vZGlmaWVkLWFncmVlZC1pbmxpbmUtZWRpdG9yJywgdHJ1ZSwgRWRpdG9yLmdldE9wdGlvbnMoJ2lubGluZScpLFxuICAgICAgICAgICAgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb3Rpb24uZ2V0TW9kaWZpZWRGaW5hbFZlcnNpb25XaXRoTGluZUJyZWFrcygkc2NvcGUudmVyc2lvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIG1vdGlvbi5zZXRNb2RpZmllZEZpbmFsVmVyc2lvblN0cmlwcGluZ0xpbmVCcmVha3Mob2JqLmVkaXRvci5nZXREYXRhKCkpO1xuICAgICAgICAgICAgICAgIG1vdGlvbi5kaXNhYmxlX3ZlcnNpb25pbmcgPSAob2JqLnRyaXZpYWxDaGFuZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgQ29uZmlnLmdldCgnbW90aW9uc19hbGxvd19kaXNhYmxlX3ZlcnNpb25pbmcnKS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIC8vIFdyYXBwZXIgZnVuY3Rpb25zIGZvciAkc2NvcGUuaW5saW5lRWRpdGluZywgdG8gd2FybiBvdGhlciB1c2Vycy5cbiAgICAgICAgdmFyIGVkaXRpbmdTdG9wcGVkQ2FsbGJhY2s7XG4gICAgICAgICRzY29wZS5lbmFibGVNb3Rpb25JbmxpbmVFZGl0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZWRpdGluZ1N0b3BwZWRDYWxsYmFjayA9IEVkaXRpbmdXYXJuaW5nLmVkaXRpbmdTdGFydGVkKCdtb3Rpb25fdXBkYXRlXycgKyBtb3Rpb24uaWQpO1xuICAgICAgICAgICAgaWYgKCRzY29wZS5tb3Rpb24uZ2V0UmVhc29uKCRzY29wZS52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5yZWFzb25JbmxpbmVFZGl0aW5nLmVuYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHNjb3BlLmlubGluZUVkaXRpbmcuZW5hYmxlKCk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5kaXNhYmxlTW90aW9uSW5saW5lRWRpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChlZGl0aW5nU3RvcHBlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgZWRpdGluZ1N0b3BwZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCRzY29wZS5tb3Rpb24gJiYgJHNjb3BlLm1vdGlvbi5nZXRSZWFzb24oJHNjb3BlLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlYXNvbklubGluZUVkaXRpbmcuZGlzYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHNjb3BlLmlubGluZUVkaXRpbmcuZGlzYWJsZSgpO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUudGV4dFJlYXNvblNhdmVUb29sYmFyVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoJHNjb3BlLmlubGluZUVkaXRpbmcuY2hhbmdlZCAmJiAkc2NvcGUuaW5saW5lRWRpdGluZy5hY3RpdmUpIHx8XG4gICAgICAgICAgICAgICAgKCRzY29wZS5yZWFzb25JbmxpbmVFZGl0aW5nLmNoYW5nZWQgJiYgJHNjb3BlLnJlYXNvbklubGluZUVkaXRpbmcuYWN0aXZlKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLnRleHRSZWFzb25TYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCRzY29wZS5tb3Rpb24uZ2V0UmVhc29uKCRzY29wZS52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5yZWFzb25JbmxpbmVFZGl0aW5nLnNhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5pbmxpbmVFZGl0aW5nLnNhdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLnRleHRSZWFzb25SZXZlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoJHNjb3BlLm1vdGlvbi5nZXRSZWFzb24oJHNjb3BlLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlYXNvbklubGluZUVkaXRpbmcucmV2ZXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUuaW5saW5lRWRpdGluZy5yZXZlcnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmNvbW1lbnRzSW5saW5lRWRpdGluZyA9IE1vdGlvbkNvbW1lbnRzSW5saW5lRWRpdGluZy5jcmVhdGVJbnN0YW5jZXMoJHNjb3BlLCBtb3Rpb24pO1xuICAgICAgICAkc2NvcGUucGVyc29uYWxOb3RlSW5saW5lRWRpdGluZyA9IE1vdGlvbklubGluZUVkaXRpbmcuY3JlYXRlSW5zdGFuY2UoJHNjb3BlLCBtb3Rpb24sXG4gICAgICAgICAgICAncGVyc29uYWwtbm90ZS1pbmxpbmUtZWRpdG9yJywgZmFsc2UsIEVkaXRvci5nZXRPcHRpb25zKCdpbmxpbmUnKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW90aW9uLnBlcnNvbmFsTm90ZSA/IG1vdGlvbi5wZXJzb25hbE5vdGUubm90ZSA6ICcnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAobW90aW9uLnBlcnNvbmFsTm90ZSkge1xuICAgICAgICAgICAgICAgICAgICBtb3Rpb24ucGVyc29uYWxOb3RlLm5vdGUgPSBvYmouZWRpdG9yLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb3Rpb24ucGVyc29uYWxOb3RlID0ge25vdGU6IG9iai5lZGl0b3IuZ2V0RGF0YSgpfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUGVyc29uYWxOb3RlTWFuYWdlci5zYXZlTm90ZShtb3Rpb24sIG1vdGlvbi5wZXJzb25hbE5vdGUpO1xuICAgICAgICAgICAgICAgIG9iai5yZXZlcnQoKTtcbiAgICAgICAgICAgICAgICBvYmouZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBEbyBub3QgdXBkYXRlIHRoZSBtb3Rpb24gdmlhIHBhdGNoIHJlcXVlc3QuXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQ2hhbmdlIHJlY29tbWVuZGF0aW9uIGNyZWF0aW9uIGZ1bmN0aW9uc1xuICAgICAgICAkc2NvcGUuY3JlYXRlQ2hhbmdlUmVjb21tZW5kYXRpb24gPSBDaGFuZ2VSZWNvbW1lbmRhdGlvbkNyZWF0ZTtcbiAgICAgICAgJHNjb3BlLmNyZWF0ZUNoYW5nZVJlY29tbWVuZGF0aW9uLmluaXQoJHNjb3BlLCBtb3Rpb24pO1xuXG4gICAgICAgIC8vIENoYW5nZSByZWNvbW1lbmRhdGlvbiBhbmQgYW1lbmRtZW50IHZpZXdpbmdcbiAgICAgICAgJHNjb3BlLnZpZXdDaGFuZ2VSZWNvbW1lbmRhdGlvbnMgPSBDaGFuZ2VSZWNvbW1lbmRhdGlvblZpZXc7XG4gICAgICAgICRzY29wZS52aWV3Q2hhbmdlUmVjb21tZW5kYXRpb25zLmluaXRTaXRlKCRzY29wZSwgbW90aW9uLCBtb3Rpb25EZWZhdWx0UmVjb21tZW5kYXRpb25UZXh0TW9kZSk7XG5cbiAgICAgICAgLy8gUERGIGNyZWF0aW5nIGZ1bmN0aW9uc1xuICAgICAgICAkc2NvcGUucGRmRXhwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSAkc2NvcGUubW90aW9uLmlkZW50aWZpZXIgPyAnLScgKyAkc2NvcGUubW90aW9uLmlkZW50aWZpZXIgOiAnJztcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnTW90aW9uJykgKyBpZGVudGlmaWVyICsgJy5wZGYnLFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICRzY29wZS52ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGNoYW5nZVJlY29tbWVuZGF0aW9uTW9kZTogJHNjb3BlLnZpZXdDaGFuZ2VSZWNvbW1lbmRhdGlvbnMubW9kZSxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyTW9kZTogJHNjb3BlLmxpbmVOdW1iZXJNb2RlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE1vdGlvblBkZkV4cG9ydC5leHBvcnQobW90aW9uLCBwYXJhbXMsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuY3JlYXRlUG9sbFBkZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE1vdGlvblBkZkV4cG9ydC5jcmVhdGVQb2xsUGRmKCRzY29wZS5tb3Rpb24sICRzY29wZS52ZXJzaW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmV4cG9ydENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudElkKSB7XG4gICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9ICRzY29wZS5tb3Rpb24uaWRlbnRpZmllciA/ICctJyArICRzY29wZS5tb3Rpb24uaWRlbnRpZmllciA6ICcnO1xuICAgICAgICAgICAgdmFyIGNvbW1lbnRzU3RyaW5nID0gJyAtICcgKyBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0NvbW1lbnRzJyk7XG4gICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ01vdGlvbicpICsgaWRlbnRpZmllciArIGNvbW1lbnRzU3RyaW5nICsgJy5wZGYnO1xuICAgICAgICAgICAgTW90aW9uUGRmRXhwb3J0LmV4cG9ydENvbW1lbnQoJHNjb3BlLm1vdGlvbiwgY29tbWVudElkLCBmaWxlbmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5leHBvcnRQZXJzb25hbE5vdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9ICRzY29wZS5tb3Rpb24uaWRlbnRpZmllciA/ICctJyArICRzY29wZS5tb3Rpb24uaWRlbnRpZmllciA6ICcnO1xuICAgICAgICAgICAgdmFyIHBlcnNvbmFsTm90ZVN0cmluZyA9ICcgLSAnICsgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdwZXJzb25hbCBub3RlJyk7XG4gICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ01vdGlvbicpICsgaWRlbnRpZmllciArIHBlcnNvbmFsTm90ZVN0cmluZyArICcucGRmJztcbiAgICAgICAgICAgIE1vdGlvblBkZkV4cG9ydC5leHBvcnRQZXJzb25hbE5vdGUoJHNjb3BlLm1vdGlvbiwgZmlsZW5hbWUpO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdDaGFuZ2VSZWNvbW1lbmRhdGlvblRpdGxlVXBkYXRlQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24nLFxuICAgICdDaGFuZ2VSZWNvbW1lbmRhdGlvblRpdGxlRm9ybScsXG4gICAgJ2RpZmZTZXJ2aWNlJyxcbiAgICAnY2hhbmdlJyxcbiAgICAnRXJyb3JNZXNzYWdlJyxcbiAgICBmdW5jdGlvbiAoJHNjb3BlLCBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbiwgQ2hhbmdlUmVjb21tZW5kYXRpb25UaXRsZUZvcm0sIGRpZmZTZXJ2aWNlLCBjaGFuZ2UsIEVycm9yTWVzc2FnZSkge1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcbiAgICAgICAgJHNjb3BlLm1vZGVsID0gYW5ndWxhci5jb3B5KGNoYW5nZSk7XG5cbiAgICAgICAgLy8gZ2V0IGFsbCBmb3JtIGZpZWxkc1xuICAgICAgICAkc2NvcGUuZm9ybUZpZWxkcyA9IENoYW5nZVJlY29tbWVuZGF0aW9uVGl0bGVGb3JtLmdldEZvcm1GaWVsZHMoKTtcbiAgICAgICAgLy8gc2F2ZSBtb3Rpb25cbiAgICAgICAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAvLyBpbmplY3QgdGhlIGNoYW5nZWQgY2hhbmdlIHJlY29tbWVuZGF0aW9uIChjb3B5KSBvYmplY3QgYmFjayBpbnRvIERTIHN0b3JlXG4gICAgICAgICAgICBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbi5pbmplY3QoY2hhbmdlKTtcbiAgICAgICAgICAgIC8vIHNhdmUgY2hhbmdlZCBjaGFuZ2UgcmVjb21tZW5kYXRpb24gb2JqZWN0IG9uIHNlcnZlclxuICAgICAgICAgICAgTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24uc2F2ZShjaGFuZ2UpLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZVRoaXNEaWFsb2coKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbi5yZWZyZXNoKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IEVycm9yTWVzc2FnZS5mb3JBbGVydChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignQ2hhbmdlUmVjb21tZW5kYXRpb25UaXRsZUNyZWF0ZUN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ01vdGlvbicsXG4gICAgJ01vdGlvbkNoYW5nZVJlY29tbWVuZGF0aW9uJyxcbiAgICAnQ2hhbmdlUmVjb21tZW5kYXRpb25UaXRsZUZvcm0nLFxuICAgICdDb25maWcnLFxuICAgICdkaWZmU2VydmljZScsXG4gICAgJ21vdGlvbicsXG4gICAgJ3ZlcnNpb24nLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgTW90aW9uLCBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbiwgQ2hhbmdlUmVjb21tZW5kYXRpb25UaXRsZUZvcm0sIENvbmZpZywgZGlmZlNlcnZpY2UsIG1vdGlvbixcbiAgICAgICAgICAgICB2ZXJzaW9uKSB7XG4gICAgICAgICRzY29wZS5hbGVydCA9IHt9O1xuXG4gICAgICAgICRzY29wZS5tb2RlbCA9IHtcbiAgICAgICAgICAgIHRleHQ6IHZlcnNpb24udGl0bGUsXG4gICAgICAgICAgICBtb3Rpb25fdmVyc2lvbl9pZDogdmVyc2lvbi5pZFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdldCBhbGwgZm9ybSBmaWVsZHNcbiAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHMgPSBDaGFuZ2VSZWNvbW1lbmRhdGlvblRpdGxlRm9ybS5nZXRGb3JtRmllbGRzKCk7XG4gICAgICAgIC8vIHNhdmUgbW90aW9uXG4gICAgICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgY2hhbmdlLmxpbmVfZnJvbSA9IDA7XG4gICAgICAgICAgICBjaGFuZ2UubGluZV90byA9IDA7XG4gICAgICAgICAgICBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbi5jcmVhdGUoY2hhbmdlKS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VUaGlzRGlhbG9nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignQ2hhbmdlUmVjb21tZW5kYXRpb25UZXh0VXBkYXRlQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24nLFxuICAgICdDaGFuZ2VSZWNvbW1lbmRhdGlvblRleHRGb3JtJyxcbiAgICAnZGlmZlNlcnZpY2UnLFxuICAgICdjaGFuZ2UnLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsIE1vdGlvbkNoYW5nZVJlY29tbWVuZGF0aW9uLCBDaGFuZ2VSZWNvbW1lbmRhdGlvblRleHRGb3JtLCBkaWZmU2VydmljZSwgY2hhbmdlLCBFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge307XG4gICAgICAgICRzY29wZS5tb2RlbCA9IGFuZ3VsYXIuY29weShjaGFuZ2UpO1xuICAgICAgICAkc2NvcGUubW9kZWwuX2NoYW5nZV9vYmplY3QgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gZ2V0IGFsbCBmb3JtIGZpZWxkc1xuICAgICAgICAkc2NvcGUuZm9ybUZpZWxkcyA9IENoYW5nZVJlY29tbWVuZGF0aW9uVGV4dEZvcm0uZ2V0Rm9ybUZpZWxkcyhjaGFuZ2UubGluZV9mcm9tLCBjaGFuZ2UubGluZV90byk7XG4gICAgICAgIC8vIHNhdmUgbW90aW9uXG4gICAgICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgY2hhbmdlLnRleHQgPSBkaWZmU2VydmljZS5yZW1vdmVEdXBsaWNhdGVDbGFzc2VzSW5zZXJ0ZWRCeUNrZWRpdG9yKGNoYW5nZS50ZXh0KTtcbiAgICAgICAgICAgIC8vIGluamVjdCB0aGUgY2hhbmdlZCBjaGFuZ2UgcmVjb21tZW5kYXRpb24gKGNvcHkpIG9iamVjdCBiYWNrIGludG8gRFMgc3RvcmVcbiAgICAgICAgICAgIE1vdGlvbkNoYW5nZVJlY29tbWVuZGF0aW9uLmluamVjdChjaGFuZ2UpO1xuICAgICAgICAgICAgLy8gc2F2ZSBjaGFuZ2VkIGNoYW5nZSByZWNvbW1lbmRhdGlvbiBvYmplY3Qgb24gc2VydmVyXG4gICAgICAgICAgICBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbi5zYXZlKGNoYW5nZSkudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlVGhpc0RpYWxvZygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIE1vdGlvbkNoYW5nZVJlY29tbWVuZGF0aW9uLnJlZnJlc2goY2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdDaGFuZ2VSZWNvbW1lbmRhdGlvblRleHRDcmVhdGVDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICdNb3Rpb24nLFxuICAgICdNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbicsXG4gICAgJ0NoYW5nZVJlY29tbWVuZGF0aW9uVGV4dEZvcm0nLFxuICAgICdDb25maWcnLFxuICAgICdkaWZmU2VydmljZScsXG4gICAgJ21vdGlvbicsXG4gICAgJ3ZlcnNpb24nLFxuICAgICdsaW5lRnJvbScsXG4gICAgJ2xpbmVUbycsXG4gICAgZnVuY3Rpb24oJHNjb3BlLCBNb3Rpb24sIE1vdGlvbkNoYW5nZVJlY29tbWVuZGF0aW9uLCBDaGFuZ2VSZWNvbW1lbmRhdGlvblRleHRGb3JtLCBDb25maWcsIGRpZmZTZXJ2aWNlLCBtb3Rpb24sXG4gICAgICAgICAgICAgdmVyc2lvbiwgbGluZUZyb20sIGxpbmVUbykge1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcblxuICAgICAgICB2YXIgaHRtbCA9IG1vdGlvbi5nZXRUZXh0V2l0aExpbmVCcmVha3ModmVyc2lvbi5pZCksXG4gICAgICAgICAgICBsaW5lRGF0YSA9IGRpZmZTZXJ2aWNlLmV4dHJhY3RSYW5nZUJ5TGluZU51bWJlcnMoaHRtbCwgbGluZUZyb20sIGxpbmVUbyk7XG5cbiAgICAgICAgJHNjb3BlLm1vZGVsID0ge1xuICAgICAgICAgICAgdGV4dDogbGluZURhdGEub3V0ZXJDb250ZXh0U3RhcnQgKyBsaW5lRGF0YS5pbm5lckNvbnRleHRTdGFydCArXG4gICAgICAgICAgICAgICAgbGluZURhdGEuaHRtbCArIGxpbmVEYXRhLmlubmVyQ29udGV4dEVuZCArIGxpbmVEYXRhLm91dGVyQ29udGV4dEVuZCxcbiAgICAgICAgICAgIGxpbmVfZnJvbTogbGluZUZyb20sXG4gICAgICAgICAgICBsaW5lX3RvOiBsaW5lVG8sXG4gICAgICAgICAgICBtb3Rpb25fdmVyc2lvbl9pZDogdmVyc2lvbi5pZCxcbiAgICAgICAgICAgIHR5cGU6IDBcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBnZXQgYWxsIGZvcm0gZmllbGRzXG4gICAgICAgICRzY29wZS5mb3JtRmllbGRzID0gQ2hhbmdlUmVjb21tZW5kYXRpb25UZXh0Rm9ybS5nZXRGb3JtRmllbGRzKGxpbmVGcm9tLCBsaW5lVG8pO1xuICAgICAgICAvLyBzYXZlIG1vdGlvblxuICAgICAgICAkc2NvcGUuc2F2ZSA9IGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgIG1vdGlvbi50ZXh0ID0gZGlmZlNlcnZpY2UucmVtb3ZlRHVwbGljYXRlQ2xhc3Nlc0luc2VydGVkQnlDa2VkaXRvcihtb3Rpb24udGV4dCk7XG4gICAgICAgICAgICBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbi5jcmVhdGUobW90aW9uKS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VUaGlzRGlhbG9nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignQW1lbmRtZW50UGFyYWdyYXBoQ2hvb3NlQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJHN0YXRlJyxcbiAgICAnTW90aW9uJyxcbiAgICAnbW90aW9uJyxcbiAgICAnc3VjY2Vzc0NiJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSwgTW90aW9uLCBtb3Rpb24sIHN1Y2Nlc3NDYikge1xuICAgICAgICAkc2NvcGUubW9kZWwgPSBhbmd1bGFyLmNvcHkobW90aW9uKTtcbiAgICAgICAgJHNjb3BlLm1vZGVsLnBhcmFncmFwaF9zZWxlY3RlZCA9IG51bGw7XG5cbiAgICAgICAgJHNjb3BlLnBhcmFncmFwaHMgPSBtb3Rpb24uZ2V0VGV4dFBhcmFncmFwaHMobW90aW9uLmFjdGl2ZV92ZXJzaW9uLCB0cnVlKS5tYXAoZnVuY3Rpb24odGV4dCwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgYW4gZXJyb3IgaW4gbmctcmVwZWF0ZXIncyBkdXBsaWNhdGlvbiBkZXRlY3Rpb24gaWYgdHdvIGlkZW50aWNhbCBwYXJhZ3JhcGhzIG9jY3VyXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFwicGFyYWdyYXBoTm9cIjogaW5kZXgsXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzY29wZS5nb3RvTW90aW9uRm9ybSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFncmFwaE5vID0gcGFyc2VJbnQoJHNjb3BlLm1vZGVsLnBhcmFncmFwaF9zZWxlY3RlZCk7XG4gICAgICAgICAgICBzdWNjZXNzQ2IocGFyYWdyYXBoTm8pO1xuICAgICAgICAgICAgJHNjb3BlLmNsb3NlVGhpc0RpYWxvZygpO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdNb3Rpb25DcmVhdGVDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckc3RhdGUnLFxuICAgICdnZXR0ZXh0JyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdvcGVyYXRvcicsXG4gICAgJ01vdGlvbicsXG4gICAgJ01vdGlvbkZvcm0nLFxuICAgICdwYXJlbnRNb3Rpb24nLFxuICAgICdwYXJhZ3JhcGhObycsXG4gICAgJ3BhcmFncmFwaFRleHRQcmUnLFxuICAgICdDYXRlZ29yeScsXG4gICAgJ0NvbmZpZycsXG4gICAgJ01lZGlhZmlsZScsXG4gICAgJ1RhZycsXG4gICAgJ1VzZXInLFxuICAgICdXb3JrZmxvdycsXG4gICAgJ0FnZW5kYScsXG4gICAgJ0Vycm9yTWVzc2FnZScsXG4gICAgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGUsIGdldHRleHQsIGdldHRleHRDYXRhbG9nLCBvcGVyYXRvciwgTW90aW9uLCBNb3Rpb25Gb3JtLCBwYXJlbnRNb3Rpb24sXG4gICAgICAgIHBhcmFncmFwaE5vLCBwYXJhZ3JhcGhUZXh0UHJlLCBDYXRlZ29yeSwgQ29uZmlnLCBNZWRpYWZpbGUsIFRhZywgVXNlciwgV29ya2Zsb3csXG4gICAgICAgIEFnZW5kYSwgRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIENhdGVnb3J5LmJpbmRBbGwoe30sICRzY29wZSwgJ2NhdGVnb3JpZXMnKTtcbiAgICAgICAgTWVkaWFmaWxlLmJpbmRBbGwoe30sICRzY29wZSwgJ21lZGlhZmlsZXMnKTtcbiAgICAgICAgVGFnLmJpbmRBbGwoe30sICRzY29wZSwgJ3RhZ3MnKTtcbiAgICAgICAgVXNlci5iaW5kQWxsKHt9LCAkc2NvcGUsICd1c2VycycpO1xuICAgICAgICBXb3JrZmxvdy5iaW5kQWxsKHt9LCAkc2NvcGUsICd3b3JrZmxvd3MnKTtcblxuICAgICAgICAkc2NvcGUubW9kZWwgPSB7XG4gICAgICAgICAgICBhZ2VuZGFfdHlwZTogcGFyc2VJbnQoQ29uZmlnLmdldCgnYWdlbmRhX25ld19pdGVtc19kZWZhdWx0X3Zpc2liaWxpdHknKS52YWx1ZSksXG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge307XG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIGlzIGEgbmV3IGFtZW5kbWVudC5cbiAgICAgICAgdmFyIGlzQW1lbmRtZW50ID0gcGFyZW50TW90aW9uICYmIHBhcmVudE1vdGlvbi5pZCxcbiAgICAgICAgICAgIGlzUGFyYWdyYXBoQmFzZWRBbWVuZG1lbnQgPSBmYWxzZTtcblxuICAgICAgICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXMgZm9yIGNyZWF0ZSBmb3JtXG4gICAgICAgIC8vIC4uLiBmb3IgYW1lbmRtZW50cyBhZGQgcGFyZW50X2lkXG4gICAgICAgIGlmIChpc0FtZW5kbWVudCkge1xuICAgICAgICAgICAgaWYgKENvbmZpZy5nZXQoJ21vdGlvbnNfYW1lbmRtZW50c190ZXh0X21vZGUnKS52YWx1ZSA9PT0gJ2Z1bGx0ZXh0Jykge1xuICAgICAgICAgICAgICAgICRzY29wZS5tb2RlbC50ZXh0ID0gcGFyZW50TW90aW9uLmdldFRleHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChDb25maWcuZ2V0KCdtb3Rpb25zX2FtZW5kbWVudHNfdGV4dF9tb2RlJykudmFsdWUgPT09ICdwYXJhZ3JhcGgnICYmXG4gICAgICAgICAgICAgICAgcGFyYWdyYXBoTm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhZ3JhcGhzID0gcGFyZW50TW90aW9uLmdldFRleHRQYXJhZ3JhcGhzKHBhcmVudE1vdGlvbi5hY3RpdmVfdmVyc2lvbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICRzY29wZS5tb2RlbC50ZXh0ID0gcGFyYWdyYXBoc1twYXJhZ3JhcGhOb107XG4gICAgICAgICAgICAgICAgaXNQYXJhZ3JhcGhCYXNlZEFtZW5kbWVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYWdyYXBoVGV4dFByZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm1vZGVsLnRleHQgPSBwYXJhZ3JhcGhUZXh0UHJlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudE1vdGlvbi5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm1vZGVsLnRpdGxlID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdBbWVuZG1lbnQgdG8nKSArXG4gICAgICAgICAgICAgICAgICAgICcgJyArIHBhcmVudE1vdGlvbi5pZGVudGlmaWVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUubW9kZWwudGl0bGUgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0FtZW5kbWVudCB0byBtb3Rpb24gJykgK1xuICAgICAgICAgICAgICAgICAgICAnICcgKyBwYXJlbnRNb3Rpb24uZ2V0VGl0bGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5tb2RlbC5wYXJhZ3JhcGhObyA9IHBhcmFncmFwaE5vO1xuICAgICAgICAgICAgJHNjb3BlLm1vZGVsLnBhcmVudF9pZCA9IHBhcmVudE1vdGlvbi5pZDtcbiAgICAgICAgICAgICRzY29wZS5tb2RlbC5jYXRlZ29yeV9pZCA9IHBhcmVudE1vdGlvbi5jYXRlZ29yeV9pZDtcbiAgICAgICAgICAgICRzY29wZS5tb2RlbC5tb3Rpb25fYmxvY2tfaWQgPSBwYXJlbnRNb3Rpb24ubW90aW9uX2Jsb2NrX2lkO1xuICAgICAgICAgICAgTW90aW9uLmJpbmRPbmUoJHNjb3BlLm1vZGVsLnBhcmVudF9pZCwgJHNjb3BlLCAncGFyZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLi4uIHByZXNlbGVjdCBkZWZhdWx0IHdvcmtmbG93IGlmIGV4aXN0XG4gICAgICAgIHZhciB3b3JrZmxvdyA9IFdvcmtmbG93LmdldChDb25maWcuZ2V0KCdtb3Rpb25zX3dvcmtmbG93JykudmFsdWUpO1xuICAgICAgICBpZiAoIXdvcmtmbG93KSB7XG4gICAgICAgICAgICB3b3JrZmxvdyA9IF8uZmlyc3QoV29ya2Zsb3cuZ2V0QWxsKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrZmxvdykge1xuICAgICAgICAgICAgJHNjb3BlLm1vZGVsLndvcmtmbG93X2lkID0gd29ya2Zsb3cuaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RhbmdlcicsXG4gICAgICAgICAgICAgICAgbXNnOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ05vIHdvcmtmbG93cyBleGlzdHMuIFlvdSB3aWxsIG5vdCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2JlIGFibGUgdG8gY3JlYXRlIGEgbW90aW9uLicpLFxuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGFsbCBmb3JtIGZpZWxkc1xuICAgICAgICAkc2NvcGUuZm9ybUZpZWxkcyA9IE1vdGlvbkZvcm0uZ2V0Rm9ybUZpZWxkcyh0cnVlLCBpc1BhcmFncmFwaEJhc2VkQW1lbmRtZW50KTtcblxuICAgICAgICAvLyBzYXZlIG1vdGlvblxuICAgICAgICAkc2NvcGUuc2F2ZSA9IGZ1bmN0aW9uIChtb3Rpb24sIGdvdG9EZXRhaWxWaWV3KSB7XG4gICAgICAgICAgICBpZiAoaXNBbWVuZG1lbnQgJiYgbW90aW9uLnBhcmFncmFwaE5vICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ19wYXJhZ3JhcGhzID0gcGFyZW50TW90aW9uLmdldFRleHRQYXJhZ3JhcGhzKHBhcmVudE1vdGlvbi5hY3RpdmVfdmVyc2lvbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIG1vdGlvbi5hbWVuZG1lbnRfcGFyYWdyYXBocyA9IG9yaWdfcGFyYWdyYXBocy5tYXAoZnVuY3Rpb24gKF8sIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGlkeCA9PT0gbW90aW9uLnBhcmFncmFwaE5vID8gbW90aW9uLnRleHQgOiBudWxsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGF0dHJpYnV0ZSBtb3Rpb24uYWdlbmRhX3BhcmVudF9pZCBpcyBzZXQgYnkgdGhlIGZvcm0sIHNlZSBmb3JtIGRlZmluaXRpb24uXG4gICAgICAgICAgICBNb3Rpb24uY3JlYXRlKG1vdGlvbikudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FtZW5kbWVudCB8fCBnb3RvRGV0YWlsVmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdtb3Rpb25zLm1vdGlvbi5kZXRhaWwnLCB7aWQ6IHN1Y2Nlc3MuaWR9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VUaGlzRGlhbG9nKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdNb3Rpb25VcGRhdGVDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckc3RhdGUnLFxuICAgICdNb3Rpb24nLFxuICAgICdDYXRlZ29yeScsXG4gICAgJ0NvbmZpZycsXG4gICAgJ01lZGlhZmlsZScsXG4gICAgJ01vdGlvbkZvcm0nLFxuICAgICdUYWcnLFxuICAgICdVc2VyJyxcbiAgICAnV29ya2Zsb3cnLFxuICAgICdBZ2VuZGEnLFxuICAgICdtb3Rpb25JZCcsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnRXJyb3JNZXNzYWdlJyxcbiAgICAnRWRpdGluZ1dhcm5pbmcnLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSwgTW90aW9uLCBDYXRlZ29yeSwgQ29uZmlnLCBNZWRpYWZpbGUsIE1vdGlvbkZvcm0sXG4gICAgICAgIFRhZywgVXNlciwgV29ya2Zsb3csIEFnZW5kYSwgbW90aW9uSWQsIG9wZXJhdG9yLCBFcnJvck1lc3NhZ2UsXG4gICAgICAgIEVkaXRpbmdXYXJuaW5nKSB7XG4gICAgICAgIENhdGVnb3J5LmJpbmRBbGwoe30sICRzY29wZSwgJ2NhdGVnb3JpZXMnKTtcbiAgICAgICAgTWVkaWFmaWxlLmJpbmRBbGwoe30sICRzY29wZSwgJ21lZGlhZmlsZXMnKTtcbiAgICAgICAgVGFnLmJpbmRBbGwoe30sICRzY29wZSwgJ3RhZ3MnKTtcbiAgICAgICAgVXNlci5iaW5kQWxsKHt9LCAkc2NvcGUsICd1c2VycycpO1xuICAgICAgICBXb3JrZmxvdy5iaW5kQWxsKHt9LCAkc2NvcGUsICd3b3JrZmxvd3MnKTtcbiAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge307XG5cbiAgICAgICAgLy8gc2V0IGluaXRpYWwgdmFsdWVzIGZvciBmb3JtIG1vZGVsIGJ5IGNyZWF0ZSBkZWVwIGNvcHkgb2YgbW90aW9uIG9iamVjdFxuICAgICAgICAvLyBzbyBsaXN0L2RldGFpbCB2aWV3IGlzIG5vdCB1cGRhdGVkIHdoaWxlIGVkaXRpbmdcbiAgICAgICAgdmFyIG1vdGlvbiA9IE1vdGlvbi5nZXQobW90aW9uSWQpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGNsb25lIHRoaXMgYnkgaGFuZC4gYW5ndWxhciBhbmQgbG9kYXNoIGFyZSBub3QgY2FwYWJsZSBvZiBrZWVwaW5nXG4gICAgICAgIC8vIGNyb3NzcmVmZXJlbmNlcyBvdXQuXG4gICAgICAgICRzY29wZS5tb2RlbCA9IHtcbiAgICAgICAgICAgIGlkOiBtb3Rpb24uaWQsXG4gICAgICAgICAgICBwYXJlbnRfaWQ6IG1vdGlvbi5wYXJlbnRfaWQsXG4gICAgICAgICAgICBpZGVudGlmaWVyOiBtb3Rpb24uaWRlbnRpZmllcixcbiAgICAgICAgICAgIHRpdGxlOiBtb3Rpb24uZ2V0VGl0bGUoKSxcbiAgICAgICAgICAgIHRleHQ6IG1vdGlvbi5nZXRUZXh0KCksXG4gICAgICAgICAgICByZWFzb246IG1vdGlvbi5nZXRSZWFzb24oKSxcbiAgICAgICAgICAgIHN1Ym1pdHRlcnNfaWQ6IF8ubWFwKG1vdGlvbi5zdWJtaXR0ZXJzX2lkKSxcbiAgICAgICAgICAgIHN1cHBvcnRlcnNfaWQ6IF8ubWFwKG1vdGlvbi5zdXBwb3J0ZXJzX2lkKSxcbiAgICAgICAgICAgIHRhZ3NfaWQ6IF8ubWFwKG1vdGlvbi50YWdzX2lkKSxcbiAgICAgICAgICAgIHN0YXRlX2lkOiBtb3Rpb24uc3RhdGVfaWQsXG4gICAgICAgICAgICByZWNvbW1lbmRhdGlvbl9pZDogbW90aW9uLnJlY29tbWVuZGF0aW9uX2lkLFxuICAgICAgICAgICAgb3JpZ2luOiBtb3Rpb24ub3JpZ2luLFxuICAgICAgICAgICAgd29ya2Zsb3dfaWQ6IG1vdGlvbi53b3JrZmxvd19pZCxcbiAgICAgICAgICAgIGNvbW1lbnRzOiBfLmNsb25lKG1vdGlvbi5jb21tZW50cyksXG4gICAgICAgICAgICBhdHRhY2htZW50c19pZDogXy5tYXAobW90aW9uLmF0dGFjaG1lbnRzX2lkKSxcbiAgICAgICAgICAgIGFjdGl2ZV92ZXJzaW9uOiBtb3Rpb24uYWN0aXZlX3ZlcnNpb24sXG4gICAgICAgICAgICBhZ2VuZGFfaXRlbV9pZDogbW90aW9uLmFnZW5kYV9pdGVtX2lkLFxuICAgICAgICAgICAgY2F0ZWdvcnlfaWQ6IG1vdGlvbi5jYXRlZ29yeV9pZCxcbiAgICAgICAgICAgIG1vdGlvbl9ibG9ja19pZDogbW90aW9uLm1vdGlvbl9ibG9ja19pZCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ2xvbmUgY29tbWVudHNcbiAgICAgICAgXy5mb3JFYWNoKG1vdGlvbi5jb21tZW50cywgZnVuY3Rpb24gKGNvbW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAkc2NvcGUubW9kZWxbJ2NvbW1lbnRfJyArIGluZGV4XSA9IGNvbW1lbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICAkc2NvcGUubW9kZWwuZGlzYWJsZV92ZXJzaW9uaW5nID0gZmFsc2U7XG4gICAgICAgICRzY29wZS5tb2RlbC5tb3JlID0gZmFsc2U7XG4gICAgICAgIGlmIChtb3Rpb24uaXNQYXJhZ3JhcGhCYXNlZEFtZW5kbWVudCgpKSB7XG4gICAgICAgICAgICBtb3Rpb24uZ2V0VmVyc2lvbihtb3Rpb24uYWN0aXZlX3ZlcnNpb24pLmFtZW5kbWVudF9wYXJhZ3JhcGhzLmZvckVhY2goZnVuY3Rpb24ocGFyYWdyYXBoX2FtZW5kLCBwYXJhZ3JhcGhObykge1xuICAgICAgICAgICAgICAgIC8vIEhpbnQ6IHRoaXMgYXNzdW1lcyB0aGVyZSBpcyBvbmx5IG9uZSBtb2RpZmllZCBwYXJhZ3JhcGhcbiAgICAgICAgICAgICAgICBpZiAocGFyYWdyYXBoX2FtZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5tb2RlbC50ZXh0ID0gcGFyYWdyYXBoX2FtZW5kO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUubW9kZWwucGFyYWdyYXBoTm8gPSBwYXJhZ3JhcGhObztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzY29wZS5tb2RlbC50aXRsZSA9IG1vdGlvbi5nZXRUaXRsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGFsbCBmb3JtIGZpZWxkc1xuICAgICAgICAkc2NvcGUuZm9ybUZpZWxkcyA9IE1vdGlvbkZvcm0uZ2V0Rm9ybUZpZWxkcyhmYWxzZSwgbW90aW9uLmlzUGFyYWdyYXBoQmFzZWRBbWVuZG1lbnQoKSk7XG4gICAgICAgIC8vIG92ZXJyaWRlIGRlZmF1bHQgdmFsdWVzIGZvciB1cGRhdGUgZm9ybVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICRzY29wZS5mb3JtRmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoJHNjb3BlLmZvcm1GaWVsZHNbaV0ua2V5ID09IFwiaWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvdyBpZGVudGlmaWVyIGZpZWxkIGlmIHRoZSBvcGVyYXRvciBoYXMgbWFuYWdlIHBlcm1pc3Npb25zXG4gICAgICAgICAgICAgICAkc2NvcGUuZm9ybUZpZWxkc1tpXS5oaWRlID0gIW9wZXJhdG9yLmhhc1Blcm1zKCdtb3Rpb25zLmNhbl9tYW5hZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkc2NvcGUuZm9ybUZpZWxkc1tpXS5rZXkgPT0gXCJ0aXRsZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRpdGxlIG9mIGxhdGVzdCB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHNbaV0uZGVmYXVsdFZhbHVlID0gbW90aW9uLmdldFRpdGxlKC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkc2NvcGUuZm9ybUZpZWxkc1tpXS5rZXkgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGV4dCBvZiBsYXRlc3QgdmVyc2lvblxuICAgICAgICAgICAgICAgICRzY29wZS5mb3JtRmllbGRzW2ldLmRlZmF1bHRWYWx1ZSA9IG1vdGlvbi5nZXRUZXh0KC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkc2NvcGUuZm9ybUZpZWxkc1tpXS5rZXkgPT0gXCJyZWFzb25cIikge1xuICAgICAgICAgICAgICAgIC8vIGdldCByZWFzb24gb2YgbGF0ZXN0IHZlcnNpb25cbiAgICAgICAgICAgICAgICAkc2NvcGUuZm9ybUZpZWxkc1tpXS5kZWZhdWx0VmFsdWUgPSBtb3Rpb24uZ2V0UmVhc29uKC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkc2NvcGUuZm9ybUZpZWxkc1tpXS5rZXkgPT0gXCJkaXNhYmxlX3ZlcnNpb25pbmdcIikge1xuICAgICAgICAgICAgICAgIGlmIChDb25maWcuZ2V0KCdtb3Rpb25zX2FsbG93X2Rpc2FibGVfdmVyc2lvbmluZycpLnZhbHVlICYmIG1vdGlvbi5zdGF0ZS52ZXJzaW9uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGN1cnJlbnQgc3RhdGUgaWYgdmVyc2lvbmluZyBpcyBhY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHNbaV0uaGlkZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkc2NvcGUuZm9ybUZpZWxkc1tpXS5rZXkgPT0gXCJ3b3JrZmxvd19pZFwiKSB7XG4gICAgICAgICAgICAgICAvLyBnZXQgc2F2ZWQgd29ya2Zsb3cgaWQgZnJvbSBzdGF0ZVxuICAgICAgICAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHNbaV0uZGVmYXVsdFZhbHVlID0gbW90aW9uLnN0YXRlLndvcmtmbG93X2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzcGxheWluZyBhIHdhcm5pbmcsIGlmIG90aGVyIHVzZXJzIGVkaXQgdGhpcyBtb3Rpb24gdG9vXG4gICAgICAgIHZhciBlZGl0aW5nU3RvcHBlZENhbGxiYWNrID0gRWRpdGluZ1dhcm5pbmcuZWRpdGluZ1N0YXJ0ZWQoJ21vdGlvbl91cGRhdGVfJyArIG1vdGlvbklkKTtcbiAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBlZGl0aW5nU3RvcHBlZENhbGxiYWNrKTtcblxuICAgICAgICAvLyBTYXZlIG1vdGlvblxuICAgICAgICAkc2NvcGUuc2F2ZSA9IGZ1bmN0aW9uIChtb2RlbCwgZ290b0RldGFpbFZpZXcpIHtcbiAgICAgICAgICAgIGlmICgkc2NvcGUubW9kZWwucGFyYWdyYXBoTm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRNb3Rpb24gPSBtb3Rpb24uZ2V0UGFyZW50TW90aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdfcGFyYWdyYXBocyA9IHBhcmVudE1vdGlvbi5nZXRUZXh0UGFyYWdyYXBocyhwYXJlbnRNb3Rpb24uYWN0aXZlX3ZlcnNpb24sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUubW9kZWwuYW1lbmRtZW50X3BhcmFncmFwaHMgPSBvcmlnX3BhcmFncmFwaHMubWFwKGZ1bmN0aW9uIChfLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpZHggPT09ICRzY29wZS5tb2RlbC5wYXJhZ3JhcGhObyA/ICRzY29wZS5tb2RlbC50ZXh0IDogbnVsbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluamVjdCB0aGUgY2hhbmdlZCBtb3Rpb24gKGNvcHkpIG9iamVjdCBiYWNrIGludG8gRFMgc3RvcmVcbiAgICAgICAgICAgIE1vdGlvbi5pbmplY3QobW9kZWwpO1xuICAgICAgICAgICAgLy8gc2F2ZSBjaGFuZ2VkIG1vdGlvbiBvYmplY3Qgb24gc2VydmVyXG4gICAgICAgICAgICBNb3Rpb24uc2F2ZShtb2RlbCkudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnb3RvRGV0YWlsVmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdtb3Rpb25zLm1vdGlvbi5kZXRhaWwnLCB7aWQ6IHN1Y2Nlc3MuaWR9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VUaGlzRGlhbG9nKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBlcnJvcjogcmV2ZXJ0IGFsbCBjaGFuZ2VzIGJ5IHJlc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gKHJlZnJlc2gpIG9yaWdpbmFsIG1vdGlvbiBvYmplY3QgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgTW90aW9uLnJlZnJlc2gobW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ01vdGlvbkNvbW1lbnRDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICdNb3Rpb24nLFxuICAgICdNb3Rpb25Db21tZW50JyxcbiAgICAnTW90aW9uQ29tbWVudEZvcm0nLFxuICAgICdtb3Rpb25JZCcsXG4gICAgJ2NvbW1lbnRGaWVsZElkJyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsIE1vdGlvbiwgTW90aW9uQ29tbWVudCwgTW90aW9uQ29tbWVudEZvcm0sIG1vdGlvbklkLCBjb21tZW50RmllbGRJZCxcbiAgICAgICAgZ2V0dGV4dENhdGFsb2csIEVycm9yTWVzc2FnZSkge1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcblxuICAgICAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZXMgZm9yIGZvcm0gbW9kZWwgYnkgY3JlYXRlIGRlZXAgY29weSBvZiBtb3Rpb24gb2JqZWN0XG4gICAgICAgIC8vIHNvIGxpc3QvZGV0YWlsIHZpZXcgaXMgbm90IHVwZGF0ZWQgd2hpbGUgZWRpdGluZ1xuICAgICAgICB2YXIgbW90aW9uID0gTW90aW9uLmdldChtb3Rpb25JZCk7XG4gICAgICAgICRzY29wZS5tb2RlbCA9IGFuZ3VsYXIuY29weShtb3Rpb24pO1xuICAgICAgICAkc2NvcGUuZm9ybUZpZWxkcyA9IE1vdGlvbkNvbW1lbnRGb3JtLmdldEZvcm1GaWVsZHMoY29tbWVudEZpZWxkSWQpO1xuXG4gICAgICAgIHZhciBmaWVsZHMgPSBNb3Rpb25Db21tZW50LmdldE5vU3BlY2lhbENvbW1lbnRzRmllbGRzKCk7XG4gICAgICAgIHZhciB0aXRsZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnRWRpdCBjb21tZW50ICUlY29tbWVudCUlIG9mIG1vdGlvbiAlJW1vdGlvbiUlJyk7XG4gICAgICAgIHRpdGxlID0gdGl0bGUucmVwbGFjZSgnJSVjb21tZW50JSUnLCBmaWVsZHNbY29tbWVudEZpZWxkSWRdLm5hbWUpO1xuICAgICAgICAkc2NvcGUudGl0bGUgPSB0aXRsZS5yZXBsYWNlKCclJW1vdGlvbiUlJywgbW90aW9uLmdldFRpdGxlKCkpO1xuXG4gICAgICAgICRzY29wZS5tb2RlbC50aXRsZSA9IG1vdGlvbi5nZXRUaXRsZSgtMSk7XG4gICAgICAgICRzY29wZS5tb2RlbC50ZXh0ID0gbW90aW9uLmdldFRleHQoLTEpO1xuICAgICAgICAkc2NvcGUubW9kZWwucmVhc29uID0gbW90aW9uLmdldFJlYXNvbigtMSk7XG5cbiAgICAgICAgaWYgKG1vdGlvbi5pc1BhcmFncmFwaEJhc2VkQW1lbmRtZW50KCkpIHtcbiAgICAgICAgICAgIG1vdGlvbi5nZXRWZXJzaW9uKG1vdGlvbi5hY3RpdmVfdmVyc2lvbikuYW1lbmRtZW50X3BhcmFncmFwaHMuZm9yRWFjaChmdW5jdGlvbihwYXJhZ3JhcGhfYW1lbmQsIHBhcmFncmFwaE5vKSB7XG4gICAgICAgICAgICAgICAgLy8gSGludDogdGhpcyBhc3N1bWVzIHRoZXJlIGlzIG9ubHkgb25lIG1vZGlmaWVkIHBhcmFncmFwaFxuICAgICAgICAgICAgICAgIGlmIChwYXJhZ3JhcGhfYW1lbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm1vZGVsLnRleHQgPSBwYXJhZ3JhcGhfYW1lbmQ7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5tb2RlbC5wYXJhZ3JhcGhObyA9IHBhcmFncmFwaE5vO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICBpZiAobW90aW9uLmlzUGFyYWdyYXBoQmFzZWRBbWVuZG1lbnQoKSkge1xuICAgICAgICAgICAgICAgIG1vdGlvbi5nZXRWZXJzaW9uKG1vdGlvbi5hY3RpdmVfdmVyc2lvbikuYW1lbmRtZW50X3BhcmFncmFwaHMuZm9yRWFjaChmdW5jdGlvbihwYXJhZ3JhcGhfYW1lbmQsIHBhcmFncmFwaE5vKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhpbnQ6IHRoaXMgYXNzdW1lcyB0aGVyZSBpcyBvbmx5IG9uZSBtb2RpZmllZCBwYXJhZ3JhcGhcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFncmFwaF9hbWVuZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm1vZGVsLnRleHQgPSBwYXJhZ3JhcGhfYW1lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubW9kZWwucGFyYWdyYXBoTm8gPSBwYXJhZ3JhcGhObztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbmplY3QgdGhlIGNoYW5nZWQgbW90aW9uIChjb3B5KSBvYmplY3QgYmFjayBpbnRvIERTIHN0b3JlXG4gICAgICAgICAgICBNb3Rpb24uaW5qZWN0KG1vdGlvbik7XG4gICAgICAgICAgICAvLyBzYXZlIGNoYW5nZWQgbW90aW9uIG9iamVjdCBvbiBzZXJ2ZXJcbiAgICAgICAgICAgIE1vdGlvbi5zYXZlKG1vdGlvbikudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZVRoaXNEaWFsb2coKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGVycm9yOiByZXZlcnQgYWxsIGNoYW5nZXMgYnkgcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICAvLyAocmVmcmVzaCkgb3JpZ2luYWwgbW90aW9uIG9iamVjdCBmcm9tIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICBNb3Rpb24ucmVmcmVzaChtb3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ01vdGlvblBvbGxVcGRhdGVDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ01vdGlvblBvbGwnLFxuICAgICdNb3Rpb25Qb2xsRm9ybScsXG4gICAgJ01vdGlvblBvbGxEZWNpbWFsUGxhY2VzJyxcbiAgICAnbW90aW9ucG9sbElkJyxcbiAgICAndm90ZU51bWJlcicsXG4gICAgJ0Vycm9yTWVzc2FnZScsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgZ2V0dGV4dENhdGFsb2csIE1vdGlvblBvbGwsIE1vdGlvblBvbGxGb3JtLCBNb3Rpb25Qb2xsRGVjaW1hbFBsYWNlcyxcbiAgICAgICAgbW90aW9ucG9sbElkLCB2b3RlTnVtYmVyLCBFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgdmFsdWVzIGZvciBmb3JtIG1vZGVsIGJ5IGNyZWF0ZSBkZWVwIGNvcHkgb2YgbW90aW9ucG9sbCBvYmplY3RcbiAgICAgICAgLy8gc28gZGV0YWlsIHZpZXcgaXMgbm90IHVwZGF0ZWQgd2hpbGUgZWRpdGluZyBwb2xsXG4gICAgICAgIHZhciBtb3Rpb25wb2xsID0gTW90aW9uUG9sbC5nZXQobW90aW9ucG9sbElkKTtcbiAgICAgICAgJHNjb3BlLm1vZGVsID0gYW5ndWxhci5jb3B5KG1vdGlvbnBvbGwpO1xuICAgICAgICAkc2NvcGUudm90ZU51bWJlciA9IHZvdGVOdW1iZXI7XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBNb3Rpb25Qb2xsRGVjaW1hbFBsYWNlcy5nZXRQbGFjZXMobW90aW9ucG9sbCk7XG4gICAgICAgICRzY29wZS5mb3JtRmllbGRzID0gTW90aW9uUG9sbEZvcm0uZ2V0Rm9ybUZpZWxkcyhwcmVjaXNpb24pO1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcblxuICAgICAgICAvLyBzYXZlIG1vdGlvbnBvbGxcbiAgICAgICAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbiAocG9sbCkge1xuICAgICAgICAgICAgcG9sbC5EU1VwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vdGlvbl9pZDogcG9sbC5tb3Rpb25faWQsXG4gICAgICAgICAgICAgICAgICAgIHZvdGVzOiB7XCJZZXNcIjogcG9sbC55ZXMsIFwiTm9cIjogcG9sbC5ubywgXCJBYnN0YWluXCI6IHBvbGwuYWJzdGFpbn0sXG4gICAgICAgICAgICAgICAgICAgIHZvdGVzdmFsaWQ6IHBvbGwudm90ZXN2YWxpZCxcbiAgICAgICAgICAgICAgICAgICAgdm90ZXNpbnZhbGlkOiBwb2xsLnZvdGVzaW52YWxpZCxcbiAgICAgICAgICAgICAgICAgICAgdm90ZXNjYXN0OiBwb2xsLnZvdGVzY2FzdFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0LnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VUaGlzRGlhbG9nKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ01vdGlvblN1Ym1pdHRlckN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRmaWx0ZXInLFxuICAgICckaHR0cCcsXG4gICAgJ1VzZXInLFxuICAgICdNb3Rpb24nLFxuICAgICdtb3Rpb25JZCcsXG4gICAgJ0Vycm9yTWVzc2FnZScsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgJGZpbHRlciwgJGh0dHAsIFVzZXIsIE1vdGlvbiwgbW90aW9uSWQsIEVycm9yTWVzc2FnZSkge1xuICAgICAgICBVc2VyLmJpbmRBbGwoe30sICRzY29wZSwgJ3VzZXJzJyk7XG4gICAgICAgICRzY29wZS5zdWJtaXR0ZXJTZWxlY3RCb3ggPSB7fTtcbiAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge307XG5cbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTW90aW9uLmxhc3RNb2RpZmllZChtb3Rpb25JZCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5tb3Rpb24gPSBNb3Rpb24uZ2V0KG1vdGlvbklkKTtcbiAgICAgICAgICAgICRzY29wZS5zdWJtaXR0ZXJzID0gJGZpbHRlcignb3JkZXJCeScpKCRzY29wZS5tb3Rpb24uc3VibWl0dGVycywgJ3dlaWdodCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkc2NvcGUuYWRkU3VibWl0dGVyID0gZnVuY3Rpb24gKHVzZXJJZCkge1xuICAgICAgICAgICAgJHNjb3BlLnN1Ym1pdHRlclNlbGVjdEJveCA9IHt9O1xuICAgICAgICAgICAgJGh0dHAucG9zdCgnL3Jlc3QvbW90aW9ucy9tb3Rpb24vJyArICRzY29wZS5tb3Rpb24uaWQgKyAnL21hbmFnZV9zdWJtaXR0ZXJzLycsIHtcbiAgICAgICAgICAgICAgICAndXNlcic6IHVzZXJJZFxuICAgICAgICAgICAgfSkudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQuc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLnJlbW92ZVN1Ym1pdHRlciA9IGZ1bmN0aW9uICh1c2VySWQpIHtcbiAgICAgICAgICAgICRodHRwLmRlbGV0ZSgnL3Jlc3QvbW90aW9ucy9tb3Rpb24vJyArICRzY29wZS5tb3Rpb24uaWQgKyAnL21hbmFnZV9zdWJtaXR0ZXJzLycsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ30sXG4gICAgICAgICAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoe3VzZXI6IHVzZXJJZH0pXG4gICAgICAgICAgICB9KS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydC5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IEVycm9yTWVzc2FnZS5mb3JBbGVydChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzYXZlIHJlb3JkZXJlZCBsaXN0IG9mIHN1Ym1pdHRlcnNcbiAgICAgICAgJHNjb3BlLnRyZWVPcHRpb25zID0ge1xuICAgICAgICAgICAgZHJvcHBlZDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1Ym1pdHRlcklkcyA9IF8ubWFwKCRzY29wZS5zdWJtaXR0ZXJzLCBmdW5jdGlvbiAoc3VibWl0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJtaXR0ZXIuaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJGh0dHAucG9zdCgnL3Jlc3QvbW90aW9ucy9tb3Rpb24vJyArICRzY29wZS5tb3Rpb24uaWQgKyAnL3NvcnRfc3VibWl0dGVycy8nLCB7XG4gICAgICAgICAgICAgICAgICAgIHN1Ym1pdHRlcnM6IHN1Ym1pdHRlcklkcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignTW90aW9uQW1lbmRtZW50TGlzdFN0YXRlQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnbW90aW9uSWQnLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsIG1vdGlvbklkKSB7XG4gICAgICAgICRzY29wZS5tb3Rpb25JZCA9IG1vdGlvbklkO1xuICAgICAgICAkc2NvcGUub3NUYWJsZVByZWZpeCA9ICdBbWVuZG1lbnRUYWJsZSc7XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ01vdGlvbkFtZW5kbWVudExpc3RDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckc2Vzc2lvblN0b3JhZ2UnLFxuICAgICckc3RhdGUnLFxuICAgICdNb3Rpb24nLFxuICAgICdNb3Rpb25Db21tZW50JyxcbiAgICAnTW90aW9uRm9ybScsXG4gICAgJ1BlcnNvbmFsTm90ZU1hbmFnZXInLFxuICAgICduZ0RpYWxvZycsXG4gICAgJ01vdGlvbkNvbW1lbnRGb3JtJyxcbiAgICAnTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24nLFxuICAgICdNb3Rpb25QZGZFeHBvcnQnLFxuICAgICdBbWVuZG1lbnRDc3ZFeHBvcnQnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ2dldHRleHQnLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsICRzZXNzaW9uU3RvcmFnZSwgJHN0YXRlLCBNb3Rpb24sIE1vdGlvbkNvbW1lbnQsIE1vdGlvbkZvcm0sXG4gICAgICAgIFBlcnNvbmFsTm90ZU1hbmFnZXIsIG5nRGlhbG9nLCBNb3Rpb25Db21tZW50Rm9ybSwgTW90aW9uQ2hhbmdlUmVjb21tZW5kYXRpb24sXG4gICAgICAgIE1vdGlvblBkZkV4cG9ydCwgQW1lbmRtZW50Q3N2RXhwb3J0LCBnZXR0ZXh0Q2F0YWxvZywgZ2V0dGV4dCkge1xuICAgICAgICBpZiAoJHNjb3BlLm1vdGlvbklkKSB7XG4gICAgICAgICAgICAkc2NvcGUubGVhZE1vdGlvbiA9IE1vdGlvbi5nZXQoJHNjb3BlLm1vdGlvbklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cGRhdGVNb3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY2hlY2ssIGlmIGxlYWQgbW90aW9uIGlzIGdpdmVuXG4gICAgICAgICAgICB2YXIgYW1lbmRtZW50cztcbiAgICAgICAgICAgIGlmICgkc2NvcGUubGVhZE1vdGlvbikge1xuICAgICAgICAgICAgICAgIGFtZW5kbWVudHMgPSBNb3Rpb24uZmlsdGVyKHtwYXJlbnRfaWQ6ICRzY29wZS5sZWFkTW90aW9uLmlkfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFtZW5kbWVudHMgPSBfLmZpbHRlcihNb3Rpb24uZ2V0QWxsKCksIGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vdGlvbi5wYXJlbnRfaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbHdheXMgb3JkZXIgYnkgaWRlbnRpZmllciAoYWZ0ZXIgY3VzdG9tIG9yZGVyaW5nKVxuICAgICAgICAgICAgJHNjb3BlLmFtZW5kbWVudHMgPSBfLm9yZGVyQnkoYW1lbmRtZW50cywgWydpZGVudGlmaWVyJ10pO1xuXG4gICAgICAgICAgICBfLmZvckVhY2goJHNjb3BlLmFtZW5kbWVudHMsIGZ1bmN0aW9uIChhbWVuZG1lbnQpIHtcbiAgICAgICAgICAgICAgICBNb3Rpb25Db21tZW50LnBvcHVsYXRlRmllbGRzKGFtZW5kbWVudCk7XG4gICAgICAgICAgICAgICAgYW1lbmRtZW50LnBlcnNvbmFsTm90ZSA9IFBlcnNvbmFsTm90ZU1hbmFnZXIuZ2V0Tm90ZShhbWVuZG1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIEZvciBmaWx0ZXJpbmcsIHdlIGNhbm5vdCBmaWx0ZXIgZm9yIC5wZXJzb25hbE5vdGUuc3RhclxuICAgICAgICAgICAgICAgIGFtZW5kbWVudC5zdGFyID0gYW1lbmRtZW50LnBlcnNvbmFsTm90ZSA/IGFtZW5kbWVudC5wZXJzb25hbE5vdGUuc3RhciA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFtZW5kbWVudC5oYXNQZXJzb25hbE5vdGUgPSBhbWVuZG1lbnQucGVyc29uYWxOb3RlID8gISFhbWVuZG1lbnQucGVyc29uYWxOb3RlLm5vdGUgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoYW1lbmRtZW50LnN0YXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBhbWVuZG1lbnQuc3RhciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFkZCBhIGN1c3RvbSBzb3J0IGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRNb3Rpb24gPSBhbWVuZG1lbnQuZ2V0UGFyZW50TW90aW9uKCk7XG4gICAgICAgICAgICAgICAgYW1lbmRtZW50LnBhcmVudE1vdGlvbkFuZExpbmVOdW1iZXIgPSBwYXJlbnRNb3Rpb24uaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICBpZiAoYW1lbmRtZW50LmlzUGFyYWdyYXBoQmFzZWRBbWVuZG1lbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYWdyYXBocyA9IGFtZW5kbWVudC5nZXRBbWVuZG1lbnRQYXJhZ3JhcGhzTGluZXNEaWZmKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWZmTGluZSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFncmFwaHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmTGluZSA9ICcnICsgcGFyYWdyYXBoc1swXS5kaWZmTGluZUZyb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRpZmZMaW5lLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZMaW5lID0gJzAnICsgZGlmZkxpbmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYW1lbmRtZW50LnBhcmVudE1vdGlvbkFuZExpbmVOdW1iZXIgKz0gJyAnICsgZGlmZkxpbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEdldCBhbGwgbGVhZCBtb3Rpb25zXG4gICAgICAgICAgICAkc2NvcGUubGVhZE1vdGlvbnMgPSBfLm9yZGVyQnkoTW90aW9uLmZpbHRlcih7cGFyZW50X2lkOiB1bmRlZmluZWR9KSwgWydpZGVudGlmaWVyJ10pO1xuXG4gICAgICAgICAgICAvL3VwZGF0ZUNvbGxpc3Npb25zKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHVwZGF0ZUNvbGxpc3Npb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLmNvbGxpc3Npb25zID0ge307XG4gICAgICAgICAgICBfLmZvckVhY2goJHNjb3BlLmFtZW5kbWVudHMsIGZ1bmN0aW9uIChhbWVuZG1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW1lbmRtZW50LmlzUGFyYWdyYXBoQmFzZWRBbWVuZG1lbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50TW90aW9uID0gYW1lbmRtZW50LmdldFBhcmVudE1vdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgYWxsIGNoYW5nZSByZWNvbW1lbmRhdGlvbnMgX2FuZF8gY2hhbmdlcyBieSBhbWVuZG1lbnRzIGZyb20gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcmVudCBtb3Rpb24uIEZyb20gYWxsIGdldCB0aGUgdW5pZmllZCBjaGFuZ2Ugb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q2hhbmdlUmVjb21tZW5kYXRpb25zID0gXy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbi5maWx0ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd3aGVyZSc6IHsnbW90aW9uX3ZlcnNpb25faWQnOiB7Jz09JzogcGFyZW50TW90aW9uLmFjdGl2ZV92ZXJzaW9ufX1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZS5pc1RleHRSZWNvbW1lbmRhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q2hhbmdlcyA9IHBhcmVudENoYW5nZVJlY29tbWVuZGF0aW9ucy5tYXAoZnVuY3Rpb24gKGNyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3IuZ2V0VW5pZmllZENoYW5nZU9iamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBfLm1hcChwYXJlbnRNb3Rpb24uZ2V0UGFyYWdyYXBoQmFzZWRBbWVuZG1lbnRzRm9yRGlmZlZpZXcoKSwgZnVuY3Rpb24gKGFtZW5kbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbWVuZG1lbnQuZ2V0VW5pZmllZENoYW5nZU9iamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IGFtZW5kbWVudC5nZXRVbmlmaWVkQ2hhbmdlT2JqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5zZXRPdGhlckNoYW5nZXNGb3JDb2xsaXNzaW9uKHBhcmVudENoYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNvbGxpc3Npb25zW2FtZW5kbWVudC5pZF0gPSAhIWNoYW5nZS5nZXRDb2xsaXNzaW9ucygpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICAgIHJldHVybiBNb3Rpb25DaGFuZ2VSZWNvbW1lbmRhdGlvbi5sYXN0TW9kaWZpZWQoKTtcbiAgICAgICAgLy99LCB1cGRhdGVDb2xsaXNzaW9ucyk7XG5cbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTW90aW9uLmxhc3RNb2RpZmllZCgpO1xuICAgICAgICB9LCB1cGRhdGVNb3Rpb25zKTtcblxuICAgICAgICAkc2NvcGUuc2VsZWN0TGVhZE1vdGlvbiA9IGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgICRzY29wZS5sZWFkTW90aW9uID0gbW90aW9uO1xuICAgICAgICAgICAgdXBkYXRlTW90aW9ucygpO1xuICAgICAgICAgICAgaWYgKCRzY29wZS5sZWFkTW90aW9uKSB7XG4gICAgICAgICAgICAgICAgJHN0YXRlLnRyYW5zaXRpb25UbygnbW90aW9ucy5tb3Rpb24uYW1lbmRtZW50LWxpc3QnLFxuICAgICAgICAgICAgICAgICAgICB7aWQ6ICRzY29wZS5sZWFkTW90aW9uLmlkfSxcbiAgICAgICAgICAgICAgICAgICAge25vdGlmeTogZmFsc2V9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHN0YXRlLnRyYW5zaXRpb25UbygnbW90aW9ucy5tb3Rpb24uYWxsYW1lbmRtZW50cycsIHt9LFxuICAgICAgICAgICAgICAgICAgICB7bm90aWZ5OiBmYWxzZX1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNhdmUgZXhwYW5kIHN0YXRlIHNvIHRoZSBzZXNzaW9uXG4gICAgICAgIGlmICgkc2Vzc2lvblN0b3JhZ2UuYW1lbmRtZW50VGFibGVFeHBhbmRTdGF0ZSkge1xuICAgICAgICAgICAgJHNjb3BlLnRvZ2dsZUV4cGFuZENvbnRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICAkc2NvcGUuc2F2ZUV4cGFuZFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICAkc2Vzc2lvblN0b3JhZ2UuYW1lbmRtZW50VGFibGVFeHBhbmRTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZCBjdXN0b20gc29ydGluZ1xuICAgICAgICAkc2NvcGUuc29ydE9wdGlvbnMudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiAncGFyZW50TW90aW9uQW5kTGluZU51bWJlcicsXG4gICAgICAgICAgICBkaXNwbGF5X25hbWU6IGdldHRleHQoJ1BhcmVudCBtb3Rpb24gYW5kIGxpbmUgbnVtYmVyJyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoISRzY29wZS5zb3J0LmNvbHVtbiB8fCAkc2NvcGUuc29ydC5jb2x1bW4gPT09ICdpZGVudGlmaWVyJykge1xuICAgICAgICAgICAgJHNjb3BlLnNvcnQuY29sdW1uID0gJ3BhcmVudE1vdGlvbkFuZExpbmVOdW1iZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgJHNjb3BlLmlzVGV4dEV4cGFuZGFibGUgPSBmdW5jdGlvbiAoY29tbWVudCwgY2hhcmFjdGVycykge1xuICAgICAgICAgICAgY29tbWVudCA9ICQoY29tbWVudCkudGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnQubGVuZ3RoID4gY2hhcmFjdGVycztcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmdldFRleHRQcmV2aWV3ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgIGNvbW1lbnQgPSAkKGNvbW1lbnQpLnRleHQoKTtcbiAgICAgICAgICAgIGlmIChjb21tZW50Lmxlbmd0aCA+IGNoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gY29tbWVudC5zdWJzdHIoMCwgY2hhcmFjdGVycykgKyAnLi4uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21tZW50O1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuZWRpdENvbW1lbnQgPSBmdW5jdGlvbiAobW90aW9uLCBmaWVsZElkKSB7XG4gICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKE1vdGlvbkNvbW1lbnRGb3JtLmdldERpYWxvZyhtb3Rpb24sIGZpZWxkSWQpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuY3JlYXRlTW9kaWZpZWRBbWVuZG1lbnQgPSBmdW5jdGlvbiAoYW1lbmRtZW50KSB7XG4gICAgICAgICAgICB2YXIgcGFyYWdyYXBoTm8sXG4gICAgICAgICAgICAgICAgcGFyYWdyYXBoVGV4dDtcbiAgICAgICAgICAgIGlmIChhbWVuZG1lbnQuaXNQYXJhZ3JhcGhCYXNlZEFtZW5kbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHRoZXJlIGlzIG9ubHkgb25lIGFmZmVjdGVkIHBhcmFncmFwaFxuICAgICAgICAgICAgICAgIGFtZW5kbWVudC5nZXRWZXJzaW9uKGFtZW5kbWVudC5hY3RpdmVfdmVyc2lvbikuYW1lbmRtZW50X3BhcmFncmFwaHMuZm9yRWFjaChmdW5jdGlvbihwYXJUZXh0LCBwYXJObykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyVGV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWdyYXBoTm8gPSBwYXJObztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFncmFwaFRleHQgPSBwYXJUZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFncmFwaFRleHQgPSBhbWVuZG1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmdEaWFsb2cub3BlbihNb3Rpb25Gb3JtLmdldERpYWxvZyhudWxsLCBhbWVuZG1lbnQuZ2V0UGFyZW50TW90aW9uKCksIHBhcmFncmFwaE5vLCBwYXJhZ3JhcGhUZXh0KSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLmFtZW5kbWVudFBkZkV4cG9ydCA9IGZ1bmN0aW9uIChtb3Rpb25zKSB7XG4gICAgICAgICAgICB2YXIgZmlsZW5hbWU7XG4gICAgICAgICAgICBpZiAoJHNjb3BlLmxlYWRNb3Rpb24pIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQW1lbmRtZW50cyB0bycpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmxlYWRNb3Rpb24uZ2V0VGl0bGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0FtZW5kbWVudHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGVuYW1lICs9ICcucGRmJztcbiAgICAgICAgICAgIE1vdGlvblBkZkV4cG9ydC5leHBvcnRBbWVuZG1lbnRzKG1vdGlvbnMsIGZpbGVuYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuZXhwb3J0Q3N2ID0gZnVuY3Rpb24gKG1vdGlvbnMpIHtcbiAgICAgICAgICAgIEFtZW5kbWVudENzdkV4cG9ydC5leHBvcnQobW90aW9ucyk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ01vdGlvbkltcG9ydEN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRxJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgJ0NhdGVnb3J5JyxcbiAgICAnTW90aW9uJyxcbiAgICAnTW90aW9uQmxvY2snLFxuICAgICdVc2VyJyxcbiAgICAnTW90aW9uQ3N2RXhwb3J0JyxcbiAgICBmdW5jdGlvbiAoJHNjb3BlLCAkcSwgZ2V0dGV4dCwgQ2F0ZWdvcnksIE1vdGlvbiwgTW90aW9uQmxvY2ssIFVzZXIsIE1vdGlvbkNzdkV4cG9ydCkge1xuICAgICAgICAvLyBzZXQgaW5pdGlhbCBkYXRhIGZvciBjc3YgaW1wb3J0XG4gICAgICAgICRzY29wZS5tb3Rpb25zID0gW107XG5cbiAgICAgICAgLy8gc2V0IGNzdlxuICAgICAgICAkc2NvcGUuY3N2Q29uZmlnID0ge1xuICAgICAgICAgICAgYWNjZXB0OiAnLmNzdiwgLnR4dCcsXG4gICAgICAgICAgICBlbmNvZGluZ09wdGlvbnM6IFsnVVRGLTgnLCAnSVNPLTg4NTktMSddLFxuICAgICAgICAgICAgcGFyc2VDb25maWc6IHtcbiAgICAgICAgICAgICAgICBza2lwRW1wdHlMaW5lczogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIEZJRUxEUyA9IFsnaWRlbnRpZmllcicsICd0aXRsZScsICd0ZXh0JywgJ3JlYXNvbicsICdzdWJtaXR0ZXInLCAnY2F0ZWdvcnknLCAnb3JpZ2luJywgJ21vdGlvbkJsb2NrJ107XG4gICAgICAgICRzY29wZS5tb3Rpb25zID0gW107XG4gICAgICAgICRzY29wZS5vbkNzdkNoYW5nZSA9IGZ1bmN0aW9uIChjc3YpIHtcbiAgICAgICAgICAgICRzY29wZS5tb3Rpb25zID0gW107XG4gICAgICAgICAgICB2YXIgbW90aW9ucyA9IFtdO1xuICAgICAgICAgICAgXy5mb3JFYWNoKGNzdi5kYXRhLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsbGVkUm93ID0gXy56aXBPYmplY3QoRklFTERTLCByb3cpO1xuICAgICAgICAgICAgICAgICAgICBtb3Rpb25zLnB1c2goZmlsbGVkUm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgXy5mb3JFYWNoKG1vdGlvbnMsIGZ1bmN0aW9uIChtb3Rpb24pIHtcbiAgICAgICAgICAgICAgICBtb3Rpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICBpZiAobW90aW9uLmlkZW50aWZpZXIgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbCBtb3Rpb24gb2JqZWN0cyBhcmUgYWxyZWFkeSBsb2FkZWQgdmlhIHRoZSByZXNvbHZlIHN0YXRlbWVudCBmcm9tIHVpLXJvdXRlci5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdGlvbnMgPSBNb3Rpb24uZ2V0QWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmZpbmQobW90aW9ucywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmlkZW50aWZpZXIgPT09IG1vdGlvbi5pZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uLmltcG9ydGVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvbi5pZGVudGlmaWVyX2Vycm9yID0gZ2V0dGV4dCgnRXJyb3I6IElkZW50aWZpZXIgYWxyZWFkeSBleGlzdHMuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGl0bGVcbiAgICAgICAgICAgICAgICBpZiAoIW1vdGlvbi50aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICBtb3Rpb24uaW1wb3J0ZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtb3Rpb24udGl0bGVfZXJyb3IgPSBnZXR0ZXh0KCdFcnJvcjogVGl0bGUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRleHRcbiAgICAgICAgICAgICAgICBpZiAoIW1vdGlvbi50ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdGlvbi5pbXBvcnRlcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1vdGlvbi50ZXh0X2Vycm9yID0gZ2V0dGV4dCgnRXJyb3I6IFRleHQgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghbW90aW9uLnRleHQuc3RhcnRzV2l0aCgnPHA+JykpIHtcbiAgICAgICAgICAgICAgICAgICAgbW90aW9uLnRleHQgPSAnPHA+JyArIG1vdGlvbi50ZXh0ICsgJzwvcD4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWFzb25cbiAgICAgICAgICAgICAgICBpZiAobW90aW9uLnJlYXNvbiAmJiAhbW90aW9uLnJlYXNvbi5zdGFydHNXaXRoKCc8cD4nKSkge1xuICAgICAgICAgICAgICAgICAgICBtb3Rpb24ucmVhc29uID0gJzxwPicgKyBtb3Rpb24ucmVhc29uICsgJzwvcD4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzdWJtaXR0ZXJcbiAgICAgICAgICAgICAgICBpZiAobW90aW9uLnN1Ym1pdHRlciAmJiBtb3Rpb24uc3VibWl0dGVyICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goVXNlci5nZXRBbGwoKSwgZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1c2VyX3Nob3J0X25hbWUgPSBbdXNlci50aXRsZSwgdXNlci5maXJzdF9uYW1lLCB1c2VyLmxhc3RfbmFtZV0uam9pbignICcpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyX3Nob3J0X25hbWUgPT0gbW90aW9uLnN1Ym1pdHRlci50cmltKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb24uc3VibWl0dGVyc19pZCA9IFt1c2VyLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb24uc3VibWl0dGVyID0gdXNlci5mdWxsX25hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1vdGlvbi5zdWJtaXR0ZXJzX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb24uc3VibWl0dGVyX2NyZWF0ZSA9IGdldHRleHQoJ05ldyBwYXJ0aWNpcGFudCB3aWxsIGJlIGNyZWF0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICBpZiAobW90aW9uLmNhdGVnb3J5ICYmIG1vdGlvbi5jYXRlZ29yeSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKENhdGVnb3J5LmdldEFsbCgpLCBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBmb3IgZXhpc3RpbmcgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXRlZ29yeS5uYW1lID09IG1vdGlvbi5jYXRlZ29yeS50cmltKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb24uY2F0ZWdvcnlfaWQgPSBjYXRlZ29yeS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb24uY2F0ZWdvcnkgPSBjYXRlZ29yeS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtb3Rpb24uY2F0ZWdvcnlfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvbi5jYXRlZ29yeV9jcmVhdGUgPSBnZXR0ZXh0KCdOZXcgY2F0ZWdvcnkgd2lsbCBiZSBjcmVhdGVkLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE1vdGlvbiBibG9ja1xuICAgICAgICAgICAgICAgIGlmIChtb3Rpb24ubW90aW9uQmxvY2sgJiYgbW90aW9uLm1vdGlvbkJsb2NrICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goTW90aW9uQmxvY2suZ2V0QWxsKCksIGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VhcmNoIGZvciBleGlzdGluZyBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrLnRpdGxlID09IG1vdGlvbi5tb3Rpb25CbG9jay50cmltKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb24ubW90aW9uX2Jsb2NrX2lkID0gYmxvY2suaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uLm1vdGlvbkJsb2NrID0gYmxvY2sudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1vdGlvbi5tb3Rpb25fYmxvY2tfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvbi5tb3Rpb25CbG9ja19jcmVhdGUgPSBnZXR0ZXh0KCdOZXcgbW90aW9uIGJsb2NrIHdpbGwgYmUgY3JlYXRlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICRzY29wZS5tb3Rpb25zLnB1c2gobW90aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHNjb3BlLmNhbGNTdGF0cygpO1xuICAgICAgICB9O1xuXG4gICAgICAgICRzY29wZS5jYWxjU3RhdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUubW90aW9uc1dpbGxOb3RCZUltcG9ydGVkID0gMDtcbiAgICAgICAgICAgICRzY29wZS5tb3Rpb25zV2lsbEJlSW1wb3J0ZWQgPSAwO1xuXG4gICAgICAgICAgICAkc2NvcGUubW90aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG1vdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICghbW90aW9uLmltcG9ydGVycm9yICYmIG1vdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUubW90aW9uc1dpbGxCZUltcG9ydGVkKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm1vdGlvbnNXaWxsTm90QmVJbXBvcnRlZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENvdW50ZXIgZm9yIGNyZWF0aW9uc1xuICAgICAgICAkc2NvcGUudXNlcnNDcmVhdGVkID0gMDtcbiAgICAgICAgJHNjb3BlLmNhdGVnb3JpZXNDcmVhdGVkID0gMDtcblxuICAgICAgICAvLyBpbXBvcnQgZnJvbSBjc3YgZmlsZVxuICAgICAgICAkc2NvcGUuaW1wb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLmNzdkltcG9ydGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IGNvdW50ZXJzXG4gICAgICAgICAgICAkc2NvcGUudXNlcnNDcmVhdGVkID0gMDtcbiAgICAgICAgICAgICRzY29wZS5jYXRlZ29yaWVzQ3JlYXRlZCA9IDA7XG4gICAgICAgICAgICAkc2NvcGUubW90aW9uQmxvY2tzQ3JlYXRlZCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBpbXBvcnRlZFVzZXJzID0gW107XG4gICAgICAgICAgICB2YXIgaW1wb3J0ZWRDYXRlZ29yaWVzID0gW107XG4gICAgICAgICAgICB2YXIgaW1wb3J0ZWRNb3Rpb25CbG9ja3MgPSBbXTtcbiAgICAgICAgICAgIC8vIGNvbGxlY3QgdXNlcnMsIGNhdGVnb3JpZXMgYW5kIG1vdGlvbiBibG9ja3NcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUubW90aW9ucywgZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChtb3Rpb24uc2VsZWN0ZWQgJiYgIW1vdGlvbi5pbXBvcnRlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IHVzZXIgaWYgbm90IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1vdGlvbi5zdWJtaXR0ZXJzX2lkICYmIG1vdGlvbi5zdWJtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG1vdGlvbi5zdWJtaXR0ZXIuaW5kZXhPZignICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RfbmFtZTogbW90aW9uLnN1Ym1pdHRlci5zdWJzdHIoMCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfbmFtZTogbW90aW9uLnN1Ym1pdHRlci5zdWJzdHIoaW5kZXgrMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzX2lkOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVkVXNlcnMucHVzaCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IGNhdGVnb3J5IGlmIG5vdCBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtb3Rpb24uY2F0ZWdvcnlfaWQgJiYgbW90aW9uLmNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbW90aW9uLmNhdGVnb3J5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeDogbW90aW9uLmNhdGVnb3J5LmNoYXJBdCgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVkQ2F0ZWdvcmllcy5wdXNoKGNhdGVnb3J5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IG1vdGlvbiBibG9jayBpZiBub3QgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIGlmICghbW90aW9uLm1vdGlvbl9ibG9ja19pZCAmJiBtb3Rpb24ubW90aW9uQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb3Rpb25CbG9jayA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogbW90aW9uLm1vdGlvbkJsb2NrLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVkTW90aW9uQmxvY2tzLnB1c2gobW90aW9uQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHVuaXF1ZSB1c2VycywgY2F0ZWdvcmllcyBhbmQgbW90aW9uIGJsb2Nrc1xuICAgICAgICAgICAgdmFyIGltcG9ydGVkVXNlcnNVbmlxdWUgPSBfLnVuaXFXaXRoKGltcG9ydGVkVXNlcnMsIGZ1bmN0aW9uICh1MSwgdTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdTEuZmlyc3RfbmFtZSA9PSB1Mi5maXJzdF9uYW1lICYmXG4gICAgICAgICAgICAgICAgICAgIHUxLmxhc3RfbmFtZSA9PSB1Mi5sYXN0X25hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBpbXBvcnRlZENhdGVnb3JpZXNVbmlxdWUgPSBfLnVuaXFXaXRoKGltcG9ydGVkQ2F0ZWdvcmllcywgZnVuY3Rpb24gKGMxLCBjMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjMS5uYW1lID09IGMyLm5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBpbXBvcnRlZE1vdGlvbkJsb2Nrc1VuaXF1ZSA9IF8udW5pcVdpdGgoaW1wb3J0ZWRNb3Rpb25CbG9ja3MsIGZ1bmN0aW9uIChjMSwgYzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYzEudGl0bGUgPT0gYzIudGl0bGU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUHJvbWlzZXMgZm9yIHVzZXJzIGFuZCBjYXRlZ29yaWVzXG4gICAgICAgICAgICB2YXIgY3JlYXRlUHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHVzZXJzIGFuZCBjYXRlZ29yaWVzXG4gICAgICAgICAgICBfLmZvckVhY2goaW1wb3J0ZWRVc2Vyc1VuaXF1ZSwgZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVQcm9taXNlcy5wdXNoKFVzZXIuY3JlYXRlKHVzZXIpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmlkID0gc3VjY2Vzcy5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS51c2Vyc0NyZWF0ZWQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfLmZvckVhY2goaW1wb3J0ZWRDYXRlZ29yaWVzVW5pcXVlLCBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVQcm9taXNlcy5wdXNoKENhdGVnb3J5LmNyZWF0ZShjYXRlZ29yeSkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5LmlkID0gc3VjY2Vzcy5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5jYXRlZ29yaWVzQ3JlYXRlZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF8uZm9yRWFjaChpbXBvcnRlZE1vdGlvbkJsb2Nrc1VuaXF1ZSwgZnVuY3Rpb24gKG1vdGlvbkJsb2NrKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlUHJvbWlzZXMucHVzaChNb3Rpb25CbG9jay5jcmVhdGUobW90aW9uQmxvY2spLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb25CbG9jay5pZCA9IHN1Y2Nlc3MuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubW90aW9uQmxvY2tzQ3JlYXRlZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gd2FpdCBmb3IgdXNlcnMgYW5kIGNhdGVnb3JpZXMgdG8gY3JlYXRlXG4gICAgICAgICAgICAkcS5hbGwoY3JlYXRlUHJvbWlzZXMpLnRoZW4oIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUubW90aW9ucywgZnVuY3Rpb24gKG1vdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW90aW9uLnNlbGVjdGVkICYmICFtb3Rpb24uaW1wb3J0ZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdywgYWRkIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbW90aW9uLnN1Ym1pdHRlcnNfaWQgJiYgbW90aW9uLnN1Ym1pdHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG1vdGlvbi5zdWJtaXR0ZXIuaW5kZXhPZignICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdF9uYW1lID0gbW90aW9uLnN1Ym1pdHRlci5zdWJzdHIoMCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0X25hbWUgPSBtb3Rpb24uc3VibWl0dGVyLnN1YnN0cihpbmRleCsxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBmb3IgdXNlciwgc2V0IGlkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChpbXBvcnRlZFVzZXJzVW5pcXVlLCBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlci5maXJzdF9uYW1lID09IGZpcnN0X25hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIubGFzdF9uYW1lID09IGxhc3RfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uLnN1Ym1pdHRlcnNfaWQgPSBbdXNlci5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBjYXRlZ29yeVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb3Rpb24uY2F0ZWdvcnlfaWQgJiYgbW90aW9uLmNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBtb3Rpb24uY2F0ZWdvcnk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWFyY2ggZm9yIGNhdGVnb3J5LCBzZXQgaWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGltcG9ydGVkQ2F0ZWdvcmllc1VuaXF1ZSwgZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXRlZ29yeS5uYW1lID09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvbi5jYXRlZ29yeV9pZCA9IGNhdGVnb3J5LmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgbW90aW9uIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1vdGlvbi5tb3Rpb25fYmxvY2tfaWQgJiYgbW90aW9uLm1vdGlvbkJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gbW90aW9uLm1vdGlvbkJsb2NrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VhcmNoIGZvciBtb3Rpb24gYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goaW1wb3J0ZWRNb3Rpb25CbG9ja3NVbmlxdWUsIGZ1bmN0aW9uIChtb3Rpb25CbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW90aW9uQmxvY2sudGl0bGUgPT0gdGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvbi5tb3Rpb25fYmxvY2tfaWQgPSBtb3Rpb25CbG9jay5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmFsbHkgY3JlYXRlIG1vdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgTW90aW9uLmNyZWF0ZShtb3Rpb24pLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3Rpb24uaW1wb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHNjb3BlLmNzdmltcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLm1vdGlvbnMgPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZG93bmxvYWQgQ1NWIGV4YW1wbGUgZmlsZVxuICAgICAgICAkc2NvcGUuZG93bmxvYWRDU1ZFeGFtcGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTW90aW9uQ3N2RXhwb3J0LmRvd25sb2FkRXhhbXBsZSgpO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdDYXRlZ29yeUxpc3RDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICdDYXRlZ29yeScsXG4gICAgJ25nRGlhbG9nJyxcbiAgICAnQ2F0ZWdvcnlGb3JtJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsIENhdGVnb3J5LCBuZ0RpYWxvZywgQ2F0ZWdvcnlGb3JtKSB7XG4gICAgICAgIENhdGVnb3J5LmJpbmRBbGwoe30sICRzY29wZSwgJ2NhdGVnb3JpZXMnKTtcblxuICAgICAgICAvLyBzZXR1cCB0YWJsZSBzb3J0aW5nXG4gICAgICAgICRzY29wZS5zb3J0Q29sdW1uID0gJ25hbWUnO1xuICAgICAgICAkc2NvcGUucmV2ZXJzZSA9IGZhbHNlO1xuICAgICAgICAvLyBmdW5jdGlvbiB0byBzb3J0IGJ5IGNsaWNrZWQgY29sdW1uXG4gICAgICAgICRzY29wZS50b2dnbGVTb3J0ID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgaWYgKCRzY29wZS5zb3J0Q29sdW1uID09PSBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUucmV2ZXJzZSA9ICEkc2NvcGUucmV2ZXJzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5zb3J0Q29sdW1uID0gY29sdW1uO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRlbGV0ZSBzZWxlY3RlZCBjYXRlZ29yeVxuICAgICAgICAkc2NvcGUuZGVsZXRlID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgICAgICBDYXRlZ29yeS5kZXN0cm95KGNhdGVnb3J5LmlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmVkaXRPckNyZWF0ZSA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICAgICAgbmdEaWFsb2cub3BlbihDYXRlZ29yeUZvcm0uZ2V0RGlhbG9nKGNhdGVnb3J5KSk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ0NhdGVnb3J5Q3JlYXRlQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnQ2F0ZWdvcnknLFxuICAgICdDYXRlZ29yeUZvcm0nLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgQ2F0ZWdvcnksIENhdGVnb3J5Rm9ybSwgRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICRzY29wZS5tb2RlbCA9IHt9O1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcbiAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHMgPSBDYXRlZ29yeUZvcm0uZ2V0Rm9ybUZpZWxkcygpO1xuICAgICAgICAkc2NvcGUuc2F2ZSA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICAgICAgQ2F0ZWdvcnkuY3JlYXRlKGNhdGVnb3J5KS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZVRoaXNEaWFsb2coKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ0NhdGVnb3J5VXBkYXRlQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnQ2F0ZWdvcnknLFxuICAgICdjYXRlZ29yeUlkJyxcbiAgICAnQ2F0ZWdvcnlGb3JtJyxcbiAgICAnRXJyb3JNZXNzYWdlJyxcbiAgICBmdW5jdGlvbiAoJHNjb3BlLCBDYXRlZ29yeSwgY2F0ZWdvcnlJZCwgQ2F0ZWdvcnlGb3JtLCBFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge307XG4gICAgICAgICRzY29wZS5tb2RlbCA9IGFuZ3VsYXIuY29weShDYXRlZ29yeS5nZXQoY2F0ZWdvcnlJZCkpO1xuICAgICAgICAkc2NvcGUuZm9ybUZpZWxkcyA9IENhdGVnb3J5Rm9ybS5nZXRGb3JtRmllbGRzKCk7XG4gICAgICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgICAgICBDYXRlZ29yeS5pbmplY3QoY2F0ZWdvcnkpO1xuICAgICAgICAgICAgQ2F0ZWdvcnkuc2F2ZShjYXRlZ29yeSkudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VUaGlzRGlhbG9nKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBlcnJvcjogcmV2ZXJ0IGFsbCBjaGFuZ2VzIGJ5IHJlc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gKHJlZnJlc2gpIG9yaWdpbmFsIGNhdGVnb3J5IG9iamVjdCBmcm9tIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICBDYXRlZ29yeS5yZWZyZXNoKGNhdGVnb3J5KTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdDYXRlZ29yeVNvcnRDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckc3RhdGVQYXJhbXMnLFxuICAgICckaHR0cCcsXG4gICAgJ0NhdGVnb3J5JyxcbiAgICAnY2F0ZWdvcnlJZCcsXG4gICAgJ01vdGlvbicsXG4gICAgJ0Vycm9yTWVzc2FnZScsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkaHR0cCwgQ2F0ZWdvcnksIGNhdGVnb3J5SWQsIE1vdGlvbiwgRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIENhdGVnb3J5LmJpbmRPbmUoY2F0ZWdvcnlJZCwgJHNjb3BlLCAnY2F0ZWdvcnknKTtcbiAgICAgICAgTW90aW9uLmJpbmRBbGwoe30sICRzY29wZSwgJ21vdGlvbnMnKTtcbiAgICAgICAgJHNjb3BlLmZpbHRlciA9IHsgY2F0ZWdvcnlfaWQ6IGNhdGVnb3J5SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudF9pZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJCeTogJ2lkZW50aWZpZXInIH07XG5cbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTW90aW9uLmxhc3RNb2RpZmllZCgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbW90aW9ucyA9IE1vdGlvbi5maWx0ZXIoJHNjb3BlLmZpbHRlcik7XG4gICAgICAgICAgICAkc2NvcGUuaXRlbXMgPSBfLm1hcChtb3Rpb25zLCBmdW5jdGlvbiAobW90aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG1vdGlvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbTogbW90aW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcbiAgICAgICAgLy8gTnVtYmVycyBhbGwgbW90aW9ucyBpbiB0aGlzIGNhdGVnb3J5IGJ5IHRoZSBnaXZlbiBvcmRlciBpbiAkc2NvcGUuaXRlbXNcbiAgICAgICAgJHNjb3BlLm51bWJlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGxpc3Qgb2YgYWxsIG1vdGlvbiBpZHMgaW4gdGhlIGN1cnJlbnQgb3JkZXIuXG4gICAgICAgICAgICB2YXIgc29ydGVkX21vdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICRzY29wZS5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgc29ydGVkX21vdGlvbnMucHVzaChpdGVtLml0ZW0uaWQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHJlbnVtYmVyIHRoZW1cbiAgICAgICAgICAgICRodHRwLnBvc3QoJy9yZXN0L21vdGlvbnMvY2F0ZWdvcnkvJyArICRzY29wZS5jYXRlZ29yeS5pZCArICcvbnVtYmVyaW5nLycsXG4gICAgICAgICAgICAgICAgeydtb3Rpb25zJzogc29ydGVkX21vdGlvbnN9ICkudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0geyB0eXBlOiAnc3VjY2VzcycsIG1zZzogc3VjY2Vzcy5kYXRhLmRldGFpbCwgc2hvdzogdHJ1ZSB9O1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi8vbWFyayBhbGwgbW90aW9ucyBjb25maWcgc3RyaW5ncyBmb3IgdHJhbnNsYXRpb24gaW4gamF2YXNjcmlwdFxuLmNvbmZpZyhbXG4gICAgJ2dldHRleHQnLFxuICAgIGZ1bmN0aW9uIChnZXR0ZXh0KSB7XG4gICAgICAgIGdldHRleHQoJ01vdGlvbnMnKTtcblxuICAgICAgICAvLyBzdWJncm91cCBHZW5lcmFsXG4gICAgICAgIGdldHRleHQoJ0dlbmVyYWwnKTtcbiAgICAgICAgZ2V0dGV4dCgnV29ya2Zsb3cgb2YgbmV3IG1vdGlvbnMnKTtcbiAgICAgICAgZ2V0dGV4dCgnSWRlbnRpZmllcicpO1xuICAgICAgICBnZXR0ZXh0KCdOdW1iZXJlZCBwZXIgY2F0ZWdvcnknKTtcbiAgICAgICAgZ2V0dGV4dCgnU2VyaWFsbHkgbnVtYmVyZWQnKTtcbiAgICAgICAgZ2V0dGV4dCgnU2V0IGl0IG1hbnVhbGx5Jyk7XG4gICAgICAgIGdldHRleHQoJ01vdGlvbiBwcmVhbWJsZScpO1xuICAgICAgICBnZXR0ZXh0KCdUaGUgYXNzZW1ibHkgbWF5IGRlY2lkZTonKTtcbiAgICAgICAgZ2V0dGV4dCgnRGVmYXVsdCBsaW5lIG51bWJlcmluZycpO1xuICAgICAgICAvLy8gTGluZSBudW1iZXJpbmc6IE91dHNpZGVcbiAgICAgICAgZ2V0dGV4dCgnT3V0c2lkZScpO1xuICAgICAgICAvLy8gTGluZSBudW1iZXJpbmc6IElubGluZVxuICAgICAgICBnZXR0ZXh0KCdJbmxpbmUnKTtcbiAgICAgICAgLy8vIExpbmUgbnVtYmVyaW5nOiBOb25lXG4gICAgICAgIGdldHRleHQoJ05vbmUnKTtcbiAgICAgICAgZ2V0dGV4dCgnTGluZSBsZW5ndGgnKTtcbiAgICAgICAgZ2V0dGV4dCgnVGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgcGVyIGxpbmUuIFJlbGV2YW50IHdoZW4gbGluZSBudW1iZXJpbmcgaXMgZW5hYmxlZC4gTWluOiA0MCcpO1xuICAgICAgICBnZXR0ZXh0KCdIaWRlIHJlYXNvbiBvbiBwcm9qZWN0b3InKTtcbiAgICAgICAgZ2V0dGV4dCgnSGlkZSBtZXRhIGluZm9ybWF0aW9uIGJveCBvbiBwcm9qZWN0b3InKTtcbiAgICAgICAgZ2V0dGV4dCgnSGlkZSByZWNvbW1lbmRhdGlvbiBvbiBwcm9qZWN0b3InKTtcbiAgICAgICAgZ2V0dGV4dCgnU3RvcCBzdWJtaXR0aW5nIG5ldyBtb3Rpb25zIGJ5IG5vbi1zdGFmZiB1c2VycycpO1xuICAgICAgICBnZXR0ZXh0KCdBbGxvdyB0byBkaXNhYmxlIHZlcnNpb25pbmcnKTtcbiAgICAgICAgZ2V0dGV4dCgnTmFtZSBvZiByZWNvbW1lbmRlcicpO1xuICAgICAgICBnZXR0ZXh0KCdEZWZhdWx0IHRleHQgdmVyc2lvbiBmb3IgY2hhbmdlIHJlY29tbWVuZGF0aW9ucycpO1xuICAgICAgICBnZXR0ZXh0KCdXaWxsIGJlIGRpc3BsYXllZCBhcyBsYWJlbCBiZWZvcmUgc2VsZWN0ZWQgcmVjb21tZW5kYXRpb24uIFVzZSBhbiBlbXB0eSB2YWx1ZSB0byBkaXNhYmxlIHRoZSByZWNvbW1lbmRhdGlvbiBzeXN0ZW0uJyk7XG4gICAgICAgIGdldHRleHQoJ0VkaXQgY29tbWVudCAlJWNvbW1lbnQlJSBvZiBtb3Rpb24gJSVtb3Rpb24lJScpO1xuXG4gICAgICAgIC8vIHN1Ymdyb3VwIEFtZW5kbWVudHNcbiAgICAgICAgZ2V0dGV4dCgnQW1lbmRtZW50cycpO1xuICAgICAgICBnZXR0ZXh0KCdBY3RpdmF0ZSBhbWVuZG1lbnRzJyk7XG4gICAgICAgIGdldHRleHQoJ1Nob3cgYW1lbmRtZW50cyB0b2dldGhlciB3aXRoIG1vdGlvbnMnKTtcbiAgICAgICAgZ2V0dGV4dCgnUHJlZml4IGZvciB0aGUgaWRlbnRpZmllciBmb3IgYW1lbmRtZW50cycpO1xuICAgICAgICBnZXR0ZXh0KCdBcHBseSB0ZXh0IGZvciBuZXcgYW1lbmRtZW50cycpO1xuICAgICAgICBnZXR0ZXh0KCdUaGUgdGl0bGUgb2YgdGhlIG1vdGlvbiBpcyBhbHdheXMgYXBwbGllZC4nKTtcbiAgICAgICAgZ2V0dGV4dCgnQW1lbmRtZW50IHRvJyk7XG4gICAgICAgIGdldHRleHQoJ0hvdyB0byBjcmVhdGUgbmV3IGFtZW5kbWVudHMnKTtcbiAgICAgICAgZ2V0dGV4dCgnRW1wdHkgdGV4dCBmaWVsZCcpO1xuICAgICAgICBnZXR0ZXh0KCdFZGl0IHRoZSB3aG9sZSBtb3Rpb24gdGV4dCcpO1xuICAgICAgICBnZXR0ZXh0KCdQYXJhZ3JhcGgtYmFzZWQsIERpZmYtZW5hYmxlZCcpO1xuXG4gICAgICAgIC8vIHN1Ymdyb3VwIFN1cHBvcnRlcnNcbiAgICAgICAgZ2V0dGV4dCgnU3VwcG9ydGVycycpO1xuICAgICAgICBnZXR0ZXh0KCdOdW1iZXIgb2YgKG1pbmltdW0pIHJlcXVpcmVkIHN1cHBvcnRlcnMgZm9yIGEgbW90aW9uJyk7XG4gICAgICAgIGdldHRleHQoJ0Nob29zZSAwIHRvIGRpc2FibGUgdGhlIHN1cHBvcnRpbmcgc3lzdGVtLicpO1xuICAgICAgICBnZXR0ZXh0KCdSZW1vdmUgYWxsIHN1cHBvcnRlcnMgb2YgYSBtb3Rpb24gaWYgYSBzdWJtaXR0ZXIgZWRpdHMgaGlzICcgK1xuICAgICAgICAgICAgICAgICdtb3Rpb24gaW4gZWFybHkgc3RhdGUnKTtcblxuICAgICAgICAvLyBzdWJncm91cCBTdXBwb3J0ZXJzXG4gICAgICAgIGdldHRleHQoJ0NvbW1lbnRzJyk7XG4gICAgICAgIGdldHRleHQoJ0NvbW1lbnQgZmllbGRzIGZvciBtb3Rpb25zJyk7XG4gICAgICAgIGdldHRleHQoJ1B1YmxpYycpO1xuICAgICAgICBnZXR0ZXh0KCdQcml2YXRlJyk7XG5cbiAgICAgICAgLy8gc3ViZ3JvdXAgVm90aW5nIGFuZCBiYWxsb3QgcGFwZXJzXG4gICAgICAgIGdldHRleHQoJ1ZvdGluZyBhbmQgYmFsbG90IHBhcGVycycpO1xuICAgICAgICBnZXR0ZXh0KCdUaGUgMTAwICUgYmFzZSBvZiBhIHZvdGluZyByZXN1bHQgY29uc2lzdHMgb2YnKTtcbiAgICAgICAgZ2V0dGV4dCgnWWVzL05vL0Fic3RhaW4nKTtcbiAgICAgICAgZ2V0dGV4dCgnWWVzL05vJyk7XG4gICAgICAgIGdldHRleHQoJ0FsbCB2YWxpZCBiYWxsb3RzJyk7XG4gICAgICAgIGdldHRleHQoJ0FsbCBjYXN0ZWQgYmFsbG90cycpO1xuICAgICAgICBnZXR0ZXh0KCdEaXNhYmxlZCAobm8gcGVyY2VudHMpJyk7XG4gICAgICAgIGdldHRleHQoJ1JlcXVpcmVkIG1ham9yaXR5Jyk7XG4gICAgICAgIGdldHRleHQoJ0RlZmF1bHQgbWV0aG9kIHRvIGNoZWNrIHdoZXRoZXIgYSBtb3Rpb24gaGFzIHJlYWNoZWQgdGhlIHJlcXVpcmVkIG1ham9yaXR5LicpO1xuICAgICAgICBnZXR0ZXh0KCdTaW1wbGUgbWFqb3JpdHknKTtcbiAgICAgICAgZ2V0dGV4dCgnVHdvLXRoaXJkcyBtYWpvcml0eScpO1xuICAgICAgICBnZXR0ZXh0KCdUaHJlZS1xdWFydGVycyBtYWpvcml0eScpO1xuICAgICAgICBnZXR0ZXh0KCdEaXNhYmxlZCcpO1xuICAgICAgICBnZXR0ZXh0KCdOdW1iZXIgb2YgYmFsbG90IHBhcGVycyAoc2VsZWN0aW9uKScpO1xuICAgICAgICBnZXR0ZXh0KCdOdW1iZXIgb2YgYWxsIGRlbGVnYXRlcycpO1xuICAgICAgICBnZXR0ZXh0KCdOdW1iZXIgb2YgYWxsIHBhcnRpY2lwYW50cycpO1xuICAgICAgICBnZXR0ZXh0KCdVc2UgdGhlIGZvbGxvd2luZyBjdXN0b20gbnVtYmVyJyk7XG4gICAgICAgIGdldHRleHQoJ0N1c3RvbSBudW1iZXIgb2YgYmFsbG90IHBhcGVycycpO1xuXG4gICAgICAgIC8vIHN1Ymdyb3VwIFBERiBhbmQgRE9DWFxuICAgICAgICBnZXR0ZXh0KCdUaXRsZSBmb3IgUERGIGFuZCBET0NYIGRvY3VtZW50cyAoYWxsIG1vdGlvbnMpJyk7XG4gICAgICAgIGdldHRleHQoJ1ByZWFtYmxlIHRleHQgZm9yIFBERiBhbmQgRE9DWCBkb2N1bWVudHMgKGFsbCBtb3Rpb25zKScpO1xuICAgICAgICBnZXR0ZXh0KCdTb3J0IGNhdGVnb3JpZXMgYnknKTtcbiAgICAgICAgZ2V0dGV4dCgnSW5jbHVkZSB0aGUgc2VxdWVudGlhbCBudW1iZXIgaW4gUERGIGFuZCBET0NYJyk7XG5cbiAgICAgICAgLy8gbWlzYyBzdHJpbmdzICh1c2VkIGR5bmFtaWNhbGx5IGluIHRlbXBsYXRlcyBieSB0cmFuc2xhdGUgZmlsdGVyKVxuICAgICAgICBnZXR0ZXh0KCduZWVkZWQnKTtcbiAgICAgICAgZ2V0dGV4dCgnQW1lbmRtZW50Jyk7XG4gICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmFuZ3VsYXIubW9kdWxlKCdPcGVuU2xpZGVzQXBwLm1vdGlvbnMud29ya2Zsb3cnLCBbXSlcblxuLmNvbnRyb2xsZXIoJ1dvcmtmbG93TGlzdEN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ1dvcmtmbG93JyxcbiAgICAnbmdEaWFsb2cnLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsIFdvcmtmbG93LCBuZ0RpYWxvZywgRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICRzY29wZS5hbGVydCA9IHt9O1xuICAgICAgICBXb3JrZmxvdy5iaW5kQWxsKHt9LCAkc2NvcGUsICd3b3JrZmxvd3MnKTtcbiAgICAgICAgJHNjb3BlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG5nRGlhbG9nLm9wZW4oe1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnc3RhdGljL3RlbXBsYXRlcy9tb3Rpb25zL3dvcmtmbG93LWVkaXQuaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ1dvcmtmbG93Q3JlYXRlQ3RybCcsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmdkaWFsb2ctdGhlbWUtZGVmYXVsdCB3aWRlLWZvcm0nLFxuICAgICAgICAgICAgICAgIGNsb3NlQnlFc2NhcGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNsb3NlQnlEb2N1bWVudDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmRlbGV0ZSA9IGZ1bmN0aW9uICh3b3JrZmxvdykge1xuICAgICAgICAgICAgV29ya2Zsb3cuZGVzdHJveSh3b3JrZmxvdykudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ1dvcmtmbG93RGV0YWlsQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJHNlc3Npb25TdG9yYWdlJyxcbiAgICAncGVybWlzc2lvbnMnLFxuICAgICdXb3JrZmxvdycsXG4gICAgJ01vdGlvblN0YXRlJyxcbiAgICAnd29ya2Zsb3dJZCcsXG4gICAgJ25nRGlhbG9nJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnRXJyb3JNZXNzYWdlJyxcbiAgICBmdW5jdGlvbiAoJHNjb3BlLCAkc2Vzc2lvblN0b3JhZ2UsIHBlcm1pc3Npb25zLCBXb3JrZmxvdywgTW90aW9uU3RhdGUsIHdvcmtmbG93SWQsXG4gICAgICAgIG5nRGlhbG9nLCBnZXR0ZXh0LCBnZXR0ZXh0Q2F0YWxvZywgRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICRzY29wZS5wZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25zO1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcblxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBXb3JrZmxvdy5sYXN0TW9kaWZpZWQod29ya2Zsb3dJZCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS53b3JrZmxvdyA9IFdvcmtmbG93LmdldCh3b3JrZmxvd0lkKTtcbiAgICAgICAgICAgICRzY29wZS5zdGF0ZXMgPSAkc2NvcGUud29ya2Zsb3cuc3RhdGVzO1xuICAgICAgICAgICAgJHNjb3BlLnN0YXRlcyA9IF8ub3JkZXJCeSgkc2NvcGUuc3RhdGVzLCAnaWQnKTtcbiAgICAgICAgICAgIF8uZm9yRWFjaCgkc2NvcGUuc3RhdGVzLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5uZXdBY3Rpb25Xb3JkID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKHN0YXRlLmFjdGlvbl93b3JkKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5uZXdSZWNvbW1lbmRhdGlvbkxhYmVsID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKHN0YXRlLnJlY29tbWVuZGF0aW9uX2xhYmVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAkc2NvcGUuYm9vbGVhbk1lbWJlcnMgPSBbXG4gICAgICAgICAgICB7bmFtZTogJ2FsbG93X3N1cHBvcnQnLFxuICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBnZXR0ZXh0KCdBbGxvdyBzdXBwb3J0JyksfSxcbiAgICAgICAgICAgIHtuYW1lOiAnYWxsb3dfY3JlYXRlX3BvbGwnLFxuICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBnZXR0ZXh0KCdBbGxvdyBjcmVhdGUgcG9sbCcpLH0sXG4gICAgICAgICAgICB7bmFtZTogJ2FsbG93X3N1Ym1pdHRlcl9lZGl0JyxcbiAgICAgICAgICAgICBkaXNwbGF5TmFtZTogZ2V0dGV4dCgnQWxsb3cgc3VibWl0dGVyIGVkaXQnKSx9LFxuICAgICAgICAgICAge25hbWU6ICd2ZXJzaW9uaW5nJyxcbiAgICAgICAgICAgICBkaXNwbGF5TmFtZTogZ2V0dGV4dCgnVmVyc2lvbmluZycpLH0sXG4gICAgICAgICAgICB7bmFtZTogJ2xlYXZlX29sZF92ZXJzaW9uX2FjdGl2ZScsXG4gICAgICAgICAgICAgZGlzcGxheU5hbWU6IGdldHRleHQoJ0xlYXZlIG9sZCB2ZXJzaW9uIGFjdGl2ZScpLH0sXG4gICAgICAgICAgICB7bmFtZTogJ2RvbnRfc2V0X2lkZW50aWZpZXInLFxuICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBnZXR0ZXh0KCdTZXQgaWRlbnRpZmllcicpLFxuICAgICAgICAgICAgIGludmVyc2U6IHRydWUsfSxcbiAgICAgICAgICAgIHtuYW1lOiAnc2hvd19zdGF0ZV9leHRlbnNpb25fZmllbGQnLFxuICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBnZXR0ZXh0KCdTaG93IHN0YXRlIGV4dGVuc2lvbiBmaWVsZCcpLH0sXG4gICAgICAgICAgICB7bmFtZTogJ3Nob3dfcmVjb21tZW5kYXRpb25fZXh0ZW5zaW9uX2ZpZWxkJyxcbiAgICAgICAgICAgICBkaXNwbGF5TmFtZTogZ2V0dGV4dCgnU2hvdyByZWNvbW1lbmRhdGlvbiBleHRlbnNpb24gZmllbGQnKSx9XG4gICAgICAgIF07XG4gICAgICAgICRzY29wZS5jc3NDbGFzc2VzID0ge1xuICAgICAgICAgICAgJ2Rhbmdlcic6IGdldHRleHQoJ1JlZCcpLFxuICAgICAgICAgICAgJ3N1Y2Nlc3MnOiBnZXR0ZXh0KCdHcmVlbicpLFxuICAgICAgICAgICAgJ3dhcm5pbmcnOiBnZXR0ZXh0KCdZZWxsb3cnKSxcbiAgICAgICAgICAgICdkZWZhdWx0JzogZ2V0dGV4dCgnR3JleScpLFxuICAgICAgICAgICAgJ3ByaW1hcnknOiBnZXR0ZXh0KCdCbHVlJyksXG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5nZXRQZXJtaXNzaW9uRGlzcGxheU5hbWUgPSBmdW5jdGlvbiAocGVybWlzc2lvbikge1xuICAgICAgICAgICAgaWYgKHBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5maW5kKCRzY29wZS5wZXJtaXNzaW9ucywgZnVuY3Rpb24gKHBlcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlcm0udmFsdWUgPT09IHBlcm1pc3Npb247XG4gICAgICAgICAgICAgICAgfSkuZGlzcGxheV9uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuY2xpY2tQZXJtaXNzaW9uID0gZnVuY3Rpb24gKHN0YXRlLCBwZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXF1aXJlZF9wZXJtaXNzaW9uX3RvX3NlZSA9XG4gICAgICAgICAgICAgICAgc3RhdGUucmVxdWlyZWRfcGVybWlzc2lvbl90b19zZWUgPT09IHBlcm1pc3Npb24udmFsdWUgPyAnJyA6IHBlcm1pc3Npb24udmFsdWU7XG4gICAgICAgICAgICAkc2NvcGUuc2F2ZShzdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS54b3IgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIChhICYmICFiKSB8fCAoIWEgJiYgYik7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLmNoYW5nZUJvb2xlYW5NZW1iZXIgPSBmdW5jdGlvbiAoc3RhdGUsIG1lbWJlck5hbWUpIHtcbiAgICAgICAgICAgIHN0YXRlW21lbWJlck5hbWVdID0gIXN0YXRlW21lbWJlck5hbWVdO1xuICAgICAgICAgICAgJHNjb3BlLnNhdmUoc3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuc2V0TWVtYmVyID0gZnVuY3Rpb24gKHN0YXRlLCBtZW1iZXIsIHZhbHVlKSB7XG4gICAgICAgICAgICBzdGF0ZVttZW1iZXJdID0gdmFsdWU7XG4gICAgICAgICAgICAkc2NvcGUuc2F2ZShzdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5jbGlja05leHRTdGF0ZUVudHJ5ID0gZnVuY3Rpb24gKHN0YXRlLCBjbGlja2VkU3RhdGVJZCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gc3RhdGUubmV4dF9zdGF0ZXNfaWQuaW5kZXhPZihjbGlja2VkU3RhdGVJZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkgeyAvLyByZW1vdmUgbm93XG4gICAgICAgICAgICAgICAgc3RhdGUubmV4dF9zdGF0ZXNfaWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGFkZFxuICAgICAgICAgICAgICAgIHN0YXRlLm5leHRfc3RhdGVzX2lkLnB1c2goY2xpY2tlZFN0YXRlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHNjb3BlLnNhdmUoc3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuc2F2ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgTW90aW9uU3RhdGUuc2F2ZShzdGF0ZSkudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2F2ZSBleHBhbmQgc3RhdGUgc28gdGhlIHNlc3Npb25cbiAgICAgICAgaWYgKCRzZXNzaW9uU3RvcmFnZS5tb3Rpb25TdGF0ZVRhYmxlRXhwYW5kU3RhdGUpIHtcbiAgICAgICAgICAgICRzY29wZS50b2dnbGVFeHBhbmRDb250ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgJHNjb3BlLnNhdmVFeHBhbmRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgJHNlc3Npb25TdG9yYWdlLm1vdGlvblN0YXRlVGFibGVFeHBhbmRTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB9O1xuXG4gICAgICAgICRzY29wZS5vcGVuU3RhdGVEaWFsb2cgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIG5nRGlhbG9nLm9wZW4oe1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnc3RhdGljL3RlbXBsYXRlcy9tb3Rpb25zL3N0YXRlLWVkaXQuaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogc3RhdGUgPyAnU3RhdGVSZW5hbWVDdHJsJyA6ICdTdGF0ZUNyZWF0ZUN0cmwnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ25nZGlhbG9nLXRoZW1lLWRlZmF1bHQgd2lkZS1mb3JtJyxcbiAgICAgICAgICAgICAgICBjbG9zZUJ5RXNjYXBlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjbG9zZUJ5RG9jdW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGZ1bmN0aW9uICgpIHtyZXR1cm4gc3RhdGU7fSxcbiAgICAgICAgICAgICAgICAgICAgd29ya2Zsb3c6IGZ1bmN0aW9uICgpIHtyZXR1cm4gJHNjb3BlLndvcmtmbG93O30sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5vcGVuV29ya2Zsb3dEaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJ3N0YXRpYy90ZW1wbGF0ZXMvbW90aW9ucy93b3JrZmxvdy1lZGl0Lmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdXb3JrZmxvd1JlbmFtZUN0cmwnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ25nZGlhbG9nLXRoZW1lLWRlZmF1bHQgd2lkZS1mb3JtJyxcbiAgICAgICAgICAgICAgICBjbG9zZUJ5RXNjYXBlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjbG9zZUJ5RG9jdW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2Zsb3c6IGZ1bmN0aW9uICgpIHtyZXR1cm4gJHNjb3BlLndvcmtmbG93O30sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLmRlbGV0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgTW90aW9uU3RhdGUuZGVzdHJveShzdGF0ZSkudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ1dvcmtmbG93Q3JlYXRlQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnV29ya2Zsb3cnLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsIFdvcmtmbG93LCBFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgd29ya2Zsb3cgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJHNjb3BlLm5ld05hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgV29ya2Zsb3cuY3JlYXRlKHdvcmtmbG93KS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlVGhpc0RpYWxvZygpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdXb3JrZmxvd1JlbmFtZUN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ3dvcmtmbG93JyxcbiAgICAnV29ya2Zsb3cnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0Vycm9yTWVzc2FnZScsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgd29ya2Zsb3csIFdvcmtmbG93LCBnZXR0ZXh0Q2F0YWxvZywgRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICRzY29wZS53b3JrZmxvdyA9IHdvcmtmbG93O1xuICAgICAgICAkc2NvcGUubmV3TmFtZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZyh3b3JrZmxvdy5uYW1lKTtcbiAgICAgICAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3b3JrZmxvdy5uYW1lID0gJHNjb3BlLm5ld05hbWU7XG4gICAgICAgICAgICBXb3JrZmxvdy5zYXZlKHdvcmtmbG93KS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlVGhpc0RpYWxvZygpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdTdGF0ZUNyZWF0ZUN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ3dvcmtmbG93JyxcbiAgICAnTW90aW9uU3RhdGUnLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsIHdvcmtmbG93LCBNb3Rpb25TdGF0ZSwgRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICRzY29wZS5uZXdOYW1lID0gJyc7XG4gICAgICAgICRzY29wZS5hY3Rpb25Xb3JkID0gJyc7XG4gICAgICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICRzY29wZS5uZXdOYW1lLFxuICAgICAgICAgICAgICAgIGFjdGlvbl93b3JkOiAkc2NvcGUuYWN0aW9uV29yZCxcbiAgICAgICAgICAgICAgICB3b3JrZmxvd19pZDogd29ya2Zsb3cuaWQsXG4gICAgICAgICAgICAgICAgYWxsb3dfY3JlYXRlX3BvbGw6IHRydWUsXG4gICAgICAgICAgICAgICAgYWxsb3dfc3VwcG9ydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbGxvd19zdWJtaXR0ZXJfZWRpdDogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBNb3Rpb25TdGF0ZS5jcmVhdGUoc3RhdGUpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZVRoaXNEaWFsb2coKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IEVycm9yTWVzc2FnZS5mb3JBbGVydChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignU3RhdGVSZW5hbWVDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICdNb3Rpb25TdGF0ZScsXG4gICAgJ3N0YXRlJyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsIE1vdGlvblN0YXRlLCBzdGF0ZSwgZ2V0dGV4dENhdGFsb2csIEVycm9yTWVzc2FnZSkge1xuICAgICAgICAkc2NvcGUuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgJHNjb3BlLm5ld05hbWUgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoc3RhdGUubmFtZSk7XG4gICAgICAgICRzY29wZS5hY3Rpb25Xb3JkID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKHN0YXRlLmFjdGlvbl93b3JkKTtcbiAgICAgICAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdGF0ZS5uYW1lID0gJHNjb3BlLm5ld05hbWU7XG4gICAgICAgICAgICBzdGF0ZS5hY3Rpb25fd29yZCA9ICRzY29wZS5hY3Rpb25Xb3JkO1xuICAgICAgICAgICAgTW90aW9uU3RhdGUuc2F2ZShzdGF0ZSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlVGhpc0RpYWxvZygpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbl0pO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC5wb2xsLm1ham9yaXR5JywgW10pXG5cbi52YWx1ZSgnTWFqb3JpdHlNZXRob2RDaG9pY2VzJywgW1xuICAgIHsndmFsdWUnOiAnc2ltcGxlX21ham9yaXR5JywgJ2Rpc3BsYXlfbmFtZSc6ICdTaW1wbGUgbWFqb3JpdHknfSxcbiAgICB7J3ZhbHVlJzogJ3R3by10aGlyZHNfbWFqb3JpdHknLCAnZGlzcGxheV9uYW1lJzogJ1R3by10aGlyZHMgbWFqb3JpdHknfSxcbiAgICB7J3ZhbHVlJzogJ3RocmVlLXF1YXJ0ZXJzX21ham9yaXR5JywgJ2Rpc3BsYXlfbmFtZSc6ICdUaHJlZS1xdWFydGVycyBtYWpvcml0eSd9LFxuICAgIHsndmFsdWUnOiAnZGlzYWJsZWQnLCAnZGlzcGxheV9uYW1lJzogJ0Rpc2FibGVkJ30sXG5dKVxuXG4uZmFjdG9yeSgnTWFqb3JpdHlNZXRob2RzJywgW1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzaW1wbGVfbWFqb3JpdHknOiBmdW5jdGlvbiAodm90ZSwgYmFzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwoLShiYXNlIC8gMiAtIHZvdGUpKSAtIDE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3R3by10aGlyZHNfbWFqb3JpdHknOiBmdW5jdGlvbiAodm90ZSwgYmFzZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAtKGJhc2UgKiAyIC0gdm90ZSAqIDMpIC8gMztcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICUgMSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBNYXRoLmNlaWwocmVzdWx0KSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3RocmVlLXF1YXJ0ZXJzX21ham9yaXR5JzogZnVuY3Rpb24gKHZvdGUsIGJhc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gLShiYXNlICogMyAtIHZvdGUgKiA0KSAvIDQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAlIDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gTWF0aC5jZWlsKHJlc3VsdCkgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkaXNhYmxlZCc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAudG9waWNzJywgW10pXG5cbi5mYWN0b3J5KCdUb3BpYycsIFtcbiAgICAnRFMnLFxuICAgICdqc0RhdGFNb2RlbCcsXG4gICAgJ2dldHRleHQnLFxuICAgIGZ1bmN0aW9uKERTLCBqc0RhdGFNb2RlbCwgZ2V0dGV4dCkge1xuICAgICAgICB2YXIgbmFtZSA9ICd0b3BpY3MvdG9waWMnO1xuICAgICAgICByZXR1cm4gRFMuZGVmaW5lUmVzb3VyY2Uoe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHVzZUNsYXNzOiBqc0RhdGFNb2RlbCxcbiAgICAgICAgICAgIHZlcmJvc2VOYW1lOiBnZXR0ZXh0KCdUb3BpYycpLFxuICAgICAgICAgICAgbWV0aG9kczoge1xuICAgICAgICAgICAgICAgIGdldFJlc291cmNlTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldEFnZW5kYVRpdGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0Q1NWRXhwb3J0VGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVsYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgYmVsb25nc1RvOiB7XG4gICAgICAgICAgICAgICAgICAgICdhZ2VuZGEvaXRlbSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsS2V5OiAnYWdlbmRhX2l0ZW1faWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGaWVsZDogJ2FnZW5kYV9pdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGFzTWFueToge1xuICAgICAgICAgICAgICAgICAgICAnbWVkaWFmaWxlcy9tZWRpYWZpbGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAnYXR0YWNobWVudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxLZXlzOiAnYXR0YWNobWVudHNfaWQnLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4ucnVuKFsnVG9waWMnLCBmdW5jdGlvbihUb3BpYykge31dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAudG9waWNzLmNzdicsIFtdKVxuXG4uZmFjdG9yeSgnVG9waWNzQ3N2RXhhbXBsZScsIFtcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdDc3ZEb3dubG9hZCcsXG4gICAgZnVuY3Rpb24gKGdldHRleHRDYXRhbG9nLCBDc3ZEb3dubG9hZCkge1xuICAgICAgICB2YXIgbWFrZUhlYWRlcmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVybGluZSA9IFsnVGl0bGUnLCAnVGV4dCcsICdEdXJhdGlvbicsICdDb21tZW50JywgJ0ludGVybmFsIGl0ZW0nXTtcbiAgICAgICAgICAgIHJldHVybiBfLm1hcChoZWFkZXJsaW5lLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG93bmxvYWRFeGFtcGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNzdlJvd3MgPSBbbWFrZUhlYWRlcmxpbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhhbXBsZSBlbnRyaWVzXG4gICAgICAgICAgICAgICAgICAgIFsnRGVtbyAxJywgJ0RlbW8gdGV4dCAxJywgJzE6MDAnLCAndGVzdCBjb21tZW50JywgJyddLFxuICAgICAgICAgICAgICAgICAgICBbJ0JyZWFrJywgJycsICcwOjEwJywgJycsICcxJ10sXG4gICAgICAgICAgICAgICAgICAgIFsnRGVtbyAyJywgJ0RlbW8gdGV4dCAyJywgJzE6MzAnLCAnJywgJyddXG5cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIENzdkRvd25sb2FkKGNzdlJvd3MsIGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnYWdlbmRhLWV4YW1wbGUnKSArICcuY3N2Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5hbmd1bGFyLm1vZHVsZSgnT3BlblNsaWRlc0FwcC50b3BpY3MucHJvamVjdG9yJywgWydPcGVuU2xpZGVzQXBwLnRvcGljcyddKVxuXG4uY29uZmlnKFtcbiAgICAnc2xpZGVzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uIChzbGlkZXNQcm92aWRlcikge1xuICAgICAgICBzbGlkZXNQcm92aWRlci5yZWdpc3RlclNsaWRlKCd0b3BpY3MvdG9waWMnLCB7XG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ3N0YXRpYy90ZW1wbGF0ZXMvdG9waWNzL3NsaWRlX3RvcGljLmh0bWwnXG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdTbGlkZVRvcGljQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnVG9waWMnLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgVG9waWMpIHtcbiAgICAgICAgLy8gQXR0ZW50aW9uISBFYWNoIG9iamVjdCB0aGF0IGlzIHVzZWQgaGVyZSBoYXMgdG8gYmUgZGVhbHQgb24gc2VydmVyIHNpZGUuXG4gICAgICAgIC8vIEFkZCBpdCB0byB0aGUgY29yZXNwb25kaW5nIGdldF9yZXF1aXJlbWVudHMgbWV0aG9kIG9mIHRoZSBQcm9qZWN0b3JFbGVtZW50XG4gICAgICAgIC8vIGNsYXNzLlxuICAgICAgICB2YXIgaWQgPSAkc2NvcGUuZWxlbWVudC5pZDtcbiAgICAgICAgVG9waWMuYmluZE9uZShpZCwgJHNjb3BlLCAndG9waWMnKTtcbiAgICB9XG5dKTtcblxufSkoKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAudG9waWNzLnNpdGUnLCBbJ09wZW5TbGlkZXNBcHAudG9waWNzJywgJ09wZW5TbGlkZXNBcHAudG9waWNzLmNzdiddKVxuXG4uY29uZmlnKFtcbiAgICAnJHN0YXRlUHJvdmlkZXInLFxuICAgICdnZXR0ZXh0JyxcbiAgICBmdW5jdGlvbigkc3RhdGVQcm92aWRlciwgZ2V0dGV4dCkge1xuICAgICAgICAkc3RhdGVQcm92aWRlclxuICAgICAgICAgICAgLnN0YXRlKCd0b3BpY3MnLCB7XG4gICAgICAgICAgICAgICAgdXJsOiAnL3RvcGljcycsXG4gICAgICAgICAgICAgICAgYWJzdHJhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHVpLXZpZXcvPlwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGdldHRleHQoJ1RvcGljcycpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXRlKCd0b3BpY3MudG9waWMnLCB7XG4gICAgICAgICAgICAgICAgYWJzdHJhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHVpLXZpZXcvPlwiLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdGF0ZSgndG9waWNzLnRvcGljLmRldGFpbCcsIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljSWQ6IFsnJHN0YXRlUGFyYW1zJywgZnVuY3Rpb24oJHN0YXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHN0YXRlUGFyYW1zLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy8gcmVkaXJlY3RzIHRvIHRvcGljIGRldGFpbCBhbmQgb3BlbnMgdG9waWMgZWRpdCBmb3JtIGRpYWxvZywgdXNlcyBlZGl0IHVybCxcbiAgICAgICAgICAgIC8vIHVzZWQgYnkgdWktc3JlZiBsaW5rcyBmcm9tIGFnZW5kYSBvbmx5XG4gICAgICAgICAgICAvLyAoZnJvbSB0b3BpYyBjb250cm9sbGVyIHVzZSBUb3BpY0Zvcm0gZmFjdG9yeSBpbnN0ZWFkIHRvIG9wZW4gZGlhbG9nIGluIGZyb250XG4gICAgICAgICAgICAvLyBvZiBjdXJyZW50IHZpZXcgd2l0aG91dCByZWRpcmVjdClcbiAgICAgICAgICAgIC5zdGF0ZSgndG9waWNzLnRvcGljLmRldGFpbC51cGRhdGUnLCB7XG4gICAgICAgICAgICAgICAgb25FbnRlcjogWyckc3RhdGVQYXJhbXMnLCAnJHN0YXRlJywgJ25nRGlhbG9nJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oJHN0YXRlUGFyYW1zLCAkc3RhdGUsIG5nRGlhbG9nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJ3N0YXRpYy90ZW1wbGF0ZXMvdG9waWNzL3RvcGljLWZvcm0uaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ1RvcGljVXBkYXRlQ3RybCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmdkaWFsb2ctdGhlbWUtZGVmYXVsdCB3aWRlLWZvcm0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlQnlFc2NhcGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlQnlEb2N1bWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BpY0lkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkc3RhdGVQYXJhbXMuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVDbG9zZUNhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCd0b3BpY3MudG9waWMuZGV0YWlsJywge3RvcGljOiAkc3RhdGVQYXJhbXMuaWR9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdGF0ZSgndG9waWNzLnRvcGljLmltcG9ydCcsIHtcbiAgICAgICAgICAgICAgICB1cmw6ICcvaW1wb3J0JyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiAnVG9waWNJbXBvcnRDdHJsJyxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdUb3BpY0Zvcm0nLCBbXG4gICAgJyRmaWx0ZXInLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnRWRpdG9yJyxcbiAgICAnTWVkaWFmaWxlJyxcbiAgICAnQWdlbmRhJyxcbiAgICAnQWdlbmRhVHJlZScsXG4gICAgJ1Nob3dBc0FnZW5kYUl0ZW1GaWVsZCcsXG4gICAgZnVuY3Rpb24gKCRmaWx0ZXIsIGdldHRleHRDYXRhbG9nLCBvcGVyYXRvciwgRWRpdG9yLCBNZWRpYWZpbGUsIEFnZW5kYSxcbiAgICAgICAgQWdlbmRhVHJlZSwgU2hvd0FzQWdlbmRhSXRlbUZpZWxkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBuZ0RpYWxvZyBmb3IgdG9waWMgZm9ybVxuICAgICAgICAgICAgZ2V0RGlhbG9nOiBmdW5jdGlvbiAodG9waWMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJ3N0YXRpYy90ZW1wbGF0ZXMvdG9waWNzL3RvcGljLWZvcm0uaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICh0b3BpYykgPyAnVG9waWNVcGRhdGVDdHJsJyA6ICdUb3BpY0NyZWF0ZUN0cmwnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICduZ2RpYWxvZy10aGVtZS1kZWZhdWx0IHdpZGUtZm9ybScsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlFc2NhcGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUJ5RG9jdW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BpY0lkOiBmdW5jdGlvbiAoKSB7cmV0dXJuIHRvcGljID8gdG9waWMuaWQ6IHZvaWQgMDt9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRGb3JtRmllbGRzOiBmdW5jdGlvbiAoaXNDcmVhdGVGb3JtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlcyA9IE1lZGlhZmlsZS5nZXRBbGxJbWFnZXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybUZpZWxkcyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ3RpdGxlJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdUaXRsZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VkaXRvcicsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnVGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNrZWRpdG9yT3B0aW9uczogRWRpdG9yLmdldE9wdGlvbnMoaW1hZ2VzKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgLy8gYXR0YWNobWVudHNcbiAgICAgICAgICAgICAgICBpZiAoTWVkaWFmaWxlLmdldEFsbCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybUZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F0dGFjaG1lbnRzX2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzZWxlY3QtbXVsdGlwbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQXR0YWNobWVudCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6ICRmaWx0ZXIoJ29yZGVyQnknKShNZWRpYWZpbGUuZ2V0QWxsKCksICd0aXRsZV9vcl9maWxlbmFtZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5nT3B0aW9uczogJ29wdGlvbi5pZCBhcyBvcHRpb24udGl0bGVfb3JfZmlsZW5hbWUgZm9yIG9wdGlvbiBpbiB0by5vcHRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTZWxlY3Qgb3Igc2VhcmNoIGFuIGF0dGFjaG1lbnQgLi4uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2hvdyBhcyBhZ2VuZGEgaXRlbSArIHBhcmVudCBpdGVtXG4gICAgICAgICAgICAgICAgaWYgKGlzQ3JlYXRlRm9ybSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtRmllbGRzLnB1c2goU2hvd0FzQWdlbmRhSXRlbUZpZWxkKCdhZ2VuZGEuY2FuX21hbmFnZScpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybUZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2FnZW5kYV9wYXJlbnRfaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NlbGVjdC1zaW5nbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnUGFyZW50IGl0ZW0nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBBZ2VuZGFUcmVlLmdldEZsYXRUcmVlKEFnZW5kYS5nZXRBbGwoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmdPcHRpb25zOiAnaXRlbS5pZCBhcyBpdGVtLmdldExpc3RWaWV3VGl0bGUoKSBmb3IgaXRlbSBpbiB0by5vcHRpb25zIHwgbm90c2VsZiA6IG1vZGVsLmFnZW5kYV9pdGVtX2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTZWxlY3QgYSBwYXJlbnQgaXRlbSAuLi4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6ICFvcGVyYXRvci5oYXNQZXJtcygnYWdlbmRhLmNhbl9tYW5hZ2UnKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybUZpZWxkcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignVG9waWNEZXRhaWxDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICduZ0RpYWxvZycsXG4gICAgJ1RvcGljRm9ybScsXG4gICAgJ1RvcGljJyxcbiAgICAndG9waWNJZCcsXG4gICAgJ1Byb2plY3RvcicsXG4gICAgJ1Byb2plY3Rpb25EZWZhdWx0JyxcbiAgICAnV2VicGFnZVRpdGxlJyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgbmdEaWFsb2csIFRvcGljRm9ybSwgVG9waWMsIHRvcGljSWQsIFByb2plY3RvciwgUHJvamVjdGlvbkRlZmF1bHQsIFdlYnBhZ2VUaXRsZSxcbiAgICAgICAgZ2V0dGV4dENhdGFsb2cpIHtcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gVG9waWMubGFzdE1vZGlmaWVkKHRvcGljSWQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUudG9waWMgPSBUb3BpYy5nZXQodG9waWNJZCk7XG4gICAgICAgICAgICBXZWJwYWdlVGl0bGUudXBkYXRlVGl0bGUoZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdUb3BpYycpICsgJyAnICtcbiAgICAgICAgICAgICAgICAkc2NvcGUudG9waWMuYWdlbmRhX2l0ZW0uZ2V0VGl0bGUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9qZWN0b3IubGFzdE1vZGlmaWVkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwcm9qZWN0aW9uZGVmYXVsdCA9IFByb2plY3Rpb25EZWZhdWx0LmZpbHRlcih7bmFtZTogJ3RvcGljcyd9KVswXTtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0aW9uZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5kZWZhdWx0UHJvamVjdG9ySWQgPSBwcm9qZWN0aW9uZGVmYXVsdC5wcm9qZWN0b3JfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAkc2NvcGUub3BlbkRpYWxvZyA9IGZ1bmN0aW9uICh0b3BpYykge1xuICAgICAgICAgICAgbmdEaWFsb2cub3BlbihUb3BpY0Zvcm0uZ2V0RGlhbG9nKHRvcGljKSk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ1RvcGljQ3JlYXRlQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJHN0YXRlJyxcbiAgICAnVG9waWMnLFxuICAgICdUb3BpY0Zvcm0nLFxuICAgICdBZ2VuZGEnLFxuICAgICdDb25maWcnLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlLCBUb3BpYywgVG9waWNGb3JtLCBBZ2VuZGEsIENvbmZpZywgRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICRzY29wZS5tb2RlbCA9IHtcbiAgICAgICAgICAgIGFnZW5kYV90eXBlOiAxLCAgLy8gRGVmYXVsdCBpcyBhIHB1YmxpYyBpdGVtLiBUaGUgY29uZmlnIGZpZWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdhZ2VuZGFfbmV3X2l0ZW1zX2RlZmF1bHRfdmlzaWJpbGl0eScgaXMgbm90IHVzZWQuXG4gICAgICAgIH07XG4gICAgICAgIC8vIGdldCBhbGwgZm9ybSBmaWVsZHNcbiAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHMgPSBUb3BpY0Zvcm0uZ2V0Rm9ybUZpZWxkcyh0cnVlKTtcbiAgICAgICAgLy8gc2F2ZSBmb3JtXG4gICAgICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24gKHRvcGljKSB7XG4gICAgICAgICAgICBUb3BpYy5jcmVhdGUodG9waWMpLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlVGhpc0RpYWxvZygpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ1RvcGljVXBkYXRlQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJHN0YXRlJyxcbiAgICAnVG9waWMnLFxuICAgICdUb3BpY0Zvcm0nLFxuICAgICdBZ2VuZGEnLFxuICAgICd0b3BpY0lkJyxcbiAgICAnRXJyb3JNZXNzYWdlJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSwgVG9waWMsIFRvcGljRm9ybSwgQWdlbmRhLCB0b3BpY0lkLCBFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHRvcGljID0gVG9waWMuZ2V0KHRvcGljSWQpO1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgdmFsdWVzIGZvciBmb3JtIG1vZGVsIGJ5IGNyZWF0ZSBkZWVwIGNvcHkgb2YgdG9waWMgb2JqZWN0XG4gICAgICAgIC8vIHNvIGxpc3QvZGV0YWlsIHZpZXcgaXMgbm90IHVwZGF0ZWQgd2hpbGUgZWRpdGluZ1xuICAgICAgICAkc2NvcGUubW9kZWwgPSBhbmd1bGFyLmNvcHkodG9waWMpO1xuICAgICAgICAvLyBnZXQgYWxsIGZvcm0gZmllbGRzXG4gICAgICAgICRzY29wZS5mb3JtRmllbGRzID0gVG9waWNGb3JtLmdldEZvcm1GaWVsZHMoKTtcblxuICAgICAgICAvLyBzYXZlIGZvcm1cbiAgICAgICAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbiAodG9waWMpIHtcbiAgICAgICAgICAgIC8vIGluamVjdCB0aGUgY2hhbmdlZCB0b3BpYyAoY29weSkgb2JqZWN0IGJhY2sgaW50byBEUyBzdG9yZVxuICAgICAgICAgICAgVG9waWMuaW5qZWN0KHRvcGljKTtcbiAgICAgICAgICAgIC8vIHNhdmUgY2hhbmdlZCB0b3BpYyBvYmplY3Qgb24gc2VydmVyXG4gICAgICAgICAgICBUb3BpYy5zYXZlKHRvcGljKS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlVGhpc0RpYWxvZygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgZXJyb3I6IHJldmVydCBhbGwgY2hhbmdlcyBieSByZXN0b3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIChyZWZyZXNoKSBvcmlnaW5hbCB0b3BpYyBvYmplY3QgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgVG9waWMucmVmcmVzaCh0b3BpYyk7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IEVycm9yTWVzc2FnZS5mb3JBbGVydChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignVG9waWNJbXBvcnRDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICdnZXR0ZXh0JyxcbiAgICAnQWdlbmRhJyxcbiAgICAnVG9waWMnLFxuICAgICdIdW1hblRpbWVDb252ZXJ0ZXInLFxuICAgICdUb3BpY3NDc3ZFeGFtcGxlJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsIGdldHRleHQsIEFnZW5kYSwgVG9waWMsIEh1bWFuVGltZUNvbnZlcnRlciwgVG9waWNzQ3N2RXhhbXBsZSkge1xuICAgICAgICAvLyBCaWcgVE9ETzogQ2hhbmdlIHdvcmRpbmcgZnJvbSBcIml0ZW1cIiB0byBcInRvcGljXCIuXG4gICAgICAgIC8vIGltcG9ydCBmcm9tIHRleHRhcmVhXG4gICAgICAgICRzY29wZS5pbXBvcnRCeUxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoJHNjb3BlLml0ZW1saXN0KSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnRpdGxlSXRlbXMgPSBfLmZpbHRlcigkc2NvcGUuaXRlbWxpc3RbMF0uc3BsaXQoXCJcXG5cIikpO1xuICAgICAgICAgICAgICAgICRzY29wZS5pbXBvcnRjb3VudGVyID0gMDtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goJHNjb3BlLnRpdGxlSXRlbXMsIGZ1bmN0aW9uKHRpdGxlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHt0aXRsZTogdGl0bGV9O1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmFnZW5kYV90eXBlID0gMTsgIC8vIFRoZSBuZXcgdG9waWMgaXMgbm90IGhpZGRlbi5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hZ2VuZGFfd2VpZ2h0ID0gMTAwMCArIGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBjcmVhdGUgYWxsIGl0ZW1zIGluIGJ1bGsgbW9kZVxuICAgICAgICAgICAgICAgICAgICBUb3BpYy5jcmVhdGUoaXRlbSkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaW1wb3J0Y291bnRlcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vICoqKiBDU1YgaW1wb3J0ICoqKlxuICAgICAgICAkc2NvcGUuY3N2Q29uZmlnID0ge1xuICAgICAgICAgICAgYWNjZXB0OiAnLmNzdiwgLnR4dCcsXG4gICAgICAgICAgICBlbmNvZGluZ09wdGlvbnM6IFsnVVRGLTgnLCAnSVNPLTg4NTktMSddLFxuICAgICAgICAgICAgcGFyc2VDb25maWc6IHtcbiAgICAgICAgICAgICAgICBza2lwRW1wdHlMaW5lczogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBGSUVMRFMgPSBbJ3RpdGxlJywgJ3RleHQnLCAnZHVyYXRpb24nLCAnY29tbWVudCcsICdpc19oaWRkZW4nXTtcbiAgICAgICAgJHNjb3BlLml0ZW1zID0gW107XG4gICAgICAgICRzY29wZS5vbkNzdkNoYW5nZSA9IGZ1bmN0aW9uIChjc3YpIHtcbiAgICAgICAgICAgICRzY29wZS5pdGVtcyA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgIF8uZm9yRWFjaChjc3YuZGF0YSwgZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICAgIGlmIChyb3cubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsbGVkUm93ID0gXy56aXBPYmplY3QoRklFTERTLCByb3cpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGZpbGxlZFJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF8uZm9yRWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0udGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5pbXBvcnRlcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udGl0bGVfZXJyb3IgPSBnZXR0ZXh0KCdFcnJvcjogVGl0bGUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBIdW1hblRpbWVDb252ZXJ0ZXIuaHVtYW5UaW1lVG9TZWNvbmRzKGl0ZW0uZHVyYXRpb24sIHtob3VyczogdHJ1ZX0pLzYwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZSA8PSAwKSB7IC8vIG51bGwgaW5zdGVhZCBvZiAwIG9yIG5lZ2F0aXZlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpdGVtLmR1cmF0aW9uID0gdGltZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaXNfaGlkZGVuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaXNfaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmlzX2hpZGRlbiA9PSAnMScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50eXBlID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc2V0IHdlaWdodCBmb3IgcmlnaHQgY3N2IHJvdyBvcmRlclxuICAgICAgICAgICAgICAgIC8vIChVc2UgMTAwMCsgdG8gcHJvdGVjdCBleGlzdGluZyBpdGVtcyBhbmQgcHJldmVudCBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICAvLyB3aXRoIG5ldyBpdGVtcyB3aGljaCB1c2Ugd2VpZ2h0IDEwMDAwIGFzIGRlZmF1bHQuKVxuICAgICAgICAgICAgICAgIGl0ZW0ud2VpZ2h0ID0gMTAwMCArIGluZGV4O1xuICAgICAgICAgICAgICAgICRzY29wZS5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2NvcGUuY2FsY1N0YXRzKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLmNhbGNTdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5pdGVtc1dpbGxOb3RCZUltcG9ydGVkID0gMDtcbiAgICAgICAgICAgICRzY29wZS5pdGVtc1dpbGxCZUltcG9ydGVkID0gMDtcblxuICAgICAgICAgICAgJHNjb3BlLml0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnNlbGVjdGVkICYmICFpdGVtLmltcG9ydGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5pdGVtc1dpbGxCZUltcG9ydGVkKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLml0ZW1zV2lsbE5vdEJlSW1wb3J0ZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBpbXBvcnQgZnJvbSBjc3YgZmlsZVxuICAgICAgICAkc2NvcGUuaW1wb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLmNzdkltcG9ydGluZyA9IHRydWU7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnNlbGVjdGVkICYmICFpdGVtLmltcG9ydGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYWdlbmRhX3R5cGUgPSBpdGVtLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYWdlbmRhX2NvbW1lbnQgPSBpdGVtLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYWdlbmRhX2R1cmF0aW9uID0gaXRlbS5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hZ2VuZGFfd2VpZ2h0ID0gaXRlbS53ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIFRvcGljLmNyZWF0ZShpdGVtKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaW1wb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHNjb3BlLmNzdmltcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLml0ZW1zID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZG93bmxvYWQgQ1NWIGV4YW1wbGUgZmlsZVxuICAgICAgICAkc2NvcGUuZG93bmxvYWRDU1ZFeGFtcGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgVG9waWNzQ3N2RXhhbXBsZS5kb3dubG9hZEV4YW1wbGUoKTtcbiAgICAgICAgfTtcbiAgICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmFuZ3VsYXIubW9kdWxlKCdPcGVuU2xpZGVzQXBwLnVzZXJzJywgW10pXG5cbi5mYWN0b3J5KCdVc2VyJywgW1xuICAgICdEUycsXG4gICAgJ0dyb3VwJyxcbiAgICAnanNEYXRhTW9kZWwnLFxuICAgICdnZXR0ZXh0JyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdDb25maWcnLFxuICAgIGZ1bmN0aW9uKERTLCBHcm91cCwganNEYXRhTW9kZWwsIGdldHRleHQsIGdldHRleHRDYXRhbG9nLCBDb25maWcpIHtcbiAgICAgICAgdmFyIG5hbWUgPSAndXNlcnMvdXNlcic7XG4gICAgICAgIHJldHVybiBEUy5kZWZpbmVSZXNvdXJjZSh7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdXNlQ2xhc3M6IGpzRGF0YU1vZGVsLFxuICAgICAgICAgICAgdmVyYm9zZU5hbWU6IGdldHRleHQoJ1BhcnRpY2lwYW50cycpLFxuICAgICAgICAgICAgdmVyYm9zZU5hbWVQbHVyYWw6IGdldHRleHQoJ1BhcnRpY2lwYW50cycpLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgICAgICAgICBmdWxsX25hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X2Z1bGxfbmFtZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2hvcnRfbmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRfc2hvcnRfbmFtZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWV0aG9kczoge1xuICAgICAgICAgICAgICAgIGdldFJlc291cmNlTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyBhIHNob3J0IGZvcm0gb2YgdGhlIG5hbWUuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBFeGFtcGxlOlxuICAgICAgICAgICAgICAgICAqIC0gRHIuIE1heCBNdXN0ZXJtYW5uXG4gICAgICAgICAgICAgICAgICogLSBQcm9mZXNzb3IgRHIuIEVuZGVycywgQ2hyaXN0b3BoXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ2V0X3Nob3J0X25hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBfLnRyaW0odGhpcy50aXRsZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE5hbWUgPSBfLnRyaW0odGhpcy5maXJzdF9uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3ROYW1lID0gXy50cmltKHRoaXMubGFzdF9uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbmZpZy5nZXQoJ3VzZXJzX3NvcnRfYnknKSAmJiBDb25maWcuZ2V0KCd1c2Vyc19zb3J0X2J5JykudmFsdWUgPT0gJ2xhc3RfbmFtZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0TmFtZSAmJiBmaXJzdE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lICs9IFtsYXN0TmFtZSwgZmlyc3ROYW1lXS5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lICs9IGxhc3ROYW1lIHx8IGZpcnN0TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gW2ZpcnN0TmFtZSwgbGFzdE5hbWVdLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZS50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy51c2VybmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGl0bGUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gdGl0bGUgKyAnICcgKyBuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyBhIGxvbmcgZm9ybSBvZiB0aGUgbmFtZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgICAgICAgICAgICogLSBEci4gTWF4IE11c3Rlcm1hbm4gKFZpbGxpbmdlbilcbiAgICAgICAgICAgICAgICAgKiAtIFByb2Zlc3NvciBEci4gRW5kZXJzLCBDaHJpc3RvcGggKExlaXB6aWcpXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ2V0X2Z1bGxfbmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXRfc2hvcnRfbmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0dXJlX2xldmVsID0gXy50cmltKHRoaXMuc3RydWN0dXJlX2xldmVsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciA9IF8udHJpbSh0aGlzLm51bWJlciksXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbiA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uOiBhZGQgbnVtYmVyIGFuZCBzdHJ1Y3R1cmUgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cnVjdHVyZV9sZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb24ucHVzaChzdHJ1Y3R1cmVfbGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIGFiYnJldmlhdGlvbiBmb3IgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdOby4nKSArICcgJyArIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArPSAnICgnICsgYWRkaXRpb24uam9pbignIMK3ICcpICsgJyknO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFBlcm1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsbFBlcm1zID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGxHcm91cHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBzX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxHcm91cHMgPSB0aGlzLmdyb3Vwc19pZC5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsR3JvdXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsR3JvdXBzLnB1c2goMSk7IC8vIGFkZCBkZWZhdWx0IGdyb3VwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGFsbEdyb3VwcywgZnVuY3Rpb24oZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gR3JvdXAuZ2V0KGdyb3VwSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGdyb3VwLnBlcm1pc3Npb25zLCBmdW5jdGlvbihwZXJtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFBlcm1zLnB1c2gocGVybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy51bmlxKGFsbFBlcm1zKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIGxpbmsgbmFtZSB3aGljaCBpcyBzaG93biBpbiBzZWFyY2ggcmVzdWx0XG4gICAgICAgICAgICAgICAgZ2V0U2VhcmNoUmVzdWx0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRfZnVsbF9uYW1lKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBzdWJ0aXRsZSBvZiBzZWFyY2ggcmVzdWx0XG4gICAgICAgICAgICAgICAgZ2V0U2VhcmNoUmVzdWx0U3VidGl0bGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUGFydGljaXBhbnRcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbGF0aW9uczoge1xuICAgICAgICAgICAgICAgIGhhc01hbnk6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3VzZXJzL2dyb3VwJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGaWVsZDogJ2dyb3VwcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEtleTogJ2dyb3Vwc19pZCcsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG5cbi5mYWN0b3J5KCdHcm91cCcsIFtcbiAgICAnRFMnLFxuICAgIGZ1bmN0aW9uKERTKSB7XG4gICAgICAgIHZhciBuYW1lID0gJ3VzZXJzL2dyb3VwJztcbiAgICAgICAgdmFyIHBlcm1pc3Npb25zO1xuICAgICAgICByZXR1cm4gRFMuZGVmaW5lUmVzb3VyY2Uoe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ1BlcnNvbmFsTm90ZScsIFtcbiAgICAnRFMnLFxuICAgIGZ1bmN0aW9uIChEUykge1xuICAgICAgICB2YXIgbmFtZSA9ICd1c2Vycy9wZXJzb25hbC1ub3RlJztcbiAgICAgICAgcmV0dXJuIERTLmRlZmluZVJlc291cmNlKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICByZWxhdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBoYXNPbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3VzZXJzL3VzZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZpZWxkOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEtleTogJ3VzZXJfaWQnLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5dKVxuXG4ucnVuKFtcbiAgICAnVXNlcicsXG4gICAgJ0dyb3VwJyxcbiAgICAnUGVyc29uYWxOb3RlJyxcbiAgICBmdW5jdGlvbihVc2VyLCBHcm91cCkge31cbl0pXG5cbi8vIE1hcmsgc3RyaW5ncyBmb3IgdHJhbnNsYXRpb24gaW4gSmF2YVNjcmlwdC5cbi5jb25maWcoW1xuICAgICdnZXR0ZXh0JyxcbiAgICBmdW5jdGlvbiAoZ2V0dGV4dCkge1xuICAgICAgICAvLyBkZWZhdWx0IGdyb3VwIG5hbWVzIChmcm9tIHVzZXJzL3NpZ25hbHMucHkpXG4gICAgICAgIGdldHRleHQoJ0RlZmF1bHQnKTtcbiAgICAgICAgZ2V0dGV4dCgnRGVsZWdhdGVzJyk7XG4gICAgICAgIGdldHRleHQoJ1N0YWZmJyk7XG4gICAgICAgIGdldHRleHQoJ0NvbW1pdHRlZXMnKTtcbiAgICB9XG5dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAudXNlcnMuY3N2JywgW10pXG5cbi5mYWN0b3J5KCdVc2VyQ3N2RXhwb3J0JywgW1xuICAgICckZmlsdGVyJyxcbiAgICAnR3JvdXAnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0NzdkRvd25sb2FkJyxcbiAgICBmdW5jdGlvbiAoJGZpbHRlciwgR3JvdXAsIGdldHRleHRDYXRhbG9nLCBDc3ZEb3dubG9hZCkge1xuICAgICAgICB2YXIgbWFrZUhlYWRlcmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVybGluZSA9IFsnVGl0bGUnLCAnR2l2ZW4gbmFtZScsICdTdXJuYW1lJywgJ1N0cnVjdHVyZSBsZXZlbCcsICdQYXJ0aWNpcGFudCBudW1iZXInLCAnR3JvdXBzJyxcbiAgICAgICAgICAgICAgICAnQ29tbWVudCcsICdJcyBhY3RpdmUnLCAnSXMgcHJlc2VudCcsICdJcyBhIGNvbW1pdHRlZScsICdJbml0aWFsIHBhc3N3b3JkJywgJ0VtYWlsJ107XG4gICAgICAgICAgICByZXR1cm4gXy5tYXAoaGVhZGVybGluZSwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldHRleHRDYXRhbG9nLmdldFN0cmluZyhlbnRyeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cG9ydDogZnVuY3Rpb24gKHVzZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNzdlJvd3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIG1ha2VIZWFkZXJsaW5lKClcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwcyA9IF8ubWFwKHVzZXIuZ3JvdXBzX2lkLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoR3JvdXAuZ2V0KGlkKS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuam9pbignLCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCdcIicgKyB1c2VyLnRpdGxlICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCdcIicgKyB1c2VyLmZpcnN0X25hbWUgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goJ1wiJyArIHVzZXIubGFzdF9uYW1lICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCdcIicgKyB1c2VyLnN0cnVjdHVyZV9sZXZlbCArICdcIicpO1xuICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgnXCInICsgdXNlci5udW1iZXIgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goJ1wiJyArIGdyb3VwcyArICdcIicpO1xuICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgnXCInICsgdXNlci5jb21tZW50ICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKHVzZXIuaXNfYWN0aXZlID8gJzEnIDogJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2godXNlci5pc19wcmVzZW50ID8gJzEnIDogJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2godXNlci5pc19jb21taXR0ZWUgPyAnMScgOiAnMCcpO1xuICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgnXCInICsgdXNlci5kZWZhdWx0X3Bhc3N3b3JkICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCdcIicgKyB1c2VyLmVtYWlsICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIGNzdlJvd3MucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIENzdkRvd25sb2FkKGNzdlJvd3MsIGdldHRleHRDYXRhbG9nLmdldFN0cmluZygncGFydGljaXBhbnRzJykgKyAnLmNzdicpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZG93bmxvYWRFeGFtcGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGdldCBhbiBleGFtcGxlIHdpdGggdHdvIGdyb3VwcyBhbmQgb25lIHdpdGggb25lIGdyb3VwXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwcyA9ICRmaWx0ZXIoJ29yZGVyQnknKShHcm91cC5nZXRBbGwoKSwgJ2lkJyk7XG4gICAgICAgICAgICAgICAgdmFyIGNzdkdyb3VwcyA9ICcnO1xuICAgICAgICAgICAgICAgIHZhciBjc3ZHcm91cCA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChncm91cHMubGVuZ3RoID49IDMpIHsgLy8gZG8gbm90IHBpY2sgZ3JvdXBzWzBdLCB0aGlzIGlzIHRoZSBkZWZhdWx0IGdyb3VwXG4gICAgICAgICAgICAgICAgICAgIGNzdkdyb3VwcyA9ICdcIicgKyBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoZ3JvdXBzWzFdLm5hbWUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJywgJyArIGdldHRleHRDYXRhbG9nLmdldFN0cmluZyhncm91cHNbMl0ubmFtZSkgKyAnXCInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzdkdyb3VwID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV0ubmFtZSk7IC8vIHRha2UgbGFzdCBncm91cFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjc3ZSb3dzID0gW21ha2VIZWFkZXJsaW5lKCksXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4YW1wbGUgZW50cmllc1xuICAgICAgICAgICAgICAgICAgICBbJ0RyLicsICdNYXgnLCAnTXVzdGVybWFubicsICdCZXJsaW4nLCcxMjM0NTY3ODkwJywgY3N2R3JvdXBzLCAneHl6JywgJzEnLCAnMScsICcnLCAnaW5pdGlhbFBhc3N3b3JkJywgJyddLFxuICAgICAgICAgICAgICAgICAgICBbJycsICdKb2huJywgJ0RvZScsICdXYXNoaW5ndG9uJywnNzUvOTkvOC0yJywgY3N2R3JvdXAsICdhYmMnLCAnMScsICcxJywgJycsICcnLCAnam9obi5kb2VAZW1haWwuY29tJ10sXG4gICAgICAgICAgICAgICAgICAgIFsnJywgJ0ZyZWQnLCAnQmxvZ2dzJywgJ0xvbmRvbicsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJ10sXG4gICAgICAgICAgICAgICAgICAgIFsnJywgJycsICdFeGVjdXRpdmUgQm9hcmQnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnMScsICcnLCAnJ10sXG5cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIENzdkRvd25sb2FkKGNzdlJvd3MsIGdldHRleHRDYXRhbG9nLmdldFN0cmluZygncGFydGljaXBhbnRzLWV4YW1wbGUnKSArICcuY3N2Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmFuZ3VsYXIubW9kdWxlKCdPcGVuU2xpZGVzQXBwLnVzZXJzLnBkZicsIFsnT3BlblNsaWRlc0FwcC5jb3JlLnBkZiddKVxuXG4uZmFjdG9yeSgnVXNlckxpc3RDb250ZW50UHJvdmlkZXInLCBbXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnUERGTGF5b3V0JyxcbiAgICAnR3JvdXAnLFxuICAgIGZ1bmN0aW9uKGdldHRleHRDYXRhbG9nLCBQREZMYXlvdXQsIEdyb3VwKSB7XG5cbiAgICAgICAgdmFyIGNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24odXNlckxpc3QpIHtcbiAgICAgICAgICAgIHZhciBncm91cHMgPSBHcm91cC5nZXRBbGwoKTtcblxuICAgICAgICAgICAgLy91c2UgdGhlIFByZWRlZmluZWQgRnVuY3Rpb25zIHRvIGNyZWF0ZSB0aGUgdGl0bGVcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IFBERkxheW91dC5jcmVhdGVUaXRsZShnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0xpc3Qgb2YgcGFydGljaXBhbnRzJykpO1xuXG4gICAgICAgICAgICAvL2Z1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSB1c2VyIGxpc3RcbiAgICAgICAgICAgIHZhciBjcmVhdGVVc2VyTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB1c2VySnNvbkxpc3QgPSBbXTtcblxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh1c2VyTGlzdCwgZnVuY3Rpb24gKHVzZXIsIGNvdW50ZXIpIHtcblxuICAgICAgICAgICAgICAgICAgICAvL3BhcnNlIGZvciB0aGUgZ3JvdXAgbmFtZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJHcm91cHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHVzZXIuZ3JvdXBzX2lkLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChncm91cHMsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZCA9PSBncm91cC5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlckdyb3Vwcy5wdXNoKGdldHRleHRDYXRhbG9nLmdldFN0cmluZyhncm91cC5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJKc29uT2JqID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIgKyAoY291bnRlcisxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogUERGTGF5b3V0LmZsaXBUYWJsZVJvd1N0eWxlKHVzZXJKc29uTGlzdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHVzZXIuc2hvcnRfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogUERGTGF5b3V0LmZsaXBUYWJsZVJvd1N0eWxlKHVzZXJKc29uTGlzdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHVzZXIuc3RydWN0dXJlX2xldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBQREZMYXlvdXQuZmxpcFRhYmxlUm93U3R5bGUodXNlckpzb25MaXN0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdXNlckdyb3Vwcy5qb2luKCcsICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBQREZMYXlvdXQuZmxpcFRhYmxlUm93U3R5bGUodXNlckpzb25MaXN0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgdXNlckpzb25MaXN0LnB1c2godXNlckpzb25PYmopO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHVzZXJUYWJsZUJvZHkgPSBbXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnIycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICd0YWJsZUhlYWRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdOYW1lJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICd0YWJsZUhlYWRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTdHJ1Y3R1cmUgbGV2ZWwnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3RhYmxlSGVhZGVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0dyb3VwcycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndGFibGVIZWFkZXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHVzZXJUYWJsZUJvZHkgPSB1c2VyVGFibGVCb2R5LmNvbmNhdCgodXNlckpzb25MaXN0KSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdXNlclRhYmxlSnNvblN0cmluZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoczogWydhdXRvJywgJyonLCAnYXV0bycsICdhdXRvJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJSb3dzOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogdXNlclRhYmxlQm9keVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6ICdoZWFkZXJMaW5lT25seSdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJUYWJsZUpzb25TdHJpbmc7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZ2V0Q29udGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVVc2VyTGlzdCgpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2V0Q29udGVudDogZ2V0Q29udGVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlSW5zdGFuY2U6IGNyZWF0ZUluc3RhbmNlXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ1VzZXJBY2Nlc3NEYXRhTGlzdENvbnRlbnRQcm92aWRlcicsIFtcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdQREZMYXlvdXQnLFxuICAgICdDb25maWcnLFxuICAgIGZ1bmN0aW9uKGdldHRleHRDYXRhbG9nLCBQREZMYXlvdXQsIENvbmZpZykge1xuXG4gICAgICAgIHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uKHVzZXJMaXN0KSB7XG5cbiAgICAgICAgICAgIHZhciBjcmVhdGVVc2VySGVhZExpbmUgPSBmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpdGxlTGluZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRpdGxlTGluZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdXNlci5nZXRfc2hvcnRfbmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3VzZXJEYXRhVGl0bGUnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXIuc3RydWN0dXJlX2xldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlTGluZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHVzZXIuc3RydWN0dXJlX2xldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICd1c2VyRGF0YUhlYWRpbmcnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGl0bGVMaW5lO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNyZWF0ZUFjY2Vzc0RhdGFDb250ZW50ID0gZnVuY3Rpb24odXNlcikge1xuICAgICAgICAgICAgICAgIC8vIHdsYW4gYWNjZXNzIGRhdGFcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uV2lmaSA9IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdXTEFOIGFjY2VzcyBkYXRhJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3VzZXJEYXRhSGVhZGluZydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdXTEFOIG5hbWUgKFNTSUQpJykgKyAnOicsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3VzZXJEYXRhVG9waWMnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IENvbmZpZy5nZXQoJ3VzZXJzX3BkZl93bGFuX3NzaWQnKS52YWx1ZSB8fCAnLScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3VzZXJEYXRhVmFsdWUnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnV0xBTiBwYXNzd29yZCcpICsgJzonLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICd1c2VyRGF0YVRvcGljJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBDb25maWcuZ2V0KCd1c2Vyc19wZGZfd2xhbl9wYXNzd29yZCcpLnZhbHVlIHx8ICctJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndXNlckRhdGFWYWx1ZSdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdXTEFOIGVuY3J5cHRpb24nKSArICc6JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndXNlckRhdGFUb3BpYydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogQ29uZmlnLmdldCgndXNlcnNfcGRmX3dsYW5fZW5jcnlwdGlvbicpLnZhbHVlIHx8ICctJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndXNlckRhdGFWYWx1ZSdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ1xcbidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgLy8gd2lmaSBxciBjb2RlXG4gICAgICAgICAgICAgICAgaWYgKENvbmZpZy5nZXQoJ3VzZXJzX3BkZl93bGFuX3NzaWQnKS52YWx1ZSAmJiBDb25maWcuZ2V0KCd1c2Vyc19wZGZfd2xhbl9lbmNyeXB0aW9uJykudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZmlRckNvZGUgPSAnV0lGSTpTOicgKyBDb25maWcuZ2V0KCd1c2Vyc19wZGZfd2xhbl9zc2lkJykudmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJztUOicgKyBDb25maWcuZ2V0KCd1c2Vyc19wZGZfd2xhbl9lbmNyeXB0aW9uJykudmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJztQOicgKyBDb25maWcuZ2V0KCd1c2Vyc19wZGZfd2xhbl9wYXNzd29yZCcpLnZhbHVlICsgJzs7JztcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uV2lmaS5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFyOiB3aWZpUXJDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpdDogMTIwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogWzAsIDAsIDAsIDhdXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnU2NhbiB0aGlzIFFSIGNvZGUgdG8gY29ubmVjdCB0byBXTEFOLicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnc21hbGwnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gb3BlbnNsaWRlcyBhY2Nlc3MgZGF0YVxuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5PcGVuU2xpZGVzID0gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ09wZW5TbGlkZXMgYWNjZXNzIGRhdGEnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndXNlckRhdGFIZWFkaW5nJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1VzZXJuYW1lJykgKyAnOicsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3VzZXJEYXRhVG9waWMnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3VzZXJEYXRhVmFsdWUnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnSW5pdGlhbCBwYXNzd29yZCcpICsgJzonLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICd1c2VyRGF0YVRvcGljJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB1c2VyLmRlZmF1bHRfcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3VzZXJEYXRhVmFsdWUnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdVUkw6JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndXNlckRhdGFUb3BpYydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogQ29uZmlnLmdldCgndXNlcnNfcGRmX3VybCcpLnZhbHVlICB8fCAnLScsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rOiBDb25maWcuZ2V0KCd1c2Vyc19wZGZfdXJsJykudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3VzZXJEYXRhVmFsdWUnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdcXG4nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIC8vIHVybCBxciBjb2RlXG4gICAgICAgICAgICAgICAgaWYgKENvbmZpZy5nZXQoJ3VzZXJzX3BkZl91cmwnKS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5PcGVuU2xpZGVzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXI6IENvbmZpZy5nZXQoJ3VzZXJzX3BkZl91cmwnKS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXQ6IDEyMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFswLCAwLCAwLCA4XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1NjYW4gdGhpcyBRUiBjb2RlIHRvIG9wZW4gVVJMLicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnc21hbGwnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGFjY2Vzc0RhdGFDb2x1bW5zID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5XaWZpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uT3BlblNsaWRlcyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBbMCwgMjBdXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3NEYXRhQ29sdW1ucztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjcmVhdGVXZWxjb21lVGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICAgQ29uZmlnLnRyYW5zbGF0ZShDb25maWcuZ2V0KCd1c2Vyc19wZGZfd2VsY29tZXRpdGxlJykudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICd1c2VyRGF0YUhlYWRpbmcnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICAgQ29uZmlnLnRyYW5zbGF0ZShDb25maWcuZ2V0KCd1c2Vyc19wZGZfd2VsY29tZXRleHQnKS52YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3VzZXJEYXRhVG9waWMnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldENvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IFtdO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh1c2VyTGlzdCwgZnVuY3Rpb24gKHVzZXIsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChjcmVhdGVVc2VySGVhZExpbmUodXNlcikpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goY3JlYXRlQWNjZXNzRGF0YUNvbnRlbnQodXNlcikpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goY3JlYXRlV2VsY29tZVRleHQoKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHBhZ2VicmVhayBhZnRlciB0aGUgbGFzdCB1c2VyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gdXNlckxpc3QubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlQnJlYWs6ICdhZnRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2V0Q29udGVudDogZ2V0Q29udGVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlSW5zdGFuY2U6IGNyZWF0ZUluc3RhbmNlXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ1VzZXJQZGZFeHBvcnQnLCBbXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnVXNlckxpc3RDb250ZW50UHJvdmlkZXInLFxuICAgICdVc2VyQWNjZXNzRGF0YUxpc3RDb250ZW50UHJvdmlkZXInLFxuICAgICdQZGZNYWtlRG9jdW1lbnRQcm92aWRlcicsXG4gICAgJ1BkZkNyZWF0ZScsXG4gICAgJ01lc3NhZ2luZycsXG4gICAgZnVuY3Rpb24gKGdldHRleHRDYXRhbG9nLCBVc2VyTGlzdENvbnRlbnRQcm92aWRlciwgVXNlckFjY2Vzc0RhdGFMaXN0Q29udGVudFByb3ZpZGVyLFxuICAgICAgICBQZGZNYWtlRG9jdW1lbnRQcm92aWRlciwgUGRmQ3JlYXRlLCBNZXNzYWdpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cG9ydFVzZXJMaXN0OiBmdW5jdGlvbiAodXNlcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0xpc3Qgb2YgcGFydGljaXBhbnRzJykgKyAnLnBkZic7XG4gICAgICAgICAgICAgICAgdmFyIHVzZXJMaXN0Q29udGVudFByb3ZpZGVyID0gVXNlckxpc3RDb250ZW50UHJvdmlkZXIuY3JlYXRlSW5zdGFuY2UodXNlcnMpO1xuICAgICAgICAgICAgICAgIFBkZk1ha2VEb2N1bWVudFByb3ZpZGVyLmNyZWF0ZUluc3RhbmNlKHVzZXJMaXN0Q29udGVudFByb3ZpZGVyKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZG9jdW1lbnRQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgUGRmQ3JlYXRlLmRvd25sb2FkKGRvY3VtZW50UHJvdmlkZXIsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdpbmcuYWRkTWVzc2FnZShlcnJvci5tc2csICdlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHBvcnRVc2VyQWNjZXNzRGF0YUxpc3Q6IGZ1bmN0aW9uICh1c2Vycykge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnTGlzdCBvZiBhY2Nlc3MgZGF0YScpICsgJy5wZGYnO1xuICAgICAgICAgICAgICAgIHZhciB1c2VyQWNjZXNzRGF0YUxpc3RDb250ZW50UHJvdmlkZXIgPSBVc2VyQWNjZXNzRGF0YUxpc3RDb250ZW50UHJvdmlkZXIuY3JlYXRlSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICAgIHVzZXJzKTtcbiAgICAgICAgICAgICAgICAvLyBubyBmb290ZXIgaGVyZVxuICAgICAgICAgICAgICAgIFBkZk1ha2VEb2N1bWVudFByb3ZpZGVyLmNyZWF0ZUluc3RhbmNlKHVzZXJBY2Nlc3NEYXRhTGlzdENvbnRlbnRQcm92aWRlciwgdHJ1ZSkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGRvY3VtZW50UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBkZkNyZWF0ZS5kb3dubG9hZChkb2N1bWVudFByb3ZpZGVyLCBmaWxlbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVzc2FnaW5nLmFkZE1lc3NhZ2UoZXJyb3IubXNnLCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmFuZ3VsYXIubW9kdWxlKCdPcGVuU2xpZGVzQXBwLnVzZXJzLnByb2plY3RvcicsIFsnT3BlblNsaWRlc0FwcC51c2VycyddKVxuXG4uY29uZmlnKFtcbiAgICAnc2xpZGVzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKHNsaWRlc1Byb3ZpZGVyKSB7XG4gICAgICAgIHNsaWRlc1Byb3ZpZGVyLnJlZ2lzdGVyU2xpZGUoJ3VzZXJzL3VzZXInLCB7XG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ3N0YXRpYy90ZW1wbGF0ZXMvdXNlcnMvc2xpZGVfdXNlci5odG1sJyxcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ1NsaWRlVXNlckN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ1VzZXInLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgVXNlcikge1xuICAgICAgICAvLyBBdHRlbnRpb24hIEVhY2ggb2JqZWN0IHRoYXQgaXMgdXNlZCBoZXJlIGhhcyB0byBiZSBkZWFsdCBvbiBzZXJ2ZXIgc2lkZS5cbiAgICAgICAgLy8gQWRkIGl0IHRvIHRoZSBjb3Jlc3BvbmRpbmcgZ2V0X3JlcXVpcmVtZW50cyBtZXRob2Qgb2YgdGhlIFByb2plY3RvckVsZW1lbnRcbiAgICAgICAgLy8gY2xhc3MuXG4gICAgICAgIHZhciBpZCA9ICRzY29wZS5lbGVtZW50LmlkO1xuICAgICAgICBVc2VyLmJpbmRPbmUoaWQsICRzY29wZSwgJ3VzZXInKTtcbiAgICB9XG5dKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ09wZW5TbGlkZXNBcHAudXNlcnMuc2l0ZScsIFtcbiAgICAnT3BlblNsaWRlc0FwcC51c2VycycsXG4gICAgJ09wZW5TbGlkZXNBcHAuY29yZS5wZGYnLFxuICAgICdPcGVuU2xpZGVzQXBwLnVzZXJzLnBkZicsXG4gICAgJ09wZW5TbGlkZXNBcHAudXNlcnMuY3N2Jyxcbl0pXG5cbi5jb25maWcoW1xuICAgICdtYWluTWVudVByb3ZpZGVyJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgZnVuY3Rpb24gKG1haW5NZW51UHJvdmlkZXIsIGdldHRleHQpIHtcbiAgICAgICAgbWFpbk1lbnVQcm92aWRlci5yZWdpc3Rlcih7XG4gICAgICAgICAgICAndWlfc3JlZic6ICd1c2Vycy51c2VyLmxpc3QnLFxuICAgICAgICAgICAgJ2ltZ19jbGFzcyc6ICd1c2VyJyxcbiAgICAgICAgICAgICd0aXRsZSc6IGdldHRleHQoJ1BhcnRpY2lwYW50cycpLFxuICAgICAgICAgICAgJ3dlaWdodCc6IDUwMCxcbiAgICAgICAgICAgICdwZXJtJzogJ3VzZXJzLmNhbl9zZWVfbmFtZScsXG4gICAgICAgIH0pO1xuICAgIH1cbl0pXG4uY29uZmlnKFtcbiAgICAnU2VhcmNoUHJvdmlkZXInLFxuICAgICdnZXR0ZXh0JyxcbiAgICBmdW5jdGlvbiAoU2VhcmNoUHJvdmlkZXIsIGdldHRleHQpIHtcbiAgICAgICAgU2VhcmNoUHJvdmlkZXIucmVnaXN0ZXIoe1xuICAgICAgICAgICAgJ3ZlcmJvc2VOYW1lJzogZ2V0dGV4dCgnUGFydGljaXBhbnRzJyksXG4gICAgICAgICAgICAnY29sbGVjdGlvbk5hbWUnOiAndXNlcnMvdXNlcicsXG4gICAgICAgICAgICAndXJsRGV0YWlsU3RhdGUnOiAndXNlcnMudXNlci5kZXRhaWwnLFxuICAgICAgICAgICAgJ3dlaWdodCc6IDUwMCxcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLmNvbmZpZyhbXG4gICAgJyRzdGF0ZVByb3ZpZGVyJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIsIGdldHRleHQpIHtcbiAgICAgICAgJHN0YXRlUHJvdmlkZXJcbiAgICAgICAgLnN0YXRlKCd1c2VycycsIHtcbiAgICAgICAgICAgIHVybDogJy91c2VycycsXG4gICAgICAgICAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjx1aS12aWV3Lz5cIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogZ2V0dGV4dCgnUGFydGljaXBhbnRzJyksXG4gICAgICAgICAgICAgICAgYmFzZVBlcm06ICd1c2Vycy5jYW5fc2VlX25hbWUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgLnN0YXRlKCd1c2Vycy51c2VyJywge1xuICAgICAgICAgICAgYWJzdHJhY3Q6IHRydWUsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8dWktdmlldy8+XCIsXG4gICAgICAgIH0pXG4gICAgICAgIC5zdGF0ZSgndXNlcnMudXNlci5saXN0Jywge30pXG4gICAgICAgIC5zdGF0ZSgndXNlcnMudXNlci5jcmVhdGUnLCB7fSlcbiAgICAgICAgLnN0YXRlKCd1c2Vycy51c2VyLmRldGFpbCcsIHtcbiAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICB1c2VySWQ6IFsnJHN0YXRlUGFyYW1zJywgZnVuY3Rpb24oJHN0YXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkc3RhdGVQYXJhbXMuaWQ7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnN0YXRlKCd1c2Vycy51c2VyLmNoYW5nZS1wYXNzd29yZCcsIHtcbiAgICAgICAgICAgIHVybDogJy9jaGFuZ2UtcGFzc3dvcmQve2lkfScsXG4gICAgICAgICAgICBjb250cm9sbGVyOiAnVXNlckNoYW5nZVBhc3N3b3JkQ3RybCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3N0YXRpYy90ZW1wbGF0ZXMvdXNlcnMvdXNlci1jaGFuZ2UtcGFzc3dvcmQuaHRtbCcsXG4gICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBbJyRzdGF0ZVBhcmFtcycsIGZ1bmN0aW9uKCRzdGF0ZVBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHN0YXRlUGFyYW1zLmlkO1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5zdGF0ZSgndXNlcnMudXNlci5pbXBvcnQnLCB7XG4gICAgICAgICAgICB1cmw6ICcvaW1wb3J0JyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdVc2VySW1wb3J0Q3RybCcsXG4gICAgICAgIH0pXG4gICAgICAgIC5zdGF0ZSgndXNlcnMudXNlci5wcmVzZW5jZScsIHtcbiAgICAgICAgICAgIHVybDogJy9wcmVzZW5jZScsXG4gICAgICAgICAgICBjb250cm9sbGVyOiAnVXNlclByZXNlbmNlQ3RybCcsXG4gICAgICAgIH0pXG4gICAgICAgIC8vIGdyb3Vwc1xuICAgICAgICAuc3RhdGUoJ3VzZXJzLmdyb3VwJywge1xuICAgICAgICAgICAgdXJsOiAnL2dyb3VwcycsXG4gICAgICAgICAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjx1aS12aWV3Lz5cIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogZ2V0dGV4dCgnR3JvdXBzJyksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICAuc3RhdGUoJ3VzZXJzLmdyb3VwLmxpc3QnLCB7fSlcbiAgICAgICAgLnN0YXRlKCdsb2dpbicsIHtcbiAgICAgICAgICAgIHRlbXBsYXRlOiBudWxsLFxuICAgICAgICAgICAgdXJsOiAnL2xvZ2luJyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGd1ZXN0X2VuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1zZzogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkVudGVyOiBbJyRzdGF0ZScsICckc3RhdGVQYXJhbXMnLCAnbmdEaWFsb2cnLCAnTG9naW5EaWFsb2cnLCBmdW5jdGlvbigkc3RhdGUsICRzdGF0ZVBhcmFtcywgbmdEaWFsb2csIExvZ2luRGlhbG9nKSB7XG4gICAgICAgICAgICAgICAgTG9naW5EaWFsb2cuaWQgPSBuZ0RpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL2NvcmUvbG9naW4tZm9ybS5odG1sJyxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ0xvZ2luRm9ybUN0cmwnLFxuICAgICAgICAgICAgICAgICAgICBzaG93Q2xvc2U6ICRzdGF0ZVBhcmFtcy5ndWVzdF9lbmFibGVkLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUJ5RXNjYXBlOiAkc3RhdGVQYXJhbXMuZ3Vlc3RfZW5hYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VCeURvY3VtZW50OiAkc3RhdGVQYXJhbXMuZ3Vlc3RfZW5hYmxlZCxcbiAgICAgICAgICAgICAgICB9KS5pZDtcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnTG9naW4nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXSlcblxuLnZhbHVlKCdMb2dpbkRpYWxvZycsIHt9KVxuXG4vKlxuICogRGlyZWN0aXZlIHRvIGNoZWNrIGZvciBwZXJtaXNzaW9uc1xuICpcbiAqIFRoaXMgaXMgdGhlIENvZGUgZnJvbSBhbmd1bGFyLmpzIG5nSWYuXG4gKlxuICogVE9ETzogZmluZCBhIHdheSBub3QgdG8gY29weSB0aGUgY29kZS5cbiovXG4uZGlyZWN0aXZlKCdvc1Blcm1zJywgW1xuICAgICckYW5pbWF0ZScsXG4gICAgZnVuY3Rpb24oJGFuaW1hdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG11bHRpRWxlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgIHRyYW5zY2x1ZGU6ICdlbGVtZW50JyxcbiAgICAgICAgICAgIHByaW9yaXR5OiA2MDAsXG4gICAgICAgICAgICB0ZXJtaW5hbDogdHJ1ZSxcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICAgICAgICAkJHRsYjogdHJ1ZSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRhdHRyLCBjdHJsLCAkdHJhbnNjbHVkZSkge1xuICAgICAgICAgICAgICAgIHZhciBibG9jaywgY2hpbGRTY29wZSwgcHJldmlvdXNFbGVtZW50cywgcGVybXM7XG4gICAgICAgICAgICAgICAgaWYgKCRhdHRyLm9zUGVybXNbMF0gPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICBwZXJtcyA9IF8udHJpbVN0YXJ0KCRhdHRyLm9zUGVybXMsICchJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVybXMgPSAkYXR0ci5vc1Blcm1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5vcGVyYXRvciAmJiBzY29wZS5vcGVyYXRvci5oYXNQZXJtcyhwZXJtcyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRhdHRyLm9zUGVybXNbMF0gPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gIXZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0cmFuc2NsdWRlKGZ1bmN0aW9uKGNsb25lLCBuZXdTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRTY29wZSA9IG5ld1Njb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbY2xvbmUubGVuZ3RoKytdID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnIGVuZCBuZ0lmOiAnICsgJGF0dHIubmdJZiArICcgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBXZSBvbmx5IG5lZWQgdGhlIGZpcnN0L2xhc3Qgbm9kZSBvZiB0aGUgY2xvbmVkIG5vZGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgd2UgbmVlZCB0byBrZWVwIHRoZSByZWZlcmVuY2UgdG8gdGhlIGpxbGl0ZSB3cmFwcGVyIGFzIGl0IG1pZ2h0IGJlIGNoYW5nZWQgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IGEgZGlyZWN0aXZlIHdpdGggdGVtcGxhdGVVcmwgd2hlbiBpdHMgdGVtcGxhdGUgYXJyaXZlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lOiBjbG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGNsb25lLCAkZWxlbWVudC5wYXJlbnQoKSwgJGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0VsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzRWxlbWVudHMucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzRWxlbWVudHMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkU2NvcGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNFbGVtZW50cyA9IGdldEJsb2NrTm9kZXMoYmxvY2suY2xvbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShwcmV2aW91c0VsZW1lbnRzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNFbGVtZW50cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnUGFzc3dvcmRHZW5lcmF0b3InLCBbXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2VuZXJhdGU6IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hhcnMgPSAnYWJjZGVmZ2hpamttbnBxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaMjM0NTY3ODknLFxuICAgICAgICAgICAgICAgIHB3ID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwdyArPSBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnUGVyc29uYWxOb3RlTWFuYWdlcicsIFtcbiAgICAnUGVyc29uYWxOb3RlJyxcbiAgICAnb3BlcmF0b3InLFxuICAgIGZ1bmN0aW9uIChQZXJzb25hbE5vdGUsIG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBfZ2V0UGVyc29uYWxOb3RlT2JqZWN0ID0gZnVuY3Rpb24gKHJlc291cmNlTmFtZSkge1xuICAgICAgICAgICAgdmFyIHBlcnNvbmFsTm90ZSA9IF8uZmluZChQZXJzb25hbE5vdGUuZ2V0QWxsKCksIGZ1bmN0aW9uIChwbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwbi51c2VyX2lkID09PSBvcGVyYXRvci51c2VyLmlkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXBlcnNvbmFsTm90ZSkge1xuICAgICAgICAgICAgICAgIHBlcnNvbmFsTm90ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZXM6IHt9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBlcnNvbmFsTm90ZS5ub3Rlc1tyZXNvdXJjZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcGVyc29uYWxOb3RlLm5vdGVzW3Jlc291cmNlTmFtZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwZXJzb25hbE5vdGU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAocmVzb3VyY2VOYW1lLCBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZXRQZXJzb25hbE5vdGVPYmplY3QocmVzb3VyY2VOYW1lKS5ub3Rlc1tyZXNvdXJjZU5hbWVdW2lkXTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNhdmUgPSBmdW5jdGlvbiAocmVzb3VyY2VOYW1lLCBpZCwgbm90ZSkge1xuICAgICAgICAgICAgdmFyIHBlcnNvbmFsTm90ZSA9IF9nZXRQZXJzb25hbE5vdGVPYmplY3QocmVzb3VyY2VOYW1lKTtcbiAgICAgICAgICAgIHBlcnNvbmFsTm90ZS5ub3Rlc1tyZXNvdXJjZU5hbWVdW2lkXSA9IG5vdGU7XG4gICAgICAgICAgICBpZiAocGVyc29uYWxOb3RlLmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNvbmFsTm90ZS5zYXZlKHBlcnNvbmFsTm90ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzb25hbE5vdGUuY3JlYXRlKHBlcnNvbmFsTm90ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXROb3RlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmouZ2V0UmVzb3VyY2VOYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnVGhlIE9iamVjdCBoYXMgdG8gYmUgYSBqcyBkYXRhIG1vZGVsISc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXQob2JqLmdldFJlc291cmNlTmFtZSgpLCBvYmouaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhdmVOb3RlOiBmdW5jdGlvbiAob2JqLCBub3RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmouZ2V0UmVzb3VyY2VOYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnVGhlIE9iamVjdCBoYXMgdG8gYmUgYSBqcyBkYXRhIG1vZGVsISc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzYXZlKG9iai5nZXRSZXNvdXJjZU5hbWUoKSwgb2JqLmlkLCBub3RlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLy8gU2VydmljZSBmb3IgZ2VuZXJpYyBhc3NpZ25tZW50IGZvcm0gKGNyZWF0ZSBhbmQgdXBkYXRlKVxuLmZhY3RvcnkoJ1VzZXJGb3JtJywgW1xuICAgICckaHR0cCcsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnRWRpdG9yJyxcbiAgICAnR3JvdXAnLFxuICAgICdNZWRpYWZpbGUnLFxuICAgICdQYXNzd29yZEdlbmVyYXRvcicsXG4gICAgZnVuY3Rpb24gKCRodHRwLCBnZXR0ZXh0Q2F0YWxvZywgRWRpdG9yLCBHcm91cCwgTWVkaWFmaWxlLCBQYXNzd29yZEdlbmVyYXRvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gbmdEaWFsb2cgZm9yIHVzZXIgZm9ybVxuICAgICAgICAgICAgZ2V0RGlhbG9nOiBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnc3RhdGljL3RlbXBsYXRlcy91c2Vycy91c2VyLWZvcm0uaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICh1c2VyKSA/ICdVc2VyVXBkYXRlQ3RybCcgOiAnVXNlckNyZWF0ZUN0cmwnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICduZ2RpYWxvZy10aGVtZS1kZWZhdWx0IHdpZGUtZm9ybScsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlFc2NhcGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUJ5RG9jdW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQ6IGZ1bmN0aW9uICgpIHtyZXR1cm4gdXNlciA/IHVzZXIuaWQgOiB2b2lkIDA7fSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gYW5ndWxhci1mb3JtbHkgZmllbGRzIGZvciB1c2VyIGZvcm1cbiAgICAgICAgICAgIGdldEZvcm1GaWVsZHM6IGZ1bmN0aW9uIChoaWRlT25DcmVhdGVGb3JtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlcyA9IE1lZGlhZmlsZS5nZXRBbGxJbWFnZXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJvd1wiLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZEdyb3VwOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAndGl0bGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNvbC14cy0yIG5vLXBhZGRpbmctbGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdUaXRsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdmaXJzdF9uYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjb2wteHMtNSBuby1wYWRkaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0dpdmVuIG5hbWUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnbGFzdF9uYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjb2wteHMtNSBuby1wYWRkaW5nLXJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1N1cm5hbWUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdlbWFpbCcsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnRW1haWwnKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwicm93XCIsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkR3JvdXA6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdzdHJ1Y3R1cmVfbGV2ZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNvbC14cy05IG5vLXBhZGRpbmctbGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdTdHJ1Y3R1cmUgbGV2ZWwnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyAgIGtleTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiY29sLXhzLTMgbm8tcGFkZGluZy1sZWZ0IG5vLXBhZGRpbmctcmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6Z2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdQYXJ0aWNpcGFudCBudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICd1c2VybmFtZScsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnVXNlcm5hbWUnKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoaWRlOiBoaWRlT25DcmVhdGVGb3JtXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2dyb3Vwc19pZCcsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzZWxlY3QtbXVsdGlwbGUnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ0dyb3VwcycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogR3JvdXAuZmlsdGVyKHt3aGVyZToge2lkOiB7Jz4nOiAxfX19KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5nT3B0aW9uczogXCJvcHRpb24uaWQgYXMgb3B0aW9uLm5hbWUgfCB0cmFuc2xhdGUgZm9yIG9wdGlvbiBpbiB0by5vcHRpb25zIHwgb3JkZXJCeTogJ2lkJ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnU2VsZWN0IG9yIHNlYXJjaCBhIGdyb3VwIC4uLicpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnZGVmYXVsdF9wYXNzd29yZCcsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnSW5pdGlhbCBwYXNzd29yZCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnSW5pdGlhbCBwYXNzd29yZCBjYW4gbm90IGJlIGNoYW5nZWQuJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRvblJpZ2h0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdHZW5lcmF0ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnZmEgZmEtbWFnaWMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ZnVuY3Rpb24gKG9wdGlvbnMsIHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLiRwYXJlbnQubW9kZWwuZGVmYXVsdF9wYXNzd29yZCA9IFBhc3N3b3JkR2VuZXJhdG9yLmdlbmVyYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoaWRlOiAhaGlkZU9uQ3JlYXRlRm9ybVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb21tZW50JyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdDb21tZW50JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdPbmx5IGZvciBpbnRlcm5hbCBub3Rlcy4nKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ21vcmUnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1Nob3cgZXh0ZW5kZWQgZmllbGRzJylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxociBjbGFzcz1cInNtYWxsaHJcIj4nLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXhwcmVzc2lvbjogJyFtb2RlbC5tb3JlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdpc19wcmVzZW50JyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdJcyBwcmVzZW50JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdEZXNpZ25hdGVzIHdoZXRoZXIgdGhpcyB1c2VyIGlzIGluIHRoZSByb29tIG9yIG5vdC4nKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFeHByZXNzaW9uOiAnIW1vZGVsLm1vcmUnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2lzX2FjdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnSXMgYWN0aXZlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdEZXNpZ25hdGVzIHdoZXRoZXIgdGhpcyB1c2VyIHNob3VsZCBiZSB0cmVhdGVkIGFzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUuIFVuc2VsZWN0IHRoaXMgaW5zdGVhZCBvZiBkZWxldGluZyB0aGUgYWNjb3VudC4nKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFeHByZXNzaW9uOiAnIW1vZGVsLm1vcmUnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2lzX2NvbW1pdHRlZScsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnSXMgYSBjb21taXR0ZWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Rlc2lnbmF0ZXMgd2hldGhlciB0aGlzIHVzZXIgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBjb21taXR0ZWUuJylcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV4cHJlc3Npb246ICchbW9kZWwubW9yZSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnYWJvdXRfbWUnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZWRpdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdBYm91dCBtZScpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBja2VkaXRvck9wdGlvbnM6IEVkaXRvci5nZXRPcHRpb25zKGltYWdlcylcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV4cHJlc3Npb246ICchbW9kZWwubW9yZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnVXNlclByb2ZpbGVGb3JtJywgW1xuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0VkaXRvcicsXG4gICAgJ01lZGlhZmlsZScsXG4gICAgZnVuY3Rpb24gKGdldHRleHRDYXRhbG9nLCBFZGl0b3IsIE1lZGlhZmlsZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gbmdEaWFsb2cgZm9yIHVzZXIgZm9ybVxuICAgICAgICAgICAgZ2V0RGlhbG9nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICdzdGF0aWMvdGVtcGxhdGVzL3VzZXJzL3Byb2ZpbGUtcGFzc3dvcmQtZm9ybS5odG1sJyxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ1VzZXJQcm9maWxlQ3RybCcsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ25nZGlhbG9nLXRoZW1lLWRlZmF1bHQgd2lkZS1mb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VCeUVzY2FwZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlEb2N1bWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBhbmd1bGFyLWZvcm1seSBmaWVsZHMgZm9yIHVzZXIgZm9ybVxuICAgICAgICAgICAgZ2V0Rm9ybUZpZWxkczogZnVuY3Rpb24gKGhpZGVPbkNyZWF0ZUZvcm0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VzID0gTWVkaWFmaWxlLmdldEFsbEltYWdlcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICd1c2VybmFtZScsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnVXNlcm5hbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2VtYWlsJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdFbWFpbCcpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2Fib3V0X21lJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VkaXRvcicsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQWJvdXQgbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2tlZGl0b3JPcHRpb25zOiBFZGl0b3IuZ2V0T3B0aW9ucyhpbWFnZXMpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmZhY3RvcnkoJ1VzZXJQYXNzd29yZEZvcm0nLCBbXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICBmdW5jdGlvbiAoZ2V0dGV4dENhdGFsb2cpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIG5nRGlhbG9nIGZvciB1c2VyIGZvcm1cbiAgICAgICAgICAgIGdldERpYWxvZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnc3RhdGljL3RlbXBsYXRlcy91c2Vycy9wcm9maWxlLXBhc3N3b3JkLWZvcm0uaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdVc2VyUGFzc3dvcmRDdHJsJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmdkaWFsb2ctdGhlbWUtZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnlFc2NhcGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUJ5RG9jdW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gYW5ndWxhci1mb3JtbHkgZmllbGRzIGZvciB1c2VyIGZvcm1cbiAgICAgICAgICAgIGdldEZvcm1GaWVsZHM6IGZ1bmN0aW9uIChoaWRlT25DcmVhdGVGb3JtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ29sZFBhc3N3b3JkJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bhc3N3b3JkJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdPbGQgcGFzc3dvcmQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ25ld1Bhc3N3b3JkJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bhc3N3b3JkJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdOZXcgcGFzc3dvcmQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ25ld1Bhc3N3b3JkMicsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwYXNzd29yZCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnQ29uZmlybSBuZXcgcGFzc3dvcmQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdVc2VyTGlzdEN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRodHRwJyxcbiAgICAnbmdEaWFsb2cnLFxuICAgICdVc2VyRm9ybScsXG4gICAgJ1VzZXInLFxuICAgICdHcm91cCcsXG4gICAgJ1Bhc3N3b3JkR2VuZXJhdG9yJyxcbiAgICAnUHJvamVjdG9yJyxcbiAgICAnUHJvamVjdGlvbkRlZmF1bHQnLFxuICAgICdDb25maWcnLFxuICAgICdVc2VyQ3N2RXhwb3J0JyxcbiAgICAnb3NUYWJsZUZpbHRlcicsXG4gICAgJ29zVGFibGVTb3J0JyxcbiAgICAnb3NUYWJsZVBhZ2luYXRpb24nLFxuICAgICdnZXR0ZXh0JyxcbiAgICAnVXNlclBkZkV4cG9ydCcsXG4gICAgJ0ludml0YXRpb25FbWFpbHMnLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgJGh0dHAsIG5nRGlhbG9nLCBVc2VyRm9ybSwgVXNlciwgR3JvdXAsIFBhc3N3b3JkR2VuZXJhdG9yLFxuICAgICAgICBQcm9qZWN0b3IsIFByb2plY3Rpb25EZWZhdWx0LCBDb25maWcsIFVzZXJDc3ZFeHBvcnQsIG9zVGFibGVGaWx0ZXIsIG9zVGFibGVTb3J0LFxuICAgICAgICBvc1RhYmxlUGFnaW5hdGlvbiwgZ2V0dGV4dCwgVXNlclBkZkV4cG9ydCwgSW52aXRhdGlvbkVtYWlscywgRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFVzZXIubGFzdE1vZGlmaWVkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS51c2VycyA9IF8ub3JkZXJCeShVc2VyLmdldEFsbCgpLCBbJ2ZpcnN0X25hbWUnXSk7XG4gICAgICAgICAgICBfLmZvckVhY2goJHNjb3BlLnVzZXJzLCBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgICAgIHVzZXIuaGFzX2xhc3RfZW1haWxfc2VuZCA9ICEhdXNlci5sYXN0X2VtYWlsX3NlbmQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICgkc2NvcGUudXBkYXRlVXNlcnMpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUudXBkYXRlVXNlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIEdyb3VwLmJpbmRBbGwoe3doZXJlOiB7aWQ6IHsnPic6IDF9fX0sICRzY29wZSwgJ2dyb3VwcycpO1xuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9qZWN0b3IubGFzdE1vZGlmaWVkKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwcm9qZWN0aW9uZGVmYXVsdCA9IFByb2plY3Rpb25EZWZhdWx0LmZpbHRlcih7bmFtZTogJ3VzZXJzJ30pWzBdO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rpb25kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlZmF1bHRQcm9qZWN0b3JJZCA9IHByb2plY3Rpb25kZWZhdWx0LnByb2plY3Rvcl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS5hbGVydCA9IHt9O1xuXG4gICAgICAgIC8vIEZpbHRlcmluZ1xuICAgICAgICAkc2NvcGUuZmlsdGVyID0gb3NUYWJsZUZpbHRlci5jcmVhdGVJbnN0YW5jZSgnVXNlclRhYmxlRmlsdGVyJyk7XG5cbiAgICAgICAgaWYgKCEkc2NvcGUuZmlsdGVyLmV4aXN0c1N0b3JhZ2VFbnRyeSgpKSB7XG4gICAgICAgICAgICAkc2NvcGUuZmlsdGVyLm11bHRpc2VsZWN0RmlsdGVycyA9IHtcbiAgICAgICAgICAgICAgICBncm91cDogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgJHNjb3BlLmZpbHRlci5ib29sZWFuRmlsdGVycyA9IHtcbiAgICAgICAgICAgICAgICBpc1ByZXNlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IGdldHRleHQoJ1ByZXNlbnQnKSxcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlWWVzOiBnZXR0ZXh0KCdJcyBwcmVzZW50JyksXG4gICAgICAgICAgICAgICAgICAgIGNob2ljZU5vOiBnZXR0ZXh0KCdJcyBub3QgcHJlc2VudCcpLFxuICAgICAgICAgICAgICAgICAgICBuZWVkRXh0cmFQZXJtaXNzaW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNBY3RpdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IGdldHRleHQoJ0FjdGl2ZScpLFxuICAgICAgICAgICAgICAgICAgICBjaG9pY2VZZXM6IGdldHRleHQoJ0lzIGFjdGl2ZScpLFxuICAgICAgICAgICAgICAgICAgICBjaG9pY2VObzogZ2V0dGV4dCgnSXMgbm90IGFjdGl2ZScpLFxuICAgICAgICAgICAgICAgICAgICBuZWVkRXh0cmFQZXJtaXNzaW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNDb21taXR0ZWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IGdldHRleHQoJ0NvbW1pdHRlZScpLFxuICAgICAgICAgICAgICAgICAgICBjaG9pY2VZZXM6IGdldHRleHQoJ0lzIGEgY29tbWl0dGVlJyksXG4gICAgICAgICAgICAgICAgICAgIGNob2ljZU5vOiBnZXR0ZXh0KCdJcyBub3QgYSBjb21taXR0ZWUnKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhc0xhc3RFbWFpbFNlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IGdldHRleHQoJ0xhc3QgZW1haWwgc2VuZCcpLFxuICAgICAgICAgICAgICAgICAgICBjaG9pY2VZZXM6IGdldHRleHQoJ0dvdCBhbiBlbWFpbCcpLFxuICAgICAgICAgICAgICAgICAgICBjaG9pY2VObzogZ2V0dGV4dChcIkRpZG4ndCBnZXQgYW4gZW1haWxcIiksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgJHNjb3BlLmZpbHRlci5wcm9wZXJ0eUxpc3QgPSBbJ2ZpcnN0X25hbWUnLCAnbGFzdF9uYW1lJywgJ3VzZXJuYW1lJywgJ3RpdGxlJyxcbiAgICAgICAgICAgICdudW1iZXInLCAnY29tbWVudCcsICdzdHJ1Y3R1cmVfbGV2ZWwnXTtcbiAgICAgICAgJHNjb3BlLmZpbHRlci5wcm9wZXJ0eURpY3QgPSB7XG4gICAgICAgICAgICAnZ3JvdXBzX2lkJyA6IGZ1bmN0aW9uIChncm91cF9pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBHcm91cC5nZXQoZ3JvdXBfaWQpLm5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuZ2V0SXRlbUlkID0ge1xuICAgICAgICAgICAgZ3JvdXA6IGZ1bmN0aW9uICh1c2VyKSB7cmV0dXJuIHVzZXIuZ3JvdXBzX2lkO30sXG4gICAgICAgIH07XG4gICAgICAgIC8vIFNvcnRpbmdcbiAgICAgICAgJHNjb3BlLnNvcnQgPSBvc1RhYmxlU29ydC5jcmVhdGVJbnN0YW5jZSgnVXNlclRhYmxlU29ydCcpO1xuICAgICAgICBpZiAoISRzY29wZS5zb3J0LmNvbHVtbikge1xuICAgICAgICAgICAgJHNjb3BlLnNvcnQuY29sdW1uID0gJHNjb3BlLmNvbmZpZygndXNlcnNfc29ydF9ieScpO1xuICAgICAgICB9XG4gICAgICAgICRzY29wZS5zb3J0T3B0aW9ucyA9IFtcbiAgICAgICAgICAgIHtuYW1lOiAnZmlyc3RfbmFtZScsXG4gICAgICAgICAgICAgZGlzcGxheV9uYW1lOiBnZXR0ZXh0KCdHaXZlbiBuYW1lJyl9LFxuICAgICAgICAgICAge25hbWU6ICdsYXN0X25hbWUnLFxuICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogZ2V0dGV4dCgnU3VybmFtZScpfSxcbiAgICAgICAgICAgIHtuYW1lOiAnaXNfcHJlc2VudCcsXG4gICAgICAgICAgICAgZGlzcGxheV9uYW1lOiBnZXR0ZXh0KCdQcmVzZW50Jyl9LFxuICAgICAgICAgICAge25hbWU6ICdpc19hY3RpdmUnLFxuICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogZ2V0dGV4dCgnQWN0aXZlJyl9LFxuICAgICAgICAgICAge25hbWU6ICdpc19jb21taXR0ZWUnLFxuICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogZ2V0dGV4dCgnQ29tbWl0dGVlJyl9LFxuICAgICAgICAgICAge25hbWU6ICdudW1iZXInLFxuICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogZ2V0dGV4dCgnTnVtYmVyJyl9LFxuICAgICAgICAgICAge25hbWU6ICdzdHJ1Y3R1cmVfbGV2ZWwnLFxuICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogZ2V0dGV4dCgnU3RydWN0dXJlIGxldmVsJyl9LFxuICAgICAgICAgICAge25hbWU6ICdjb21tZW50JyxcbiAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGdldHRleHQoJ0NvbW1lbnQnKX0sXG4gICAgICAgICAgICB7bmFtZTogJ2xhc3RfZW1haWxfc2VuZCcsXG4gICAgICAgICAgICAgZGlzcGxheV9uYW1lOiBnZXR0ZXh0KCdMYXN0IGVtYWlsIHNlbmQnKX0sXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gcGFnaW5hdGlvblxuICAgICAgICAkc2NvcGUucGFnaW5hdGlvbiA9IG9zVGFibGVQYWdpbmF0aW9uLmNyZWF0ZUluc3RhbmNlKCdVc2VyVGFibGVQYWdpbmF0aW9uJyk7XG5cbiAgICAgICAgLy8gVG9nZ2xlIGdyb3VwIGZyb20gdXNlclxuICAgICAgICAkc2NvcGUudG9nZ2xlR3JvdXAgPSBmdW5jdGlvbiAodXNlciwgZ3JvdXApIHtcbiAgICAgICAgICAgIGlmIChfLmluZGV4T2YodXNlci5ncm91cHNfaWQsIGdyb3VwLmlkKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdXNlci5ncm91cHNfaWQgPSBfLmZpbHRlcih1c2VyLmdyb3Vwc19pZCwgZnVuY3Rpb24gKGdyb3VwX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBncm91cF9pZCAhPSBncm91cC5pZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXNlci5ncm91cHNfaWQucHVzaChncm91cC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUuc2F2ZSh1c2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gb3BlbiBuZXcvZWRpdCBkaWFsb2dcbiAgICAgICAgJHNjb3BlLm9wZW5EaWFsb2cgPSBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgbmdEaWFsb2cub3BlbihVc2VyRm9ybS5nZXREaWFsb2codXNlcikpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBzYXZlIGNoYW5nZWQgdXNlclxuICAgICAgICAkc2NvcGUuc2F2ZSA9IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgICAgICBVc2VyLnNhdmUodXNlcikudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdXNlci5xdWlja0VkaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0LnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yKXtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZGVsZXRlIHNpbmdsZSB1c2VyXG4gICAgICAgICRzY29wZS5kZWxldGUgPSBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgVXNlci5kZXN0cm95KHVzZXIuaWQpO1xuICAgICAgICB9O1xuICAgICAgICAvLyAqKiogc2VsZWN0IG1vZGUgZnVuY3Rpb25zICoqKlxuICAgICAgICAkc2NvcGUuaXNTZWxlY3RNb2RlID0gZmFsc2U7XG4gICAgICAgIC8vIGNoZWNrIGFsbCBjaGVja2JveGVzXG4gICAgICAgICRzY29wZS5jaGVja0FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5zZWxlY3RlZEFsbCA9ICEkc2NvcGUuc2VsZWN0ZWRBbGw7XG4gICAgICAgICAgICBfLmZvckVhY2goJHNjb3BlLnVzZXJzRmlsdGVyZWQsIGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgdXNlci5zZWxlY3RlZCA9ICRzY29wZS5zZWxlY3RlZEFsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyB1bmNoZWNrIGFsbCBjaGVja2JveGVzIGlmIGlzU2VsZWN0TW9kZSBpcyBjbG9zZWRcbiAgICAgICAgJHNjb3BlLnVuY2hlY2tBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISRzY29wZS5pc1NlbGVjdE1vZGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc2VsZWN0ZWRBbGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlLnVzZXJzLCBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgICAgICAgICB1c2VyLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZWxlY3RNb2RlQWN0aW9uID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS51c2Vyc0ZpbHRlcmVkLCBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgICAgIGlmICh1c2VyLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZSh1c2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzY29wZS5pc1NlbGVjdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICRzY29wZS51bmNoZWNrQWxsKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRlbGV0ZSBhbGwgc2VsZWN0ZWQgdXNlcnNcbiAgICAgICAgJHNjb3BlLmRlbGV0ZU11bHRpcGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZWN0TW9kZUFjdGlvbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgICAgICRzY29wZS5kZWxldGUodXNlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYWRkIGdyb3VwIGZvciBzZWxlY3RlZCB1c2Vyc1xuICAgICAgICAkc2NvcGUuYWRkR3JvdXBNdWx0aXBsZSA9IGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0TW9kZUFjdGlvbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgICAgICAgICB1c2VyLmdyb3Vwc19pZC5wdXNoKGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgVXNlci5zYXZlKHVzZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyByZW1vdmUgZ3JvdXAgZm9yIHNlbGVjdGVkIHVzZXJzXG4gICAgICAgICRzY29wZS5yZW1vdmVHcm91cE11bHRpcGxlID0gZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RNb2RlQWN0aW9uKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cEluZGV4ID0gXy5pbmRleE9mKHVzZXIuZ3JvdXBzX2lkLCBwYXJzZUludChncm91cCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmdyb3Vwc19pZC5zcGxpY2UoZ3JvdXBJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBVc2VyLnNhdmUodXNlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZ2VuZXJhdGUgbmV3IHBhc3N3b3Jkc1xuICAgICAgICAkc2NvcGUuZ2VuZXJhdGVOZXdQYXNzd29yZHNNdWx0aXBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGVjdE1vZGVBY3Rpb24oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UGFzc3dvcmQgPSBQYXNzd29yZEdlbmVyYXRvci5nZW5lcmF0ZSgpO1xuICAgICAgICAgICAgICAgIHVzZXIuZGVmYXVsdF9wYXNzd29yZCA9IG5ld1Bhc3N3b3JkO1xuICAgICAgICAgICAgICAgIFVzZXIuc2F2ZSh1c2VyKTtcbiAgICAgICAgICAgICAgICAkaHR0cC5wb3N0KFxuICAgICAgICAgICAgICAgICAgICAnL3Jlc3QvdXNlcnMvdXNlci8nICsgdXNlci5pZCArICcvcmVzZXRfcGFzc3dvcmQvJyxcbiAgICAgICAgICAgICAgICAgICAgeydwYXNzd29yZCc6IG5ld1Bhc3N3b3JkfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2V0IGJvb2xlYW4gcHJvcGVydGllcyAoaXNfYWN0aXZlLCBpc19wcmVzZW50LCBpc19jb21taXR0ZWUpXG4gICAgICAgICRzY29wZS5zZXRCb29sUHJvcGVydHlNdWx0aXBsZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHNlbGVjdE1vZGVBY3Rpb24oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgICAgICB1c2VyW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIFVzZXIuc2F2ZSh1c2VyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBTZW5kIGludml0YXRpb24gZW1haWxzXG4gICAgICAgICRzY29wZS5zZW5kSW52aXRhdGlvbkVtYWlscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEludml0YXRpb25FbWFpbHMuc2VuZCgkc2NvcGUudXNlcnNGaWx0ZXJlZCkudGhlbihmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IHN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmlzU2VsZWN0TW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICRzY29wZS51bmNoZWNrQWxsKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgICAgICRzY29wZS5pc1NlbGVjdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAkc2NvcGUudW5jaGVja0FsbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRXhwb3J0IGFzIFBERlxuICAgICAgICAkc2NvcGUucGRmRXhwb3J0VXNlckxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBVc2VyUGRmRXhwb3J0LmV4cG9ydFVzZXJMaXN0KCRzY29wZS51c2Vyc0ZpbHRlcmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLnBkZkV4cG9ydFVzZXJBY2Nlc3NEYXRhTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFVzZXJQZGZFeHBvcnQuZXhwb3J0VXNlckFjY2Vzc0RhdGFMaXN0KCRzY29wZS51c2Vyc0ZpbHRlcmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRXhwb3J0IGFzIGEgY3N2IGZpbGVcbiAgICAgICAgJHNjb3BlLmNzdkV4cG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFVzZXJDc3ZFeHBvcnQuZXhwb3J0KCRzY29wZS51c2Vyc0ZpbHRlcmVkKTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnSW52aXRhdGlvbkVtYWlscycsIFtcbiAgICAnJGh0dHAnLFxuICAgICdVc2VyJyxcbiAgICAnQ29uZmlnJyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgIGZ1bmN0aW9uICgkaHR0cCwgVXNlciwgQ29uZmlnLCBnZXR0ZXh0Q2F0YWxvZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gUmV0dXJucyB0aGUgcmVxdWVzdCBwcm9taXNlLiBJZiBpdCB3YXMgc3VjY2Vzc2Z1bGwsIGEgbmljZSBtZXNzYWdlIGZvclxuICAgICAgICAgICAgLy8gYW4gYWxlcnQgaXMgZ2VuZXJhdGVkIGFuZCB0aGUgYWxlcnQtb2JqZWN0IGlzIHJldHVybmVkLlxuICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24gKHVzZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVzZXJfaWRzID0gX1xuICAgICAgICAgICAgICAgICAgICAuY2hhaW4odXNlcnMpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VyLnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlci5pZDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHN1YmplY3QgPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoQ29uZmlnLmdldCgndXNlcnNfZW1haWxfc3ViamVjdCcpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZyhDb25maWcuZ2V0KCd1c2Vyc19lbWFpbF9ib2R5JykudmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICRodHRwLnBvc3QoJy9yZXN0L3VzZXJzL3VzZXIvbWFzc19pbnZpdGVfZW1haWwvJywge1xuICAgICAgICAgICAgICAgICAgICB1c2VyX2lkczogdXNlcl9pZHMsXG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3Q6IHN1YmplY3QsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRW1haWxzID0gc3VjY2Vzcy5kYXRhLmNvdW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9FbWFpbElkcyA9IHN1Y2Nlc3MuZGF0YS5ub19lbWFpbF9pZHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gJ3N1Y2Nlc3MnLCBtc2c7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1FbWFpbHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnZGFuZ2VyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnTm8gZW1haWxzIHdlcmUgc2VuZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW1FbWFpbHMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnT25lIGVtYWlsIHdhcyBzZW5kIHN1Y2Vzc2Z1bGx5LicpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCclbnVtJSBlbWFpbHMgd2VyZSBzZW5kIHN1Y2Vzc2Z1bGx5LicpLnJlcGxhY2UoJyVudW0lJywgbnVtRW1haWxzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub0VtYWlsSWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICd3YXJuaW5nJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyArPSAnICc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub0VtYWlsSWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZyArPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1RoZSB1c2VyICV1c2VyJSBoYXMgbm8gZW1haWwsIHNvIHRoZSBpbnZpdGF0aW9uIGVtYWlsIGNvdWxkIG5vdCBiZSBzZW5kLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cgKz0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdUaGUgdXNlcnMgJXVzZXIlIGhhdmUgbm8gZW1haWwsIHNvIHRoZSBpbnZpdGF0aW9uIGVtYWlscyBjb3VsZCBub3QgYmUgc2VuZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBvbmUgYnVpbGRzIGEgdXNlcm5hbWUgc3RyaW5nIGxpa2UgXCJ1c2VyMSwgdXNlcjIgYW5kIHVzZXIzXCIgd2l0aCB0aGUgZnVsbCBuYW1lcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0VXNlcm5hbWUsIHVzZXJTdHJpbmcgPSBfXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNoYWluKG5vRW1haWxJZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXIgPSBVc2VyLmdldChpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VyID8gdXNlci5nZXRfZnVsbF9uYW1lKCkgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VybmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50YXAoZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RVc2VybmFtZSA9IG5hbWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aHJ1KGZ1bmN0aW9uIChuYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdFVzZXJuYW1lID8gbmFtZXMgKyAnICcgKyBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ2FuZCcpICsgJyAnICsgbGFzdFVzZXJuYW1lIDogbmFtZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKCcldXNlciUnLCB1c2VyU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2c6IG1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignVXNlckRldGFpbEN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ25nRGlhbG9nJyxcbiAgICAnVXNlckZvcm0nLFxuICAgICdVc2VyJyxcbiAgICAndXNlcklkJyxcbiAgICAnR3JvdXAnLFxuICAgICdQcm9qZWN0b3InLFxuICAgICdQcm9qZWN0aW9uRGVmYXVsdCcsXG4gICAgJ2dldHRleHRDYXRhbG9nJyxcbiAgICAnV2VicGFnZVRpdGxlJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsIG5nRGlhbG9nLCBVc2VyRm9ybSwgVXNlciwgdXNlcklkLCBHcm91cCwgUHJvamVjdG9yLCBQcm9qZWN0aW9uRGVmYXVsdCwgZ2V0dGV4dENhdGFsb2csXG4gICAgICAgIFdlYnBhZ2VUaXRsZSkge1xuICAgICAgICBHcm91cC5iaW5kQWxsKHt3aGVyZToge2lkOiB7Jz4nOiAxfX19LCAkc2NvcGUsICdncm91cHMnKTtcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gVXNlci5sYXN0TW9kaWZpZWQodXNlcklkKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLnVzZXIgPSBVc2VyLmdldCh1c2VySWQpO1xuICAgICAgICAgICAgV2VicGFnZVRpdGxlLnVwZGF0ZVRpdGxlKGdldHRleHRDYXRhbG9nLmdldFN0cmluZygnUGFydGljaXBhbnQnKSArICcgJyArICRzY29wZS51c2VyLmdldF9zaG9ydF9uYW1lKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvamVjdG9yLmxhc3RNb2RpZmllZCgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJvamVjdGlvbmRlZmF1bHQgPSBQcm9qZWN0aW9uRGVmYXVsdC5maWx0ZXIoe25hbWU6ICd1c2Vycyd9KVswXTtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0aW9uZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5kZWZhdWx0UHJvamVjdG9ySWQgPSBwcm9qZWN0aW9uZGVmYXVsdC5wcm9qZWN0b3JfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG9wZW4gZWRpdCBkaWFsb2dcbiAgICAgICAgJHNjb3BlLm9wZW5EaWFsb2cgPSBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgbmdEaWFsb2cub3BlbihVc2VyRm9ybS5nZXREaWFsb2codXNlcikpO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdVc2VyQ3JlYXRlQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJHN0YXRlJyxcbiAgICAnVXNlcicsXG4gICAgJ1VzZXJGb3JtJyxcbiAgICAnRXJyb3JNZXNzYWdlJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSwgVXNlciwgVXNlckZvcm0sIEVycm9yTWVzc2FnZSkge1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcbiAgICAgICAgLy8gZ2V0IGFsbCBmb3JtIGZpZWxkc1xuICAgICAgICAkc2NvcGUuZm9ybUZpZWxkcyA9IFVzZXJGb3JtLmdldEZvcm1GaWVsZHModHJ1ZSk7XG5cbiAgICAgICAgLy8gc2F2ZSB1c2VyXG4gICAgICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgIGlmICghdXNlci5ncm91cHNfaWQpIHtcbiAgICAgICAgICAgICAgICB1c2VyLmdyb3Vwc19pZCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVXNlci5jcmVhdGUodXNlcikudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VUaGlzRGlhbG9nKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdVc2VyVXBkYXRlQ3RybCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnJHN0YXRlJyxcbiAgICAnVXNlcicsXG4gICAgJ1VzZXJGb3JtJyxcbiAgICAndXNlcklkJyxcbiAgICAnRXJyb3JNZXNzYWdlJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSwgVXNlciwgVXNlckZvcm0sIHVzZXJJZCwgRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICRzY29wZS5hbGVydCA9IHt9O1xuICAgICAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZXMgZm9yIGZvcm0gbW9kZWwgYnkgY3JlYXRlIGRlZXAgY29weSBvZiB1c2VyIG9iamVjdFxuICAgICAgICAvLyBzbyBsaXN0L2RldGFpbCB2aWV3IGlzIG5vdCB1cGRhdGVkIHdoaWxlIGVkaXRpbmdcbiAgICAgICAgJHNjb3BlLm1vZGVsID0gYW5ndWxhci5jb3B5KFVzZXIuZ2V0KHVzZXJJZCkpO1xuXG4gICAgICAgIC8vIGdldCBhbGwgZm9ybSBmaWVsZHNcbiAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHMgPSBVc2VyRm9ybS5nZXRGb3JtRmllbGRzKCk7XG5cbiAgICAgICAgLy8gc2F2ZSB1c2VyXG4gICAgICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgIGlmICghdXNlci5ncm91cHNfaWQpIHtcbiAgICAgICAgICAgICAgICB1c2VyLmdyb3Vwc19pZCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW5qZWN0IHRoZSBjaGFuZ2VkIHVzZXIgKGNvcHkpIG9iamVjdCBiYWNrIGludG8gRFMgc3RvcmVcbiAgICAgICAgICAgIFVzZXIuaW5qZWN0KHVzZXIpO1xuICAgICAgICAgICAgLy8gc2F2ZSBjaGFuZ2UgdXNlciBvYmplY3Qgb24gc2VydmVyXG4gICAgICAgICAgICBVc2VyLnNhdmUodXNlcikudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VUaGlzRGlhbG9nKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBlcnJvcjogcmV2ZXJ0IGFsbCBjaGFuZ2VzIGJ5IHJlc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gKHJlZnJlc2gpIG9yaWdpbmFsIHVzZXIgb2JqZWN0IGZyb20gc2VydmVyXG4gICAgICAgICAgICAgICAgICAgIFVzZXIucmVmcmVzaCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdVc2VyUHJvZmlsZUN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ0VkaXRvcicsXG4gICAgJ1VzZXInLFxuICAgICdvcGVyYXRvcicsXG4gICAgJ1VzZXJQcm9maWxlRm9ybScsXG4gICAgJ2dldHRleHQnLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgRWRpdG9yLCBVc2VyLCBvcGVyYXRvciwgVXNlclByb2ZpbGVGb3JtLCBnZXR0ZXh0LCBFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgJHNjb3BlLm1vZGVsID0gYW5ndWxhci5jb3B5KG9wZXJhdG9yLnVzZXIpO1xuICAgICAgICAkc2NvcGUudGl0bGUgPSBnZXR0ZXh0KCdFZGl0IHByb2ZpbGUnKTtcbiAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHMgPSBVc2VyUHJvZmlsZUZvcm0uZ2V0Rm9ybUZpZWxkcygpO1xuICAgICAgICAkc2NvcGUuc2F2ZSA9IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgICAgICBVc2VyLmluamVjdCh1c2VyKTtcbiAgICAgICAgICAgIFVzZXIuc2F2ZSh1c2VyKS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlVGhpc0RpYWxvZygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBlcnJvcjogcmV2ZXJ0IGFsbCBjaGFuZ2VzIGJ5IHJlc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gKHJlZnJlc2gpIG9yaWdpbmFsIHVzZXIgb2JqZWN0IGZyb20gc2VydmVyXG4gICAgICAgICAgICAgICAgICAgIFVzZXIucmVmcmVzaCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdVc2VyQ2hhbmdlUGFzc3dvcmRDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckc3RhdGUnLFxuICAgICckaHR0cCcsXG4gICAgJ1VzZXInLFxuICAgICd1c2VySWQnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ1Bhc3N3b3JkR2VuZXJhdG9yJyxcbiAgICAnRXJyb3JNZXNzYWdlJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSwgJGh0dHAsIFVzZXIsIHVzZXJJZCwgZ2V0dGV4dENhdGFsb2csIFBhc3N3b3JkR2VuZXJhdG9yLCBFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgVXNlci5iaW5kT25lKHVzZXJJZCwgJHNjb3BlLCAndXNlcicpO1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcbiAgICAgICAgJHNjb3BlLmdlbmVyYXRlUGFzc3dvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUubmV3X3Bhc3N3b3JkID0gUGFzc3dvcmRHZW5lcmF0b3IuZ2VuZXJhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgaWYgKCRzY29wZS5uZXdfcGFzc3dvcmQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgJGh0dHAucG9zdChcbiAgICAgICAgICAgICAgICAgICAgJy9yZXN0L3VzZXJzL3VzZXIvJyArIHVzZXIuaWQgKyAnL3Jlc2V0X3Bhc3N3b3JkLycsXG4gICAgICAgICAgICAgICAgICAgIHsncGFzc3dvcmQnOiAkc2NvcGUubmV3X3Bhc3N3b3JkfVxuICAgICAgICAgICAgICAgICkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IHt0eXBlOiAnc3VjY2VzcycsIG1zZzogc3VjY2Vzcy5kYXRhLmRldGFpbCwgc2hvdzogdHJ1ZX07XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubmV3X3Bhc3N3b3JkID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmRpcmVjdGl2ZShcInNob3dQYXNzd29yZFwiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGlua0ZuKHNjb3BlLCBlbGVtLCBhdHRycykge1xuICAgICAgICBzY29wZS4kd2F0Y2goYXR0cnMuc2hvd1Bhc3N3b3JkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5hdHRyKFwidHlwZVwiLCBcInRleHRcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW0uYXR0cihcInR5cGVcIiwgXCJwYXNzd29yZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn0pXG5cbi5jb250cm9sbGVyKCdVc2VyUGFzc3dvcmRDdHJsJywgW1xuICAgICckc2NvcGUnLFxuICAgICckc3RhdGUnLFxuICAgICckaHR0cCcsXG4gICAgJ2dldHRleHQnLFxuICAgICdVc2VyUGFzc3dvcmRGb3JtJyxcbiAgICAnRXJyb3JNZXNzYWdlJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZSwgJGh0dHAsIGdldHRleHQsIFVzZXJQYXNzd29yZEZvcm0sIEVycm9yTWVzc2FnZSkge1xuICAgICAgICAkc2NvcGUudGl0bGUgPSAnQ2hhbmdlIHBhc3N3b3JkJztcbiAgICAgICAgJHNjb3BlLmFsZXJ0ID0ge307XG4gICAgICAgICRzY29wZS5tb2RlbCA9IHt9O1xuICAgICAgICAkc2NvcGUuZm9ybUZpZWxkcyA9IFVzZXJQYXNzd29yZEZvcm0uZ2V0Rm9ybUZpZWxkcygpO1xuICAgICAgICAkc2NvcGUuc2F2ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5uZXdQYXNzd29yZCAhPSBkYXRhLm5ld1Bhc3N3b3JkMikge1xuICAgICAgICAgICAgICAgIGRhdGEubmV3UGFzc3dvcmQgPSBkYXRhLm5ld1Bhc3N3b3JkMiA9ICcnO1xuICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RhbmdlcicsXG4gICAgICAgICAgICAgICAgICAgIG1zZzogZ2V0dGV4dCgnUGFzc3dvcmQgY29uZmlybWF0aW9uIGRvZXMgbm90IG1hdGNoLicpLFxuICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRodHRwLnBvc3QoXG4gICAgICAgICAgICAgICAgICAgICcvdXNlcnMvc2V0cGFzc3dvcmQvJyxcbiAgICAgICAgICAgICAgICAgICAgeydvbGRfcGFzc3dvcmQnOiBkYXRhLm9sZFBhc3N3b3JkLCAnbmV3X3Bhc3N3b3JkJzogZGF0YS5uZXdQYXNzd29yZH1cbiAgICAgICAgICAgICAgICApLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VUaGlzRGlhbG9nKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3IsIGUuIGcuIHdyb25nIG9sZCBwYXNzd29yZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5tb2RlbCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFsZXJ0ID0gRXJyb3JNZXNzYWdlLmZvckFsZXJ0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ1VzZXJQcmVzZW5jZUN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ1VzZXInLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0Vycm9yTWVzc2FnZScsXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgVXNlciwgZ2V0dGV4dENhdGFsb2csIEVycm9yTWVzc2FnZSkge1xuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcbiAgICAgICAgJCgnI3VzZXJOdW1iZXInKS5mb2N1cygpO1xuXG4gICAgICAgICRzY29wZS5jaGFuZ2VTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghJHNjb3BlLm51bWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbnRlcmVkTnVtYmVyID0gJHNjb3BlLm51bWJlci50cmltKCk7XG4gICAgICAgICAgICB2YXIgdXNlciA9IF8uZmluZChVc2VyLmdldEFsbCgpLCBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VyLm51bWJlciA9PT0gZW50ZXJlZE51bWJlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAgICAgICB1c2VyLmlzX3ByZXNlbnQgPSAhdXNlci5pc19wcmVzZW50O1xuICAgICAgICAgICAgICAgIFVzZXIuc2F2ZSh1c2VyKS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlVGV4dCA9IHVzZXIuZnVsbF9uYW1lICsgJyAnICsgZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdpcyBub3cnKSArICcgJztcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVRleHQgKz0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKHVzZXIuaXNfcHJlc2VudCA/ICdwcmVzZW50JyA6ICdub3QgcHJlc2VudCcpICsgJy4nO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2c6IG1lc3NhZ2VUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm51bWJlciA9ICcnO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZzogZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKCdDYW5ub3QgZmluZCB0aGUgcGFydGljaXBhbnQgd2l0aCB0aGUgcGFydGljaXBhbnQgbnVtYmVyJykgKyAnIFwiJyArIGVudGVyZWROdW1iZXIgKyAnXCIuJyxcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RhbmdlcicsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQoJyN1c2VyTnVtYmVyJykuZm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignVXNlckltcG9ydEN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRodHRwJyxcbiAgICAnJHEnLFxuICAgICdnZXR0ZXh0JyxcbiAgICAnZ2V0dGV4dENhdGFsb2cnLFxuICAgICdVc2VyJyxcbiAgICAnR3JvdXAnLFxuICAgICdVc2VyQ3N2RXhwb3J0JyxcbiAgICAnb3NUYWJsZVBhZ2luYXRpb24nLFxuICAgICdFcnJvck1lc3NhZ2UnLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgJGh0dHAsICRxLCBnZXR0ZXh0LCBnZXR0ZXh0Q2F0YWxvZywgVXNlciwgR3JvdXAsIFVzZXJDc3ZFeHBvcnQsXG4gICAgICAgIG9zVGFibGVQYWdpbmF0aW9uLCBFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgLy8gaW1wb3J0IGZyb20gdGV4dGFyZWFcbiAgICAgICAgJHNjb3BlLmltcG9ydEJ5TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VybmFtZXMgPSAkc2NvcGUudXNlcmxpc3RbMF0uc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICB2YXIgdXNlcnMgPSBfLm1hcCh1c2VybmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgZWFjaCBmdWxsIG5hbWUgaW4gZmlyc3QgYW5kIGxhc3QgbmFtZS5cbiAgICAgICAgICAgICAgICAvLyBUaGUgbGFzdCB3b3JkIGlzIHNldCBhcyBsYXN0IG5hbWUsIHJlc3QgaXMgdGhlIGZpcnN0IG5hbWUocykuXG4gICAgICAgICAgICAgICAgLy8gKGUuZy46IFwiTWF4IE1hcnRpbiBNdXN0ZXJtYW5uXCIgLT4gbGFzdF9uYW1lID0gXCJNdXN0ZXJtYW5uXCIpXG4gICAgICAgICAgICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RfbmFtZSA9IG5hbWVzLnNsaWNlKC0xKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RfbmFtZSA9IG5hbWVzLnNsaWNlKDAsIC0xKS5qb2luKFwiIFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdF9uYW1lOiBmaXJzdF9uYW1lLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X25hbWU6IGxhc3RfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzX2lkOiBbXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkaHR0cC5wb3N0KCcvcmVzdC91c2Vycy91c2VyL21hc3NfaW1wb3J0LycsIHtcbiAgICAgICAgICAgICAgICB1c2VyczogdXNlcnNcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgbXNnOiBzdWNjZXNzLmRhdGEuZGV0YWlsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcGFnaW5hdGlvblxuICAgICAgICAkc2NvcGUucGFnaW5hdGlvbiA9IG9zVGFibGVQYWdpbmF0aW9uLmNyZWF0ZUluc3RhbmNlKCdVc2VySW1wb3J0VGFibGVQYWdpbmF0aW9uJywgMTAwKTtcblxuICAgICAgICAvLyBEdXBsaWNhdGVzXG4gICAgICAgICRzY29wZS5kdXBsaWNhdGVBY3Rpb25zID0gW1xuICAgICAgICAgICAgZ2V0dGV4dCgna2VlcCBvcmlnaW5hbCcpLFxuICAgICAgICAgICAgZ2V0dGV4dCgnb3ZlcnJpZGUgbmV3JyksXG4gICAgICAgICAgICBnZXR0ZXh0KCdjcmVhdGUgZHVwbGljYXRlJylcbiAgICAgICAgXTtcblxuICAgICAgICAvLyAqKiogY3N2IGltcG9ydCAqKipcbiAgICAgICAgJHNjb3BlLmNzdkNvbmZpZyA9IHtcbiAgICAgICAgICAgIGFjY2VwdDogJy5jc3YsIC50eHQnLFxuICAgICAgICAgICAgZW5jb2RpbmdPcHRpb25zOiBbJ1VURi04JywgJ0lTTy04ODU5LTEnXSxcbiAgICAgICAgICAgIHBhcnNlQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgc2tpcEVtcHR5TGluZXM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBGSUVMRFMgPSBbJ3RpdGxlJywgJ2ZpcnN0X25hbWUnLCAnbGFzdF9uYW1lJywgJ3N0cnVjdHVyZV9sZXZlbCcsICdudW1iZXInLFxuICAgICAgICAnZ3JvdXBzJywgJ2NvbW1lbnQnLCAnaXNfYWN0aXZlJywgJ2lzX3ByZXNlbnQnLCAnaXNfY29tbWl0dGVlJywgJ2RlZmF1bHRfcGFzc3dvcmQnLCAnZW1haWwnXTtcbiAgICAgICAgJHNjb3BlLnVzZXJzID0gW107XG4gICAgICAgICRzY29wZS5vbkNzdkNoYW5nZSA9IGZ1bmN0aW9uIChjc3YpIHtcbiAgICAgICAgICAgICRzY29wZS5jc3ZJbXBvcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIEFsbCB1c2VyIG9iamVjdHMgYXJlIGFscmVhZHkgbG9hZGVkIHZpYSB0aGUgcmVzb2x2ZSBzdGF0ZW1lbnQgZnJvbSB1aS1yb3V0ZXIuXG4gICAgICAgICAgICB2YXIgdXNlcnMgPSBVc2VyLmdldEFsbCgpO1xuICAgICAgICAgICAgJHNjb3BlLnVzZXJzID0gW107XG5cbiAgICAgICAgICAgIHZhciBjc3ZVc2VycyA9IFtdO1xuICAgICAgICAgICAgXy5mb3JFYWNoKGNzdi5kYXRhLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsbGVkUm93ID0gXy56aXBPYmplY3QoRklFTERTLCByb3cpO1xuICAgICAgICAgICAgICAgICAgICBjc3ZVc2Vycy5wdXNoKGZpbGxlZFJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2NvcGUuZHVwbGljYXRlcyA9IDA7XG4gICAgICAgICAgICBfLmZvckVhY2goY3N2VXNlcnMsIGZ1bmN0aW9uICh1c2VyLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHVzZXIuaW1wb3J0VHJhY2tJZCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHVzZXIuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghdXNlci5maXJzdF9uYW1lICYmICF1c2VyLmxhc3RfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB1c2VyLmltcG9ydGVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdXNlci5uYW1lX2Vycm9yID0gZ2V0dGV4dCgnRXJyb3I6IEdpdmVuIG5hbWUgb3Igc3VybmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbnVtYmVyXG4gICAgICAgICAgICAgICAgaWYgKCF1c2VyLm51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICB1c2VyLm51bWJlciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGdyb3Vwc1xuICAgICAgICAgICAgICAgIHVzZXIuZ3JvdXBzX2lkID0gW107IC8vIHdpbGwgYmUgb3ZlcndyaXR0ZW4gaWYgdGhlcmUgYXJlIGdyb3Vwc1xuICAgICAgICAgICAgICAgIGlmICh1c2VyLmdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICB1c2VyLmdyb3VwcyA9IHVzZXIuZ3JvdXBzLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIHVzZXIuZ3JvdXBzID0gXy5tYXAodXNlci5ncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8udHJpbShncm91cCk7IC8vIHJlbW92ZSB3aGl0ZXNwYWNlcyBvbiBzdGFydCBvciBlbmRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGdyb3VwIG9iamVjdHMgYXJlIGFscmVhZHkgbG9hZGVkIHZpYSB0aGUgcmVzb2x2ZSBzdGF0ZW1lbnQgZnJvbSB1aS1yb3V0ZXIuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGxHcm91cHMgPSBHcm91cC5nZXRBbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gYWxsR3JvdXBzTmFtZXMgYXIgYWxsIG9yaWdpbmFsIGdyb3VwIG5hbWVzIGFuZCB0cmFuc2xhdGVkIG5hbWVzIGlmIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNsYXRpb24gZXhpc3RzIChlLmcuIGZvciBkZWZhdWx0IGdyb3VwIERlbGVnYXRlcylcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsbEdyb3Vwc05hbWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChhbGxHcm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwVHJhbnNsYXRpb24gPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoZ3JvdXAubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAubmFtZSAhPT0gZ3JvdXBUcmFuc2xhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEdyb3Vwc05hbWVzLnB1c2goZ3JvdXBUcmFuc2xhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxHcm91cHNOYW1lcy5wdXNoKGdyb3VwLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdXNlci5ncm91cHNUb0NyZWF0ZSA9IF8uZGlmZmVyZW5jZSh1c2VyLmdyb3VwcywgYWxsR3JvdXBzTmFtZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciB0ZW1wbGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgdXNlci5ncm91cHNOb3RUb0NyZWF0ZSA9IF8uZGlmZmVyZW5jZSh1c2VyLmdyb3VwcywgdXNlci5ncm91cHNUb0NyZWF0ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlci5ncm91cHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXNlci5pc19hY3RpdmUgPSAodXNlci5pc19hY3RpdmUgIT09IHVuZGVmaW5lZCAmJiB1c2VyLmlzX2FjdGl2ZSA9PT0gJzEnKTtcbiAgICAgICAgICAgICAgICB1c2VyLmlzX3ByZXNlbnQgPSAodXNlci5pc19wcmVzZW50ICE9PSB1bmRlZmluZWQgJiYgdXNlci5pc19wcmVzZW50ID09PSAnMScpO1xuICAgICAgICAgICAgICAgIHVzZXIuaXNfY29tbWl0dGVlID0gKHVzZXIuaXNfY29tbWl0dGVlICE9PSB1bmRlZmluZWQgJiYgdXNlci5pc19jb21taXR0ZWUgPT09ICcxJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlc1xuICAgICAgICAgICAgICAgIHVzZXIuZHVwbGljYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdXNlcnMuZm9yRWFjaChmdW5jdGlvbih1c2VyXykge1xuICAgICAgICAgICAgICAgICAgICB1c2VyXy5mdWxsbmFtZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJfLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcl8uZmlyc3RfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJfLmxhc3RfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJfLnN0cnVjdHVyZV9sZXZlbF0uam9pbignICcpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgdXNlci5mdWxsbmFtZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmZpcnN0X25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmxhc3RfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIuc3RydWN0dXJlX2xldmVsXS5qb2luKCcgJykudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlcl8uZnVsbG5hbWUgPT09IHVzZXIuZnVsbG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyLmR1cGxpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBtdWx0aXBsZSBkdXBsaWNhdGVzIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIuZHVwbGljYXRlX2luZm8gKz0gJ1xcbicgKyBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1RoZXJlIGFyZSBtb3JlIHRoYW4gb25lIGR1cGxpY2F0ZXMgb2YgdGhpcyB1c2VyIScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmR1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlci5kdXBsaWNhdGVBY3Rpb24gPSAkc2NvcGUuZHVwbGljYXRlQWN0aW9uc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmR1cGxpY2F0ZV9pbmZvID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJfLnRpdGxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmR1cGxpY2F0ZV9pbmZvICs9IHVzZXJfLnRpdGxlICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyXy5maXJzdF9uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmR1cGxpY2F0ZV9pbmZvICs9IHVzZXJfLmZpcnN0X25hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJfLmZpcnN0X25hbWUgJiYgdXNlcl8ubGFzdF9uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmR1cGxpY2F0ZV9pbmZvICs9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcl8ubGFzdF9uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmR1cGxpY2F0ZV9pbmZvICs9IHVzZXJfLmxhc3RfbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmR1cGxpY2F0ZV9pbmZvICs9ICcgKCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJfLm51bWJlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlci5kdXBsaWNhdGVfaW5mbyArPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ051bWJlcicpICsgJzogJyArIHVzZXJfLm51bWJlciArICcsICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJfLnN0cnVjdHVyZV9sZXZlbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlci5kdXBsaWNhdGVfaW5mbyArPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1N0cnVjdHVyZSBsZXZlbCcpICsgJzogJyArIHVzZXJfLnN0cnVjdHVyZV9sZXZlbCArICcsICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlci5kdXBsaWNhdGVfaW5mbyArPSBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ1VzZXJuYW1lJykgKyAnOiAnICsgdXNlcl8udXNlcm5hbWUgKyAnKSAnK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoJ2FscmVhZHkgZXhpc3RzLicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmR1cGxpY2F0ZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICRzY29wZS51c2Vycy5wdXNoKHVzZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2NvcGUuY2FsY1N0YXRzKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3RhdHNcbiAgICAgICAgJHNjb3BlLmNhbGNTdGF0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gbm90IGltcG9ydGVkOiBpZiBpbXBvcnRlcnJvciBvciBkdXBsaWNhdGUtPmtlZXAgb3JpZ2luYWxcbiAgICAgICAgICAgICRzY29wZS51c2Vyc1dpbGxOb3RCZUltcG9ydGVkID0gMDtcbiAgICAgICAgICAgIC8vIGltcG9ydGVkOiBhbGwgb3RoZXJzXG4gICAgICAgICAgICAkc2NvcGUudXNlcnNXaWxsQmVJbXBvcnRlZCA9IDA7XG5cbiAgICAgICAgICAgICRzY29wZS51c2Vycy5mb3JFYWNoKGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVzZXIuc2VsZWN0ZWQgfHwgdXNlci5pbXBvcnRlcnJvciB8fCAodXNlci5kdXBsaWNhdGUgJiYgdXNlci5kdXBsaWNhdGVBY3Rpb24gPT0gJHNjb3BlLmR1cGxpY2F0ZUFjdGlvbnNbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS51c2Vyc1dpbGxOb3RCZUltcG9ydGVkKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnVzZXJzV2lsbEJlSW1wb3J0ZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuc2V0R2xvYmFsQWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgJHNjb3BlLnVzZXJzLmZvckVhY2goZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlci5kdXBsaWNhdGUpXG4gICAgICAgICAgICAgICAgICAgIHVzZXIuZHVwbGljYXRlQWN0aW9uID0gYWN0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2NvcGUuY2FsY1N0YXRzKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaW1wb3J0IGZyb20gY3N2IGZpbGVcbiAgICAgICAgJHNjb3BlLmltcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzY29wZS5jc3ZJbXBvcnRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBjb2xsZWN0IGFsbCBuZWVkZWQgZ3JvdXBzIGFuZCBjcmVhdGUgbm9uIGV4aXN0aW5nIGdyb3Vwc1xuICAgICAgICAgICAgdmFyIGdyb3Vwc1RvQ3JlYXRlID0gW107XG4gICAgICAgICAgICBfLmZvckVhY2goJHNjb3BlLnVzZXJzLCBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgICAgIGlmICh1c2VyLnNlbGVjdGVkICYmICF1c2VyLmltcG9ydGVycm9yICYmIHVzZXIuZ3JvdXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2godXNlci5ncm91cHNUb0NyZWF0ZSwgZnVuY3Rpb24gKGdyb3VwKSB7IC8vIEp1c3QgYXBwZW5kIGdyb3VwcywgdGhhdCBhcmUgbm90IGxpc3RlZCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5pbmRleE9mKGdyb3Vwc1RvQ3JlYXRlLCBncm91cCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cHNUb0NyZWF0ZS5wdXNoKGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgY3JlYXRlUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICRzY29wZS5ncm91cHNDcmVhdGVkID0gMDtcbiAgICAgICAgICAgIF8uZm9yRWFjaChncm91cHNUb0NyZWF0ZSwgZnVuY3Rpb24gKGdyb3VwbmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZ3JvdXBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNyZWF0ZVByb21pc2VzLnB1c2goR3JvdXAuY3JlYXRlKGdyb3VwKS50aGVuKCBmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZ3JvdXBzQ3JlYXRlZCsrO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkcS5hbGwoY3JlYXRlUHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbG9hZCBhbGxHcm91cHMsIG5vdyBhbGwgbmV3IGdyb3VwcyBhcmUgY3JlYXRlZFxuICAgICAgICAgICAgICAgIHZhciBhbGxHcm91cHMgPSBHcm91cC5nZXRBbGwoKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdVc2VycyA9IFVzZXIuZ2V0QWxsKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3Igb3B0aW9uICdkZWxldGUgZXhpc3RpbmcgdXNlcicgb24gZHVwbGljYXRlc1xuICAgICAgICAgICAgICAgIHZhciBkZWxldGVQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIEFycmF5IG9mIHVzZXJzIGZvciBtYXNzIGltcG9ydFxuICAgICAgICAgICAgICAgIHZhciB1c2Vyc1RvQmVJbXBvcnRlZCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKCRzY29wZS51c2VycywgZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXIuc2VsZWN0ZWQgJiYgIXVzZXIuaW1wb3J0ZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiBhbGwgZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2godXNlci5ncm91cHMsIGZ1bmN0aW9uKGNzdkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsR3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGFsbEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHdpdGggYW5kIHdpdGhvdXQgdHJhbnNsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzdkdyb3VwID09PSBhbGxHcm91cC5uYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3ZHcm91cCA9PT0gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKGFsbEdyb3VwLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmdyb3Vwc19pZC5wdXNoKGFsbEdyb3VwLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgb24gZHVwbGljYXRlQWN0aW9uPT1kdXBsaWNhdGVBY3Rpb25zWzBdIChrZWVwIG9yaWdpbmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXIuZHVwbGljYXRlICYmICh1c2VyLmR1cGxpY2F0ZUFjdGlvbiA9PSAkc2NvcGUuZHVwbGljYXRlQWN0aW9uc1sxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgZXhpc3RpbmcgdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVXNlcnMuZm9yRWFjaChmdW5jdGlvbih1c2VyXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyXy5mdWxsbmFtZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJfLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcl8uZmlyc3RfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJfLmxhc3RfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJfLnN0cnVjdHVyZV9sZXZlbF0uam9pbignICcpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlci5mdWxsbmFtZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmZpcnN0X25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmxhc3RfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIuc3RydWN0dXJlX2xldmVsXS5qb2luKCcgJykudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcl8uZnVsbG5hbWUgPT09IHVzZXIuZnVsbG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb21pc2VzLnB1c2goVXNlci5kZXN0cm95KHVzZXJfLmlkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2Vyc1RvQmVJbXBvcnRlZC5wdXNoKHVzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdXNlci5kdXBsaWNhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHVzZXIuZHVwbGljYXRlQWN0aW9uID09ICRzY29wZS5kdXBsaWNhdGVBY3Rpb25zWzJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcnNUb0JlSW1wb3J0ZWQucHVzaCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICRxLmFsbChkZWxldGVQcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICRodHRwLnBvc3QoJy9yZXN0L3VzZXJzL3VzZXIvbWFzc19pbXBvcnQvJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcnM6IHVzZXJzVG9CZUltcG9ydGVkXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChzdWNjZXNzLmRhdGEuaW1wb3J0ZWRUcmFja0lkcywgZnVuY3Rpb24gKHRyYWNrSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmZpbmQoJHNjb3BlLnVzZXJzLCBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlci5pbXBvcnRUcmFja0lkID09PSB0cmFja0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmltcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNzdmltcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnQgPSBFcnJvck1lc3NhZ2UuZm9yQWxlcnQoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUudXNlcnMgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuZXhjbHVkZUltcG9ydGVkVXNlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUudXNlcnMgPSBfLmZpbHRlcigkc2NvcGUudXNlcnMsIGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1c2VyLmltcG9ydGVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2NvcGUuY3N2SW1wb3J0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAkc2NvcGUuY2FsY1N0YXRzKCk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5zb21lSW1wb3J0ZWRVc2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfLnNvbWUoJHNjb3BlLnVzZXJzLCBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VyLmltcG9ydGVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRvd25sb2FkIENTViBleGFtcGxlIGZpbGVcbiAgICAgICAgJHNjb3BlLmRvd25sb2FkQ1NWRXhhbXBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFVzZXJDc3ZFeHBvcnQuZG93bmxvYWRFeGFtcGxlKCk7XG4gICAgICAgIH07XG4gICAgfVxuXSlcblxuLmNvbnRyb2xsZXIoJ0dyb3VwTGlzdEN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJyRodHRwJyxcbiAgICAnJGZpbHRlcicsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnR3JvdXAnLFxuICAgICdwZXJtaXNzaW9ucycsXG4gICAgJ2dldHRleHQnLFxuICAgICdBZ2VuZGEnLFxuICAgICdBc3NpZ25tZW50JyxcbiAgICAnTWVkaWFmaWxlJyxcbiAgICAnTW90aW9uJyxcbiAgICAnVXNlcicsXG4gICAgJ25nRGlhbG9nJyxcbiAgICAnT3BlblNsaWRlc1BsdWdpbnMnLFxuICAgIGZ1bmN0aW9uKCRzY29wZSwgJGh0dHAsICRmaWx0ZXIsIG9wZXJhdG9yLCBHcm91cCwgcGVybWlzc2lvbnMsIGdldHRleHQsIEFnZW5kYSxcbiAgICAgICAgQXNzaWdubWVudCwgTWVkaWFmaWxlLCBNb3Rpb24sIFVzZXIsIG5nRGlhbG9nLCBPcGVuU2xpZGVzUGx1Z2lucykge1xuICAgICAgICAkc2NvcGUucGVybWlzc2lvbnMgPSBwZXJtaXNzaW9ucztcblxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIEdyb3VwLmxhc3RNb2RpZmllZCgpO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS5ncm91cHMgPSAkZmlsdGVyKCdvcmRlckJ5JykoR3JvdXAuZ2V0QWxsKCksICdpZCcpO1xuXG4gICAgICAgICAgICAvLyBmaW5kIGFsbCBncm91cHMgd2l0aCB0aGUgMiBkYW5nZXJvdXMgcGVybWlzc2lvbnNcbiAgICAgICAgICAgIHZhciBncm91cHNfZGFuZ2VyID0gW107XG4gICAgICAgICAgICAkc2NvcGUuZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgaWYgKChfLmluZGV4T2YoZ3JvdXAucGVybWlzc2lvbnMsICd1c2Vycy5jYW5fc2VlX25hbWUnKSA+IC0xKSAmJlxuICAgICAgICAgICAgICAgICAgICAoXy5pbmRleE9mKGdyb3VwLnBlcm1pc3Npb25zLCAndXNlcnMuY2FuX21hbmFnZScpID4gLTEpKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yLmlzSW5Hcm91cChncm91cCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzX2Rhbmdlci5wdXNoKGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgZGFuZ2Vyb3VzIGdyb3VwLCBibG9jayBpdC5cbiAgICAgICAgICAgICRzY29wZS5ncm91cF9kYW5nZXIgPSBncm91cHNfZGFuZ2VyLmxlbmd0aCA9PSAxID8gZ3JvdXBzX2RhbmdlclswXSA6IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERpY3QgdG8gbWFwIHBsdWdpbiBuYW1lIC0+IGRpc3BsYXlfbmFtZVxuICAgICAgICB2YXIgcGx1Z2luVHJhbnNsYXRpb24gPSB7fTtcbiAgICAgICAgXy5mb3JFYWNoKE9wZW5TbGlkZXNQbHVnaW5zLmdldEFsbCgpLCBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgICAgICBwbHVnaW5UcmFuc2xhdGlvbltwbHVnaW4ubmFtZV0gPSBwbHVnaW4uZGlzcGxheV9uYW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgJHNjb3BlLmFwcHMgPSBbXTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBtYWluIGNsdXN0ZXJpbmcgd2l0aCBhcHBuYW1lLT5wZXJtaXNzaW9uc1xuICAgICAgICBhbmd1bGFyLmZvckVhY2gocGVybWlzc2lvbnMsIGZ1bmN0aW9uKHBlcm0pIHtcbiAgICAgICAgICAgIHZhciBwZXJtaXNzaW9uQXBwID0gcGVybS52YWx1ZS5zcGxpdCgnLicpWzBdOyAvLyBnZXQgYXBwbmFtZVxuXG4gICAgICAgICAgICAvLyBUbyBpbnNlcnQgcGVybSBpbiB0aGUgcmlnaHQgc3BvdCBpbiAkc2NvcGUuYXBwc1xuICAgICAgICAgICAgdmFyIGluc2VydCA9IGZ1bmN0aW9uIChpZCwgcGVybSwgdmVyYm9zZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoISRzY29wZS5hcHBzW2lkXSkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYXBwc1tpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBfbmFtZTogdmVyYm9zZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBfdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiBbXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkc2NvcGUuYXBwc1tpZF0ucGVybWlzc2lvbnMucHVzaChwZXJtKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHN3aXRjaChwZXJtaXNzaW9uQXBwKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29yZSc6IC8vIGlkIDAgKHByb2plY3RvcikgYW5kIGlkIDYgKGdlbmVyYWwpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJtLnZhbHVlLmluZGV4T2YoJ3Byb2plY3RvcicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydCgwLCBwZXJtLCBnZXR0ZXh0KCdQcm9qZWN0b3InKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQoNiwgcGVybSwgZ2V0dGV4dCgnR2VuZXJhbCcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdhZ2VuZGEnOiAvLyBpZCAxXG4gICAgICAgICAgICAgICAgICAgIGluc2VydCgxLCBwZXJtLCBBZ2VuZGEudmVyYm9zZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtb3Rpb25zJzogLy8gaWQgMlxuICAgICAgICAgICAgICAgICAgICBpbnNlcnQoMiwgcGVybSwgTW90aW9uLnZlcmJvc2VOYW1lUGx1cmFsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXNzaWdubWVudHMnOiAvLyBpZCAzXG4gICAgICAgICAgICAgICAgICAgIGluc2VydCgzLCBwZXJtLCBBc3NpZ25tZW50LnZlcmJvc2VOYW1lUGx1cmFsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWVkaWFmaWxlcyc6IC8vIGlkIDRcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KDQsIHBlcm0sIE1lZGlhZmlsZS52ZXJib3NlTmFtZVBsdXJhbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VzZXJzJzogLy8gaWQgNVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnQoNSwgcGVybSwgVXNlci52ZXJib3NlTmFtZVBsdXJhbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IC8vIHBsdWdpbnM6IGlkPjVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3BsYXlfbmFtZSA9IHBsdWdpblRyYW5zbGF0aW9uW3Blcm1pc3Npb25BcHBdIHx8IHBlcm1pc3Npb25BcHAuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbkFwcC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9lcyB0aGUgYXBwIGV4aXN0cz9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlLmFwcHMsIGZ1bmN0aW9uIChhcHAsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXBwLmFwcF9uYW1lID09PSBkaXNwbGF5X25hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSByZXN1bHQgPT0gLTEgPyAkc2NvcGUuYXBwcy5sZW5ndGggOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydChpZCwgcGVybSwgZGlzcGxheV9uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNvcnQgZWFjaCBhcHA6IGZpcnN0IGFsbCBwZXJtaXNzaW9uIHdpdGggJ3NlZScsIHRoZW4gJ21hbmFnZScsIHRoZW4gdGhlIHJlc3RcbiAgICAgICAgLy8gc2F2ZSB0aGUgcGVybWlzc2lvbnMgaW4gZGlmZmVyZW50IGxpc3RzIGFuIGNvbmNhdCB0aGVtIGluIHRoZSByaWdodCBvcmRlciB0b2dldGhlclxuICAgICAgICAvLyBTcGVjaWFsIFVzZXJzOiB0aGUgdHdvIFwic2VlXCItcGVybWlzc2lvbnMgYXJlIG5vcm1hbGx5IHN3YXBwZWQuIFRvIGNyZWF0ZSB0aGUgcmlnaHRcbiAgICAgICAgLy8gb3JkZXIsIHdlIGNvdWxkIHNpbXBseSByZXZlcnNlIHRoZSB3aG9sZSBwZXJtaXNzaW9ucy5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5hcHBzLCBmdW5jdGlvbiAoYXBwLCBpbmRleCkge1xuICAgICAgICAgICAgaWYoaW5kZXggPT0gNSkgeyAvLyB1c2Vyc1xuICAgICAgICAgICAgICAgIGFwcC5wZXJtaXNzaW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyByZXN0XG4gICAgICAgICAgICAgICAgdmFyIHNlZSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBtYW5hZ2UgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJzID0gW107XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGFwcC5wZXJtaXNzaW9ucywgZnVuY3Rpb24gKHBlcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlcm0udmFsdWUuaW5kZXhPZignc2VlJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VlLnB1c2gocGVybSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGVybS52YWx1ZS5pbmRleE9mKCdtYW5hZ2UnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2UucHVzaChwZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVycy5wdXNoKHBlcm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXBwLnBlcm1pc3Npb25zID0gc2VlLmNvbmNhdChtYW5hZ2UuY29uY2F0KG90aGVycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgZ2l2ZW4gZ3JvdXAgaGFzIHRoZSBnaXZlbiBwZXJtaXNzaW9uXG4gICAgICAgICRzY29wZS5oYXNQZXJtID0gZnVuY3Rpb24gKGdyb3VwLCBwZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5pbmRleE9mKGdyb3VwLnBlcm1pc3Npb25zLCBwZXJtaXNzaW9uLnZhbHVlKSA+IC0xO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRoZSBjdXJyZW50IHVzZXIgaXMgbm90IGFsbG93ZWQgdG8gbG9jayBoaW1zZWxmIG91dCBvZiB0aGUgY29uZmlndXJhdGlvbjpcbiAgICAgICAgLy8gLSBpZiB0aGUgcGVybWlzc2lvbiBpcyAndXNlcnMuY2FuX21hbmFnZScgb3IgJ3VzZXJzLmNhbl9zZWUnXG4gICAgICAgIC8vIC0gaWYgdGhlIHVzZXIgaXMgaW4gb25seSBvbmUgZ3JvdXAgd2l0aCB0aGVzZSBwZXJtaXNzaW9ucyAoZ3JvdXBfZGFuZ2VyIGlzIHNldClcbiAgICAgICAgJHNjb3BlLmRhbmdlciA9IGZ1bmN0aW9uIChncm91cCwgcGVybWlzc2lvbil7XG4gICAgICAgICAgICBpZiAoJHNjb3BlLmdyb3VwX2Rhbmdlcil7XG4gICAgICAgICAgICAgICAgaWYgKHBlcm1pc3Npb24udmFsdWUgPT0gJ3VzZXJzLmNhbl9zZWVfbmFtZScgfHxcbiAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbi52YWx1ZSA9PSAndXNlcnMuY2FuX21hbmFnZScpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHNjb3BlLmdyb3VwX2RhbmdlciA9PSBncm91cDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZGVsZXRlIHNlbGVjdGVkIGdyb3VwXG4gICAgICAgICRzY29wZS5kZWxldGUgPSBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgICAgIEdyb3VwLmRlc3Ryb3koZ3JvdXAuaWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNhdmUgY2hhbmdlZCBwZXJtaXNzaW9uXG4gICAgICAgICRzY29wZS5jaGFuZ2VQZXJtaXNzaW9uID0gZnVuY3Rpb24gKGdyb3VwLCBwZXJtKSB7XG4gICAgICAgICAgICBpZiAoISRzY29wZS5kYW5nZXIoZ3JvdXAsIHBlcm0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuaGFzUGVybShncm91cCwgcGVybSkpIHsgLy8gYWN0aXZhdGUgcGVybVxuICAgICAgICAgICAgICAgICAgICBncm91cC5wZXJtaXNzaW9ucy5wdXNoKHBlcm0udmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBwZXJtIGluIGdyb3VwLnBlcm1pc3Npb25zXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnBlcm1pc3Npb25zID0gXy5maWx0ZXIoZ3JvdXAucGVybWlzc2lvbnMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gcGVybS52YWx1ZTsgLy8gcmVtb3ZlIHBlcm1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEdyb3VwLnNhdmUoZ3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgICRzY29wZS5vcGVuRGlhbG9nID0gZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJ3N0YXRpYy90ZW1wbGF0ZXMvdXNlcnMvZ3JvdXAtZWRpdC5odG1sJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBncm91cCA/ICdHcm91cFJlbmFtZUN0cmwnIDogJ0dyb3VwQ3JlYXRlQ3RybCcsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmdkaWFsb2ctdGhlbWUtZGVmYXVsdCB3aWRlLWZvcm0nLFxuICAgICAgICAgICAgICAgIGNsb3NlQnlFc2NhcGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNsb3NlQnlEb2N1bWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZToge1xuICAgICAgICAgICAgICAgICAgICBncm91cDogZnVuY3Rpb24gKCkge3JldHVybiBncm91cDt9LFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdHcm91cFJlbmFtZUN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ0dyb3VwJyxcbiAgICAnZ3JvdXAnLFxuICAgICdnZXR0ZXh0Q2F0YWxvZycsXG4gICAgJ0Vycm9yTWVzc2FnZScsXG4gICAgZnVuY3Rpb24oJHNjb3BlLCBHcm91cCwgZ3JvdXAsIGdldHRleHRDYXRhbG9nLCBFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgJHNjb3BlLmdyb3VwID0gZ3JvdXA7XG4gICAgICAgICRzY29wZS5uZXdfbmFtZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZyhncm91cC5uYW1lKTtcblxuICAgICAgICAkc2NvcGUuYWxlcnQgPSB7fTtcbiAgICAgICAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvbGRfbmFtZSA9IGdldHRleHRDYXRhbG9nLmdldFN0cmluZygkc2NvcGUuZ3JvdXAubmFtZSk7XG4gICAgICAgICAgICAkc2NvcGUuZ3JvdXAubmFtZSA9ICRzY29wZS5uZXdfbmFtZTtcbiAgICAgICAgICAgIEdyb3VwLnNhdmUoJHNjb3BlLmdyb3VwKS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZVRoaXNEaWFsb2coKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IEVycm9yTWVzc2FnZS5mb3JBbGVydChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgJHNjb3BlLmdyb3VwLm5hbWUgPSBvbGRfbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdHcm91cENyZWF0ZUN0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ0dyb3VwJyxcbiAgICAnRXJyb3JNZXNzYWdlJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsIEdyb3VwLCBFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgJHNjb3BlLm5ld19uYW1lID0gJyc7XG4gICAgICAgICRzY29wZS5hbGVydCA9IHt9O1xuXG4gICAgICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJHNjb3BlLm5ld19uYW1lLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiBbXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgR3JvdXAuY3JlYXRlKGdyb3VwKS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZVRoaXNEaWFsb2coKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICRzY29wZS5hbGVydCA9IEVycm9yTWVzc2FnZS5mb3JBbGVydChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uZmFjdG9yeSgnVXNlck1lbnUnLCBbXG4gICAgJyRodHRwJyxcbiAgICAnT3BlblNsaWRlcycsXG4gICAgJ25nRGlhbG9nJyxcbiAgICAnVXNlclByb2ZpbGVGb3JtJyxcbiAgICAnVXNlclBhc3N3b3JkRm9ybScsXG4gICAgZnVuY3Rpb24gKCRodHRwLCBPcGVuU2xpZGVzLCBuZ0RpYWxvZywgVXNlclByb2ZpbGVGb3JtLCBVc2VyUGFzc3dvcmRGb3JtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2dvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkaHR0cC5wb3N0KCcvdXNlcnMvbG9nb3V0LycpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3M6IFVzZXIgbG9nZ2VkIG91dCwgc28gcmVib290IE9wZW5TbGlkZXMuXG4gICAgICAgICAgICAgICAgICAgIE9wZW5TbGlkZXMucmVib290KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWRpdFByb2ZpbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKFVzZXJQcm9maWxlRm9ybS5nZXREaWFsb2coKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhbmdlUGFzc3dvcmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKFVzZXJQYXNzd29yZEZvcm0uZ2V0RGlhbG9nKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcigndXNlck1lbnUnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ1VzZXJNZW51JyxcbiAgICBmdW5jdGlvbigkc2NvcGUsIFVzZXJNZW51KSB7XG4gICAgICAgICRzY29wZS5sb2dvdXQgPSBVc2VyTWVudS5sb2dvdXQ7XG4gICAgICAgICRzY29wZS5lZGl0UHJvZmlsZSA9IFVzZXJNZW51LmVkaXRQcm9maWxlO1xuICAgICAgICAkc2NvcGUuY2hhbmdlUGFzc3dvcmQgPSBVc2VyTWVudS5jaGFuZ2VQYXNzd29yZDtcblxuICAgIH1cbl0pXG5cbi5jb250cm9sbGVyKCdMb2dpbkZvcm1DdHJsJywgW1xuICAgICckcm9vdFNjb3BlJyxcbiAgICAnJHNjb3BlJyxcbiAgICAnJGh0dHAnLFxuICAgICckc3RhdGUnLFxuICAgICckc3RhdGVQYXJhbXMnLFxuICAgICckcScsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnZ2V0dGV4dCcsXG4gICAgJ2F1dG91cGRhdGUnLFxuICAgICdtYWluTWVudScsXG4gICAgJ0RTJyxcbiAgICAnbmdEaWFsb2cnLFxuICAgIGZ1bmN0aW9uICgkcm9vdFNjb3BlLCAkc2NvcGUsICRodHRwLCAkc3RhdGUsICRzdGF0ZVBhcmFtcywgJHEsIG9wZXJhdG9yLCBnZXR0ZXh0LFxuICAgICAgICBhdXRvdXBkYXRlLCBtYWluTWVudSwgRFMsIG5nRGlhbG9nKSB7XG4gICAgICAgICRzY29wZS5hbGVydHMgPSBbXTtcblxuICAgICAgICBpZiAoJHN0YXRlUGFyYW1zLm1zZykge1xuICAgICAgICAgICAgJHNjb3BlLmFsZXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGFuZ2VyJyxcbiAgICAgICAgICAgICAgICBtc2c6ICRzdGF0ZVBhcmFtcy5tc2csXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIGd1ZXN0IGxvZ2luIGlzIGFsbG93ZWRcbiAgICAgICAgJHNjb3BlLmd1ZXN0QWxsb3dlZCA9ICRyb290U2NvcGUuZ3Vlc3RfZW5hYmxlZDtcblxuICAgICAgICAvLyBnZXQgbG9naW4gaW5mby10ZXh0IGZyb20gc2VydmVyXG4gICAgICAgICRodHRwLmdldCgnL3VzZXJzL2xvZ2luLycpLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGlmKHN1Y2Nlc3MuZGF0YS5pbmZvX3RleHQpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuYWxlcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgICAgIG1zZzogc3VjY2Vzcy5kYXRhLmluZm9fdGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2hlY2sgaWYgY29va2llcyBhcmUgZW5hYmxlZFxuICAgICAgICBpZiAoIW5hdmlnYXRvci5jb29raWVFbmFibGVkKSB7XG4gICAgICAgICAgICAkc2NvcGUuYWxlcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkYW5nZXInLFxuICAgICAgICAgICAgICAgIG1zZzogZ2V0dGV4dCgnWW91IGhhdmUgdG8gZW5hYmxlIGNvb2tpZXMgdG8gdXNlIE9wZW5TbGlkZXMuJyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsb3NlIGFsZXJ0IGZ1bmN0aW9uXG4gICAgICAgICRzY29wZS5jbG9zZUFsZXJ0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICRzY29wZS5hbGVydHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gbG9naW5cbiAgICAgICAgJHNjb3BlLmxvZ2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNjb3BlLmNsb3NlVGhpc0RpYWxvZygpO1xuICAgICAgICAgICAgJHNjb3BlLmFsZXJ0cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7ICd1c2VybmFtZSc6ICRzY29wZS51c2VybmFtZSwgJ3Bhc3N3b3JkJzogJHNjb3BlLnBhc3N3b3JkIH07XG4gICAgICAgICAgICBpZiAoIW5hdmlnYXRvci5jb29raWVFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jb29raWVzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkaHR0cC5wb3N0KCcvdXNlcnMvbG9naW4vJywgZGF0YSkudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VjY2VzczogVXNlciBsb2dnZWQgaW4uXG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIHN0b3JlIGFuZCByZXNldCBkZWZlcnJlZCBmaXJzdCBtZXNzYWdlLCBpZiBndWVzdHMgd2FzIGVuYWJsZWQgYmVmb3JlLlxuICAgICAgICAgICAgICAgICAgICBEUy5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICBhdXRvdXBkYXRlLmZpcnN0TWVzc2FnZURlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5leHQgbGluZXMgYXJlIHBhcnRseSB0aGUgc2FtZSBsaW5lcyBhcyBpbiBjb3JlL3N0YXJ0LmpzXG4gICAgICAgICAgICAgICAgICAgIGF1dG91cGRhdGUubmV3Q29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBhdXRvdXBkYXRlLmZpcnN0TWVzc2FnZURlZmVycmVkLnByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvci5zZXRVc2VyKHJlc3BvbnNlLmRhdGEudXNlcl9pZCwgcmVzcG9uc2UuZGF0YS51c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5NZW51LnVwZGF0ZU1haW5NZW51KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ2hvbWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUub3BlbnNsaWRlc0Jvb3RzdHJhcERvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBFcnJvcjogVXNlcm5hbWUgb3IgcGFzc3dvcmQgaXMgbm90IGNvcnJlY3QuXG4gICAgICAgICAgICAgICAgICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oJHN0YXRlLmN1cnJlbnQsIHttc2c6IGVycm9yLmRhdGEuZGV0YWlsfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvYWQ6IHRydWUsIGluaGVyaXQ6IGZhbHNlLCBub3RpZnk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZ3Vlc3QgbG9naW5cbiAgICAgICAgJHNjb3BlLmd1ZXN0TG9naW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkc2NvcGUuY2xvc2VUaGlzRGlhbG9nKCk7XG4gICAgICAgICAgICAkc3RhdGUuZ28oJ2hvbWUnKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcXVpY2sgZml4LCB0aGF0IHdlIGNhbm5vdCBjaGFuZ2UgdGhlIHN0YXRlIHRvIHRoZSBtYWluIHByaXZhY3lcbiAgICAgICAgLy8gcG9saWN5IHZpZXcuIERpc3BsYXkgaXQgaW4gYSBkaWFsb2cuLlxuICAgICAgICAkc2NvcGUub3BlblByaXZhY3lQb2xpY3lEaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJ3N0YXRpYy90ZW1wbGF0ZXMvcHJpdmFjeXBvbGljeWRpYWxvZy5odG1sJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICduZ2RpYWxvZy10aGVtZS1kZWZhdWx0IHdpZGUtZm9ybScsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ1ByaXZhY3lQb2xpY3lEaWFsb2dDdHJsJyxcbiAgICAgICAgICAgICAgICBzaG93Q2xvc2U6IHRydWUsXG4gICAgICAgICAgICAgICAgY2xvc2VCeUVzY2FwZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjbG9zZUJ5RG9jdW1lbnQ6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5dKVxuXG4uY29udHJvbGxlcignUHJpdmFjeVBvbGljeURpYWxvZ0N0cmwnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ1ByaXZhY3lQb2xpY3knLFxuICAgIGZ1bmN0aW9uICgkc2NvcGUsIFByaXZhY3lQb2xpY3kpIHtcbiAgICAgICAgJHNjb3BlLnByaXZhY3lQb2xpY3kgPSBQcml2YWN5UG9saWN5O1xuICAgIH1cbl0pXG5cbi8vIE1hcmsgYWxsIHVzZXJzIHN0cmluZ3MgZm9yIHRyYW5zbGF0aW9uIGluIEphdmFTY3JpcHQuXG4uY29uZmlnKFtcbiAgICAnZ2V0dGV4dCcsXG4gICAgZnVuY3Rpb24gKGdldHRleHQpIHtcbiAgICAgICAgLy8gcGVybWlzc2lvbiBzdHJpbmdzIChzZWUgbW9kZWxzLnB5IG9mIGVhY2ggRGphbmdvIGFwcClcbiAgICAgICAgLy8gYWdlbmRhXG4gICAgICAgIGdldHRleHQoJ0NhbiBzZWUgYWdlbmRhJyk7XG4gICAgICAgIGdldHRleHQoJ0NhbiBtYW5hZ2UgYWdlbmRhJyk7XG4gICAgICAgIGdldHRleHQoJ0NhbiBtYW5hZ2UgbGlzdCBvZiBzcGVha2VycycpO1xuICAgICAgICBnZXR0ZXh0KCdDYW4gc2VlIGludGVybmFsIGl0ZW1zIGFuZCB0aW1lIHNjaGVkdWxpbmcgb2YgYWdlbmRhJyk7XG4gICAgICAgIGdldHRleHQoJ0NhbiBwdXQgb25lc2VsZiBvbiB0aGUgbGlzdCBvZiBzcGVha2VycycpO1xuICAgICAgICAvLyBhc3NpZ25tZW50c1xuICAgICAgICBnZXR0ZXh0KCdDYW4gc2VlIGVsZWN0aW9ucycpO1xuICAgICAgICBnZXR0ZXh0KCdDYW4gbm9taW5hdGUgYW5vdGhlciBwYXJ0aWNpcGFudCcpO1xuICAgICAgICBnZXR0ZXh0KCdDYW4gbm9taW5hdGUgb25lc2VsZicpO1xuICAgICAgICBnZXR0ZXh0KCdDYW4gbWFuYWdlIGVsZWN0aW9ucycpO1xuICAgICAgICAvLyBjb3JlXG4gICAgICAgIGdldHRleHQoJ0NhbiBzZWUgdGhlIHByb2plY3RvcicpO1xuICAgICAgICBnZXR0ZXh0KCdDYW4gbWFuYWdlIHRoZSBwcm9qZWN0b3InKTtcbiAgICAgICAgZ2V0dGV4dCgnQ2FuIHNlZSB0aGUgZnJvbnQgcGFnZScpO1xuICAgICAgICBnZXR0ZXh0KCdDYW4gbWFuYWdlIHRhZ3MnKTtcbiAgICAgICAgZ2V0dGV4dCgnQ2FuIG1hbmFnZSBjb25maWd1cmF0aW9uJyk7XG4gICAgICAgIGdldHRleHQoJ0NhbiB1c2UgdGhlIGNoYXQnKTtcbiAgICAgICAgZ2V0dGV4dCgnQ2FuIG1hbmFnZSB0aGUgY2hhdCcpO1xuICAgICAgICBnZXR0ZXh0KCdDYW4gbWFuYWdlIGxvZ29zIGFuZCBmb250cycpO1xuICAgICAgICAvLyBtZWRpYWZpbGVzXG4gICAgICAgIGdldHRleHQoJ0NhbiBzZWUgdGhlIGxpc3Qgb2YgZmlsZXMnKTtcbiAgICAgICAgZ2V0dGV4dCgnQ2FuIHVwbG9hZCBmaWxlcycpO1xuICAgICAgICBnZXR0ZXh0KCdDYW4gbWFuYWdlIGZpbGVzJyk7XG4gICAgICAgIGdldHRleHQoJ0NhbiBzZWUgaGlkZGVuIGZpbGVzJyk7XG4gICAgICAgIC8vIG1vdGlvbnNcbiAgICAgICAgZ2V0dGV4dCgnQ2FuIHNlZSBtb3Rpb25zJyk7XG4gICAgICAgIGdldHRleHQoJ0NhbiBjcmVhdGUgbW90aW9ucycpO1xuICAgICAgICBnZXR0ZXh0KCdDYW4gc3VwcG9ydCBtb3Rpb25zJyk7XG4gICAgICAgIGdldHRleHQoJ0NhbiBtYW5hZ2UgbW90aW9ucycpO1xuICAgICAgICBnZXR0ZXh0KCdDYW4gc2VlIGNvbW1lbnRzJyk7XG4gICAgICAgIGdldHRleHQoJ0NhbiBtYW5hZ2UgY29tbWVudHMnKTtcbiAgICAgICAgLy8gdXNlcnNcbiAgICAgICAgZ2V0dGV4dCgnQ2FuIHNlZSBuYW1lcyBvZiB1c2VycycpO1xuICAgICAgICBnZXR0ZXh0KCdDYW4gc2VlIGV4dHJhIGRhdGEgb2YgdXNlcnMgKGUuZy4gcHJlc2VudCBhbmQgY29tbWVudCknKTtcbiAgICAgICAgZ2V0dGV4dCgnQ2FuIG1hbmFnZSB1c2VycycpO1xuXG4gICAgICAgIC8vIGNvbmZpZyBzdHJpbmdzIGluIHVzZXJzL2NvbmZpZ192YXJpYWJsZXMucHlcbiAgICAgICAgZ2V0dGV4dCgnR2VuZXJhbCcpO1xuICAgICAgICBnZXR0ZXh0KCdTb3J0IG5hbWUgb2YgcGFydGljaXBhbnRzIGJ5Jyk7XG4gICAgICAgIGdldHRleHQoJ0VuYWJsZSBwYXJ0aWNpcGFudCBwcmVzZW5jZSB2aWV3Jyk7XG4gICAgICAgIGdldHRleHQoJ1BhcnRpY2lwYW50cycpO1xuICAgICAgICBnZXR0ZXh0KCdHaXZlbiBuYW1lJyk7XG4gICAgICAgIGdldHRleHQoJ1N1cm5hbWUnKTtcbiAgICAgICAgZ2V0dGV4dCgnUERGJyk7XG4gICAgICAgIGdldHRleHQoJ1dlbGNvbWUgdG8gT3BlblNsaWRlcycpO1xuICAgICAgICBnZXR0ZXh0KCdUaXRsZSBmb3IgYWNjZXNzIGRhdGEgYW5kIHdlbGNvbWUgUERGJyk7XG4gICAgICAgIGdldHRleHQoJ1tQbGFjZSBmb3IgeW91ciB3ZWxjb21lIGFuZCBoZWxwIHRleHQuXScpO1xuICAgICAgICBnZXR0ZXh0KCdIZWxwIHRleHQgZm9yIGFjY2VzcyBkYXRhIGFuZCB3ZWxjb21lIFBERicpO1xuICAgICAgICBnZXR0ZXh0KCdTeXN0ZW0gVVJMJyk7XG4gICAgICAgIGdldHRleHQoJ1VzZWQgZm9yIFFSQ29kZSBpbiBQREYgb2YgYWNjZXNzIGRhdGEuJyk7XG4gICAgICAgIGdldHRleHQoJ1dMQU4gbmFtZSAoU1NJRCknKTtcbiAgICAgICAgZ2V0dGV4dCgnVXNlZCBmb3IgV0xBTiBRUkNvZGUgaW4gUERGIG9mIGFjY2VzcyBkYXRhLicpO1xuICAgICAgICBnZXR0ZXh0KCdXTEFOIHBhc3N3b3JkJyk7XG4gICAgICAgIGdldHRleHQoJ1VzZWQgZm9yIFdMQU4gUVJDb2RlIGluIFBERiBvZiBhY2Nlc3MgZGF0YS4nKTtcbiAgICAgICAgZ2V0dGV4dCgnV0xBTiBlbmNyeXB0aW9uJyk7XG4gICAgICAgIGdldHRleHQoJ1VzZWQgZm9yIFdMQU4gUVJDb2RlIGluIFBERiBvZiBhY2Nlc3MgZGF0YS4nKTtcbiAgICAgICAgZ2V0dGV4dCgnV0VQJyk7XG4gICAgICAgIGdldHRleHQoJ1dQQS9XUEEyJyk7XG4gICAgICAgIGdldHRleHQoJ05vIGVuY3J5cHRpb24nKTtcbiAgICAgICAgZ2V0dGV4dCgnRW1haWwnKTtcbiAgICAgICAgZ2V0dGV4dCgnRW1haWwgc2VuZGVyJyk7XG4gICAgICAgIGdldHRleHQoJ0VtYWlsIHN1YmplY3QnKTtcbiAgICAgICAgZ2V0dGV4dCgnWW91ciBsb2dpbiBmb3Ige2V2ZW50X25hbWV9Jyk7XG4gICAgICAgIGdldHRleHQoJ1lvdSBjYW4gdXNlIHtldmVudF9uYW1lfSBhcyBhIHBsYWNlaG9sZGVyLicpO1xuICAgICAgICBnZXR0ZXh0KCdFbWFpbCBib2R5Jyk7XG4gICAgICAgIGdldHRleHQoJ0RlYXIge25hbWV9LFxcblxcbnRoaXMgaXMgeW91ciBPcGVuU2xpZGVzIGxvZ2luIGZvciB0aGUgZXZlbnQge2V2ZW50X25hbWV9OlxcblxcbiAgICB7dXJsfVxcbiAgICB1c2VybmFtZToge3VzZXJuYW1lfVxcbiAgICBwYXNzd29yZDoge3Bhc3N3b3JkfVxcblxcblRoaXMgZW1haWwgd2FzIGdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5LicpO1xuICAgICAgICBnZXR0ZXh0KCdVc2UgdGhlc2UgcGxhY2Vob2xkZXJzOiB7bmFtZX0sIHtldmVudF9uYW1lfSwge3VybH0sIHt1c2VybmFtZX0sIHtwYXNzd29yZH0uIFRoZSB1cmwgcmVmZXJycyB0byB0aGUgc3lzdGVtIHVybC4nKTtcbiAgICB9XG5dKTtcblxuXG4vLyB0aGlzIGlzIGNvZGUgZnJvbSBhbmd1bGFyLmpzLiBGaW5kIGEgd2F5IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiBmcm9tIHRoaXMgZmlsZVxuZnVuY3Rpb24gZ2V0QmxvY2tOb2Rlcyhub2Rlcykge1xuICAvLyBUT0RPKHBlcmYpOiBqdXN0IGNoZWNrIGlmIGFsbCBpdGVtcyBpbiBgbm9kZXNgIGFyZSBzaWJsaW5ncyBhbmQgaWYgdGhleSBhcmUgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAvLyAgICAgICAgICAgICBjb2xsZWN0aW9uLCBvdGhlcndpc2UgdXBkYXRlIHRoZSBvcmlnaW5hbCBjb2xsZWN0aW9uLlxuICB2YXIgbm9kZSA9IG5vZGVzWzBdO1xuICB2YXIgZW5kTm9kZSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICB2YXIgYmxvY2tOb2RlcyA9IFtub2RlXTtcblxuICBkbyB7XG4gICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgaWYgKCFub2RlKSBicmVhaztcbiAgICBibG9ja05vZGVzLnB1c2gobm9kZSk7XG4gIH0gd2hpbGUgKG5vZGUgIT09IGVuZE5vZGUpO1xuXG4gIHJldHVybiAkKGJsb2NrTm9kZXMpO1xufVxuXG59KCkpO1xuIl19
